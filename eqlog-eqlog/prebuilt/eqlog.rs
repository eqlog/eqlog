// src-digest: C984B1F44EF54AE75F7664B2AD55329B262D2D1B451C044F988211F330A506C7
#[allow(unused)]
use std::collections::{BTreeSet, BTreeMap};
use std::fmt;
#[allow(unused)]
use eqlog_runtime::Unification;
use eqlog_runtime::tabled::{Tabled, Table, Header, Modify, Alignment, Style, object::Segment, Extract};
use std::ops::Bound;

#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Ident(pub u32);
impl Into<u32> for Ident { fn into(self) -> u32 { self.0 } }
impl From<u32> for Ident { fn from(x: u32) -> Self { Ident(x) } }
impl fmt::Display for Ident {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct VirtIdent(pub u32);
impl Into<u32> for VirtIdent { fn into(self) -> u32 { self.0 } }
impl From<u32> for VirtIdent { fn from(x: u32) -> Self { VirtIdent(x) } }
impl fmt::Display for VirtIdent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TypeDeclNode(pub u32);
impl Into<u32> for TypeDeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for TypeDeclNode { fn from(x: u32) -> Self { TypeDeclNode(x) } }
impl fmt::Display for TypeDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ArgDeclNode(pub u32);
impl Into<u32> for ArgDeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for ArgDeclNode { fn from(x: u32) -> Self { ArgDeclNode(x) } }
impl fmt::Display for ArgDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TypeExprNode(pub u32);
impl Into<u32> for TypeExprNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for TypeExprNode { fn from(x: u32) -> Self { TypeExprNode(x) } }
impl fmt::Display for TypeExprNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ArgDeclListNode(pub u32);
impl Into<u32> for ArgDeclListNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for ArgDeclListNode { fn from(x: u32) -> Self { ArgDeclListNode(x) } }
impl fmt::Display for ArgDeclListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct PredDeclNode(pub u32);
impl Into<u32> for PredDeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for PredDeclNode { fn from(x: u32) -> Self { PredDeclNode(x) } }
impl fmt::Display for PredDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct FuncDeclNode(pub u32);
impl Into<u32> for FuncDeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for FuncDeclNode { fn from(x: u32) -> Self { FuncDeclNode(x) } }
impl fmt::Display for FuncDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct CtorDeclNode(pub u32);
impl Into<u32> for CtorDeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for CtorDeclNode { fn from(x: u32) -> Self { CtorDeclNode(x) } }
impl fmt::Display for CtorDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct CtorDeclListNode(pub u32);
impl Into<u32> for CtorDeclListNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for CtorDeclListNode { fn from(x: u32) -> Self { CtorDeclListNode(x) } }
impl fmt::Display for CtorDeclListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct EnumDeclNode(pub u32);
impl Into<u32> for EnumDeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for EnumDeclNode { fn from(x: u32) -> Self { EnumDeclNode(x) } }
impl fmt::Display for EnumDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TermNode(pub u32);
impl Into<u32> for TermNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for TermNode { fn from(x: u32) -> Self { TermNode(x) } }
impl fmt::Display for TermNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TermListNode(pub u32);
impl Into<u32> for TermListNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for TermListNode { fn from(x: u32) -> Self { TermListNode(x) } }
impl fmt::Display for TermListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct OptTermNode(pub u32);
impl Into<u32> for OptTermNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for OptTermNode { fn from(x: u32) -> Self { OptTermNode(x) } }
impl fmt::Display for OptTermNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct MatchCaseNode(pub u32);
impl Into<u32> for MatchCaseNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for MatchCaseNode { fn from(x: u32) -> Self { MatchCaseNode(x) } }
impl fmt::Display for MatchCaseNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct StmtListNode(pub u32);
impl Into<u32> for StmtListNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for StmtListNode { fn from(x: u32) -> Self { StmtListNode(x) } }
impl fmt::Display for StmtListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct MatchCaseListNode(pub u32);
impl Into<u32> for MatchCaseListNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for MatchCaseListNode { fn from(x: u32) -> Self { MatchCaseListNode(x) } }
impl fmt::Display for MatchCaseListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct IfAtomNode(pub u32);
impl Into<u32> for IfAtomNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for IfAtomNode { fn from(x: u32) -> Self { IfAtomNode(x) } }
impl fmt::Display for IfAtomNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ThenAtomNode(pub u32);
impl Into<u32> for ThenAtomNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for ThenAtomNode { fn from(x: u32) -> Self { ThenAtomNode(x) } }
impl fmt::Display for ThenAtomNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct StmtNode(pub u32);
impl Into<u32> for StmtNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for StmtNode { fn from(x: u32) -> Self { StmtNode(x) } }
impl fmt::Display for StmtNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct StmtBlockListNode(pub u32);
impl Into<u32> for StmtBlockListNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for StmtBlockListNode { fn from(x: u32) -> Self { StmtBlockListNode(x) } }
impl fmt::Display for StmtBlockListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct RuleDeclNode(pub u32);
impl Into<u32> for RuleDeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for RuleDeclNode { fn from(x: u32) -> Self { RuleDeclNode(x) } }
impl fmt::Display for RuleDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ModelDeclNode(pub u32);
impl Into<u32> for ModelDeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for ModelDeclNode { fn from(x: u32) -> Self { ModelDeclNode(x) } }
impl fmt::Display for ModelDeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct DeclListNode(pub u32);
impl Into<u32> for DeclListNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for DeclListNode { fn from(x: u32) -> Self { DeclListNode(x) } }
impl fmt::Display for DeclListNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct DeclNode(pub u32);
impl Into<u32> for DeclNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for DeclNode { fn from(x: u32) -> Self { DeclNode(x) } }
impl fmt::Display for DeclNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ModuleNode(pub u32);
impl Into<u32> for ModuleNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for ModuleNode { fn from(x: u32) -> Self { ModuleNode(x) } }
impl fmt::Display for ModuleNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Loc(pub u32);
impl Into<u32> for Loc { fn into(self) -> u32 { self.0 } }
impl From<u32> for Loc { fn from(x: u32) -> Self { Loc(x) } }
impl fmt::Display for Loc {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct RuleDescendantNode(pub u32);
impl Into<u32> for RuleDescendantNode { fn into(self) -> u32 { self.0 } }
impl From<u32> for RuleDescendantNode { fn from(x: u32) -> Self { RuleDescendantNode(x) } }
impl fmt::Display for RuleDescendantNode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Scope(pub u32);
impl Into<u32> for Scope { fn into(self) -> u32 { self.0 } }
impl From<u32> for Scope { fn from(x: u32) -> Self { Scope(x) } }
impl fmt::Display for Scope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Type(pub u32);
impl Into<u32> for Type { fn into(self) -> u32 { self.0 } }
impl From<u32> for Type { fn from(x: u32) -> Self { Type(x) } }
impl fmt::Display for Type {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct TypeList(pub u32);
impl Into<u32> for TypeList { fn into(self) -> u32 { self.0 } }
impl From<u32> for TypeList { fn from(x: u32) -> Self { TypeList(x) } }
impl fmt::Display for TypeList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct SymbolScope(pub u32);
impl Into<u32> for SymbolScope { fn into(self) -> u32 { self.0 } }
impl From<u32> for SymbolScope { fn from(x: u32) -> Self { SymbolScope(x) } }
impl fmt::Display for SymbolScope {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Func(pub u32);
impl Into<u32> for Func { fn into(self) -> u32 { self.0 } }
impl From<u32> for Func { fn from(x: u32) -> Self { Func(x) } }
impl fmt::Display for Func {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Pred(pub u32);
impl Into<u32> for Pred { fn into(self) -> u32 { self.0 } }
impl From<u32> for Pred { fn from(x: u32) -> Self { Pred(x) } }
impl fmt::Display for Pred {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Rel(pub u32);
impl Into<u32> for Rel { fn into(self) -> u32 { self.0 } }
impl From<u32> for Rel { fn from(x: u32) -> Self { Rel(x) } }
impl fmt::Display for Rel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Structure(pub u32);
impl Into<u32> for Structure { fn into(self) -> u32 { self.0 } }
impl From<u32> for Structure { fn from(x: u32) -> Self { Structure(x) } }
impl fmt::Display for Structure {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct El(pub u32);
impl Into<u32> for El { fn into(self) -> u32 { self.0 } }
impl From<u32> for El { fn from(x: u32) -> Self { El(x) } }
impl fmt::Display for El {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ElList(pub u32);
impl Into<u32> for ElList { fn into(self) -> u32 { self.0 } }
impl From<u32> for ElList { fn from(x: u32) -> Self { ElList(x) } }
impl fmt::Display for ElList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ElName(pub u32);
impl Into<u32> for ElName { fn into(self) -> u32 { self.0 } }
impl From<u32> for ElName { fn from(x: u32) -> Self { ElName(x) } }
impl fmt::Display for ElName {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ElementType(pub u32);
impl Into<u32> for ElementType { fn into(self) -> u32 { self.0 } }
impl From<u32> for ElementType { fn from(x: u32) -> Self { ElementType(x) } }
impl fmt::Display for ElementType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct ElementTypeList(pub u32);
impl Into<u32> for ElementTypeList { fn into(self) -> u32 { self.0 } }
impl From<u32> for ElementTypeList { fn from(x: u32) -> Self { ElementTypeList(x) } }
impl fmt::Display for ElementTypeList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Morphism(pub u32);
impl Into<u32> for Morphism { fn into(self) -> u32 { self.0 } }
impl From<u32> for Morphism { fn from(x: u32) -> Self { Morphism(x) } }
impl fmt::Display for Morphism {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct SymbolKind(pub u32);
impl Into<u32> for SymbolKind { fn into(self) -> u32 { self.0 } }
impl From<u32> for SymbolKind { fn from(x: u32) -> Self { SymbolKind(x) } }
impl fmt::Display for SymbolKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}
#[allow(dead_code)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub struct Nat(pub u32);
impl Into<u32> for Nat { fn into(self) -> u32 { self.0 } }
impl From<u32> for Nat { fn from(x: u32) -> Self { Nat(x) } }
impl fmt::Display for Nat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum TypeListCase {
NilTypeList(),
ConsTypeList(Type, TypeList),
SnocTypeList(TypeList, Type),

}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum RelCase {
PredRel(Pred),
FuncRel(Func),

}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum ElListCase {
NilElList(Structure),
ConsElList(El, ElList),
SnocElList(ElList, El),

}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum ElementTypeCase {
AmbientType(Type),
InstantiatedType(El, Type),

}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum ElementTypeListCase {
NilElementTypeList(),
ConsElementTypeList(ElementType, ElementTypeList),
SnocElementTypeList(ElementTypeList, ElementType),

}

#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord)]
pub enum SymbolKindCase {
TypeSymbol(),
PredSymbol(),
FuncSymbol(),
RuleSymbol(),
EnumSymbol(),
CtorSymbol(),
ModelSymbol(),

}

#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Absurd();
#[derive(Clone, Hash, Debug)]
struct AbsurdTable {
    index_new: BTreeSet<()>,
    index_old: BTreeSet<()>,

}
impl AbsurdTable {
#[allow(unused)]
const WEIGHT: usize = 0;
fn new() -> Self {
    Self {
        index_new: BTreeSet::new(),
        index_old: BTreeSet::new(),

    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Absurd) -> bool {
if self.index_old.contains(&Self::permute(t)) {
return false;
}
if !self.index_new.insert(Self::permute(t)) {
return false;
}



true
}
#[allow(dead_code)]
fn contains(&self, t: Absurd) -> bool {
    self.index_new.contains(&Self::permute(t))
 || self.index_old.contains(&Self::permute(t))

}
fn drop_dirt(&mut self) {
self.index_old.extend(
    self.index_new
    .iter().copied()
    .map(|t| Self::permute(Self::permute_inverse(t)))
);

self.index_new.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new.is_empty()
}
#[allow(unused)]
fn permute(t: Absurd) -> () {
    ()
}
#[allow(unused)]
fn permute_inverse(t: ()) -> Absurd {
    Absurd()
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Absurd> {

self.index_new
    .range((
        Bound::Included(&( )),
        Bound::Included(&( ))
    ))
    .copied()
    .map(Self::permute_inverse)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Absurd> {

self.index_new
    .range((
        Bound::Included(&( )),
        Bound::Included(&( ))
    ))
    .copied()
    .map(Self::permute_inverse)
.chain(self.index_old
    .range((
        Bound::Included(&( )),
        Bound::Included(&( ))
    ))
    .copied()
    .map(Self::permute_inverse)
)}
}
impl fmt::Display for AbsurdTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("absurd"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDecl(pub TypeDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct TypeDeclTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<TypeDecl>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<TypeDecl>>,
}
impl TypeDeclTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_type_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TypeDecl) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TypeDecl) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TypeDecl) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TypeDecl {
    TypeDecl(TypeDeclNode::from(t.0), Ident::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: TypeDecl) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> TypeDecl {
    TypeDecl(TypeDeclNode::from(t.1), Ident::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TypeDecl> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TypeDecl> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeDeclNode) -> impl '_ + Iterator<Item = TypeDecl> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeDeclNode) -> impl '_ + Iterator<Item = TypeDecl> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = TypeDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = TypeDecl> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<TypeDecl> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_decl_node(&mut self, tm: TypeDeclNode) -> Vec<TypeDecl> {
    let mut ts = match self.element_index_type_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TypeDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeName(pub ArgDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeNameTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeName>>,
    element_index_ident: BTreeMap<Ident, Vec<ArgDeclNodeName>>,
}
impl ArgDeclNodeNameTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_arg_decl_node: BTreeMap::new(),
    element_index_ident: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ArgDeclNodeName) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ArgDeclNodeName) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ArgDeclNodeName) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ArgDeclNodeName {
    ArgDeclNodeName(ArgDeclNode::from(t.0), Ident::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ArgDeclNodeName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ArgDeclNodeName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ArgDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = ArgDeclNodeName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ArgDeclNodeName> {
    let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ArgDeclNodeName> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ArgDeclNodeNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeType(pub ArgDeclNode, pub TypeExprNode);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeTypeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeType>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<ArgDeclNodeType>>,
}
impl ArgDeclNodeTypeTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_arg_decl_node: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ArgDeclNodeType) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_expr_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ArgDeclNodeType) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ArgDeclNodeType) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ArgDeclNodeType {
    ArgDeclNodeType(ArgDeclNode::from(t.0), TypeExprNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ArgDeclNodeType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ArgDeclNodeType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ArgDeclNode) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: ArgDeclNode, arg1: TypeExprNode) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ArgDeclNode, arg1: TypeExprNode) -> impl '_ + Iterator<Item = ArgDeclNodeType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ArgDeclNodeType> {
    let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<ArgDeclNodeType> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ArgDeclNodeTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilArgDeclListNode(pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct NilArgDeclListNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<NilArgDeclListNode>>,
}
impl NilArgDeclListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_arg_decl_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilArgDeclListNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilArgDeclListNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilArgDeclListNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilArgDeclListNode {
    NilArgDeclListNode(ArgDeclListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilArgDeclListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = NilArgDeclListNode> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilArgDeclListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = NilArgDeclListNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<NilArgDeclListNode> {
    let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilArgDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_arg_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsArgDeclListNode(pub ArgDeclListNode, pub ArgDeclNode, pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct ConsArgDeclListNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<ConsArgDeclListNode>>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ConsArgDeclListNode>>,
}
impl ConsArgDeclListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
    element_index_arg_decl_list_node: BTreeMap::new(),
    element_index_arg_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsArgDeclListNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_arg_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsArgDeclListNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsArgDeclListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsArgDeclListNode {
    ConsArgDeclListNode(ArgDeclListNode::from(t.0), ArgDeclNode::from(t.1), ArgDeclListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: ConsArgDeclListNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> ConsArgDeclListNode {
    ConsArgDeclListNode(ArgDeclListNode::from(t.2), ArgDeclNode::from(t.0), ArgDeclListNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ArgDeclListNode, arg1: ArgDeclNode, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ArgDeclNode) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: ArgDeclNode, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = ConsArgDeclListNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<ConsArgDeclListNode> {
    let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ConsArgDeclListNode> {
    let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsArgDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_arg_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredDecl(pub PredDeclNode, pub Ident, pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct PredDeclTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_2_1: BTreeSet<(u32, u32, u32, )>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<PredDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<PredDecl>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<PredDecl>>,
}
impl PredDeclTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_0_2_1: BTreeSet::new(),
    element_index_arg_decl_list_node: BTreeMap::new(),
    element_index_ident: BTreeMap::new(),
    element_index_pred_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PredDecl) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_pred_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_pred_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PredDecl) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_0_2_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_2_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: PredDecl) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> PredDecl {
    PredDecl(PredDeclNode::from(t.0), Ident::from(t.1), ArgDeclListNode::from(t.2))
}
#[allow(unused)]
fn permute_0_2_1(t: PredDecl) -> (u32, u32, u32, ) {
    (t.0.into(), t.2.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_2_1(t: (u32, u32, u32, )) -> PredDecl {
    PredDecl(PredDeclNode::from(t.0), Ident::from(t.2), ArgDeclListNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PredDecl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PredDecl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: PredDeclNode) -> impl '_ + Iterator<Item = PredDecl> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: PredDeclNode) -> impl '_ + Iterator<Item = PredDecl> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: PredDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = PredDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: PredDeclNode, arg1: Ident, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = PredDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: PredDeclNode, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = PredDecl> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_0_2_1
    .range((
        Bound::Included(&(arg0, arg2,  u32::MIN, )),
        Bound::Included(&(arg0, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_2_1)
}
#[allow(dead_code)]
fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<PredDecl> {
    let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<PredDecl> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_pred_decl_node(&mut self, tm: PredDeclNode) -> Vec<PredDecl> {
    let mut ts = match self.element_index_pred_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PredDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncDecl(pub FuncDeclNode, pub Ident, pub ArgDeclListNode, pub TypeExprNode);
#[derive(Clone, Hash, Debug)]
struct FuncDeclTable {
    index_new_0_1_2_3: BTreeSet<(u32, u32, u32, u32, )>,
    index_old_0_1_2_3: BTreeSet<(u32, u32, u32, u32, )>,
    index_old_0_2_1_3: BTreeSet<(u32, u32, u32, u32, )>,
    index_old_0_3_1_2: BTreeSet<(u32, u32, u32, u32, )>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<FuncDecl>>,
    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<FuncDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<FuncDecl>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<FuncDecl>>,
}
impl FuncDeclTable {
#[allow(unused)]
const WEIGHT: usize = 20;
fn new() -> Self {
    Self {
        index_new_0_1_2_3: BTreeSet::new(),
        index_old_0_1_2_3: BTreeSet::new(),
        index_old_0_2_1_3: BTreeSet::new(),
        index_old_0_3_1_2: BTreeSet::new(),
    element_index_arg_decl_list_node: BTreeMap::new(),
    element_index_func_decl_node: BTreeMap::new(),
    element_index_ident: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FuncDecl) -> bool {
if self.index_old_0_1_2_3.contains(&Self::permute_0_1_2_3(t)) {
return false;
}
if !self.index_new_0_1_2_3.insert(Self::permute_0_1_2_3(t)) {
return false;
}



            match self.element_index_func_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.2, vec![t]); },
            };
        

            match self.element_index_type_expr_node.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.3, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FuncDecl) -> bool {
    self.index_new_0_1_2_3.contains(&Self::permute_0_1_2_3(t))
 || self.index_old_0_1_2_3.contains(&Self::permute_0_1_2_3(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2_3.extend(
    self.index_new_0_1_2_3
    .iter().copied()
    .map(|t| Self::permute_0_1_2_3(Self::permute_inverse_0_1_2_3(t)))
);

self.index_old_0_2_1_3.extend(
    self.index_new_0_1_2_3
    .iter().copied()
    .map(|t| Self::permute_0_2_1_3(Self::permute_inverse_0_1_2_3(t)))
);

self.index_old_0_3_1_2.extend(
    self.index_new_0_1_2_3
    .iter().copied()
    .map(|t| Self::permute_0_3_1_2(Self::permute_inverse_0_1_2_3(t)))
);

self.index_new_0_1_2_3.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2_3.is_empty()
}
#[allow(unused)]
fn permute_0_1_2_3(t: FuncDecl) -> (u32, u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), t.3.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2_3(t: (u32, u32, u32, u32, )) -> FuncDecl {
    FuncDecl(FuncDeclNode::from(t.0), Ident::from(t.1), ArgDeclListNode::from(t.2), TypeExprNode::from(t.3))
}
#[allow(unused)]
fn permute_0_2_1_3(t: FuncDecl) -> (u32, u32, u32, u32, ) {
    (t.0.into(), t.2.into(), t.1.into(), t.3.into(), )
}
#[allow(unused)]
fn permute_inverse_0_2_1_3(t: (u32, u32, u32, u32, )) -> FuncDecl {
    FuncDecl(FuncDeclNode::from(t.0), Ident::from(t.2), ArgDeclListNode::from(t.1), TypeExprNode::from(t.3))
}
#[allow(unused)]
fn permute_0_3_1_2(t: FuncDecl) -> (u32, u32, u32, u32, ) {
    (t.0.into(), t.3.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_3_1_2(t: (u32, u32, u32, u32, )) -> FuncDecl {
    FuncDecl(FuncDeclNode::from(t.0), Ident::from(t.2), ArgDeclListNode::from(t.3), TypeExprNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FuncDecl> {

self.index_new_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FuncDecl> {

self.index_new_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: FuncDeclNode) -> impl '_ + Iterator<Item = FuncDecl> {
    let arg0 = arg0.0;
self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: FuncDeclNode) -> impl '_ + Iterator<Item = FuncDecl> {
    let arg0 = arg0.0;
self.index_new_0_1_2_3
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: FuncDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = FuncDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
}
#[allow(dead_code)]
fn iter_all_0_1_2_3(&self, arg0: FuncDeclNode, arg1: Ident, arg2: ArgDeclListNode, arg3: TypeExprNode) -> impl '_ + Iterator<Item = FuncDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
    let arg3 = arg3.0;
self.index_new_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: FuncDeclNode, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = FuncDecl> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_0_2_1_3
    .range((
        Bound::Included(&(arg0, arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0, arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_2_1_3)
}
#[allow(dead_code)]
fn iter_old_0_3(&self, arg0: FuncDeclNode, arg3: TypeExprNode) -> impl '_ + Iterator<Item = FuncDecl> {
    let arg0 = arg0.0;
    let arg3 = arg3.0;
self.index_old_0_3_1_2
    .range((
        Bound::Included(&(arg0, arg3,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0, arg3,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_3_1_2)
}
#[allow(dead_code)]
fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<FuncDecl> {
    let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            self.index_old_0_2_1_3.remove(&Self::permute_0_2_1_3(t));
self.index_old_0_3_1_2.remove(&Self::permute_0_3_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_func_decl_node(&mut self, tm: FuncDeclNode) -> Vec<FuncDecl> {
    let mut ts = match self.element_index_func_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            self.index_old_0_2_1_3.remove(&Self::permute_0_2_1_3(t));
self.index_old_0_3_1_2.remove(&Self::permute_0_3_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<FuncDecl> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            self.index_old_0_2_1_3.remove(&Self::permute_0_2_1_3(t));
self.index_old_0_3_1_2.remove(&Self::permute_0_3_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<FuncDecl> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            self.index_old_0_2_1_3.remove(&Self::permute_0_2_1_3(t));
self.index_old_0_3_1_2.remove(&Self::permute_0_3_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FuncDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorDecl(pub CtorDeclNode, pub Ident, pub ArgDeclListNode);
#[derive(Clone, Hash, Debug)]
struct CtorDeclTable {
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_2_1: BTreeSet<(u32, u32, u32, )>,
    index_new_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<CtorDecl>>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CtorDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<CtorDecl>>,
}
impl CtorDeclTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_old_0_1_2: BTreeSet::new(),
        index_old_0_2_1: BTreeSet::new(),
        index_new_1_0_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
    element_index_arg_decl_list_node: BTreeMap::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_ident: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CtorDecl) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_1_0_2.insert(Self::permute_1_0_2(t)) {
return false;
}



            match self.element_index_ctor_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_arg_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CtorDecl) -> bool {
    self.index_new_1_0_2.contains(&Self::permute_1_0_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_1_0_2(t)))
);

self.index_old_0_2_1.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_0_2_1(Self::permute_inverse_1_0_2(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_1_0_2(t)))
);

self.index_new_1_0_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_1_0_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: CtorDecl) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> CtorDecl {
    CtorDecl(CtorDeclNode::from(t.0), Ident::from(t.1), ArgDeclListNode::from(t.2))
}
#[allow(unused)]
fn permute_0_2_1(t: CtorDecl) -> (u32, u32, u32, ) {
    (t.0.into(), t.2.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_2_1(t: (u32, u32, u32, )) -> CtorDecl {
    CtorDecl(CtorDeclNode::from(t.0), Ident::from(t.2), ArgDeclListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0_2(t: CtorDecl) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> CtorDecl {
    CtorDecl(CtorDeclNode::from(t.1), Ident::from(t.0), ArgDeclListNode::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CtorDecl> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CtorDecl> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorDecl> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: CtorDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = CtorDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: CtorDeclNode, arg1: Ident, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = CtorDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0, arg2,  )),
        Bound::Included(&(arg1, arg0, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: CtorDeclNode, arg2: ArgDeclListNode) -> impl '_ + Iterator<Item = CtorDecl> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_0_2_1
    .range((
        Bound::Included(&(arg0, arg2,  u32::MIN, )),
        Bound::Included(&(arg0, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_2_1)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = CtorDecl> {
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<CtorDecl> {
    let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CtorDecl> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<CtorDecl> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CtorDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctor_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilCtorDeclListNode(pub CtorDeclListNode);
#[derive(Clone, Hash, Debug)]
struct NilCtorDeclListNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<NilCtorDeclListNode>>,
}
impl NilCtorDeclListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_ctor_decl_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilCtorDeclListNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_ctor_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilCtorDeclListNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilCtorDeclListNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilCtorDeclListNode {
    NilCtorDeclListNode(CtorDeclListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilCtorDeclListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilCtorDeclListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: CtorDeclListNode) -> impl '_ + Iterator<Item = NilCtorDeclListNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_list_node(&mut self, tm: CtorDeclListNode) -> Vec<NilCtorDeclListNode> {
    let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilCtorDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_ctor_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsCtorDeclListNode(pub CtorDeclListNode, pub CtorDeclNode, pub CtorDeclListNode);
#[derive(Clone, Hash, Debug)]
struct ConsCtorDeclListNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<ConsCtorDeclListNode>>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<ConsCtorDeclListNode>>,
}
impl ConsCtorDeclListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_ctor_decl_list_node: BTreeMap::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsCtorDeclListNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_ctor_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_ctor_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsCtorDeclListNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsCtorDeclListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsCtorDeclListNode {
    ConsCtorDeclListNode(CtorDeclListNode::from(t.0), CtorDeclNode::from(t.1), CtorDeclListNode::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: CtorDeclListNode) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: CtorDeclListNode) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: CtorDeclListNode, arg1: CtorDeclNode, arg2: CtorDeclListNode) -> impl '_ + Iterator<Item = ConsCtorDeclListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_list_node(&mut self, tm: CtorDeclListNode) -> Vec<ConsCtorDeclListNode> {
    let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<ConsCtorDeclListNode> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsCtorDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_ctor_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumDecl(pub EnumDeclNode, pub Ident, pub CtorDeclListNode);
#[derive(Clone, Hash, Debug)]
struct EnumDeclTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_new_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<EnumDecl>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<EnumDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<EnumDecl>>,
}
impl EnumDeclTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_new_1_0_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
    element_index_ctor_decl_list_node: BTreeMap::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    element_index_ident: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: EnumDecl) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}

self.index_new_1_0_2.insert(Self::permute_1_0_2(t));

            match self.element_index_enum_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_ctor_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: EnumDecl) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

self.index_new_1_0_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: EnumDecl) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> EnumDecl {
    EnumDecl(EnumDeclNode::from(t.0), Ident::from(t.1), CtorDeclListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: EnumDecl) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> EnumDecl {
    EnumDecl(EnumDeclNode::from(t.1), Ident::from(t.0), CtorDeclListNode::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = EnumDecl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = EnumDecl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: EnumDeclNode) -> impl '_ + Iterator<Item = EnumDecl> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: EnumDeclNode) -> impl '_ + Iterator<Item = EnumDecl> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: EnumDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = EnumDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: EnumDeclNode, arg1: Ident, arg2: CtorDeclListNode) -> impl '_ + Iterator<Item = EnumDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = EnumDecl> {
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_list_node(&mut self, tm: CtorDeclListNode) -> Vec<EnumDecl> {
    let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<EnumDecl> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<EnumDecl> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for EnumDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("enum_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilTermListNode(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct NilTermListNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<NilTermListNode>>,
}
impl NilTermListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilTermListNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilTermListNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilTermListNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilTermListNode {
    NilTermListNode(TermListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilTermListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilTermListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = NilTermListNode> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = NilTermListNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<NilTermListNode> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilTermListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_term_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsTermListNode(pub TermListNode, pub TermNode, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct ConsTermListNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_2_1: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<ConsTermListNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<ConsTermListNode>>,
}
impl ConsTermListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_0_2_1: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
    element_index_term_list_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsTermListNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsTermListNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_0_2_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_2_1(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsTermListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsTermListNode {
    ConsTermListNode(TermListNode::from(t.0), TermNode::from(t.1), TermListNode::from(t.2))
}
#[allow(unused)]
fn permute_0_2_1(t: ConsTermListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.2.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_2_1(t: (u32, u32, u32, )) -> ConsTermListNode {
    ConsTermListNode(TermListNode::from(t.0), TermNode::from(t.2), TermListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_2_0(t: ConsTermListNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> ConsTermListNode {
    ConsTermListNode(TermListNode::from(t.2), TermNode::from(t.0), TermListNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsTermListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsTermListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: TermListNode, arg1: TermNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: TermListNode, arg1: TermNode, arg2: TermListNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: TermListNode, arg2: TermListNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_0_2_1
    .range((
        Bound::Included(&(arg0, arg2,  u32::MIN, )),
        Bound::Included(&(arg0, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_2_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: TermNode, arg2: TermListNode) -> impl '_ + Iterator<Item = ConsTermListNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<ConsTermListNode> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<ConsTermListNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsTermListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_term_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientTypeExpr(pub TypeExprNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct AmbientTypeExprTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<AmbientTypeExpr>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<AmbientTypeExpr>>,
}
impl AmbientTypeExprTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: AmbientTypeExpr) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_expr_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: AmbientTypeExpr) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: AmbientTypeExpr) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> AmbientTypeExpr {
    AmbientTypeExpr(TypeExprNode::from(t.0), Ident::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: AmbientTypeExpr) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> AmbientTypeExpr {
    AmbientTypeExpr(TypeExprNode::from(t.1), Ident::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = AmbientTypeExpr> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = AmbientTypeExpr> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = AmbientTypeExpr> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = AmbientTypeExpr> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = AmbientTypeExpr> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeExprNode, arg1: Ident) -> impl '_ + Iterator<Item = AmbientTypeExpr> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = AmbientTypeExpr> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<AmbientTypeExpr> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<AmbientTypeExpr> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for AmbientTypeExprTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ambient_type_expr"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MemberTypeExpr(pub TypeExprNode, pub TermNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct MemberTypeExprTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<MemberTypeExpr>>,
    element_index_term_node: BTreeMap<TermNode, Vec<MemberTypeExpr>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<MemberTypeExpr>>,
}
impl MemberTypeExprTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MemberTypeExpr) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_type_expr_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MemberTypeExpr) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: MemberTypeExpr) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> MemberTypeExpr {
    MemberTypeExpr(TypeExprNode::from(t.0), TermNode::from(t.1), Ident::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: MemberTypeExpr) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> MemberTypeExpr {
    MemberTypeExpr(TypeExprNode::from(t.2), TermNode::from(t.0), Ident::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MemberTypeExpr> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MemberTypeExpr> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = MemberTypeExpr> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = MemberTypeExpr> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: TypeExprNode, arg1: TermNode) -> impl '_ + Iterator<Item = MemberTypeExpr> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: TypeExprNode, arg1: TermNode, arg2: Ident) -> impl '_ + Iterator<Item = MemberTypeExpr> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = MemberTypeExpr> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: TermNode, arg2: Ident) -> impl '_ + Iterator<Item = MemberTypeExpr> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<MemberTypeExpr> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<MemberTypeExpr> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<MemberTypeExpr> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MemberTypeExprTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("member_type_expr"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MorTypeExpr(pub TypeExprNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct MorTypeExprTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<MorTypeExpr>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<MorTypeExpr>>,
}
impl MorTypeExprTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MorTypeExpr) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_expr_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MorTypeExpr) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: MorTypeExpr) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> MorTypeExpr {
    MorTypeExpr(TypeExprNode::from(t.0), Ident::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: MorTypeExpr) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> MorTypeExpr {
    MorTypeExpr(TypeExprNode::from(t.1), Ident::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MorTypeExpr> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MorTypeExpr> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = MorTypeExpr> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = MorTypeExpr> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeExprNode, arg1: Ident) -> impl '_ + Iterator<Item = MorTypeExpr> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = MorTypeExpr> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<MorTypeExpr> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<MorTypeExpr> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MorTypeExprTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("mor_type_expr"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NoneTermNode(pub OptTermNode);
#[derive(Clone, Hash, Debug)]
struct NoneTermNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<NoneTermNode>>,
}
impl NoneTermNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_opt_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NoneTermNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_opt_term_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NoneTermNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NoneTermNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NoneTermNode {
    NoneTermNode(OptTermNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NoneTermNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NoneTermNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = NoneTermNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<NoneTermNode> {
    let mut ts = match self.element_index_opt_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NoneTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("none_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SomeTermNode(pub OptTermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct SomeTermNodeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<SomeTermNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<SomeTermNode>>,
}
impl SomeTermNodeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_opt_term_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SomeTermNode) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_opt_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SomeTermNode) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: SomeTermNode) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> SomeTermNode {
    SomeTermNode(OptTermNode::from(t.0), TermNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: SomeTermNode) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> SomeTermNode {
    SomeTermNode(OptTermNode::from(t.1), TermNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SomeTermNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SomeTermNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = SomeTermNode> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = SomeTermNode> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: OptTermNode, arg1: TermNode) -> impl '_ + Iterator<Item = SomeTermNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = SomeTermNode> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<SomeTermNode> {
    let mut ts = match self.element_index_opt_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<SomeTermNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SomeTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("some_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarTermNode(pub TermNode, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct VarTermNodeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_term_node: BTreeMap<TermNode, Vec<VarTermNode>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarTermNode>>,
}
impl VarTermNodeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_term_node: BTreeMap::new(),
    element_index_virt_ident: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: VarTermNode) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_virt_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: VarTermNode) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: VarTermNode) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> VarTermNode {
    VarTermNode(TermNode::from(t.0), VirtIdent::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: VarTermNode) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> VarTermNode {
    VarTermNode(TermNode::from(t.1), VirtIdent::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = VarTermNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = VarTermNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = VarTermNode> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = VarTermNode> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermNode, arg1: VirtIdent) -> impl '_ + Iterator<Item = VarTermNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: VirtIdent) -> impl '_ + Iterator<Item = VarTermNode> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<VarTermNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<VarTermNode> {
    let mut ts = match self.element_index_virt_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for VarTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct WildcardTermNode(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct WildcardTermNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_term_node: BTreeMap<TermNode, Vec<WildcardTermNode>>,
}
impl WildcardTermNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: WildcardTermNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: WildcardTermNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: WildcardTermNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> WildcardTermNode {
    WildcardTermNode(TermNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = WildcardTermNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = WildcardTermNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = WildcardTermNode> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = WildcardTermNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<WildcardTermNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for WildcardTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("wildcard_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AppTermNode(pub TermNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct AppTermNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<AppTermNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<AppTermNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<AppTermNode>>,
}
impl AppTermNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_term_list_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: AppTermNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: AppTermNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: AppTermNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> AppTermNode {
    AppTermNode(TermNode::from(t.0), Ident::from(t.1), TermListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: AppTermNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> AppTermNode {
    AppTermNode(TermNode::from(t.2), Ident::from(t.0), TermListNode::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: AppTermNode) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> AppTermNode {
    AppTermNode(TermNode::from(t.1), Ident::from(t.2), TermListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = AppTermNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = AppTermNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = AppTermNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = AppTermNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: TermNode, arg1: Ident) -> impl '_ + Iterator<Item = AppTermNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: TermNode, arg1: Ident, arg2: TermListNode) -> impl '_ + Iterator<Item = AppTermNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: TermNode, arg2: TermListNode) -> impl '_ + Iterator<Item = AppTermNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Ident) -> impl '_ + Iterator<Item = AppTermNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: Ident, arg2: TermListNode) -> impl '_ + Iterator<Item = AppTermNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = AppTermNode> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<AppTermNode> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<AppTermNode> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<AppTermNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for AppTermNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("app_term_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCase(pub MatchCaseNode, pub TermNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct MatchCaseTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<MatchCase>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<MatchCase>>,
    element_index_term_node: BTreeMap<TermNode, Vec<MatchCase>>,
}
impl MatchCaseTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
    element_index_match_case_node: BTreeMap::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MatchCase) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_stmt_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MatchCase) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: MatchCase) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> MatchCase {
    MatchCase(MatchCaseNode::from(t.0), TermNode::from(t.1), StmtListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: MatchCase) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> MatchCase {
    MatchCase(MatchCaseNode::from(t.1), TermNode::from(t.0), StmtListNode::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MatchCase> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MatchCase> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = MatchCase> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = MatchCase> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: MatchCaseNode, arg1: TermNode) -> impl '_ + Iterator<Item = MatchCase> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: MatchCaseNode, arg1: TermNode, arg2: StmtListNode) -> impl '_ + Iterator<Item = MatchCase> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = MatchCase> {
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<MatchCase> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<MatchCase> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<MatchCase> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MatchCaseTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_case"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilMatchCaseListNode(pub MatchCaseListNode);
#[derive(Clone, Hash, Debug)]
struct NilMatchCaseListNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<NilMatchCaseListNode>>,
}
impl NilMatchCaseListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_match_case_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilMatchCaseListNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilMatchCaseListNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilMatchCaseListNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilMatchCaseListNode {
    NilMatchCaseListNode(MatchCaseListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilMatchCaseListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = NilMatchCaseListNode> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilMatchCaseListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = NilMatchCaseListNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_match_case_list_node(&mut self, tm: MatchCaseListNode) -> Vec<NilMatchCaseListNode> {
    let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilMatchCaseListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_match_case_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsMatchCaseListNode(pub MatchCaseListNode, pub MatchCaseNode, pub MatchCaseListNode);
#[derive(Clone, Hash, Debug)]
struct ConsMatchCaseListNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<ConsMatchCaseListNode>>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<ConsMatchCaseListNode>>,
}
impl ConsMatchCaseListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_match_case_list_node: BTreeMap::new(),
    element_index_match_case_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsMatchCaseListNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_match_case_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_match_case_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsMatchCaseListNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsMatchCaseListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsMatchCaseListNode {
    ConsMatchCaseListNode(MatchCaseListNode::from(t.0), MatchCaseNode::from(t.1), MatchCaseListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: ConsMatchCaseListNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> ConsMatchCaseListNode {
    ConsMatchCaseListNode(MatchCaseListNode::from(t.2), MatchCaseNode::from(t.0), MatchCaseListNode::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: ConsMatchCaseListNode) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> ConsMatchCaseListNode {
    ConsMatchCaseListNode(MatchCaseListNode::from(t.1), MatchCaseNode::from(t.2), MatchCaseListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: MatchCaseListNode, arg1: MatchCaseNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: MatchCaseListNode, arg1: MatchCaseNode, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: MatchCaseListNode, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: MatchCaseNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: MatchCaseNode, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = ConsMatchCaseListNode> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_match_case_list_node(&mut self, tm: MatchCaseListNode) -> Vec<ConsMatchCaseListNode> {
    let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<ConsMatchCaseListNode> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsMatchCaseListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_match_case_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EqualIfAtomNode(pub IfAtomNode, pub TermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct EqualIfAtomNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_2_1: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<EqualIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<EqualIfAtomNode>>,
}
impl EqualIfAtomNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_0_2_1: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: EqualIfAtomNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: EqualIfAtomNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_0_2_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_2_1(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: EqualIfAtomNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> EqualIfAtomNode {
    EqualIfAtomNode(IfAtomNode::from(t.0), TermNode::from(t.1), TermNode::from(t.2))
}
#[allow(unused)]
fn permute_0_2_1(t: EqualIfAtomNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.2.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_2_1(t: (u32, u32, u32, )) -> EqualIfAtomNode {
    EqualIfAtomNode(IfAtomNode::from(t.0), TermNode::from(t.2), TermNode::from(t.1))
}
#[allow(unused)]
fn permute_1_2_0(t: EqualIfAtomNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> EqualIfAtomNode {
    EqualIfAtomNode(IfAtomNode::from(t.2), TermNode::from(t.0), TermNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = EqualIfAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = EqualIfAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: IfAtomNode, arg1: TermNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: IfAtomNode, arg1: TermNode, arg2: TermNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: IfAtomNode, arg2: TermNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_0_2_1
    .range((
        Bound::Included(&(arg0, arg2,  u32::MIN, )),
        Bound::Included(&(arg0, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_2_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: TermNode, arg2: TermNode) -> impl '_ + Iterator<Item = EqualIfAtomNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<EqualIfAtomNode> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<EqualIfAtomNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for EqualIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("equal_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedIfAtomNode(pub IfAtomNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct DefinedIfAtomNodeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<DefinedIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<DefinedIfAtomNode>>,
}
impl DefinedIfAtomNodeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DefinedIfAtomNode) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DefinedIfAtomNode) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DefinedIfAtomNode) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DefinedIfAtomNode {
    DefinedIfAtomNode(IfAtomNode::from(t.0), TermNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DefinedIfAtomNode) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DefinedIfAtomNode {
    DefinedIfAtomNode(IfAtomNode::from(t.1), TermNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: IfAtomNode, arg1: TermNode) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = DefinedIfAtomNode> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<DefinedIfAtomNode> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<DefinedIfAtomNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DefinedIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredIfAtomNode(pub IfAtomNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct PredIfAtomNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<PredIfAtomNode>>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<PredIfAtomNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<PredIfAtomNode>>,
}
impl PredIfAtomNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PredIfAtomNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PredIfAtomNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: PredIfAtomNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> PredIfAtomNode {
    PredIfAtomNode(IfAtomNode::from(t.0), Ident::from(t.1), TermListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: PredIfAtomNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> PredIfAtomNode {
    PredIfAtomNode(IfAtomNode::from(t.2), Ident::from(t.0), TermListNode::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: PredIfAtomNode) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> PredIfAtomNode {
    PredIfAtomNode(IfAtomNode::from(t.1), Ident::from(t.2), TermListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PredIfAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PredIfAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: IfAtomNode, arg1: Ident) -> impl '_ + Iterator<Item = PredIfAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: IfAtomNode, arg1: Ident, arg2: TermListNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: IfAtomNode, arg2: TermListNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: Ident, arg2: TermListNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = PredIfAtomNode> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<PredIfAtomNode> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<PredIfAtomNode> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<PredIfAtomNode> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PredIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarIfAtomNode(pub IfAtomNode, pub TermNode, pub TypeExprNode);
#[derive(Clone, Hash, Debug)]
struct VarIfAtomNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<VarIfAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<VarIfAtomNode>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<VarIfAtomNode>>,
}
impl VarIfAtomNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: VarIfAtomNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_type_expr_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: VarIfAtomNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: VarIfAtomNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> VarIfAtomNode {
    VarIfAtomNode(IfAtomNode::from(t.0), TermNode::from(t.1), TypeExprNode::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: VarIfAtomNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> VarIfAtomNode {
    VarIfAtomNode(IfAtomNode::from(t.2), TermNode::from(t.0), TypeExprNode::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: VarIfAtomNode) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> VarIfAtomNode {
    VarIfAtomNode(IfAtomNode::from(t.1), TermNode::from(t.2), TypeExprNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = VarIfAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = VarIfAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: IfAtomNode, arg1: TermNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: IfAtomNode, arg1: TermNode, arg2: TypeExprNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: IfAtomNode, arg2: TypeExprNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: TermNode, arg2: TypeExprNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: TypeExprNode) -> impl '_ + Iterator<Item = VarIfAtomNode> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<VarIfAtomNode> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<VarIfAtomNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<VarIfAtomNode> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for VarIfAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_if_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EqualThenAtomNode(pub ThenAtomNode, pub TermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct EqualThenAtomNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_2_1: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    element_index_term_node: BTreeMap<TermNode, Vec<EqualThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<EqualThenAtomNode>>,
}
impl EqualThenAtomNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_0_2_1: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
    element_index_term_node: BTreeMap::new(),
    element_index_then_atom_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: EqualThenAtomNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_then_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: EqualThenAtomNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_0_2_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_2_1(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: EqualThenAtomNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> EqualThenAtomNode {
    EqualThenAtomNode(ThenAtomNode::from(t.0), TermNode::from(t.1), TermNode::from(t.2))
}
#[allow(unused)]
fn permute_0_2_1(t: EqualThenAtomNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.2.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_2_1(t: (u32, u32, u32, )) -> EqualThenAtomNode {
    EqualThenAtomNode(ThenAtomNode::from(t.0), TermNode::from(t.2), TermNode::from(t.1))
}
#[allow(unused)]
fn permute_1_2_0(t: EqualThenAtomNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> EqualThenAtomNode {
    EqualThenAtomNode(ThenAtomNode::from(t.2), TermNode::from(t.0), TermNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = EqualThenAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = EqualThenAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: ThenAtomNode, arg1: TermNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ThenAtomNode, arg1: TermNode, arg2: TermNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: ThenAtomNode, arg2: TermNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_0_2_1
    .range((
        Bound::Included(&(arg0, arg2,  u32::MIN, )),
        Bound::Included(&(arg0, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_2_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: TermNode, arg2: TermNode) -> impl '_ + Iterator<Item = EqualThenAtomNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<EqualThenAtomNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<EqualThenAtomNode> {
    let mut ts = match self.element_index_then_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for EqualThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("equal_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedThenAtomNode(pub ThenAtomNode, pub OptTermNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct DefinedThenAtomNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<DefinedThenAtomNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<DefinedThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<DefinedThenAtomNode>>,
}
impl DefinedThenAtomNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_opt_term_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    element_index_then_atom_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DefinedThenAtomNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_then_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_opt_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_opt_term_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DefinedThenAtomNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: DefinedThenAtomNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> DefinedThenAtomNode {
    DefinedThenAtomNode(ThenAtomNode::from(t.0), OptTermNode::from(t.1), TermNode::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: DefinedThenAtomNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> DefinedThenAtomNode {
    DefinedThenAtomNode(ThenAtomNode::from(t.2), OptTermNode::from(t.0), TermNode::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: DefinedThenAtomNode) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> DefinedThenAtomNode {
    DefinedThenAtomNode(ThenAtomNode::from(t.1), OptTermNode::from(t.2), TermNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: ThenAtomNode, arg1: OptTermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ThenAtomNode, arg1: OptTermNode, arg2: TermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: ThenAtomNode, arg2: TermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: OptTermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: OptTermNode, arg2: TermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: TermNode) -> impl '_ + Iterator<Item = DefinedThenAtomNode> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<DefinedThenAtomNode> {
    let mut ts = match self.element_index_opt_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<DefinedThenAtomNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<DefinedThenAtomNode> {
    let mut ts = match self.element_index_then_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DefinedThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredThenAtomNode(pub ThenAtomNode, pub Ident, pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct PredThenAtomNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<PredThenAtomNode>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<PredThenAtomNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<PredThenAtomNode>>,
}
impl PredThenAtomNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_term_list_node: BTreeMap::new(),
    element_index_then_atom_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PredThenAtomNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_then_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_term_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PredThenAtomNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: PredThenAtomNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> PredThenAtomNode {
    PredThenAtomNode(ThenAtomNode::from(t.0), Ident::from(t.1), TermListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: PredThenAtomNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> PredThenAtomNode {
    PredThenAtomNode(ThenAtomNode::from(t.2), Ident::from(t.0), TermListNode::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: PredThenAtomNode) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> PredThenAtomNode {
    PredThenAtomNode(ThenAtomNode::from(t.1), Ident::from(t.2), TermListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PredThenAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PredThenAtomNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: ThenAtomNode, arg1: Ident) -> impl '_ + Iterator<Item = PredThenAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ThenAtomNode, arg1: Ident, arg2: TermListNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: ThenAtomNode, arg2: TermListNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: Ident, arg2: TermListNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: TermListNode) -> impl '_ + Iterator<Item = PredThenAtomNode> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<PredThenAtomNode> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<PredThenAtomNode> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<PredThenAtomNode> {
    let mut ts = match self.element_index_then_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PredThenAtomNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_then_atom_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfStmtNode(pub StmtNode, pub IfAtomNode);
#[derive(Clone, Hash, Debug)]
struct IfStmtNodeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfStmtNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<IfStmtNode>>,
}
impl IfStmtNodeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IfStmtNode) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_if_atom_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IfStmtNode) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: IfStmtNode) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> IfStmtNode {
    IfStmtNode(StmtNode::from(t.0), IfAtomNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: IfStmtNode) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> IfStmtNode {
    IfStmtNode(StmtNode::from(t.1), IfAtomNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IfStmtNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IfStmtNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = IfStmtNode> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = IfStmtNode> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: StmtNode, arg1: IfAtomNode) -> impl '_ + Iterator<Item = IfStmtNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: IfAtomNode) -> impl '_ + Iterator<Item = IfStmtNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: IfAtomNode) -> impl '_ + Iterator<Item = IfStmtNode> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<IfStmtNode> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<IfStmtNode> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IfStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenStmtNode(pub StmtNode, pub ThenAtomNode);
#[derive(Clone, Hash, Debug)]
struct ThenStmtNodeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<ThenStmtNode>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenStmtNode>>,
}
impl ThenStmtNodeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_stmt_node: BTreeMap::new(),
    element_index_then_atom_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ThenStmtNode) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_then_atom_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_then_atom_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ThenStmtNode) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ThenStmtNode) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ThenStmtNode {
    ThenStmtNode(StmtNode::from(t.0), ThenAtomNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ThenStmtNode) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ThenStmtNode {
    ThenStmtNode(StmtNode::from(t.1), ThenAtomNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ThenStmtNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ThenStmtNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: StmtNode, arg1: ThenAtomNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: ThenAtomNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ThenAtomNode) -> impl '_ + Iterator<Item = ThenStmtNode> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<ThenStmtNode> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<ThenStmtNode> {
    let mut ts = match self.element_index_then_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ThenStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BranchStmtNode(pub StmtNode, pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct BranchStmtNodeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<BranchStmtNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<BranchStmtNode>>,
}
impl BranchStmtNodeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_stmt_block_list_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: BranchStmtNode) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_block_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_block_list_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: BranchStmtNode) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: BranchStmtNode) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> BranchStmtNode {
    BranchStmtNode(StmtNode::from(t.0), StmtBlockListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: BranchStmtNode) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> BranchStmtNode {
    BranchStmtNode(StmtNode::from(t.1), StmtBlockListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = BranchStmtNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = BranchStmtNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = BranchStmtNode> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: StmtBlockListNode) -> impl '_ + Iterator<Item = BranchStmtNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: StmtBlockListNode) -> impl '_ + Iterator<Item = BranchStmtNode> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_stmt_block_list_node(&mut self, tm: StmtBlockListNode) -> Vec<BranchStmtNode> {
    let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<BranchStmtNode> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for BranchStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("branch_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtNode(pub StmtNode, pub TermNode, pub MatchCaseListNode);
#[derive(Clone, Hash, Debug)]
struct MatchStmtNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<MatchStmtNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtNode>>,
    element_index_term_node: BTreeMap<TermNode, Vec<MatchStmtNode>>,
}
impl MatchStmtNodeTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_match_case_list_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MatchStmtNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_match_case_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MatchStmtNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: MatchStmtNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> MatchStmtNode {
    MatchStmtNode(StmtNode::from(t.0), TermNode::from(t.1), MatchCaseListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: MatchStmtNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> MatchStmtNode {
    MatchStmtNode(StmtNode::from(t.2), TermNode::from(t.0), MatchCaseListNode::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: MatchStmtNode) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> MatchStmtNode {
    MatchStmtNode(StmtNode::from(t.1), TermNode::from(t.2), MatchCaseListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MatchStmtNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MatchStmtNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: StmtNode, arg1: TermNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: StmtNode, arg1: TermNode, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: StmtNode, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TermNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: TermNode, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: MatchCaseListNode) -> impl '_ + Iterator<Item = MatchStmtNode> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_match_case_list_node(&mut self, tm: MatchCaseListNode) -> Vec<MatchStmtNode> {
    let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtNode> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<MatchStmtNode> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MatchStmtNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilStmtListNode(pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct NilStmtListNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<NilStmtListNode>>,
}
impl NilStmtListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilStmtListNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilStmtListNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilStmtListNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilStmtListNode {
    NilStmtListNode(StmtListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilStmtListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilStmtListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = NilStmtListNode> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = NilStmtListNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<NilStmtListNode> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilStmtListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_stmt_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsStmtListNode(pub StmtListNode, pub StmtNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct ConsStmtListNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_new_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<ConsStmtListNode>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<ConsStmtListNode>>,
}
impl ConsStmtListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_new_1_0_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsStmtListNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}

self.index_new_1_0_2.insert(Self::permute_1_0_2(t));

            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_stmt_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsStmtListNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

self.index_new_1_0_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsStmtListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsStmtListNode {
    ConsStmtListNode(StmtListNode::from(t.0), StmtNode::from(t.1), StmtListNode::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: ConsStmtListNode) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> ConsStmtListNode {
    ConsStmtListNode(StmtListNode::from(t.1), StmtNode::from(t.0), StmtListNode::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: ConsStmtListNode) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> ConsStmtListNode {
    ConsStmtListNode(StmtListNode::from(t.1), StmtNode::from(t.2), StmtListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsStmtListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsStmtListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: StmtListNode, arg1: StmtNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: StmtListNode, arg1: StmtNode, arg2: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: StmtListNode, arg2: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: StmtNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: StmtNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtListNode> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<ConsStmtListNode> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<ConsStmtListNode> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_1_0_2.remove(&Self::permute_1_0_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsStmtListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_stmt_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilStmtBlockListNode(pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct NilStmtBlockListNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<NilStmtBlockListNode>>,
}
impl NilStmtBlockListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_stmt_block_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilStmtBlockListNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_stmt_block_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_block_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilStmtBlockListNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilStmtBlockListNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilStmtBlockListNode {
    NilStmtBlockListNode(StmtBlockListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilStmtBlockListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilStmtBlockListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtBlockListNode) -> impl '_ + Iterator<Item = NilStmtBlockListNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_stmt_block_list_node(&mut self, tm: StmtBlockListNode) -> Vec<NilStmtBlockListNode> {
    let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilStmtBlockListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_stmt_block_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsStmtBlockListNode(pub StmtBlockListNode, pub StmtListNode, pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct ConsStmtBlockListNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_2_1: BTreeSet<(u32, u32, u32, )>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<ConsStmtBlockListNode>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<ConsStmtBlockListNode>>,
}
impl ConsStmtBlockListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_0_2_1: BTreeSet::new(),
    element_index_stmt_block_list_node: BTreeMap::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsStmtBlockListNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_stmt_block_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_block_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_stmt_block_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_block_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsStmtBlockListNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_0_2_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_2_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsStmtBlockListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsStmtBlockListNode {
    ConsStmtBlockListNode(StmtBlockListNode::from(t.0), StmtListNode::from(t.1), StmtBlockListNode::from(t.2))
}
#[allow(unused)]
fn permute_0_2_1(t: ConsStmtBlockListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.2.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_2_1(t: (u32, u32, u32, )) -> ConsStmtBlockListNode {
    ConsStmtBlockListNode(StmtBlockListNode::from(t.0), StmtListNode::from(t.2), StmtBlockListNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtBlockListNode) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtBlockListNode) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: StmtBlockListNode, arg1: StmtListNode) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: StmtBlockListNode, arg1: StmtListNode, arg2: StmtBlockListNode) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: StmtBlockListNode, arg2: StmtBlockListNode) -> impl '_ + Iterator<Item = ConsStmtBlockListNode> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_0_2_1
    .range((
        Bound::Included(&(arg0, arg2,  u32::MIN, )),
        Bound::Included(&(arg0, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_2_1)
}
#[allow(dead_code)]
fn drain_with_element_stmt_block_list_node(&mut self, tm: StmtBlockListNode) -> Vec<ConsStmtBlockListNode> {
    let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<ConsStmtBlockListNode> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_0_2_1.remove(&Self::permute_0_2_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsStmtBlockListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_stmt_block_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDecl(pub RuleDeclNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct RuleDeclTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleDecl>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<RuleDecl>>,
}
impl RuleDeclTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_decl_node: BTreeMap::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDecl) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDecl) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDecl) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDecl {
    RuleDecl(RuleDeclNode::from(t.0), StmtListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RuleDecl) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RuleDecl {
    RuleDecl(RuleDeclNode::from(t.1), StmtListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDecl> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDecl> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDecl> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDecl> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDeclNode, arg1: StmtListNode) -> impl '_ + Iterator<Item = RuleDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: StmtListNode) -> impl '_ + Iterator<Item = RuleDecl> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<RuleDecl> {
    let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<RuleDecl> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModelDecl(pub ModelDeclNode, pub Ident, pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct ModelDeclTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<ModelDecl>>,
    element_index_ident: BTreeMap<Ident, Vec<ModelDecl>>,
    element_index_model_decl_node: BTreeMap<ModelDeclNode, Vec<ModelDecl>>,
}
impl ModelDeclTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_decl_list_node: BTreeMap::new(),
    element_index_ident: BTreeMap::new(),
    element_index_model_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ModelDecl) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_model_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_model_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ModelDecl) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ModelDecl) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ModelDecl {
    ModelDecl(ModelDeclNode::from(t.0), Ident::from(t.1), DeclListNode::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: ModelDecl) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> ModelDecl {
    ModelDecl(ModelDeclNode::from(t.1), Ident::from(t.2), DeclListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ModelDecl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ModelDecl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ModelDeclNode) -> impl '_ + Iterator<Item = ModelDecl> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ModelDeclNode) -> impl '_ + Iterator<Item = ModelDecl> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: ModelDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = ModelDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1_2(&self, arg0: ModelDeclNode, arg1: Ident, arg2: DeclListNode) -> impl '_ + Iterator<Item = ModelDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ModelDeclNode, arg1: Ident, arg2: DeclListNode) -> impl '_ + Iterator<Item = ModelDecl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: ModelDeclNode, arg2: DeclListNode) -> impl '_ + Iterator<Item = ModelDecl> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: DeclListNode) -> impl '_ + Iterator<Item = ModelDecl> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<ModelDecl> {
    let mut ts = match self.element_index_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ModelDecl> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_model_decl_node(&mut self, tm: ModelDeclNode) -> Vec<ModelDecl> {
    let mut ts = match self.element_index_model_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ModelDeclTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("model_decl"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeType(pub DeclNode, pub TypeDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeTypeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeType>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<DeclNodeType>>,
}
impl DeclNodeTypeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_node: BTreeMap::new(),
    element_index_type_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclNodeType) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclNodeType) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclNodeType) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclNodeType {
    DeclNodeType(DeclNode::from(t.0), TypeDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclNodeType) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclNodeType {
    DeclNodeType(DeclNode::from(t.1), TypeDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclNodeType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclNodeType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodeType> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: DeclNode, arg1: TypeDeclNode) -> impl '_ + Iterator<Item = DeclNodeType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclNode, arg1: TypeDeclNode) -> impl '_ + Iterator<Item = DeclNodeType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TypeDeclNode) -> impl '_ + Iterator<Item = DeclNodeType> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeType> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_decl_node(&mut self, tm: TypeDeclNode) -> Vec<DeclNodeType> {
    let mut ts = match self.element_index_type_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclNodeTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodePred(pub DeclNode, pub PredDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodePredTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodePred>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<DeclNodePred>>,
}
impl DeclNodePredTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_node: BTreeMap::new(),
    element_index_pred_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclNodePred) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_pred_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_pred_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclNodePred) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclNodePred) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclNodePred {
    DeclNodePred(DeclNode::from(t.0), PredDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclNodePred) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclNodePred {
    DeclNodePred(DeclNode::from(t.1), PredDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclNodePred> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclNodePred> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodePred> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclNode, arg1: PredDeclNode) -> impl '_ + Iterator<Item = DeclNodePred> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: PredDeclNode) -> impl '_ + Iterator<Item = DeclNodePred> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodePred> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_pred_decl_node(&mut self, tm: PredDeclNode) -> Vec<DeclNodePred> {
    let mut ts = match self.element_index_pred_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclNodePredTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_pred"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeFunc(pub DeclNode, pub FuncDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeFuncTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeFunc>>,
    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<DeclNodeFunc>>,
}
impl DeclNodeFuncTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_node: BTreeMap::new(),
    element_index_func_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclNodeFunc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_func_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclNodeFunc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclNodeFunc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclNodeFunc {
    DeclNodeFunc(DeclNode::from(t.0), FuncDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclNodeFunc) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclNodeFunc {
    DeclNodeFunc(DeclNode::from(t.1), FuncDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclNodeFunc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclNodeFunc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodeFunc> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclNode, arg1: FuncDeclNode) -> impl '_ + Iterator<Item = DeclNodeFunc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: FuncDeclNode) -> impl '_ + Iterator<Item = DeclNodeFunc> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeFunc> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_func_decl_node(&mut self, tm: FuncDeclNode) -> Vec<DeclNodeFunc> {
    let mut ts = match self.element_index_func_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclNodeFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeRule(pub DeclNode, pub RuleDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeRuleTable {
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeRule>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<DeclNodeRule>>,
}
impl DeclNodeRuleTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_node: BTreeMap::new(),
    element_index_rule_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclNodeRule) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_1_0.insert(Self::permute_1_0(t)) {
return false;
}



            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclNodeRule) -> bool {
    self.index_new_1_0.contains(&Self::permute_1_0(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_1_0
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_1_0(t)))
);

self.index_old_1_0.extend(
    self.index_new_1_0
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_1_0(t)))
);

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_1_0.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclNodeRule) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclNodeRule {
    DeclNodeRule(DeclNode::from(t.0), RuleDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclNodeRule) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclNodeRule {
    DeclNodeRule(DeclNode::from(t.1), RuleDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclNodeRule> {

self.index_new_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclNodeRule> {

self.index_new_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodeRule> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclNode, arg1: RuleDeclNode) -> impl '_ + Iterator<Item = DeclNodeRule> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDeclNode) -> impl '_ + Iterator<Item = DeclNodeRule> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: RuleDeclNode) -> impl '_ + Iterator<Item = DeclNodeRule> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeRule> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<DeclNodeRule> {
    let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclNodeRuleTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_rule"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeEnum(pub DeclNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeEnumTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeEnum>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<DeclNodeEnum>>,
}
impl DeclNodeEnumTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_node: BTreeMap::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclNodeEnum) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclNodeEnum) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclNodeEnum) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclNodeEnum {
    DeclNodeEnum(DeclNode::from(t.0), EnumDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclNodeEnum) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclNodeEnum {
    DeclNodeEnum(DeclNode::from(t.1), EnumDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclNodeEnum> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclNodeEnum> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodeEnum> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclNode, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = DeclNodeEnum> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = DeclNodeEnum> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeEnum> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<DeclNodeEnum> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclNodeEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeModel(pub DeclNode, pub ModelDeclNode);
#[derive(Clone, Hash, Debug)]
struct DeclNodeModelTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeModel>>,
    element_index_model_decl_node: BTreeMap<ModelDeclNode, Vec<DeclNodeModel>>,
}
impl DeclNodeModelTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_node: BTreeMap::new(),
    element_index_model_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclNodeModel) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_model_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_model_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclNodeModel) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclNodeModel) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclNodeModel {
    DeclNodeModel(DeclNode::from(t.0), ModelDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclNodeModel) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclNodeModel {
    DeclNodeModel(DeclNode::from(t.1), ModelDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclNodeModel> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclNodeModel> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodeModel> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclNode, arg1: ModelDeclNode) -> impl '_ + Iterator<Item = DeclNodeModel> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ModelDeclNode) -> impl '_ + Iterator<Item = DeclNodeModel> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeModel> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_model_decl_node(&mut self, tm: ModelDeclNode) -> Vec<DeclNodeModel> {
    let mut ts = match self.element_index_model_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclNodeModelTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_model"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilDeclListNode(pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct NilDeclListNodeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<NilDeclListNode>>,
}
impl NilDeclListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_decl_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilDeclListNode) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilDeclListNode) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilDeclListNode) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilDeclListNode {
    NilDeclListNode(DeclListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilDeclListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilDeclListNode> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: DeclListNode) -> impl '_ + Iterator<Item = NilDeclListNode> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<NilDeclListNode> {
    let mut ts = match self.element_index_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("nil_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsDeclListNode(pub DeclListNode, pub DeclNode, pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct ConsDeclListNodeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<ConsDeclListNode>>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<ConsDeclListNode>>,
}
impl ConsDeclListNodeTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_decl_list_node: BTreeMap::new(),
    element_index_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsDeclListNode) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_decl_list_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_list_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsDeclListNode) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsDeclListNode) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsDeclListNode {
    ConsDeclListNode(DeclListNode::from(t.0), DeclNode::from(t.1), DeclListNode::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsDeclListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsDeclListNode> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: DeclListNode) -> impl '_ + Iterator<Item = ConsDeclListNode> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: DeclListNode, arg1: DeclNode, arg2: DeclListNode) -> impl '_ + Iterator<Item = ConsDeclListNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<ConsDeclListNode> {
    let mut ts = match self.element_index_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<ConsDeclListNode> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsDeclListNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cons_decl_list_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclsModuleNode(pub ModuleNode, pub DeclListNode);
#[derive(Clone, Hash, Debug)]
struct DeclsModuleNodeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<DeclsModuleNode>>,
    element_index_module_node: BTreeMap<ModuleNode, Vec<DeclsModuleNode>>,
}
impl DeclsModuleNodeTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_list_node: BTreeMap::new(),
    element_index_module_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclsModuleNode) -> bool {
if self.index_old_1_0.contains(&Self::permute_1_0(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_module_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_module_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_decl_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_list_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclsModuleNode) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_1_0.contains(&Self::permute_1_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclsModuleNode) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclsModuleNode {
    DeclsModuleNode(ModuleNode::from(t.0), DeclListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclsModuleNode) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclsModuleNode {
    DeclsModuleNode(ModuleNode::from(t.1), DeclListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclsModuleNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclsModuleNode> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ModuleNode, arg1: DeclListNode) -> impl '_ + Iterator<Item = DeclsModuleNode> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: DeclListNode) -> impl '_ + Iterator<Item = DeclsModuleNode> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<DeclsModuleNode> {
    let mut ts = match self.element_index_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_module_node(&mut self, tm: ModuleNode) -> Vec<DeclsModuleNode> {
    let mut ts = match self.element_index_module_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclsModuleNodeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decls_module_node"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarInScope(pub VirtIdent, pub Scope);
#[derive(Clone, Hash, Debug)]
struct VarInScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_scope: BTreeMap<Scope, Vec<VarInScope>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VarInScope>>,
}
impl VarInScopeTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_scope: BTreeMap::new(),
    element_index_virt_ident: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: VarInScope) -> bool {
if self.index_old_1_0.contains(&Self::permute_1_0(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_virt_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_virt_ident.insert(t.0, vec![t]); },
            };
        

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: VarInScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_1_0.contains(&Self::permute_1_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: VarInScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> VarInScope {
    VarInScope(VirtIdent::from(t.0), Scope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: VarInScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> VarInScope {
    VarInScope(VirtIdent::from(t.1), Scope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = VarInScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = VarInScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: VirtIdent, arg1: Scope) -> impl '_ + Iterator<Item = VarInScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: VirtIdent, arg1: Scope) -> impl '_ + Iterator<Item = VarInScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = VarInScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<VarInScope> {
    let mut ts = match self.element_index_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<VarInScope> {
    let mut ts = match self.element_index_virt_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for VarInScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var_in_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ScopeExtension(pub Scope, pub Scope);
#[derive(Clone, Hash, Debug)]
struct ScopeExtensionTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_scope: BTreeMap<Scope, Vec<ScopeExtension>>,
}
impl ScopeExtensionTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ScopeExtension) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ScopeExtension) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ScopeExtension) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ScopeExtension {
    ScopeExtension(Scope::from(t.0), Scope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ScopeExtension) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ScopeExtension {
    ScopeExtension(Scope::from(t.1), Scope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ScopeExtension> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ScopeExtension> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Scope) -> impl '_ + Iterator<Item = ScopeExtension> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Scope) -> impl '_ + Iterator<Item = ScopeExtension> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Scope, arg1: Scope) -> impl '_ + Iterator<Item = ScopeExtension> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = ScopeExtension> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<ScopeExtension> {
    let mut ts = match self.element_index_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ScopeExtensionTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("scope_extension"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ScopeSingleChild(pub RuleDescendantNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct ScopeSingleChildTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<ScopeSingleChild>>,
}
impl ScopeSingleChildTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ScopeSingleChild) -> bool {
if self.index_old_1_0.contains(&Self::permute_1_0(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rule_descendant_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ScopeSingleChild) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_1_0.contains(&Self::permute_1_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ScopeSingleChild) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ScopeSingleChild {
    ScopeSingleChild(RuleDescendantNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ScopeSingleChild) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ScopeSingleChild {
    ScopeSingleChild(RuleDescendantNode::from(t.1), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ScopeSingleChild> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ScopeSingleChild> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDescendantNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = ScopeSingleChild> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = ScopeSingleChild> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<ScopeSingleChild> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ScopeSingleChildTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("scope_single_child"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ScopeExtensionSiblings(pub RuleDescendantNode, pub RuleDescendantNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct ScopeExtensionSiblingsTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<ScopeExtensionSiblings>>,
}
impl ScopeExtensionSiblingsTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ScopeExtensionSiblings) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_rule_descendant_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ScopeExtensionSiblings) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ScopeExtensionSiblings) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ScopeExtensionSiblings {
    ScopeExtensionSiblings(RuleDescendantNode::from(t.0), RuleDescendantNode::from(t.1), RuleDescendantNode::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: ScopeExtensionSiblings) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> ScopeExtensionSiblings {
    ScopeExtensionSiblings(RuleDescendantNode::from(t.1), RuleDescendantNode::from(t.0), RuleDescendantNode::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: ScopeExtensionSiblings) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> ScopeExtensionSiblings {
    ScopeExtensionSiblings(RuleDescendantNode::from(t.1), RuleDescendantNode::from(t.2), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: RuleDescendantNode) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: RuleDescendantNode, arg1: RuleDescendantNode, arg2: RuleDescendantNode) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: RuleDescendantNode) -> impl '_ + Iterator<Item = ScopeExtensionSiblings> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<ScopeExtensionSiblings> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ScopeExtensionSiblingsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("scope_extension_siblings"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsNormalType(pub Type);
#[derive(Clone, Hash, Debug)]
struct IsNormalTypeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_type: BTreeMap<Type, Vec<IsNormalType>>,
}
impl IsNormalTypeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IsNormalType) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IsNormalType) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: IsNormalType) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> IsNormalType {
    IsNormalType(Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IsNormalType> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IsNormalType> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = IsNormalType> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<IsNormalType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IsNormalTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_normal_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsEnumType(pub Type);
#[derive(Clone, Hash, Debug)]
struct IsEnumTypeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_type: BTreeMap<Type, Vec<IsEnumType>>,
}
impl IsEnumTypeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IsEnumType) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IsEnumType) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: IsEnumType) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> IsEnumType {
    IsEnumType(Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IsEnumType> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IsEnumType> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = IsEnumType> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<IsEnumType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IsEnumTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_enum_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsModelType(pub Type);
#[derive(Clone, Hash, Debug)]
struct IsModelTypeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_type: BTreeMap<Type, Vec<IsModelType>>,
}
impl IsModelTypeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IsModelType) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IsModelType) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: IsModelType) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> IsModelType {
    IsModelType(Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IsModelType> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = IsModelType> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IsModelType> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Type) -> impl '_ + Iterator<Item = IsModelType> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = IsModelType> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<IsModelType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IsModelTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_model_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsMorType(pub Type);
#[derive(Clone, Hash, Debug)]
struct IsMorTypeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_type: BTreeMap<Type, Vec<IsMorType>>,
}
impl IsMorTypeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IsMorType) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IsMorType) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: IsMorType) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> IsMorType {
    IsMorType(Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IsMorType> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IsMorType> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = IsMorType> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<IsMorType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IsMorTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_mor_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IllegalMemberTypeExprInSignature(pub TypeExprNode);
#[derive(Clone, Hash, Debug)]
struct IllegalMemberTypeExprInSignatureTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<IllegalMemberTypeExprInSignature>>,
}
impl IllegalMemberTypeExprInSignatureTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IllegalMemberTypeExprInSignature) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_type_expr_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IllegalMemberTypeExprInSignature) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: IllegalMemberTypeExprInSignature) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> IllegalMemberTypeExprInSignature {
    IllegalMemberTypeExprInSignature(TypeExprNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IllegalMemberTypeExprInSignature> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IllegalMemberTypeExprInSignature> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = IllegalMemberTypeExprInSignature> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<IllegalMemberTypeExprInSignature> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IllegalMemberTypeExprInSignatureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("illegal_member_type_expr_in_signature"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsTotalFunc(pub Func);
#[derive(Clone, Hash, Debug)]
struct IsTotalFuncTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_func: BTreeMap<Func, Vec<IsTotalFunc>>,
}
impl IsTotalFuncTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IsTotalFunc) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IsTotalFunc) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: IsTotalFunc) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> IsTotalFunc {
    IsTotalFunc(Func::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IsTotalFunc> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IsTotalFunc> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = IsTotalFunc> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<IsTotalFunc> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IsTotalFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_total_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelApp(pub Rel, pub ElList);
#[derive(Clone, Hash, Debug)]
struct RelAppTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_el_list: BTreeMap<ElList, Vec<RelApp>>,
    element_index_rel: BTreeMap<Rel, Vec<RelApp>>,
}
impl RelAppTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_rel: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RelApp) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rel.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RelApp) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RelApp) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RelApp {
    RelApp(Rel::from(t.0), ElList::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RelApp) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RelApp {
    RelApp(Rel::from(t.1), ElList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RelApp> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RelApp> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = RelApp> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = RelApp> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Rel, arg1: ElList) -> impl '_ + Iterator<Item = RelApp> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = RelApp> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = RelApp> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<RelApp> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<RelApp> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RelAppTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rel_app"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElType(pub El, pub ElementType);
#[derive(Clone, Hash, Debug)]
struct ElTypeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<ElType>>,
    element_index_element_type: BTreeMap<ElementType, Vec<ElType>>,
}
impl ElTypeTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_element_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ElType) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.0, vec![t]); },
            };
        

            match self.element_index_element_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ElType) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ElType) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ElType {
    ElType(El::from(t.0), ElementType::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ElType) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ElType {
    ElType(El::from(t.1), ElementType::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ElType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ElType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElType> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElType> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: El, arg1: ElementType) -> impl '_ + Iterator<Item = ElType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ElementType) -> impl '_ + Iterator<Item = ElType> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: ElementType) -> impl '_ + Iterator<Item = ElType> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<ElType> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_element_type(&mut self, tm: ElementType) -> Vec<ElType> {
    let mut ts = match self.element_index_element_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ElTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElTypes(pub ElList, pub ElementTypeList);
#[derive(Clone, Hash, Debug)]
struct ElTypesTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_el_list: BTreeMap<ElList, Vec<ElTypes>>,
    element_index_element_type_list: BTreeMap<ElementTypeList, Vec<ElTypes>>,
}
impl ElTypesTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_element_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ElTypes) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.0, vec![t]); },
            };
        

            match self.element_index_element_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ElTypes) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ElTypes) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ElTypes {
    ElTypes(ElList::from(t.0), ElementTypeList::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ElTypes) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ElTypes {
    ElTypes(ElList::from(t.1), ElementTypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ElTypes> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ElTypes> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ElTypes> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ElTypes> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ElList, arg1: ElementTypeList) -> impl '_ + Iterator<Item = ElTypes> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ElementTypeList) -> impl '_ + Iterator<Item = ElTypes> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: ElementTypeList) -> impl '_ + Iterator<Item = ElTypes> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<ElTypes> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_element_type_list(&mut self, tm: ElementTypeList) -> Vec<ElTypes> {
    let mut ts = match self.element_index_element_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ElTypesTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_types"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConstrainedEl(pub El);
#[derive(Clone, Hash, Debug)]
struct ConstrainedElTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_el: BTreeMap<El, Vec<ConstrainedEl>>,
}
impl ConstrainedElTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConstrainedEl) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConstrainedEl) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: ConstrainedEl) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> ConstrainedEl {
    ConstrainedEl(El::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConstrainedEl> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConstrainedEl> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ConstrainedEl> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<ConstrainedEl> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConstrainedElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("constrained_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConstrainedEls(pub ElList);
#[derive(Clone, Hash, Debug)]
struct ConstrainedElsTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_el_list: BTreeMap<ElList, Vec<ConstrainedEls>>,
}
impl ConstrainedElsTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_el_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConstrainedEls) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConstrainedEls) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: ConstrainedEls) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> ConstrainedEls {
    ConstrainedEls(ElList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConstrainedEls> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConstrainedEls> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ConstrainedEls> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<ConstrainedEls> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConstrainedElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("constrained_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct InKer(pub Morphism, pub El, pub El);
#[derive(Clone, Hash, Debug)]
struct InKerTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<InKer>>,
    element_index_morphism: BTreeMap<Morphism, Vec<InKer>>,
}
impl InKerTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_morphism: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: InKer) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: InKer) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: InKer) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> InKer {
    InKer(Morphism::from(t.0), El::from(t.1), El::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = InKer> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = InKer> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Morphism, arg1: El, arg2: El) -> impl '_ + Iterator<Item = InKer> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<InKer> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<InKer> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for InKerTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("in_ker"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElInImg(pub Morphism, pub El);
#[derive(Clone, Hash, Debug)]
struct ElInImgTable {
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<ElInImg>>,
    element_index_morphism: BTreeMap<Morphism, Vec<ElInImg>>,
}
impl ElInImgTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_morphism: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ElInImg) -> bool {
if self.index_old_1_0.contains(&Self::permute_1_0(t)) {
return false;
}
if !self.index_new_1_0.insert(Self::permute_1_0(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ElInImg) -> bool {
    self.index_new_1_0.contains(&Self::permute_1_0(t))
 || self.index_old_1_0.contains(&Self::permute_1_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0.extend(
    self.index_new_1_0
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_1_0(t)))
);

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_1_0.is_empty()
}
#[allow(unused)]
fn permute_1_0(t: ElInImg) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ElInImg {
    ElInImg(Morphism::from(t.1), El::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ElInImg> {

self.index_new_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ElInImg> {

self.index_new_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Morphism, arg1: El) -> impl '_ + Iterator<Item = ElInImg> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: El) -> impl '_ + Iterator<Item = ElInImg> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<ElInImg> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<ElInImg> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ElInImgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_in_img"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelTupleInImg(pub Morphism, pub Rel, pub ElList);
#[derive(Clone, Hash, Debug)]
struct RelTupleInImgTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_el_list: BTreeMap<ElList, Vec<RelTupleInImg>>,
    element_index_morphism: BTreeMap<Morphism, Vec<RelTupleInImg>>,
    element_index_rel: BTreeMap<Rel, Vec<RelTupleInImg>>,
}
impl RelTupleInImgTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_rel: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RelTupleInImg) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rel.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RelTupleInImg) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: RelTupleInImg) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> RelTupleInImg {
    RelTupleInImg(Morphism::from(t.0), Rel::from(t.1), ElList::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RelTupleInImg> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RelTupleInImg> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Morphism, arg1: Rel, arg2: ElList) -> impl '_ + Iterator<Item = RelTupleInImg> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<RelTupleInImg> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<RelTupleInImg> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<RelTupleInImg> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RelTupleInImgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rel_tuple_in_img"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SymbolScopeExtension(pub SymbolScope, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct SymbolScopeExtensionTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SymbolScopeExtension>>,
}
impl SymbolScopeExtensionTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SymbolScopeExtension) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SymbolScopeExtension) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: SymbolScopeExtension) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> SymbolScopeExtension {
    SymbolScopeExtension(SymbolScope::from(t.0), SymbolScope::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SymbolScopeExtension> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SymbolScopeExtension> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeExtension> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeExtension> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SymbolScopeExtension> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SymbolScopeExtensionTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("symbol_scope_extension"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SymbolScopeAncestor(pub SymbolScope, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct SymbolScopeAncestorTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SymbolScopeAncestor>>,
}
impl SymbolScopeAncestorTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SymbolScopeAncestor) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SymbolScopeAncestor) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: SymbolScopeAncestor) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> SymbolScopeAncestor {
    SymbolScopeAncestor(SymbolScope::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: SymbolScopeAncestor) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> SymbolScopeAncestor {
    SymbolScopeAncestor(SymbolScope::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SymbolScopeAncestor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SymbolScopeAncestor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeAncestor> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeAncestor> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeAncestor> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SymbolScopeAncestor> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SymbolScopeAncestorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("symbol_scope_ancestor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElementMemberSymbolScope(pub El, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct ElementMemberSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<ElementMemberSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ElementMemberSymbolScope>>,
}
impl ElementMemberSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ElementMemberSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ElementMemberSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ElementMemberSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ElementMemberSymbolScope {
    ElementMemberSymbolScope(El::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ElementMemberSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ElementMemberSymbolScope {
    ElementMemberSymbolScope(El::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ElementMemberSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ElementMemberSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElementMemberSymbolScope> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElementMemberSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: El, arg1: SymbolScope) -> impl '_ + Iterator<Item = ElementMemberSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = ElementMemberSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<ElementMemberSymbolScope> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ElementMemberSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ElementMemberSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("element_member_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DefinedSymbol(pub SymbolScope, pub Ident, pub SymbolKind, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DefinedSymbolTable {
    index_new_0_1_2_3: BTreeSet<(u32, u32, u32, u32, )>,
    index_old_0_1_2_3: BTreeSet<(u32, u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<DefinedSymbol>>,
    element_index_loc: BTreeMap<Loc, Vec<DefinedSymbol>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<DefinedSymbol>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<DefinedSymbol>>,
}
impl DefinedSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2_3: BTreeSet::new(),
        index_old_0_1_2_3: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    element_index_symbol_kind: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DefinedSymbol) -> bool {
if self.index_old_0_1_2_3.contains(&Self::permute_0_1_2_3(t)) {
return false;
}
if !self.index_new_0_1_2_3.insert(Self::permute_0_1_2_3(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_symbol_kind.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.2, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.3, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DefinedSymbol) -> bool {
    self.index_new_0_1_2_3.contains(&Self::permute_0_1_2_3(t))
 || self.index_old_0_1_2_3.contains(&Self::permute_0_1_2_3(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2_3.extend(
    self.index_new_0_1_2_3
    .iter().copied()
    .map(|t| Self::permute_0_1_2_3(Self::permute_inverse_0_1_2_3(t)))
);

self.index_new_0_1_2_3.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2_3.is_empty()
}
#[allow(unused)]
fn permute_0_1_2_3(t: DefinedSymbol) -> (u32, u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), t.3.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2_3(t: (u32, u32, u32, u32, )) -> DefinedSymbol {
    DefinedSymbol(SymbolScope::from(t.0), Ident::from(t.1), SymbolKind::from(t.2), Loc::from(t.3))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DefinedSymbol> {

self.index_new_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DefinedSymbol> {

self.index_new_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = DefinedSymbol> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = DefinedSymbol> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn iter_all_0_1_2_3(&self, arg0: SymbolScope, arg1: Ident, arg2: SymbolKind, arg3: Loc) -> impl '_ + Iterator<Item = DefinedSymbol> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
    let arg3 = arg3.0;
self.index_new_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<DefinedSymbol> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<DefinedSymbol> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<DefinedSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<DefinedSymbol> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DefinedSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("defined_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AccessibleSymbol(pub SymbolScope, pub Ident, pub SymbolKind, pub Loc);
#[derive(Clone, Hash, Debug)]
struct AccessibleSymbolTable {
    index_new_0_1_2_3: BTreeSet<(u32, u32, u32, u32, )>,
    index_old_0_1_2_3: BTreeSet<(u32, u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<AccessibleSymbol>>,
    element_index_loc: BTreeMap<Loc, Vec<AccessibleSymbol>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<AccessibleSymbol>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<AccessibleSymbol>>,
}
impl AccessibleSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2_3: BTreeSet::new(),
        index_old_0_1_2_3: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    element_index_symbol_kind: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: AccessibleSymbol) -> bool {
if self.index_old_0_1_2_3.contains(&Self::permute_0_1_2_3(t)) {
return false;
}
if !self.index_new_0_1_2_3.insert(Self::permute_0_1_2_3(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_symbol_kind.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.2, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.3, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: AccessibleSymbol) -> bool {
    self.index_new_0_1_2_3.contains(&Self::permute_0_1_2_3(t))
 || self.index_old_0_1_2_3.contains(&Self::permute_0_1_2_3(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2_3.extend(
    self.index_new_0_1_2_3
    .iter().copied()
    .map(|t| Self::permute_0_1_2_3(Self::permute_inverse_0_1_2_3(t)))
);

self.index_new_0_1_2_3.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2_3.is_empty()
}
#[allow(unused)]
fn permute_0_1_2_3(t: AccessibleSymbol) -> (u32, u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), t.3.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2_3(t: (u32, u32, u32, u32, )) -> AccessibleSymbol {
    AccessibleSymbol(SymbolScope::from(t.0), Ident::from(t.1), SymbolKind::from(t.2), Loc::from(t.3))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = AccessibleSymbol> {

self.index_new_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = AccessibleSymbol> {

self.index_new_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = AccessibleSymbol> {
    let arg0 = arg0.0;
self.index_new_0_1_2_3
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn iter_all_0_1_2_3(&self, arg0: SymbolScope, arg1: Ident, arg2: SymbolKind, arg3: Loc) -> impl '_ + Iterator<Item = AccessibleSymbol> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
    let arg3 = arg3.0;
self.index_new_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<AccessibleSymbol> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<AccessibleSymbol> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<AccessibleSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<AccessibleSymbol> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for AccessibleSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("accessible_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeSymbol(pub Ident, pub SymbolKind, pub SymbolScope, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ShouldBeSymbolTable {
    index_new_0_1_2_3: BTreeSet<(u32, u32, u32, u32, )>,
    index_old_0_1_2_3: BTreeSet<(u32, u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<ShouldBeSymbol>>,
    element_index_loc: BTreeMap<Loc, Vec<ShouldBeSymbol>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<ShouldBeSymbol>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ShouldBeSymbol>>,
}
impl ShouldBeSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2_3: BTreeSet::new(),
        index_old_0_1_2_3: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    element_index_symbol_kind: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ShouldBeSymbol) -> bool {
if self.index_old_0_1_2_3.contains(&Self::permute_0_1_2_3(t)) {
return false;
}
if !self.index_new_0_1_2_3.insert(Self::permute_0_1_2_3(t)) {
return false;
}



            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_kind.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.1, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.2, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.3, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ShouldBeSymbol) -> bool {
    self.index_new_0_1_2_3.contains(&Self::permute_0_1_2_3(t))
 || self.index_old_0_1_2_3.contains(&Self::permute_0_1_2_3(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2_3.extend(
    self.index_new_0_1_2_3
    .iter().copied()
    .map(|t| Self::permute_0_1_2_3(Self::permute_inverse_0_1_2_3(t)))
);

self.index_new_0_1_2_3.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2_3.is_empty()
}
#[allow(unused)]
fn permute_0_1_2_3(t: ShouldBeSymbol) -> (u32, u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), t.3.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2_3(t: (u32, u32, u32, u32, )) -> ShouldBeSymbol {
    ShouldBeSymbol(Ident::from(t.0), SymbolKind::from(t.1), SymbolScope::from(t.2), Loc::from(t.3))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ShouldBeSymbol> {

self.index_new_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ShouldBeSymbol> {

self.index_new_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn iter_old_0_1_2(&self, arg0: Ident, arg1: SymbolKind, arg2: SymbolScope) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg0, arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
}
#[allow(dead_code)]
fn iter_all_0_1_2_3(&self, arg0: Ident, arg1: SymbolKind, arg2: SymbolScope, arg3: Loc) -> impl '_ + Iterator<Item = ShouldBeSymbol> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
    let arg3 = arg3.0;
self.index_new_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
.chain(self.index_old_0_1_2_3
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ShouldBeSymbol> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ShouldBeSymbol> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<ShouldBeSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ShouldBeSymbol> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3.remove(&Self::permute_0_1_2_3(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ShouldBeSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_symbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeSymbol2(pub Ident, pub SymbolKind, pub SymbolKind, pub SymbolScope, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ShouldBeSymbol2Table {
    index_new_0_1_2_3_4: BTreeSet<(u32, u32, u32, u32, u32, )>,
    index_old_0_1_2_3_4: BTreeSet<(u32, u32, u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<ShouldBeSymbol2>>,
    element_index_loc: BTreeMap<Loc, Vec<ShouldBeSymbol2>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<ShouldBeSymbol2>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ShouldBeSymbol2>>,
}
impl ShouldBeSymbol2Table {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2_3_4: BTreeSet::new(),
        index_old_0_1_2_3_4: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    element_index_symbol_kind: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ShouldBeSymbol2) -> bool {
if self.index_old_0_1_2_3_4.contains(&Self::permute_0_1_2_3_4(t)) {
return false;
}
if !self.index_new_0_1_2_3_4.insert(Self::permute_0_1_2_3_4(t)) {
return false;
}



            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_kind.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.1, vec![t]); },
            };
        

            match self.element_index_symbol_kind.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.2, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.3, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.4) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.4, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ShouldBeSymbol2) -> bool {
    self.index_new_0_1_2_3_4.contains(&Self::permute_0_1_2_3_4(t))
 || self.index_old_0_1_2_3_4.contains(&Self::permute_0_1_2_3_4(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2_3_4.extend(
    self.index_new_0_1_2_3_4
    .iter().copied()
    .map(|t| Self::permute_0_1_2_3_4(Self::permute_inverse_0_1_2_3_4(t)))
);

self.index_new_0_1_2_3_4.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2_3_4.is_empty()
}
#[allow(unused)]
fn permute_0_1_2_3_4(t: ShouldBeSymbol2) -> (u32, u32, u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), t.3.into(), t.4.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2_3_4(t: (u32, u32, u32, u32, u32, )) -> ShouldBeSymbol2 {
    ShouldBeSymbol2(Ident::from(t.0), SymbolKind::from(t.1), SymbolKind::from(t.2), SymbolScope::from(t.3), Loc::from(t.4))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ShouldBeSymbol2> {

self.index_new_0_1_2_3_4
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ShouldBeSymbol2> {

self.index_new_0_1_2_3_4
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4)
.chain(self.index_old_0_1_2_3_4
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4)
)}
#[allow(dead_code)]
fn iter_all_0_1_2_3_4(&self, arg0: Ident, arg1: SymbolKind, arg2: SymbolKind, arg3: SymbolScope, arg4: Loc) -> impl '_ + Iterator<Item = ShouldBeSymbol2> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
    let arg3 = arg3.0;
    let arg4 = arg4.0;
self.index_new_0_1_2_3_4
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3, arg4,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3, arg4,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4)
.chain(self.index_old_0_1_2_3_4
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3, arg4,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3, arg4,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ShouldBeSymbol2> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3_4.remove(&Self::permute_0_1_2_3_4(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3_4.remove(&Self::permute_0_1_2_3_4(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ShouldBeSymbol2> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3_4.remove(&Self::permute_0_1_2_3_4(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3_4.remove(&Self::permute_0_1_2_3_4(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<ShouldBeSymbol2> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3_4.remove(&Self::permute_0_1_2_3_4(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3_4.remove(&Self::permute_0_1_2_3_4(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ShouldBeSymbol2> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3_4.remove(&Self::permute_0_1_2_3_4(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3_4.remove(&Self::permute_0_1_2_3_4(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ShouldBeSymbol2Table {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_symbol_2"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeSymbol3(pub Ident, pub SymbolKind, pub SymbolKind, pub SymbolKind, pub SymbolScope, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ShouldBeSymbol3Table {
    index_new_0_1_2_3_4_5: BTreeSet<(u32, u32, u32, u32, u32, u32, )>,
    index_old_0_1_2_3_4_5: BTreeSet<(u32, u32, u32, u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<ShouldBeSymbol3>>,
    element_index_loc: BTreeMap<Loc, Vec<ShouldBeSymbol3>>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<ShouldBeSymbol3>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ShouldBeSymbol3>>,
}
impl ShouldBeSymbol3Table {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2_3_4_5: BTreeSet::new(),
        index_old_0_1_2_3_4_5: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    element_index_symbol_kind: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ShouldBeSymbol3) -> bool {
if self.index_old_0_1_2_3_4_5.contains(&Self::permute_0_1_2_3_4_5(t)) {
return false;
}
if !self.index_new_0_1_2_3_4_5.insert(Self::permute_0_1_2_3_4_5(t)) {
return false;
}



            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_kind.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.1, vec![t]); },
            };
        

            match self.element_index_symbol_kind.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.2, vec![t]); },
            };
        

            match self.element_index_symbol_kind.get_mut(&t.3) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.3, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.4) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.4, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.5) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.5, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ShouldBeSymbol3) -> bool {
    self.index_new_0_1_2_3_4_5.contains(&Self::permute_0_1_2_3_4_5(t))
 || self.index_old_0_1_2_3_4_5.contains(&Self::permute_0_1_2_3_4_5(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2_3_4_5.extend(
    self.index_new_0_1_2_3_4_5
    .iter().copied()
    .map(|t| Self::permute_0_1_2_3_4_5(Self::permute_inverse_0_1_2_3_4_5(t)))
);

self.index_new_0_1_2_3_4_5.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2_3_4_5.is_empty()
}
#[allow(unused)]
fn permute_0_1_2_3_4_5(t: ShouldBeSymbol3) -> (u32, u32, u32, u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), t.3.into(), t.4.into(), t.5.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2_3_4_5(t: (u32, u32, u32, u32, u32, u32, )) -> ShouldBeSymbol3 {
    ShouldBeSymbol3(Ident::from(t.0), SymbolKind::from(t.1), SymbolKind::from(t.2), SymbolKind::from(t.3), SymbolScope::from(t.4), Loc::from(t.5))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ShouldBeSymbol3> {

self.index_new_0_1_2_3_4_5
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4_5)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ShouldBeSymbol3> {

self.index_new_0_1_2_3_4_5
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4_5)
.chain(self.index_old_0_1_2_3_4_5
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4_5)
)}
#[allow(dead_code)]
fn iter_all_0_1_2_3_4_5(&self, arg0: Ident, arg1: SymbolKind, arg2: SymbolKind, arg3: SymbolKind, arg4: SymbolScope, arg5: Loc) -> impl '_ + Iterator<Item = ShouldBeSymbol3> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
    let arg3 = arg3.0;
    let arg4 = arg4.0;
    let arg5 = arg5.0;
self.index_new_0_1_2_3_4_5
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3, arg4, arg5,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3, arg4, arg5,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4_5)
.chain(self.index_old_0_1_2_3_4_5
    .range((
        Bound::Included(&(arg0, arg1, arg2, arg3, arg4, arg5,  )),
        Bound::Included(&(arg0, arg1, arg2, arg3, arg4, arg5,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2_3_4_5)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ShouldBeSymbol3> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3_4_5.remove(&Self::permute_0_1_2_3_4_5(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3_4_5.remove(&Self::permute_0_1_2_3_4_5(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ShouldBeSymbol3> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3_4_5.remove(&Self::permute_0_1_2_3_4_5(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3_4_5.remove(&Self::permute_0_1_2_3_4_5(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<ShouldBeSymbol3> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3_4_5.remove(&Self::permute_0_1_2_3_4_5(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3_4_5.remove(&Self::permute_0_1_2_3_4_5(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ShouldBeSymbol3> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2_3_4_5.remove(&Self::permute_0_1_2_3_4_5(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2_3_4_5.remove(&Self::permute_0_1_2_3_4_5(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ShouldBeSymbol3Table {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_symbol_3"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredArgNumShouldMatch(pub Nat, pub Nat, pub Loc);
#[derive(Clone, Hash, Debug)]
struct PredArgNumShouldMatchTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<PredArgNumShouldMatch>>,
    element_index_nat: BTreeMap<Nat, Vec<PredArgNumShouldMatch>>,
}
impl PredArgNumShouldMatchTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_nat: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PredArgNumShouldMatch) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.0, vec![t]); },
            };
        

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.1, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PredArgNumShouldMatch) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: PredArgNumShouldMatch) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> PredArgNumShouldMatch {
    PredArgNumShouldMatch(Nat::from(t.0), Nat::from(t.1), Loc::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Nat, arg1: Nat, arg2: Loc) -> impl '_ + Iterator<Item = PredArgNumShouldMatch> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<PredArgNumShouldMatch> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<PredArgNumShouldMatch> {
    let mut ts = match self.element_index_nat.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PredArgNumShouldMatchTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_arg_num_should_match"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncArgNumShouldMatch(pub Nat, pub Nat, pub Loc);
#[derive(Clone, Hash, Debug)]
struct FuncArgNumShouldMatchTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<FuncArgNumShouldMatch>>,
    element_index_nat: BTreeMap<Nat, Vec<FuncArgNumShouldMatch>>,
}
impl FuncArgNumShouldMatchTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_nat: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FuncArgNumShouldMatch) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.0, vec![t]); },
            };
        

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.1, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FuncArgNumShouldMatch) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: FuncArgNumShouldMatch) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> FuncArgNumShouldMatch {
    FuncArgNumShouldMatch(Nat::from(t.0), Nat::from(t.1), Loc::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Nat, arg1: Nat, arg2: Loc) -> impl '_ + Iterator<Item = FuncArgNumShouldMatch> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<FuncArgNumShouldMatch> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<FuncArgNumShouldMatch> {
    let mut ts = match self.element_index_nat.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FuncArgNumShouldMatchTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_arg_num_should_match"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdge(pub StmtNode, pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdge>>,
}
impl CfgEdgeTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CfgEdge) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CfgEdge) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CfgEdge) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CfgEdge {
    CfgEdge(StmtNode::from(t.0), StmtNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CfgEdge> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CfgEdge> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = CfgEdge> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: StmtNode) -> impl '_ + Iterator<Item = CfgEdge> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdge> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CfgEdgeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdgeStmtsStmt(pub StmtListNode, pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeStmtsStmtTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<CfgEdgeStmtsStmt>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdgeStmtsStmt>>,
}
impl CfgEdgeStmtsStmtTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CfgEdgeStmtsStmt) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CfgEdgeStmtsStmt) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CfgEdgeStmtsStmt) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CfgEdgeStmtsStmt {
    CfgEdgeStmtsStmt(StmtListNode::from(t.0), StmtNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtListNode, arg1: StmtNode) -> impl '_ + Iterator<Item = CfgEdgeStmtsStmt> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<CfgEdgeStmtsStmt> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdgeStmtsStmt> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CfgEdgeStmtsStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge_stmts_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdgeStmtStmts(pub StmtNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeStmtStmtsTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<CfgEdgeStmtStmts>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdgeStmtStmts>>,
}
impl CfgEdgeStmtStmtsTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CfgEdgeStmtStmts) -> bool {
if self.index_old_1_0.contains(&Self::permute_1_0(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CfgEdgeStmtStmts) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_1_0.contains(&Self::permute_1_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CfgEdgeStmtStmts) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CfgEdgeStmtStmts {
    CfgEdgeStmtStmts(StmtNode::from(t.0), StmtListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: CfgEdgeStmtStmts) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> CfgEdgeStmtStmts {
    CfgEdgeStmtStmts(StmtNode::from(t.1), StmtListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CfgEdgeStmtStmts> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CfgEdgeStmtStmts> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: StmtListNode) -> impl '_ + Iterator<Item = CfgEdgeStmtStmts> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: StmtListNode) -> impl '_ + Iterator<Item = CfgEdgeStmtStmts> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<CfgEdgeStmtStmts> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdgeStmtStmts> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CfgEdgeStmtStmtsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge_stmt_stmts"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdgeFork(pub StmtNode, pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeForkTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<CfgEdgeFork>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdgeFork>>,
}
impl CfgEdgeForkTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_stmt_block_list_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CfgEdgeFork) -> bool {
if self.index_old_1_0.contains(&Self::permute_1_0(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_block_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_block_list_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CfgEdgeFork) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_1_0.contains(&Self::permute_1_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CfgEdgeFork) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CfgEdgeFork {
    CfgEdgeFork(StmtNode::from(t.0), StmtBlockListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: CfgEdgeFork) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> CfgEdgeFork {
    CfgEdgeFork(StmtNode::from(t.1), StmtBlockListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CfgEdgeFork> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CfgEdgeFork> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: StmtBlockListNode) -> impl '_ + Iterator<Item = CfgEdgeFork> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1, arg0,  )),
        Bound::Included(&(arg1, arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: StmtBlockListNode) -> impl '_ + Iterator<Item = CfgEdgeFork> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_stmt_block_list_node(&mut self, tm: StmtBlockListNode) -> Vec<CfgEdgeFork> {
    let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdgeFork> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_1_0.remove(&Self::permute_1_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CfgEdgeForkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge_fork"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CfgEdgeJoin(pub StmtBlockListNode, pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct CfgEdgeJoinTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<CfgEdgeJoin>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<CfgEdgeJoin>>,
}
impl CfgEdgeJoinTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_stmt_block_list_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CfgEdgeJoin) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_block_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_block_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CfgEdgeJoin) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CfgEdgeJoin) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CfgEdgeJoin {
    CfgEdgeJoin(StmtBlockListNode::from(t.0), StmtNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CfgEdgeJoin> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CfgEdgeJoin> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtBlockListNode) -> impl '_ + Iterator<Item = CfgEdgeJoin> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtBlockListNode, arg1: StmtNode) -> impl '_ + Iterator<Item = CfgEdgeJoin> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_stmt_block_list_node(&mut self, tm: StmtBlockListNode) -> Vec<CfgEdgeJoin> {
    let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<CfgEdgeJoin> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CfgEdgeJoinTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cfg_edge_join"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BeforeStmtStructure(pub StmtNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct BeforeStmtStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<BeforeStmtStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<BeforeStmtStructure>>,
}
impl BeforeStmtStructureTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_stmt_node: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: BeforeStmtStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: BeforeStmtStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: BeforeStmtStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> BeforeStmtStructure {
    BeforeStmtStructure(StmtNode::from(t.0), Structure::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: BeforeStmtStructure) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> BeforeStmtStructure {
    BeforeStmtStructure(StmtNode::from(t.1), Structure::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = BeforeStmtStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = BeforeStmtStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: StmtNode, arg1: Structure) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: Structure) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = BeforeStmtStructure> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<BeforeStmtStructure> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<BeforeStmtStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for BeforeStmtStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("before_stmt_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtMorphism(pub StmtNode, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct StmtMorphismTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<StmtMorphism>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<StmtMorphism>>,
}
impl StmtMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: StmtMorphism) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_morphism.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: StmtMorphism) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: StmtMorphism) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> StmtMorphism {
    StmtMorphism(StmtNode::from(t.0), Morphism::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: StmtMorphism) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> StmtMorphism {
    StmtMorphism(StmtNode::from(t.1), Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = StmtMorphism> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = StmtMorphism> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = StmtMorphism> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: Morphism) -> impl '_ + Iterator<Item = StmtMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Morphism) -> impl '_ + Iterator<Item = StmtMorphism> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<StmtMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<StmtMorphism> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for StmtMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfMorphism(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct IfMorphismTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<IfMorphism>>,
}
impl IfMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IfMorphism) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IfMorphism) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: IfMorphism) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> IfMorphism {
    IfMorphism(Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IfMorphism> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IfMorphism> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = IfMorphism> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<IfMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IfMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SurjThenMorphism(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct SurjThenMorphismTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<SurjThenMorphism>>,
}
impl SurjThenMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SurjThenMorphism) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SurjThenMorphism) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: SurjThenMorphism) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> SurjThenMorphism {
    SurjThenMorphism(Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SurjThenMorphism> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = SurjThenMorphism> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SurjThenMorphism> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = SurjThenMorphism> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = SurjThenMorphism> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<SurjThenMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SurjThenMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("surj_then_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NonSurjThenMorphism(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct NonSurjThenMorphismTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<NonSurjThenMorphism>>,
}
impl NonSurjThenMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NonSurjThenMorphism) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NonSurjThenMorphism) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NonSurjThenMorphism) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NonSurjThenMorphism {
    NonSurjThenMorphism(Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NonSurjThenMorphism> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = NonSurjThenMorphism> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NonSurjThenMorphism> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = NonSurjThenMorphism> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = NonSurjThenMorphism> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<NonSurjThenMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NonSurjThenMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("non_surj_then_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NoopMorphism(pub Morphism);
#[derive(Clone, Hash, Debug)]
struct NoopMorphismTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<NoopMorphism>>,
}
impl NoopMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NoopMorphism) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NoopMorphism) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NoopMorphism) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NoopMorphism {
    NoopMorphism(Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NoopMorphism> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NoopMorphism> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = NoopMorphism> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<NoopMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NoopMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("noop_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtStructure(pub StmtNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct StmtStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<StmtStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<StmtStructure>>,
}
impl StmtStructureTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_stmt_node: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: StmtStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: StmtStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: StmtStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> StmtStructure {
    StmtStructure(StmtNode::from(t.0), Structure::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = StmtStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = StmtStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = StmtStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: Structure) -> impl '_ + Iterator<Item = StmtStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<StmtStructure> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<StmtStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for StmtStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomStructure(pub IfAtomNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct IfAtomStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfAtomStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<IfAtomStructure>>,
}
impl IfAtomStructureTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IfAtomStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IfAtomStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: IfAtomStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> IfAtomStructure {
    IfAtomStructure(IfAtomNode::from(t.0), Structure::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IfAtomStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IfAtomStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = IfAtomStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: IfAtomNode, arg1: Structure) -> impl '_ + Iterator<Item = IfAtomStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<IfAtomStructure> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<IfAtomStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IfAtomStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_atom_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomStructure(pub ThenAtomNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ThenAtomStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_structure: BTreeMap<Structure, Vec<ThenAtomStructure>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenAtomStructure>>,
}
impl ThenAtomStructureTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_structure: BTreeMap::new(),
    element_index_then_atom_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ThenAtomStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_then_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ThenAtomStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ThenAtomStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ThenAtomStructure {
    ThenAtomStructure(ThenAtomNode::from(t.0), Structure::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ThenAtomStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ThenAtomStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = ThenAtomStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ThenAtomNode, arg1: Structure) -> impl '_ + Iterator<Item = ThenAtomStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<ThenAtomStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<ThenAtomStructure> {
    let mut ts = match self.element_index_then_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ThenAtomStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_atom_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermStructure(pub TermNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct TermStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_structure: BTreeMap<Structure, Vec<TermStructure>>,
    element_index_term_node: BTreeMap<TermNode, Vec<TermStructure>>,
}
impl TermStructureTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_structure: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TermStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TermStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TermStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TermStructure {
    TermStructure(TermNode::from(t.0), Structure::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TermStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TermStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: TermNode, arg1: Structure) -> impl '_ + Iterator<Item = TermStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermNode, arg1: Structure) -> impl '_ + Iterator<Item = TermStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<TermStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<TermStructure> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TermStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermsStructure(pub TermListNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct TermsStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_structure: BTreeMap<Structure, Vec<TermsStructure>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermsStructure>>,
}
impl TermsStructureTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_structure: BTreeMap::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TermsStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TermsStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TermsStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TermsStructure {
    TermsStructure(TermListNode::from(t.0), Structure::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: TermsStructure) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> TermsStructure {
    TermsStructure(TermListNode::from(t.1), Structure::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TermsStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TermsStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermsStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermListNode, arg1: Structure) -> impl '_ + Iterator<Item = TermsStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = TermsStructure> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<TermsStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<TermsStructure> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TermsStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("terms_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct OptTermStructure(pub OptTermNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct OptTermStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<OptTermStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<OptTermStructure>>,
}
impl OptTermStructureTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_opt_term_node: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: OptTermStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_opt_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: OptTermStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: OptTermStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> OptTermStructure {
    OptTermStructure(OptTermNode::from(t.0), Structure::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = OptTermStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = OptTermStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = OptTermStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: OptTermNode, arg1: Structure) -> impl '_ + Iterator<Item = OptTermStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<OptTermStructure> {
    let mut ts = match self.element_index_opt_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<OptTermStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for OptTermStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("opt_term_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeExprStructure(pub TypeExprNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct TypeExprStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_structure: BTreeMap<Structure, Vec<TypeExprStructure>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<TypeExprStructure>>,
}
impl TypeExprStructureTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_structure: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TypeExprStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_expr_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TypeExprStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TypeExprStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TypeExprStructure {
    TypeExprStructure(TypeExprNode::from(t.0), Structure::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TypeExprStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TypeExprStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = TypeExprStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeExprNode, arg1: Structure) -> impl '_ + Iterator<Item = TypeExprStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<TypeExprStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<TypeExprStructure> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TypeExprStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_expr_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermShouldBeEpicOk(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct TermShouldBeEpicOkTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_term_node: BTreeMap<TermNode, Vec<TermShouldBeEpicOk>>,
}
impl TermShouldBeEpicOkTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TermShouldBeEpicOk) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TermShouldBeEpicOk) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: TermShouldBeEpicOk) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> TermShouldBeEpicOk {
    TermShouldBeEpicOk(TermNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermShouldBeEpicOk> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<TermShouldBeEpicOk> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TermShouldBeEpicOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_should_be_epic_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermsShouldBeEpicOk(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct TermsShouldBeEpicOkTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermsShouldBeEpicOk>>,
}
impl TermsShouldBeEpicOkTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TermsShouldBeEpicOk) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TermsShouldBeEpicOk) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: TermsShouldBeEpicOk) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> TermsShouldBeEpicOk {
    TermsShouldBeEpicOk(TermListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermsShouldBeEpicOk> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<TermsShouldBeEpicOk> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TermsShouldBeEpicOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("terms_should_be_epic_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElShouldBeSurjectiveOk(pub El);
#[derive(Clone, Hash, Debug)]
struct ElShouldBeSurjectiveOkTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_el: BTreeMap<El, Vec<ElShouldBeSurjectiveOk>>,
}
impl ElShouldBeSurjectiveOkTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ElShouldBeSurjectiveOk) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ElShouldBeSurjectiveOk) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: ElShouldBeSurjectiveOk) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> ElShouldBeSurjectiveOk {
    ElShouldBeSurjectiveOk(El::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElShouldBeSurjectiveOk> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<ElShouldBeSurjectiveOk> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ElShouldBeSurjectiveOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_should_be_surjective_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElIsSurjectiveOk(pub El);
#[derive(Clone, Hash, Debug)]
struct ElIsSurjectiveOkTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_el: BTreeMap<El, Vec<ElIsSurjectiveOk>>,
}
impl ElIsSurjectiveOkTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ElIsSurjectiveOk) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ElIsSurjectiveOk) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: ElIsSurjectiveOk) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> ElIsSurjectiveOk {
    ElIsSurjectiveOk(El::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElIsSurjectiveOk> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<ElIsSurjectiveOk> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ElIsSurjectiveOkTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_is_surjective_ok"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ShouldBeObtainedByCtor(pub TermNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct ShouldBeObtainedByCtorTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<ShouldBeObtainedByCtor>>,
    element_index_term_node: BTreeMap<TermNode, Vec<ShouldBeObtainedByCtor>>,
}
impl ShouldBeObtainedByCtorTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ShouldBeObtainedByCtor) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ShouldBeObtainedByCtor) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ShouldBeObtainedByCtor) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ShouldBeObtainedByCtor {
    ShouldBeObtainedByCtor(TermNode::from(t.0), EnumDeclNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ShouldBeObtainedByCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ShouldBeObtainedByCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermNode, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = ShouldBeObtainedByCtor> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<ShouldBeObtainedByCtor> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<ShouldBeObtainedByCtor> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ShouldBeObtainedByCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("should_be_obtained_by_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsGivenByCtor(pub TermNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct IsGivenByCtorTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<IsGivenByCtor>>,
    element_index_term_node: BTreeMap<TermNode, Vec<IsGivenByCtor>>,
}
impl IsGivenByCtorTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IsGivenByCtor) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IsGivenByCtor) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: IsGivenByCtor) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> IsGivenByCtor {
    IsGivenByCtor(TermNode::from(t.0), EnumDeclNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IsGivenByCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IsGivenByCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermNode, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = IsGivenByCtor> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<IsGivenByCtor> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<IsGivenByCtor> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IsGivenByCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_given_by_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FunctionCanBeMadeDefined(pub Func);
#[derive(Clone, Hash, Debug)]
struct FunctionCanBeMadeDefinedTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_func: BTreeMap<Func, Vec<FunctionCanBeMadeDefined>>,
}
impl FunctionCanBeMadeDefinedTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FunctionCanBeMadeDefined) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FunctionCanBeMadeDefined) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: FunctionCanBeMadeDefined) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> FunctionCanBeMadeDefined {
    FunctionCanBeMadeDefined(Func::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FunctionCanBeMadeDefined> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FunctionCanBeMadeDefined> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = FunctionCanBeMadeDefined> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<FunctionCanBeMadeDefined> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FunctionCanBeMadeDefinedTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("function_can_be_made_defined"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasePatternIsVariable(pub Loc);
#[derive(Clone, Hash, Debug)]
struct CasePatternIsVariableTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<CasePatternIsVariable>>,
}
impl CasePatternIsVariableTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CasePatternIsVariable) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_loc.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CasePatternIsVariable) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: CasePatternIsVariable) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> CasePatternIsVariable {
    CasePatternIsVariable(Loc::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CasePatternIsVariable> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CasePatternIsVariable> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Loc) -> impl '_ + Iterator<Item = CasePatternIsVariable> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<CasePatternIsVariable> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CasePatternIsVariableTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("case_pattern_is_variable"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasePatternIsWildcard(pub Loc);
#[derive(Clone, Hash, Debug)]
struct CasePatternIsWildcardTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<CasePatternIsWildcard>>,
}
impl CasePatternIsWildcardTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CasePatternIsWildcard) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_loc.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CasePatternIsWildcard) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: CasePatternIsWildcard) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> CasePatternIsWildcard {
    CasePatternIsWildcard(Loc::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CasePatternIsWildcard> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CasePatternIsWildcard> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Loc) -> impl '_ + Iterator<Item = CasePatternIsWildcard> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<CasePatternIsWildcard> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CasePatternIsWildcardTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("case_pattern_is_wildcard"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IsPatternCtorArg(pub TermNode);
#[derive(Clone, Hash, Debug)]
struct IsPatternCtorArgTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_term_node: BTreeMap<TermNode, Vec<IsPatternCtorArg>>,
}
impl IsPatternCtorArgTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IsPatternCtorArg) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IsPatternCtorArg) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: IsPatternCtorArg) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> IsPatternCtorArg {
    IsPatternCtorArg(TermNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IsPatternCtorArg> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = IsPatternCtorArg> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IsPatternCtorArg> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = IsPatternCtorArg> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = IsPatternCtorArg> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<IsPatternCtorArg> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IsPatternCtorArgTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("is_pattern_ctor_arg"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArePatternCtorArgs(pub TermListNode);
#[derive(Clone, Hash, Debug)]
struct ArePatternCtorArgsTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<ArePatternCtorArgs>>,
}
impl ArePatternCtorArgsTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ArePatternCtorArgs) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ArePatternCtorArgs) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: ArePatternCtorArgs) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> ArePatternCtorArgs {
    ArePatternCtorArgs(TermListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ArePatternCtorArgs> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ArePatternCtorArgs> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = ArePatternCtorArgs> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = ArePatternCtorArgs> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<ArePatternCtorArgs> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ArePatternCtorArgsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("are_pattern_ctor_args"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PatternCtorArgIsApp(pub Loc);
#[derive(Clone, Hash, Debug)]
struct PatternCtorArgIsAppTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<PatternCtorArgIsApp>>,
}
impl PatternCtorArgIsAppTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PatternCtorArgIsApp) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_loc.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PatternCtorArgIsApp) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: PatternCtorArgIsApp) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> PatternCtorArgIsApp {
    PatternCtorArgIsApp(Loc::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PatternCtorArgIsApp> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PatternCtorArgIsApp> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Loc) -> impl '_ + Iterator<Item = PatternCtorArgIsApp> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<PatternCtorArgIsApp> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PatternCtorArgIsAppTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pattern_ctor_arg_is_app"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PatternCtorArgVarIsNotFresh(pub Loc);
#[derive(Clone, Hash, Debug)]
struct PatternCtorArgVarIsNotFreshTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<PatternCtorArgVarIsNotFresh>>,
}
impl PatternCtorArgVarIsNotFreshTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PatternCtorArgVarIsNotFresh) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_loc.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PatternCtorArgVarIsNotFresh) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: PatternCtorArgVarIsNotFresh) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> PatternCtorArgVarIsNotFresh {
    PatternCtorArgVarIsNotFresh(Loc::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PatternCtorArgVarIsNotFresh> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PatternCtorArgVarIsNotFresh> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Loc) -> impl '_ + Iterator<Item = PatternCtorArgVarIsNotFresh> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<PatternCtorArgVarIsNotFresh> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PatternCtorArgVarIsNotFreshTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pattern_ctor_arg_var_is_not_fresh"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesContainCtor(pub MatchCaseListNode, pub CtorDeclNode);
#[derive(Clone, Hash, Debug)]
struct CasesContainCtorTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CasesContainCtor>>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<CasesContainCtor>>,
}
impl CasesContainCtorTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_match_case_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CasesContainCtor) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CasesContainCtor) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CasesContainCtor) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CasesContainCtor {
    CasesContainCtor(MatchCaseListNode::from(t.0), CtorDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: CasesContainCtor) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> CasesContainCtor {
    CasesContainCtor(MatchCaseListNode::from(t.1), CtorDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CasesContainCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CasesContainCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = CasesContainCtor> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseListNode, arg1: CtorDeclNode) -> impl '_ + Iterator<Item = CasesContainCtor> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: CtorDeclNode) -> impl '_ + Iterator<Item = CasesContainCtor> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CasesContainCtor> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_match_case_list_node(&mut self, tm: MatchCaseListNode) -> Vec<CasesContainCtor> {
    let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CasesContainCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cases_contain_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtContainsCtorOfEnum(pub StmtNode, pub CtorDeclNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct MatchStmtContainsCtorOfEnumTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<MatchStmtContainsCtorOfEnum>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<MatchStmtContainsCtorOfEnum>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtContainsCtorOfEnum>>,
}
impl MatchStmtContainsCtorOfEnumTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MatchStmtContainsCtorOfEnum) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_enum_decl_node.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MatchStmtContainsCtorOfEnum) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: MatchStmtContainsCtorOfEnum) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> MatchStmtContainsCtorOfEnum {
    MatchStmtContainsCtorOfEnum(StmtNode::from(t.0), CtorDeclNode::from(t.1), EnumDeclNode::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MatchStmtContainsCtorOfEnum> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MatchStmtContainsCtorOfEnum> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: StmtNode, arg1: CtorDeclNode, arg2: EnumDeclNode) -> impl '_ + Iterator<Item = MatchStmtContainsCtorOfEnum> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<MatchStmtContainsCtorOfEnum> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<MatchStmtContainsCtorOfEnum> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtContainsCtorOfEnum> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MatchStmtContainsCtorOfEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_contains_ctor_of_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtShouldContainCtor(pub StmtNode, pub CtorDeclNode);
#[derive(Clone, Hash, Debug)]
struct MatchStmtShouldContainCtorTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<MatchStmtShouldContainCtor>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtShouldContainCtor>>,
}
impl MatchStmtShouldContainCtorTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MatchStmtShouldContainCtor) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MatchStmtShouldContainCtor) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: MatchStmtShouldContainCtor) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> MatchStmtShouldContainCtor {
    MatchStmtShouldContainCtor(StmtNode::from(t.0), CtorDeclNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MatchStmtShouldContainCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MatchStmtShouldContainCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: CtorDeclNode) -> impl '_ + Iterator<Item = MatchStmtShouldContainCtor> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<MatchStmtShouldContainCtor> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtShouldContainCtor> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MatchStmtShouldContainCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_should_contain_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtContainsCtor(pub StmtNode, pub CtorDeclNode);
#[derive(Clone, Hash, Debug)]
struct MatchStmtContainsCtorTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<MatchStmtContainsCtor>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtContainsCtor>>,
}
impl MatchStmtContainsCtorTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MatchStmtContainsCtor) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MatchStmtContainsCtor) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: MatchStmtContainsCtor) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> MatchStmtContainsCtor {
    MatchStmtContainsCtor(StmtNode::from(t.0), CtorDeclNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MatchStmtContainsCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MatchStmtContainsCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: CtorDeclNode) -> impl '_ + Iterator<Item = MatchStmtContainsCtor> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<MatchStmtContainsCtor> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtContainsCtor> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MatchStmtContainsCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_contains_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RealVirtIdent(pub Ident, pub VirtIdent);
#[derive(Clone, Hash, Debug)]
struct RealVirtIdentTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<RealVirtIdent>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<RealVirtIdent>>,
}
impl RealVirtIdentTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_virt_ident: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RealVirtIdent) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.0, vec![t]); },
            };
        

            match self.element_index_virt_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_virt_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RealVirtIdent) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RealVirtIdent) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RealVirtIdent {
    RealVirtIdent(Ident::from(t.0), VirtIdent::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RealVirtIdent> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RealVirtIdent> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Ident) -> impl '_ + Iterator<Item = RealVirtIdent> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Ident, arg1: VirtIdent) -> impl '_ + Iterator<Item = RealVirtIdent> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<RealVirtIdent> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<RealVirtIdent> {
    let mut ts = match self.element_index_virt_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RealVirtIdentTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("real_virt_ident"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VirtRealIdent(pub VirtIdent, pub Ident);
#[derive(Clone, Hash, Debug)]
struct VirtRealIdentTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<VirtRealIdent>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<VirtRealIdent>>,
}
impl VirtRealIdentTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_virt_ident: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: VirtRealIdent) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_virt_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_virt_ident.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: VirtRealIdent) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: VirtRealIdent) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> VirtRealIdent {
    VirtRealIdent(VirtIdent::from(t.0), Ident::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = VirtRealIdent> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = VirtRealIdent> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: VirtIdent) -> impl '_ + Iterator<Item = VirtRealIdent> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: VirtIdent, arg1: Ident) -> impl '_ + Iterator<Item = VirtRealIdent> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<VirtRealIdent> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<VirtRealIdent> {
    let mut ts = match self.element_index_virt_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for VirtRealIdentTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("virt_real_ident"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Var(pub Structure, pub ElName, pub El);
#[derive(Clone, Hash, Debug)]
struct VarTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<Var>>,
    element_index_el_name: BTreeMap<ElName, Vec<Var>>,
    element_index_structure: BTreeMap<Structure, Vec<Var>>,
}
impl VarTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_el_name: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Var) -> bool {
if self.index_old_2_0_1.contains(&Self::permute_2_0_1(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_structure.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el_name.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_name.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: Var) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_2_0_1.contains(&Self::permute_2_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: Var) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> Var {
    Var(Structure::from(t.0), ElName::from(t.1), El::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: Var) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> Var {
    Var(Structure::from(t.1), ElName::from(t.2), El::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Var> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Var> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Structure, arg1: ElName) -> impl '_ + Iterator<Item = Var> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Structure, arg1: ElName, arg2: El) -> impl '_ + Iterator<Item = Var> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: El) -> impl '_ + Iterator<Item = Var> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<Var> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_el_name(&mut self, tm: ElName) -> Vec<Var> {
    let mut ts = match self.element_index_el_name.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<Var> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for VarTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("var"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleName(pub RuleDeclNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct RuleNameTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<RuleName>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleName>>,
}
impl RuleNameTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_rule_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleName) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleName) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleName) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleName {
    RuleName(RuleDeclNode::from(t.0), Ident::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleName> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleName> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDeclNode, arg1: Ident) -> impl '_ + Iterator<Item = RuleName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<RuleName> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<RuleName> {
    let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleName(pub ModuleNode, pub Ident);
#[derive(Clone, Hash, Debug)]
struct ModuleNameTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<ModuleName>>,
    element_index_module_node: BTreeMap<ModuleNode, Vec<ModuleName>>,
}
impl ModuleNameTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_module_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ModuleName) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_module_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_module_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ModuleName) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ModuleName) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ModuleName {
    ModuleName(ModuleNode::from(t.0), Ident::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ModuleName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ModuleName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ModuleNode) -> impl '_ + Iterator<Item = ModuleName> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ModuleNode, arg1: Ident) -> impl '_ + Iterator<Item = ModuleName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<ModuleName> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_module_node(&mut self, tm: ModuleNode) -> Vec<ModuleName> {
    let mut ts = match self.element_index_module_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ModuleNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("module_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDeclNodeLoc(pub TypeDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TypeDeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<TypeDeclNodeLoc>>,
    element_index_type_decl_node: BTreeMap<TypeDeclNode, Vec<TypeDeclNodeLoc>>,
}
impl TypeDeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_type_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TypeDeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TypeDeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TypeDeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TypeDeclNodeLoc {
    TypeDeclNodeLoc(TypeDeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeDeclNode) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeDeclNode, arg1: Loc) -> impl '_ + Iterator<Item = TypeDeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<TypeDeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_decl_node(&mut self, tm: TypeDeclNode) -> Vec<TypeDeclNodeLoc> {
    let mut ts = match self.element_index_type_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TypeDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeLoc(pub ArgDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ArgDeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<ArgDeclNodeLoc>>,
}
impl ArgDeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_arg_decl_node: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ArgDeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ArgDeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ArgDeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ArgDeclNodeLoc {
    ArgDeclNodeLoc(ArgDeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ArgDeclNode) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ArgDeclNode, arg1: Loc) -> impl '_ + Iterator<Item = ArgDeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ArgDeclNodeLoc> {
    let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ArgDeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ArgDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclListNodeLoc(pub ArgDeclListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ArgDeclListNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<ArgDeclListNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<ArgDeclListNodeLoc>>,
}
impl ArgDeclListNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_arg_decl_list_node: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ArgDeclListNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ArgDeclListNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ArgDeclListNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ArgDeclListNodeLoc {
    ArgDeclListNodeLoc(ArgDeclListNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ArgDeclListNode, arg1: Loc) -> impl '_ + Iterator<Item = ArgDeclListNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<ArgDeclListNodeLoc> {
    let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ArgDeclListNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ArgDeclListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_decl_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredDeclNodeLoc(pub PredDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct PredDeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<PredDeclNodeLoc>>,
    element_index_pred_decl_node: BTreeMap<PredDeclNode, Vec<PredDeclNodeLoc>>,
}
impl PredDeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_pred_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PredDeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_pred_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_pred_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PredDeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: PredDeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> PredDeclNodeLoc {
    PredDeclNodeLoc(PredDeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: PredDeclNode) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: PredDeclNode, arg1: Loc) -> impl '_ + Iterator<Item = PredDeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<PredDeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_pred_decl_node(&mut self, tm: PredDeclNode) -> Vec<PredDeclNodeLoc> {
    let mut ts = match self.element_index_pred_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PredDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncDeclNodeLoc(pub FuncDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct FuncDeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_func_decl_node: BTreeMap<FuncDeclNode, Vec<FuncDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<FuncDeclNodeLoc>>,
}
impl FuncDeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_func_decl_node: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FuncDeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_func_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FuncDeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: FuncDeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> FuncDeclNodeLoc {
    FuncDeclNodeLoc(FuncDeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: FuncDeclNode) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: FuncDeclNode, arg1: Loc) -> impl '_ + Iterator<Item = FuncDeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_func_decl_node(&mut self, tm: FuncDeclNode) -> Vec<FuncDeclNodeLoc> {
    let mut ts = match self.element_index_func_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<FuncDeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FuncDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorDeclNodeLoc(pub CtorDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct CtorDeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CtorDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<CtorDeclNodeLoc>>,
}
impl CtorDeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CtorDeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_ctor_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CtorDeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CtorDeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CtorDeclNodeLoc {
    CtorDeclNodeLoc(CtorDeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CtorDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CtorDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorDeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: CtorDeclNode, arg1: Loc) -> impl '_ + Iterator<Item = CtorDeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CtorDeclNodeLoc> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<CtorDeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CtorDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctor_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumDeclNodeLoc(pub EnumDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct EnumDeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<EnumDeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<EnumDeclNodeLoc>>,
}
impl EnumDeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: EnumDeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_enum_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: EnumDeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: EnumDeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> EnumDeclNodeLoc {
    EnumDeclNodeLoc(EnumDeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = EnumDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = EnumDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: EnumDeclNode) -> impl '_ + Iterator<Item = EnumDeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: EnumDeclNode, arg1: Loc) -> impl '_ + Iterator<Item = EnumDeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<EnumDeclNodeLoc> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<EnumDeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for EnumDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("enum_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModelDeclNodeLoc(pub ModelDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ModelDeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<ModelDeclNodeLoc>>,
    element_index_model_decl_node: BTreeMap<ModelDeclNode, Vec<ModelDeclNodeLoc>>,
}
impl ModelDeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_model_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ModelDeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_model_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_model_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ModelDeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ModelDeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ModelDeclNodeLoc {
    ModelDeclNodeLoc(ModelDeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ModelDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ModelDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ModelDeclNode) -> impl '_ + Iterator<Item = ModelDeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ModelDeclNode, arg1: Loc) -> impl '_ + Iterator<Item = ModelDeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ModelDeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_model_decl_node(&mut self, tm: ModelDeclNode) -> Vec<ModelDeclNodeLoc> {
    let mut ts = match self.element_index_model_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ModelDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("model_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermNodeLoc(pub TermNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TermNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<TermNodeLoc>>,
    element_index_term_node: BTreeMap<TermNode, Vec<TermNodeLoc>>,
}
impl TermNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TermNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TermNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TermNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TermNodeLoc {
    TermNodeLoc(TermNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TermNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = TermNodeLoc> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TermNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermNodeLoc> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = TermNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermNode, arg1: Loc) -> impl '_ + Iterator<Item = TermNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<TermNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<TermNodeLoc> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TermNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListNodeLoc(pub TermListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TermListNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<TermListNodeLoc>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermListNodeLoc>>,
}
impl TermListNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TermListNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TermListNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TermListNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TermListNodeLoc {
    TermListNodeLoc(TermListNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TermListNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TermListNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermListNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermListNode, arg1: Loc) -> impl '_ + Iterator<Item = TermListNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<TermListNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<TermListNodeLoc> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TermListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCaseNodeLoc(pub MatchCaseNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct MatchCaseNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<MatchCaseNodeLoc>>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<MatchCaseNodeLoc>>,
}
impl MatchCaseNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_match_case_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MatchCaseNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MatchCaseNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: MatchCaseNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> MatchCaseNodeLoc {
    MatchCaseNodeLoc(MatchCaseNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MatchCaseNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MatchCaseNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = MatchCaseNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseNode, arg1: Loc) -> impl '_ + Iterator<Item = MatchCaseNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<MatchCaseNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<MatchCaseNodeLoc> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MatchCaseNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_case_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct OptTermNodeLoc(pub OptTermNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct OptTermNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<OptTermNodeLoc>>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<OptTermNodeLoc>>,
}
impl OptTermNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_opt_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: OptTermNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_opt_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: OptTermNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: OptTermNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> OptTermNodeLoc {
    OptTermNodeLoc(OptTermNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = OptTermNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = OptTermNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: OptTermNode, arg1: Loc) -> impl '_ + Iterator<Item = OptTermNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<OptTermNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<OptTermNodeLoc> {
    let mut ts = match self.element_index_opt_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for OptTermNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("opt_term_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomNodeLoc(pub IfAtomNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct IfAtomNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfAtomNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<IfAtomNodeLoc>>,
}
impl IfAtomNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IfAtomNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IfAtomNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: IfAtomNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> IfAtomNodeLoc {
    IfAtomNodeLoc(IfAtomNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: IfAtomNode, arg1: Loc) -> impl '_ + Iterator<Item = IfAtomNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<IfAtomNodeLoc> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<IfAtomNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IfAtomNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_atom_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomNodeLoc(pub ThenAtomNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ThenAtomNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<ThenAtomNodeLoc>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenAtomNodeLoc>>,
}
impl ThenAtomNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_then_atom_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ThenAtomNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_then_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ThenAtomNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ThenAtomNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ThenAtomNodeLoc {
    ThenAtomNodeLoc(ThenAtomNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ThenAtomNode, arg1: Loc) -> impl '_ + Iterator<Item = ThenAtomNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ThenAtomNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<ThenAtomNodeLoc> {
    let mut ts = match self.element_index_then_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ThenAtomNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_atom_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtNodeLoc(pub StmtNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct StmtNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<StmtNodeLoc>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<StmtNodeLoc>>,
}
impl StmtNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: StmtNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: StmtNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: StmtNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> StmtNodeLoc {
    StmtNodeLoc(StmtNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = StmtNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = StmtNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = StmtNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: Loc) -> impl '_ + Iterator<Item = StmtNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<StmtNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<StmtNodeLoc> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for StmtNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtListNodeLoc(pub StmtListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct StmtListNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<StmtListNodeLoc>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<StmtListNodeLoc>>,
}
impl StmtListNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: StmtListNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: StmtListNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: StmtListNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> StmtListNodeLoc {
    StmtListNodeLoc(StmtListNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = StmtListNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = StmtListNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtListNode, arg1: Loc) -> impl '_ + Iterator<Item = StmtListNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<StmtListNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<StmtListNodeLoc> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for StmtListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("stmt_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDeclNodeLoc(pub RuleDeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct RuleDeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<RuleDeclNodeLoc>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleDeclNodeLoc>>,
}
impl RuleDeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_rule_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDeclNodeLoc {
    RuleDeclNodeLoc(RuleDeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDeclNode, arg1: Loc) -> impl '_ + Iterator<Item = RuleDeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<RuleDeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<RuleDeclNodeLoc> {
    let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeLoc(pub DeclNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DeclNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<DeclNodeLoc>>,
}
impl DeclNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_decl_node: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclNodeLoc {
    DeclNodeLoc(DeclNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclNode, arg1: Loc) -> impl '_ + Iterator<Item = DeclNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclNodeLoc> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<DeclNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclListNodeLoc(pub DeclListNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct DeclListNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<DeclListNodeLoc>>,
    element_index_loc: BTreeMap<Loc, Vec<DeclListNodeLoc>>,
}
impl DeclListNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_decl_list_node: BTreeMap::new(),
    element_index_loc: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclListNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclListNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclListNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclListNodeLoc {
    DeclListNodeLoc(DeclListNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclListNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclListNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: DeclListNode) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclListNode, arg1: Loc) -> impl '_ + Iterator<Item = DeclListNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<DeclListNodeLoc> {
    let mut ts = match self.element_index_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<DeclListNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclListNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_list_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleNodeLoc(pub ModuleNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct ModuleNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<ModuleNodeLoc>>,
    element_index_module_node: BTreeMap<ModuleNode, Vec<ModuleNodeLoc>>,
}
impl ModuleNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_module_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ModuleNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_module_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_module_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ModuleNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ModuleNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ModuleNodeLoc {
    ModuleNodeLoc(ModuleNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ModuleNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ModuleNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ModuleNode) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ModuleNode, arg1: Loc) -> impl '_ + Iterator<Item = ModuleNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<ModuleNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_module_node(&mut self, tm: ModuleNode) -> Vec<ModuleNodeLoc> {
    let mut ts = match self.element_index_module_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ModuleNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("module_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeExprNodeLoc(pub TypeExprNode, pub Loc);
#[derive(Clone, Hash, Debug)]
struct TypeExprNodeLocTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_loc: BTreeMap<Loc, Vec<TypeExprNodeLoc>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<TypeExprNodeLoc>>,
}
impl TypeExprNodeLocTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_loc: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TypeExprNodeLoc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_expr_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_loc.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_loc.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TypeExprNodeLoc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TypeExprNodeLoc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TypeExprNodeLoc {
    TypeExprNodeLoc(TypeExprNode::from(t.0), Loc::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TypeExprNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = TypeExprNodeLoc> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TypeExprNodeLoc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = TypeExprNodeLoc> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = TypeExprNodeLoc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: TypeExprNode, arg1: Loc) -> impl '_ + Iterator<Item = TypeExprNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeExprNode, arg1: Loc) -> impl '_ + Iterator<Item = TypeExprNodeLoc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_loc(&mut self, tm: Loc) -> Vec<TypeExprNodeLoc> {
    let mut ts = match self.element_index_loc.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<TypeExprNodeLoc> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TypeExprNodeLocTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_expr_node_loc"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantRule(pub RuleDeclNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantRuleTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<RuleDescendantRule>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantRule>>,
}
impl RuleDescendantRuleTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_decl_node: BTreeMap::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantRule) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantRule) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantRule) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantRule {
    RuleDescendantRule(RuleDeclNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RuleDescendantRule) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RuleDescendantRule {
    RuleDescendantRule(RuleDeclNode::from(t.1), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantRule> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantRule> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDescendantRule> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = RuleDescendantRule> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDeclNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantRule> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantRule> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<RuleDescendantRule> {
    let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantRule> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantRuleTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_rule"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTerm(pub TermNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantTermTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantTerm>>,
    element_index_term_node: BTreeMap<TermNode, Vec<RuleDescendantTerm>>,
}
impl RuleDescendantTermTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantTerm) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantTerm) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantTerm) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantTerm {
    RuleDescendantTerm(TermNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RuleDescendantTerm) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RuleDescendantTerm {
    RuleDescendantTerm(TermNode::from(t.1), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTerm> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTerm> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTerm> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: TermNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantTerm> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantTerm> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<RuleDescendantTerm> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTermList(pub TermListNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantTermListTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantTermList>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<RuleDescendantTermList>>,
}
impl RuleDescendantTermListTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantTermList) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantTermList) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantTermList) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantTermList {
    RuleDescendantTermList(TermListNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTermList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTermList> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTermList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = RuleDescendantTermList> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermListNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantTermList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantTermList> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<RuleDescendantTermList> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantTermListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_term_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantOptTerm(pub OptTermNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantOptTermTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_opt_term_node: BTreeMap<OptTermNode, Vec<RuleDescendantOptTerm>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantOptTerm>>,
}
impl RuleDescendantOptTermTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_opt_term_node: BTreeMap::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantOptTerm) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_opt_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_opt_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantOptTerm) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantOptTerm) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantOptTerm {
    RuleDescendantOptTerm(OptTermNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: OptTermNode) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: OptTermNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantOptTerm> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_opt_term_node(&mut self, tm: OptTermNode) -> Vec<RuleDescendantOptTerm> {
    let mut ts = match self.element_index_opt_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantOptTerm> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantOptTermTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_opt_term"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantIfAtom(pub IfAtomNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantIfAtomTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<RuleDescendantIfAtom>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantIfAtom>>,
}
impl RuleDescendantIfAtomTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantIfAtom) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantIfAtom) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantIfAtom) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantIfAtom {
    RuleDescendantIfAtom(IfAtomNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RuleDescendantIfAtom) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RuleDescendantIfAtom {
    RuleDescendantIfAtom(IfAtomNode::from(t.1), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: IfAtomNode) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: IfAtomNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantIfAtom> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<RuleDescendantIfAtom> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantIfAtom> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantIfAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_if_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantThenAtom(pub ThenAtomNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantThenAtomTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantThenAtom>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<RuleDescendantThenAtom>>,
}
impl RuleDescendantThenAtomTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_then_atom_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantThenAtom) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_then_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantThenAtom) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantThenAtom) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantThenAtom {
    RuleDescendantThenAtom(ThenAtomNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RuleDescendantThenAtom) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RuleDescendantThenAtom {
    RuleDescendantThenAtom(ThenAtomNode::from(t.1), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ThenAtomNode) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ThenAtomNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantThenAtom> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantThenAtom> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<RuleDescendantThenAtom> {
    let mut ts = match self.element_index_then_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantThenAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_then_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantMatchCase(pub MatchCaseNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantMatchCaseTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<RuleDescendantMatchCase>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantMatchCase>>,
}
impl RuleDescendantMatchCaseTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_match_case_node: BTreeMap::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantMatchCase) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantMatchCase) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantMatchCase) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantMatchCase {
    RuleDescendantMatchCase(MatchCaseNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RuleDescendantMatchCase) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RuleDescendantMatchCase {
    RuleDescendantMatchCase(MatchCaseNode::from(t.1), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantMatchCase> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<RuleDescendantMatchCase> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantMatchCase> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantMatchCaseTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_match_case"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantMatchCaseList(pub MatchCaseListNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantMatchCaseListTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<RuleDescendantMatchCaseList>>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantMatchCaseList>>,
}
impl RuleDescendantMatchCaseListTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_match_case_list_node: BTreeMap::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantMatchCaseList) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantMatchCaseList) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantMatchCaseList) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantMatchCaseList {
    RuleDescendantMatchCaseList(MatchCaseListNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RuleDescendantMatchCaseList) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RuleDescendantMatchCaseList {
    RuleDescendantMatchCaseList(MatchCaseListNode::from(t.1), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseListNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantMatchCaseList> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_match_case_list_node(&mut self, tm: MatchCaseListNode) -> Vec<RuleDescendantMatchCaseList> {
    let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantMatchCaseList> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantMatchCaseListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_match_case_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmt(pub StmtNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantStmtTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantStmt>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<RuleDescendantStmt>>,
}
impl RuleDescendantStmtTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantStmt) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantStmt) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantStmt) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantStmt {
    RuleDescendantStmt(StmtNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmt> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmt> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmt> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = RuleDescendantStmt> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtNode) -> impl '_ + Iterator<Item = RuleDescendantStmt> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantStmt> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantStmt> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<RuleDescendantStmt> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtList(pub StmtListNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantStmtListTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantStmtList>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<RuleDescendantStmtList>>,
}
impl RuleDescendantStmtListTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantStmtList) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantStmtList) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantStmtList) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantStmtList {
    RuleDescendantStmtList(StmtListNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtListNode) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtListNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantStmtList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantStmtList> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<RuleDescendantStmtList> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantStmtListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_stmt_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtBlockList(pub StmtBlockListNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantStmtBlockListTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantStmtBlockList>>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<RuleDescendantStmtBlockList>>,
}
impl RuleDescendantStmtBlockListTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_stmt_block_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantStmtBlockList) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_stmt_block_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_block_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantStmtBlockList) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantStmtBlockList) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantStmtBlockList {
    RuleDescendantStmtBlockList(StmtBlockListNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RuleDescendantStmtBlockList) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RuleDescendantStmtBlockList {
    RuleDescendantStmtBlockList(StmtBlockListNode::from(t.1), RuleDescendantNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: StmtBlockListNode) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: StmtBlockListNode) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtBlockListNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantStmtBlockList> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantStmtBlockList> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_block_list_node(&mut self, tm: StmtBlockListNode) -> Vec<RuleDescendantStmtBlockList> {
    let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantStmtBlockListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_stmt_block_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTypeExpr(pub TypeExprNode, pub RuleDescendantNode);
#[derive(Clone, Hash, Debug)]
struct RuleDescendantTypeExprTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<RuleDescendantTypeExpr>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<RuleDescendantTypeExpr>>,
}
impl RuleDescendantTypeExprTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleDescendantTypeExpr) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_expr_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rule_descendant_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleDescendantTypeExpr) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RuleDescendantTypeExpr) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RuleDescendantTypeExpr {
    RuleDescendantTypeExpr(TypeExprNode::from(t.0), RuleDescendantNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTypeExpr> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTypeExpr> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleDescendantTypeExpr> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeExprNode) -> impl '_ + Iterator<Item = RuleDescendantTypeExpr> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeExprNode, arg1: RuleDescendantNode) -> impl '_ + Iterator<Item = RuleDescendantTypeExpr> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<RuleDescendantTypeExpr> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<RuleDescendantTypeExpr> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleDescendantTypeExprTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rule_descendant_type_expr"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EntryScope(pub RuleDescendantNode, pub Scope);
#[derive(Clone, Hash, Debug)]
struct EntryScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<EntryScope>>,
    element_index_scope: BTreeMap<Scope, Vec<EntryScope>>,
}
impl EntryScopeTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: EntryScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rule_descendant_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: EntryScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: EntryScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> EntryScope {
    EntryScope(RuleDescendantNode::from(t.0), Scope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: EntryScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> EntryScope {
    EntryScope(RuleDescendantNode::from(t.1), Scope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = EntryScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = EntryScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: RuleDescendantNode) -> impl '_ + Iterator<Item = EntryScope> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDescendantNode) -> impl '_ + Iterator<Item = EntryScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDescendantNode, arg1: Scope) -> impl '_ + Iterator<Item = EntryScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = EntryScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = EntryScope> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<EntryScope> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<EntryScope> {
    let mut ts = match self.element_index_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for EntryScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("entry_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ExitScope(pub RuleDescendantNode, pub Scope);
#[derive(Clone, Hash, Debug)]
struct ExitScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_descendant_node: BTreeMap<RuleDescendantNode, Vec<ExitScope>>,
    element_index_scope: BTreeMap<Scope, Vec<ExitScope>>,
}
impl ExitScopeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_descendant_node: BTreeMap::new(),
    element_index_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ExitScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rule_descendant_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_descendant_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ExitScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ExitScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ExitScope {
    ExitScope(RuleDescendantNode::from(t.0), Scope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ExitScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ExitScope {
    ExitScope(RuleDescendantNode::from(t.1), Scope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ExitScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ExitScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: RuleDescendantNode) -> impl '_ + Iterator<Item = ExitScope> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDescendantNode) -> impl '_ + Iterator<Item = ExitScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDescendantNode, arg1: Scope) -> impl '_ + Iterator<Item = ExitScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = ExitScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_rule_descendant_node(&mut self, tm: RuleDescendantNode) -> Vec<ExitScope> {
    let mut ts = match self.element_index_rule_descendant_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<ExitScope> {
    let mut ts = match self.element_index_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ExitScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("exit_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorEnum(pub CtorDeclNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct CtorEnumTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CtorEnum>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<CtorEnum>>,
}
impl CtorEnumTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CtorEnum) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_ctor_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CtorEnum) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CtorEnum) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CtorEnum {
    CtorEnum(CtorDeclNode::from(t.0), EnumDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: CtorEnum) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> CtorEnum {
    CtorEnum(CtorDeclNode::from(t.1), EnumDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CtorEnum> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CtorEnum> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorEnum> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorEnum> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: CtorDeclNode, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = CtorEnum> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = CtorEnum> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = CtorEnum> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CtorEnum> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<CtorEnum> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CtorEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctor_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorsEnum(pub CtorDeclListNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct CtorsEnumTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<CtorsEnum>>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<CtorsEnum>>,
}
impl CtorsEnumTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ctor_decl_list_node: BTreeMap::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CtorsEnum) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_ctor_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CtorsEnum) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CtorsEnum) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CtorsEnum {
    CtorsEnum(CtorDeclListNode::from(t.0), EnumDeclNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CtorsEnum> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CtorsEnum> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: CtorDeclListNode) -> impl '_ + Iterator<Item = CtorsEnum> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: CtorDeclListNode) -> impl '_ + Iterator<Item = CtorsEnum> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: CtorDeclListNode, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = CtorsEnum> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_list_node(&mut self, tm: CtorDeclListNode) -> Vec<CtorsEnum> {
    let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<CtorsEnum> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CtorsEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctors_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesDiscriminee(pub MatchCaseListNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct CasesDiscrimineeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<CasesDiscriminee>>,
    element_index_term_node: BTreeMap<TermNode, Vec<CasesDiscriminee>>,
}
impl CasesDiscrimineeTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_match_case_list_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CasesDiscriminee) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CasesDiscriminee) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CasesDiscriminee) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CasesDiscriminee {
    CasesDiscriminee(MatchCaseListNode::from(t.0), TermNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CasesDiscriminee> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CasesDiscriminee> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = CasesDiscriminee> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = CasesDiscriminee> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseListNode, arg1: TermNode) -> impl '_ + Iterator<Item = CasesDiscriminee> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_match_case_list_node(&mut self, tm: MatchCaseListNode) -> Vec<CasesDiscriminee> {
    let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<CasesDiscriminee> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CasesDiscrimineeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cases_discriminee"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CaseDiscriminee(pub MatchCaseNode, pub TermNode);
#[derive(Clone, Hash, Debug)]
struct CaseDiscrimineeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<CaseDiscriminee>>,
    element_index_term_node: BTreeMap<TermNode, Vec<CaseDiscriminee>>,
}
impl CaseDiscrimineeTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_match_case_node: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CaseDiscriminee) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_term_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CaseDiscriminee) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CaseDiscriminee) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CaseDiscriminee {
    CaseDiscriminee(MatchCaseNode::from(t.0), TermNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CaseDiscriminee> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CaseDiscriminee> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = CaseDiscriminee> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = CaseDiscriminee> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseNode, arg1: TermNode) -> impl '_ + Iterator<Item = CaseDiscriminee> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<CaseDiscriminee> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<CaseDiscriminee> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CaseDiscrimineeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("case_discriminee"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseEqualityAtom(pub MatchCaseNode, pub IfAtomNode);
#[derive(Clone, Hash, Debug)]
struct DesugaredCaseEqualityAtomTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<DesugaredCaseEqualityAtom>>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<DesugaredCaseEqualityAtom>>,
}
impl DesugaredCaseEqualityAtomTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_match_case_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DesugaredCaseEqualityAtom) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_if_atom_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DesugaredCaseEqualityAtom) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DesugaredCaseEqualityAtom) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DesugaredCaseEqualityAtom {
    DesugaredCaseEqualityAtom(MatchCaseNode::from(t.0), IfAtomNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseNode, arg1: IfAtomNode) -> impl '_ + Iterator<Item = DesugaredCaseEqualityAtom> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<DesugaredCaseEqualityAtom> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<DesugaredCaseEqualityAtom> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DesugaredCaseEqualityAtomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("desugared_case_equality_atom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseEqualityStmt(pub MatchCaseNode, pub StmtNode);
#[derive(Clone, Hash, Debug)]
struct DesugaredCaseEqualityStmtTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<DesugaredCaseEqualityStmt>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<DesugaredCaseEqualityStmt>>,
}
impl DesugaredCaseEqualityStmtTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_match_case_node: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DesugaredCaseEqualityStmt) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DesugaredCaseEqualityStmt) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DesugaredCaseEqualityStmt) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DesugaredCaseEqualityStmt {
    DesugaredCaseEqualityStmt(MatchCaseNode::from(t.0), StmtNode::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseNode, arg1: StmtNode) -> impl '_ + Iterator<Item = DesugaredCaseEqualityStmt> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<DesugaredCaseEqualityStmt> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<DesugaredCaseEqualityStmt> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DesugaredCaseEqualityStmtTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("desugared_case_equality_stmt"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseBlock(pub MatchCaseNode, pub StmtListNode);
#[derive(Clone, Hash, Debug)]
struct DesugaredCaseBlockTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<DesugaredCaseBlock>>,
    element_index_stmt_list_node: BTreeMap<StmtListNode, Vec<DesugaredCaseBlock>>,
}
impl DesugaredCaseBlockTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_match_case_node: BTreeMap::new(),
    element_index_stmt_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DesugaredCaseBlock) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_list_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DesugaredCaseBlock) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DesugaredCaseBlock) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DesugaredCaseBlock {
    DesugaredCaseBlock(MatchCaseNode::from(t.0), StmtListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DesugaredCaseBlock) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DesugaredCaseBlock {
    DesugaredCaseBlock(MatchCaseNode::from(t.1), StmtListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseNode, arg1: StmtListNode) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: StmtListNode) -> impl '_ + Iterator<Item = DesugaredCaseBlock> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<DesugaredCaseBlock> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_list_node(&mut self, tm: StmtListNode) -> Vec<DesugaredCaseBlock> {
    let mut ts = match self.element_index_stmt_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DesugaredCaseBlockTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("desugared_case_block"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseBlockList(pub MatchCaseListNode, pub StmtBlockListNode);
#[derive(Clone, Hash, Debug)]
struct DesugaredCaseBlockListTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<DesugaredCaseBlockList>>,
    element_index_stmt_block_list_node: BTreeMap<StmtBlockListNode, Vec<DesugaredCaseBlockList>>,
}
impl DesugaredCaseBlockListTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_match_case_list_node: BTreeMap::new(),
    element_index_stmt_block_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DesugaredCaseBlockList) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_stmt_block_list_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_block_list_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DesugaredCaseBlockList) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DesugaredCaseBlockList) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DesugaredCaseBlockList {
    DesugaredCaseBlockList(MatchCaseListNode::from(t.0), StmtBlockListNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DesugaredCaseBlockList) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DesugaredCaseBlockList {
    DesugaredCaseBlockList(MatchCaseListNode::from(t.1), StmtBlockListNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseListNode, arg1: StmtBlockListNode) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: StmtBlockListNode) -> impl '_ + Iterator<Item = DesugaredCaseBlockList> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_match_case_list_node(&mut self, tm: MatchCaseListNode) -> Vec<DesugaredCaseBlockList> {
    let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_block_list_node(&mut self, tm: StmtBlockListNode) -> Vec<DesugaredCaseBlockList> {
    let mut ts = match self.element_index_stmt_block_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DesugaredCaseBlockListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("desugared_case_block_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilTypeList(pub TypeList);
#[derive(Clone, Hash, Debug)]
struct NilTypeListTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_type_list: BTreeMap<TypeList, Vec<NilTypeList>>,
}
impl NilTypeListTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilTypeList) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilTypeList) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilTypeList) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilTypeList {
    NilTypeList(TypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilTypeList> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = NilTypeList> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilTypeList> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = NilTypeList> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = NilTypeList> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<NilTypeList> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("NilTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsTypeList(pub Type, pub TypeList, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct ConsTypeListTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_type: BTreeMap<Type, Vec<ConsTypeList>>,
    element_index_type_list: BTreeMap<TypeList, Vec<ConsTypeList>>,
}
impl ConsTypeListTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_type: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsTypeList) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_2_0_1.insert(Self::permute_2_0_1(t)) {
return false;
}

self.index_new_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.1, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsTypeList) -> bool {
    self.index_new_2_0_1.contains(&Self::permute_2_0_1(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_2_0_1(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_2_0_1(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_2_0_1(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_2_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsTypeList) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsTypeList {
    ConsTypeList(Type::from(t.0), TypeList::from(t.1), TypeList::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: ConsTypeList) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> ConsTypeList {
    ConsTypeList(Type::from(t.1), TypeList::from(t.0), TypeList::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: ConsTypeList) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> ConsTypeList {
    ConsTypeList(Type::from(t.1), TypeList::from(t.2), TypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsTypeList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsTypeList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Type) -> impl '_ + Iterator<Item = ConsTypeList> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Type, arg1: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Type, arg1: TypeList, arg2: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: TypeList) -> impl '_ + Iterator<Item = ConsTypeList> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<ConsTypeList> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<ConsTypeList> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ConsTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocTypeList(pub TypeList, pub Type, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct SnocTypeListTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_type: BTreeMap<Type, Vec<SnocTypeList>>,
    element_index_type_list: BTreeMap<TypeList, Vec<SnocTypeList>>,
}
impl SnocTypeListTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_type: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SnocTypeList) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.1, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SnocTypeList) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SnocTypeList) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SnocTypeList {
    SnocTypeList(TypeList::from(t.0), Type::from(t.1), TypeList::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: SnocTypeList) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> SnocTypeList {
    SnocTypeList(TypeList::from(t.1), Type::from(t.0), TypeList::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: SnocTypeList) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> SnocTypeList {
    SnocTypeList(TypeList::from(t.1), Type::from(t.2), TypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SnocTypeList> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SnocTypeList> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = SnocTypeList> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: TypeList, arg1: Type) -> impl '_ + Iterator<Item = SnocTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeList, arg1: Type) -> impl '_ + Iterator<Item = SnocTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: TypeList, arg1: Type, arg2: TypeList) -> impl '_ + Iterator<Item = SnocTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Type) -> impl '_ + Iterator<Item = SnocTypeList> {
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: TypeList) -> impl '_ + Iterator<Item = SnocTypeList> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<SnocTypeList> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<SnocTypeList> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SnocTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("SnocTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticType(pub SymbolScope, pub Ident, pub Type);
#[derive(Clone, Hash, Debug)]
struct SemanticTypeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<SemanticType>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SemanticType>>,
    element_index_type: BTreeMap<Type, Vec<SemanticType>>,
}
impl SemanticTypeTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticType) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}

self.index_new_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticType) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SemanticType) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SemanticType {
    SemanticType(SymbolScope::from(t.0), Ident::from(t.1), Type::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: SemanticType) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> SemanticType {
    SemanticType(SymbolScope::from(t.2), Ident::from(t.0), Type::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: SemanticType) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> SemanticType {
    SemanticType(SymbolScope::from(t.1), Ident::from(t.2), Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticType> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticType> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SemanticType> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = SemanticType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = SemanticType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: SymbolScope, arg1: Ident, arg2: Type) -> impl '_ + Iterator<Item = SemanticType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: SymbolScope, arg2: Type) -> impl '_ + Iterator<Item = SemanticType> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_0_2(&self, arg0: SymbolScope, arg2: Type) -> impl '_ + Iterator<Item = SemanticType> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: Ident, arg2: Type) -> impl '_ + Iterator<Item = SemanticType> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: Type) -> impl '_ + Iterator<Item = SemanticType> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: Type) -> impl '_ + Iterator<Item = SemanticType> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<SemanticType> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SemanticType> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<SemanticType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclSymbolScope(pub DeclNode, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct DeclSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_node: BTreeMap<DeclNode, Vec<DeclSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<DeclSymbolScope>>,
}
impl DeclSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_node: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclSymbolScope {
    DeclSymbolScope(DeclNode::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclSymbolScope {
    DeclSymbolScope(DeclNode::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = DeclSymbolScope> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclSymbolScope> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: DeclNode) -> impl '_ + Iterator<Item = DeclSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: DeclNode, arg1: SymbolScope) -> impl '_ + Iterator<Item = DeclSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclNode, arg1: SymbolScope) -> impl '_ + Iterator<Item = DeclSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = DeclSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_decl_node(&mut self, tm: DeclNode) -> Vec<DeclSymbolScope> {
    let mut ts = match self.element_index_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<DeclSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decl_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MorType(pub Type, pub Type);
#[derive(Clone, Hash, Debug)]
struct MorTypeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_type: BTreeMap<Type, Vec<MorType>>,
}
impl MorTypeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MorType) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MorType) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: MorType) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> MorType {
    MorType(Type::from(t.0), Type::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: MorType) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> MorType {
    MorType(Type::from(t.1), Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MorType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MorType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Type) -> impl '_ + Iterator<Item = MorType> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = MorType> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Type, arg1: Type) -> impl '_ + Iterator<Item = MorType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: Type) -> impl '_ + Iterator<Item = MorType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Type) -> impl '_ + Iterator<Item = MorType> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<MorType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MorTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("mor_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MorTypeDomFunc(pub Type, pub Func);
#[derive(Clone, Hash, Debug)]
struct MorTypeDomFuncTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_func: BTreeMap<Func, Vec<MorTypeDomFunc>>,
    element_index_type: BTreeMap<Type, Vec<MorTypeDomFunc>>,
}
impl MorTypeDomFuncTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MorTypeDomFunc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_func.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MorTypeDomFunc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: MorTypeDomFunc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> MorTypeDomFunc {
    MorTypeDomFunc(Type::from(t.0), Func::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: MorTypeDomFunc) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> MorTypeDomFunc {
    MorTypeDomFunc(Type::from(t.1), Func::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MorTypeDomFunc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MorTypeDomFunc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Type) -> impl '_ + Iterator<Item = MorTypeDomFunc> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = MorTypeDomFunc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: Func) -> impl '_ + Iterator<Item = MorTypeDomFunc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Func) -> impl '_ + Iterator<Item = MorTypeDomFunc> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<MorTypeDomFunc> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<MorTypeDomFunc> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MorTypeDomFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("mor_type_dom_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MorTypeCodFunc(pub Type, pub Func);
#[derive(Clone, Hash, Debug)]
struct MorTypeCodFuncTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_func: BTreeMap<Func, Vec<MorTypeCodFunc>>,
    element_index_type: BTreeMap<Type, Vec<MorTypeCodFunc>>,
}
impl MorTypeCodFuncTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MorTypeCodFunc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_func.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MorTypeCodFunc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: MorTypeCodFunc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> MorTypeCodFunc {
    MorTypeCodFunc(Type::from(t.0), Func::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: MorTypeCodFunc) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> MorTypeCodFunc {
    MorTypeCodFunc(Type::from(t.1), Func::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MorTypeCodFunc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = MorTypeCodFunc> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MorTypeCodFunc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Type) -> impl '_ + Iterator<Item = MorTypeCodFunc> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = MorTypeCodFunc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: Func) -> impl '_ + Iterator<Item = MorTypeCodFunc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Func) -> impl '_ + Iterator<Item = MorTypeCodFunc> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<MorTypeCodFunc> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<MorTypeCodFunc> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MorTypeCodFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("mor_type_cod_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDefinitionSymbolScope(pub Type, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct TypeDefinitionSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<TypeDefinitionSymbolScope>>,
    element_index_type: BTreeMap<Type, Vec<TypeDefinitionSymbolScope>>,
}
impl TypeDefinitionSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_symbol_scope: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TypeDefinitionSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TypeDefinitionSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TypeDefinitionSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TypeDefinitionSymbolScope {
    TypeDefinitionSymbolScope(Type::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: TypeDefinitionSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> TypeDefinitionSymbolScope {
    TypeDefinitionSymbolScope(Type::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TypeDefinitionSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TypeDefinitionSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Type) -> impl '_ + Iterator<Item = TypeDefinitionSymbolScope> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = TypeDefinitionSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: SymbolScope) -> impl '_ + Iterator<Item = TypeDefinitionSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = TypeDefinitionSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<TypeDefinitionSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<TypeDefinitionSymbolScope> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TypeDefinitionSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_definition_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncRel(pub Func, pub Rel);
#[derive(Clone, Hash, Debug)]
struct FuncRelTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_func: BTreeMap<Func, Vec<FuncRel>>,
    element_index_rel: BTreeMap<Rel, Vec<FuncRel>>,
}
impl FuncRelTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    element_index_rel: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FuncRel) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rel.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FuncRel) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: FuncRel) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> FuncRel {
    FuncRel(Func::from(t.0), Rel::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: FuncRel) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> FuncRel {
    FuncRel(Func::from(t.1), Rel::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FuncRel> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = FuncRel> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FuncRel> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Func) -> impl '_ + Iterator<Item = FuncRel> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = FuncRel> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Func, arg1: Rel) -> impl '_ + Iterator<Item = FuncRel> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Rel) -> impl '_ + Iterator<Item = FuncRel> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Rel) -> impl '_ + Iterator<Item = FuncRel> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<FuncRel> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<FuncRel> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FuncRelTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("FuncRel"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelDefinitionSymbolScope(pub Rel, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct RelDefinitionSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rel: BTreeMap<Rel, Vec<RelDefinitionSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<RelDefinitionSymbolScope>>,
}
impl RelDefinitionSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rel: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RelDefinitionSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rel.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RelDefinitionSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RelDefinitionSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RelDefinitionSymbolScope {
    RelDefinitionSymbolScope(Rel::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: RelDefinitionSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> RelDefinitionSymbolScope {
    RelDefinitionSymbolScope(Rel::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RelDefinitionSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RelDefinitionSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = RelDefinitionSymbolScope> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = RelDefinitionSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Rel, arg1: SymbolScope) -> impl '_ + Iterator<Item = RelDefinitionSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Rel, arg1: SymbolScope) -> impl '_ + Iterator<Item = RelDefinitionSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = RelDefinitionSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<RelDefinitionSymbolScope> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<RelDefinitionSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RelDefinitionSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rel_definition_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Domain(pub Func, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct DomainTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_func: BTreeMap<Func, Vec<Domain>>,
    element_index_type_list: BTreeMap<TypeList, Vec<Domain>>,
}
impl DomainTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Domain) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: Domain) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: Domain) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> Domain {
    Domain(Func::from(t.0), TypeList::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: Domain) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> Domain {
    Domain(Func::from(t.1), TypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Domain> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Domain> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Func) -> impl '_ + Iterator<Item = Domain> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = Domain> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Func, arg1: TypeList) -> impl '_ + Iterator<Item = Domain> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Func, arg1: TypeList) -> impl '_ + Iterator<Item = Domain> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = Domain> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<Domain> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<Domain> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DomainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("domain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Codomain(pub Func, pub Type);
#[derive(Clone, Hash, Debug)]
struct CodomainTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_func: BTreeMap<Func, Vec<Codomain>>,
    element_index_type: BTreeMap<Type, Vec<Codomain>>,
}
impl CodomainTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Codomain) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: Codomain) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: Codomain) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> Codomain {
    Codomain(Func::from(t.0), Type::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: Codomain) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> Codomain {
    Codomain(Func::from(t.1), Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Codomain> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Codomain> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = Codomain> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Func, arg1: Type) -> impl '_ + Iterator<Item = Codomain> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Type) -> impl '_ + Iterator<Item = Codomain> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Type) -> impl '_ + Iterator<Item = Codomain> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<Codomain> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<Codomain> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CodomainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("codomain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeName(pub Type, pub Ident);
#[derive(Clone, Hash, Debug)]
struct TypeNameTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<TypeName>>,
    element_index_type: BTreeMap<Type, Vec<TypeName>>,
}
impl TypeNameTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TypeName) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TypeName) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TypeName) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TypeName {
    TypeName(Type::from(t.0), Ident::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TypeName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TypeName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = TypeName> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: Ident) -> impl '_ + Iterator<Item = TypeName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<TypeName> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<TypeName> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TypeNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VirtualSymbolScope(pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct VirtualSymbolScopeTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<VirtualSymbolScope>>,
}
impl VirtualSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: VirtualSymbolScope) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: VirtualSymbolScope) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: VirtualSymbolScope) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> VirtualSymbolScope {
    VirtualSymbolScope(SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = VirtualSymbolScope> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = VirtualSymbolScope> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = VirtualSymbolScope> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = VirtualSymbolScope> {
    let arg0 = arg0.0;
self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = VirtualSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<VirtualSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for VirtualSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("virtual_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ParentModelFunc(pub Type, pub Func);
#[derive(Clone, Hash, Debug)]
struct ParentModelFuncTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_func: BTreeMap<Func, Vec<ParentModelFunc>>,
    element_index_type: BTreeMap<Type, Vec<ParentModelFunc>>,
}
impl ParentModelFuncTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ParentModelFunc) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_func.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ParentModelFunc) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ParentModelFunc) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ParentModelFunc {
    ParentModelFunc(Type::from(t.0), Func::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ParentModelFunc) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ParentModelFunc {
    ParentModelFunc(Type::from(t.1), Func::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ParentModelFunc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = ParentModelFunc> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ParentModelFunc> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Type) -> impl '_ + Iterator<Item = ParentModelFunc> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = ParentModelFunc> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: Func) -> impl '_ + Iterator<Item = ParentModelFunc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Func) -> impl '_ + Iterator<Item = ParentModelFunc> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<ParentModelFunc> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<ParentModelFunc> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ParentModelFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("parent_model_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SymbolScopeModel(pub SymbolScope, pub Type);
#[derive(Clone, Hash, Debug)]
struct SymbolScopeModelTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SymbolScopeModel>>,
    element_index_type: BTreeMap<Type, Vec<SymbolScopeModel>>,
}
impl SymbolScopeModelTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_symbol_scope: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SymbolScopeModel) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SymbolScopeModel) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: SymbolScopeModel) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> SymbolScopeModel {
    SymbolScopeModel(SymbolScope::from(t.0), Type::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: SymbolScopeModel) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> SymbolScopeModel {
    SymbolScopeModel(SymbolScope::from(t.1), Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SymbolScopeModel> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SymbolScopeModel> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeModel> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeModel> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: Type) -> impl '_ + Iterator<Item = SymbolScopeModel> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Type) -> impl '_ + Iterator<Item = SymbolScopeModel> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SymbolScopeModel> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<SymbolScopeModel> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SymbolScopeModelTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("symbol_scope_model"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FlatDomain(pub Func, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct FlatDomainTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_func: BTreeMap<Func, Vec<FlatDomain>>,
    element_index_type_list: BTreeMap<TypeList, Vec<FlatDomain>>,
}
impl FlatDomainTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FlatDomain) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FlatDomain) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: FlatDomain) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> FlatDomain {
    FlatDomain(Func::from(t.0), TypeList::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FlatDomain> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FlatDomain> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Func) -> impl '_ + Iterator<Item = FlatDomain> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Func, arg1: TypeList) -> impl '_ + Iterator<Item = FlatDomain> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<FlatDomain> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<FlatDomain> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FlatDomainTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("flat_domain"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticSignatureTypeExpr(pub SymbolScope, pub TypeExprNode, pub Type);
#[derive(Clone, Hash, Debug)]
struct SemanticSignatureTypeExprTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SemanticSignatureTypeExpr>>,
    element_index_type: BTreeMap<Type, Vec<SemanticSignatureTypeExpr>>,
    element_index_type_expr_node: BTreeMap<TypeExprNode, Vec<SemanticSignatureTypeExpr>>,
}
impl SemanticSignatureTypeExprTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
    element_index_symbol_scope: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    element_index_type_expr_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticSignatureTypeExpr) -> bool {
if self.index_old_1_0_2.contains(&Self::permute_1_0_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_expr_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_expr_node.insert(t.1, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticSignatureTypeExpr) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_1_0_2.contains(&Self::permute_1_0_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SemanticSignatureTypeExpr) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SemanticSignatureTypeExpr {
    SemanticSignatureTypeExpr(SymbolScope::from(t.0), TypeExprNode::from(t.1), Type::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: SemanticSignatureTypeExpr) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> SemanticSignatureTypeExpr {
    SemanticSignatureTypeExpr(SymbolScope::from(t.1), TypeExprNode::from(t.0), Type::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticSignatureTypeExpr> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticSignatureTypeExpr> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: SymbolScope, arg1: TypeExprNode) -> impl '_ + Iterator<Item = SemanticSignatureTypeExpr> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: TypeExprNode) -> impl '_ + Iterator<Item = SemanticSignatureTypeExpr> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: SymbolScope, arg1: TypeExprNode, arg2: Type) -> impl '_ + Iterator<Item = SemanticSignatureTypeExpr> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0, arg2,  )),
        Bound::Included(&(arg1, arg0, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TypeExprNode) -> impl '_ + Iterator<Item = SemanticSignatureTypeExpr> {
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SemanticSignatureTypeExpr> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<SemanticSignatureTypeExpr> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_expr_node(&mut self, tm: TypeExprNode) -> Vec<SemanticSignatureTypeExpr> {
    let mut ts = match self.element_index_type_expr_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticSignatureTypeExprTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_signature_type_expr"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct TypeSymbolTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<TypeSymbol>>,
}
impl TypeSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_symbol_kind: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TypeSymbol) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TypeSymbol) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: TypeSymbol) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> TypeSymbol {
    TypeSymbol(SymbolKind::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TypeSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = TypeSymbol> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TypeSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = TypeSymbol> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<TypeSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TypeSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("TypeSymbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct EnumSymbolTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<EnumSymbol>>,
}
impl EnumSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_symbol_kind: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: EnumSymbol) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: EnumSymbol) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: EnumSymbol) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> EnumSymbol {
    EnumSymbol(SymbolKind::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = EnumSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = EnumSymbol> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = EnumSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = EnumSymbol> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<EnumSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for EnumSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("EnumSymbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModelSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct ModelSymbolTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<ModelSymbol>>,
}
impl ModelSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_symbol_kind: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ModelSymbol) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ModelSymbol) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: ModelSymbol) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> ModelSymbol {
    ModelSymbol(SymbolKind::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ModelSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = ModelSymbol> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ModelSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = ModelSymbol> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<ModelSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ModelSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ModelSymbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticArgType(pub ArgDeclNode, pub Type);
#[derive(Clone, Hash, Debug)]
struct SemanticArgTypeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<SemanticArgType>>,
    element_index_type: BTreeMap<Type, Vec<SemanticArgType>>,
}
impl SemanticArgTypeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_arg_decl_node: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticArgType) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticArgType) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: SemanticArgType) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> SemanticArgType {
    SemanticArgType(ArgDeclNode::from(t.0), Type::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: SemanticArgType) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> SemanticArgType {
    SemanticArgType(ArgDeclNode::from(t.1), Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticArgType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = SemanticArgType> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticArgType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ArgDeclNode) -> impl '_ + Iterator<Item = SemanticArgType> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ArgDeclNode, arg1: Type) -> impl '_ + Iterator<Item = SemanticArgType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Type) -> impl '_ + Iterator<Item = SemanticArgType> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<SemanticArgType> {
    let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<SemanticArgType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticArgTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_arg_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgSymbolScope(pub ArgDeclNode, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct ArgSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_arg_decl_node: BTreeMap<ArgDeclNode, Vec<ArgSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ArgSymbolScope>>,
}
impl ArgSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_arg_decl_node: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ArgSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_arg_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ArgSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ArgSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ArgSymbolScope {
    ArgSymbolScope(ArgDeclNode::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ArgSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ArgSymbolScope {
    ArgSymbolScope(ArgDeclNode::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ArgSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ArgSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ArgDeclNode) -> impl '_ + Iterator<Item = ArgSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ArgDeclNode, arg1: SymbolScope) -> impl '_ + Iterator<Item = ArgSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = ArgSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_arg_decl_node(&mut self, tm: ArgDeclNode) -> Vec<ArgSymbolScope> {
    let mut ts = match self.element_index_arg_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ArgSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ArgSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arg_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticArgTypes(pub ArgDeclListNode, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct SemanticArgTypesTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<SemanticArgTypes>>,
    element_index_type_list: BTreeMap<TypeList, Vec<SemanticArgTypes>>,
}
impl SemanticArgTypesTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_arg_decl_list_node: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticArgTypes) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticArgTypes) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: SemanticArgTypes) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> SemanticArgTypes {
    SemanticArgTypes(ArgDeclListNode::from(t.0), TypeList::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: SemanticArgTypes) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> SemanticArgTypes {
    SemanticArgTypes(ArgDeclListNode::from(t.1), TypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticArgTypes> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticArgTypes> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = SemanticArgTypes> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ArgDeclListNode, arg1: TypeList) -> impl '_ + Iterator<Item = SemanticArgTypes> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = SemanticArgTypes> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<SemanticArgTypes> {
    let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<SemanticArgTypes> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticArgTypesTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_arg_types"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticPred(pub SymbolScope, pub Ident, pub Pred);
#[derive(Clone, Hash, Debug)]
struct SemanticPredTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<SemanticPred>>,
    element_index_pred: BTreeMap<Pred, Vec<SemanticPred>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SemanticPred>>,
}
impl SemanticPredTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_pred: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticPred) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}

self.index_new_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_pred.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_pred.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticPred) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SemanticPred) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SemanticPred {
    SemanticPred(SymbolScope::from(t.0), Ident::from(t.1), Pred::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: SemanticPred) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> SemanticPred {
    SemanticPred(SymbolScope::from(t.2), Ident::from(t.0), Pred::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: SemanticPred) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> SemanticPred {
    SemanticPred(SymbolScope::from(t.1), Ident::from(t.2), Pred::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticPred> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticPred> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SemanticPred> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = SemanticPred> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = SemanticPred> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: SymbolScope, arg1: Ident, arg2: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_2(&self, arg0: SymbolScope, arg2: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: Ident, arg2: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: Pred) -> impl '_ + Iterator<Item = SemanticPred> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<SemanticPred> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_pred(&mut self, tm: Pred) -> Vec<SemanticPred> {
    let mut ts = match self.element_index_pred.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SemanticPred> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticPredTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_pred"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredArity(pub Pred, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct PredArityTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_pred: BTreeMap<Pred, Vec<PredArity>>,
    element_index_type_list: BTreeMap<TypeList, Vec<PredArity>>,
}
impl PredArityTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_pred: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PredArity) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_pred.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_pred.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PredArity) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: PredArity) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> PredArity {
    PredArity(Pred::from(t.0), TypeList::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: PredArity) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> PredArity {
    PredArity(Pred::from(t.1), TypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PredArity> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PredArity> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Pred) -> impl '_ + Iterator<Item = PredArity> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Pred) -> impl '_ + Iterator<Item = PredArity> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Pred, arg1: TypeList) -> impl '_ + Iterator<Item = PredArity> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = PredArity> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_pred(&mut self, tm: Pred) -> Vec<PredArity> {
    let mut ts = match self.element_index_pred.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<PredArity> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PredArityTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("pred_arity"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticFunc(pub SymbolScope, pub Ident, pub Func);
#[derive(Clone, Hash, Debug)]
struct SemanticFuncTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_func: BTreeMap<Func, Vec<SemanticFunc>>,
    element_index_ident: BTreeMap<Ident, Vec<SemanticFunc>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SemanticFunc>>,
}
impl SemanticFuncTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_func: BTreeMap::new(),
    element_index_ident: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticFunc) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}

self.index_new_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        

            match self.element_index_func.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticFunc) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SemanticFunc) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SemanticFunc {
    SemanticFunc(SymbolScope::from(t.0), Ident::from(t.1), Func::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: SemanticFunc) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> SemanticFunc {
    SemanticFunc(SymbolScope::from(t.2), Ident::from(t.0), Func::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: SemanticFunc) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> SemanticFunc {
    SemanticFunc(SymbolScope::from(t.1), Ident::from(t.2), Func::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticFunc> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticFunc> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SemanticFunc> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = SemanticFunc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = SemanticFunc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: SymbolScope, arg1: Ident, arg2: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_2(&self, arg0: SymbolScope, arg2: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: Ident, arg2: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: Func) -> impl '_ + Iterator<Item = SemanticFunc> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<SemanticFunc> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<SemanticFunc> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SemanticFunc> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticFuncTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_func"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorSymbolScope(pub CtorDeclNode, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct CtorSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<CtorSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<CtorSymbolScope>>,
}
impl CtorSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CtorSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_ctor_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CtorSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CtorSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CtorSymbolScope {
    CtorSymbolScope(CtorDeclNode::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: CtorSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> CtorSymbolScope {
    CtorSymbolScope(CtorDeclNode::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CtorSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = CtorSymbolScope> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CtorSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorSymbolScope> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: CtorDeclNode) -> impl '_ + Iterator<Item = CtorSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: CtorDeclNode, arg1: SymbolScope) -> impl '_ + Iterator<Item = CtorSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = CtorSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<CtorSymbolScope> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<CtorSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CtorSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctor_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredRel(pub Pred, pub Rel);
#[derive(Clone, Hash, Debug)]
struct PredRelTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_pred: BTreeMap<Pred, Vec<PredRel>>,
    element_index_rel: BTreeMap<Rel, Vec<PredRel>>,
}
impl PredRelTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_pred: BTreeMap::new(),
    element_index_rel: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PredRel) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_pred.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_pred.insert(t.0, vec![t]); },
            };
        

            match self.element_index_rel.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PredRel) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: PredRel) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> PredRel {
    PredRel(Pred::from(t.0), Rel::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: PredRel) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> PredRel {
    PredRel(Pred::from(t.1), Rel::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PredRel> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = PredRel> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PredRel> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Pred) -> impl '_ + Iterator<Item = PredRel> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Pred) -> impl '_ + Iterator<Item = PredRel> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Pred, arg1: Rel) -> impl '_ + Iterator<Item = PredRel> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Rel) -> impl '_ + Iterator<Item = PredRel> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_pred(&mut self, tm: Pred) -> Vec<PredRel> {
    let mut ts = match self.element_index_pred.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<PredRel> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PredRelTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("PredRel"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelName(pub Rel, pub Ident);
#[derive(Clone, Hash, Debug)]
struct RelNameTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<RelName>>,
    element_index_rel: BTreeMap<Rel, Vec<RelName>>,
}
impl RelNameTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_rel: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RelName) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rel.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RelName) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: RelName) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> RelName {
    RelName(Rel::from(t.0), Ident::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RelName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RelName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = RelName> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Rel, arg1: Ident) -> impl '_ + Iterator<Item = RelName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<RelName> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<RelName> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RelNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rel_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Arity(pub Rel, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct ArityTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rel: BTreeMap<Rel, Vec<Arity>>,
    element_index_type_list: BTreeMap<TypeList, Vec<Arity>>,
}
impl ArityTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rel: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Arity) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_rel.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: Arity) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: Arity) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> Arity {
    Arity(Rel::from(t.0), TypeList::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: Arity) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> Arity {
    Arity(Rel::from(t.1), TypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Arity> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Arity> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = Arity> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Rel, arg1: TypeList) -> impl '_ + Iterator<Item = Arity> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Rel, arg1: TypeList) -> impl '_ + Iterator<Item = Arity> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: TypeList) -> impl '_ + Iterator<Item = Arity> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<Arity> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<Arity> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ArityTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("arity"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Dom(pub Morphism, pub Structure);
#[derive(Clone, Hash, Debug)]
struct DomTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<Dom>>,
    element_index_structure: BTreeMap<Structure, Vec<Dom>>,
}
impl DomTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Dom) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: Dom) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: Dom) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> Dom {
    Dom(Morphism::from(t.0), Structure::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: Dom) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> Dom {
    Dom(Morphism::from(t.1), Structure::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Dom> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Dom> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = Dom> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = Dom> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Morphism, arg1: Structure) -> impl '_ + Iterator<Item = Dom> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = Dom> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<Dom> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<Dom> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DomTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("dom"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Cod(pub Morphism, pub Structure);
#[derive(Clone, Hash, Debug)]
struct CodTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<Cod>>,
    element_index_structure: BTreeMap<Structure, Vec<Cod>>,
}
impl CodTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Cod) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: Cod) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: Cod) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> Cod {
    Cod(Morphism::from(t.0), Structure::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: Cod) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> Cod {
    Cod(Morphism::from(t.1), Structure::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Cod> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Cod> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = Cod> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Morphism, arg1: Structure) -> impl '_ + Iterator<Item = Cod> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Morphism, arg1: Structure) -> impl '_ + Iterator<Item = Cod> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = Cod> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<Cod> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<Cod> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CodTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cod"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FlatArity(pub Rel, pub TypeList);
#[derive(Clone, Hash, Debug)]
struct FlatArityTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_rel: BTreeMap<Rel, Vec<FlatArity>>,
    element_index_type_list: BTreeMap<TypeList, Vec<FlatArity>>,
}
impl FlatArityTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_rel: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FlatArity) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rel.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FlatArity) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: FlatArity) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> FlatArity {
    FlatArity(Rel::from(t.0), TypeList::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FlatArity> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FlatArity> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Rel) -> impl '_ + Iterator<Item = FlatArity> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Rel, arg1: TypeList) -> impl '_ + Iterator<Item = FlatArity> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<FlatArity> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<FlatArity> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FlatArityTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("flat_arity"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleSymbolScope(pub ModuleNode, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct ModuleSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_module_node: BTreeMap<ModuleNode, Vec<ModuleSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ModuleSymbolScope>>,
}
impl ModuleSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_module_node: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ModuleSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_module_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_module_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ModuleSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ModuleSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ModuleSymbolScope {
    ModuleSymbolScope(ModuleNode::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ModuleSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ModuleSymbolScope {
    ModuleSymbolScope(ModuleNode::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ModuleSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ModuleSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ModuleNode) -> impl '_ + Iterator<Item = ModuleSymbolScope> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ModuleNode) -> impl '_ + Iterator<Item = ModuleSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ModuleNode, arg1: SymbolScope) -> impl '_ + Iterator<Item = ModuleSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = ModuleSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = ModuleSymbolScope> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_module_node(&mut self, tm: ModuleNode) -> Vec<ModuleSymbolScope> {
    let mut ts = match self.element_index_module_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ModuleSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ModuleSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("module_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilElList(pub Structure, pub ElList);
#[derive(Clone, Hash, Debug)]
struct NilElListTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_el_list: BTreeMap<ElList, Vec<NilElList>>,
    element_index_structure: BTreeMap<Structure, Vec<NilElList>>,
}
impl NilElListTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilElList) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_structure.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilElList) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: NilElList) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> NilElList {
    NilElList(Structure::from(t.0), ElList::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: NilElList) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> NilElList {
    NilElList(Structure::from(t.1), ElList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilElList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = NilElList> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilElList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Structure) -> impl '_ + Iterator<Item = NilElList> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Structure, arg1: ElList) -> impl '_ + Iterator<Item = NilElList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = NilElList> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = NilElList> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<NilElList> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<NilElList> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilElListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("NilElList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsElList(pub El, pub ElList, pub ElList);
#[derive(Clone, Hash, Debug)]
struct ConsElListTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<ConsElList>>,
    element_index_el_list: BTreeMap<ElList, Vec<ConsElList>>,
}
impl ConsElListTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_el_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsElList) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_2_0_1.insert(Self::permute_2_0_1(t)) {
return false;
}

self.index_new_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsElList) -> bool {
    self.index_new_2_0_1.contains(&Self::permute_2_0_1(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_2_0_1(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_2_0_1(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_2_0_1(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_2_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsElList) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsElList {
    ConsElList(El::from(t.0), ElList::from(t.1), ElList::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: ConsElList) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> ConsElList {
    ConsElList(El::from(t.2), ElList::from(t.0), ElList::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: ConsElList) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> ConsElList {
    ConsElList(El::from(t.1), ElList::from(t.2), ElList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsElList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsElList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: El) -> impl '_ + Iterator<Item = ConsElList> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: El, arg1: ElList) -> impl '_ + Iterator<Item = ConsElList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: El, arg1: ElList) -> impl '_ + Iterator<Item = ConsElList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: El, arg1: ElList, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: El, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = ConsElList> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: ElList, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = ConsElList> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<ConsElList> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<ConsElList> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsElListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ConsElList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocElList(pub ElList, pub El, pub ElList);
#[derive(Clone, Hash, Debug)]
struct SnocElListTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<SnocElList>>,
    element_index_el_list: BTreeMap<ElList, Vec<SnocElList>>,
}
impl SnocElListTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_el_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SnocElList) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_2_0_1.insert(Self::permute_2_0_1(t)) {
return false;
}

self.index_new_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SnocElList) -> bool {
    self.index_new_2_0_1.contains(&Self::permute_2_0_1(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_2_0_1(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_2_0_1(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_2_0_1(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_2_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SnocElList) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SnocElList {
    SnocElList(ElList::from(t.0), El::from(t.1), ElList::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: SnocElList) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> SnocElList {
    SnocElList(ElList::from(t.2), El::from(t.0), ElList::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: SnocElList) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> SnocElList {
    SnocElList(ElList::from(t.1), El::from(t.2), ElList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SnocElList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SnocElList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = SnocElList> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: ElList, arg1: El) -> impl '_ + Iterator<Item = SnocElList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ElList, arg1: El) -> impl '_ + Iterator<Item = SnocElList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ElList, arg1: El, arg2: ElList) -> impl '_ + Iterator<Item = SnocElList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: ElList, arg2: ElList) -> impl '_ + Iterator<Item = SnocElList> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: El) -> impl '_ + Iterator<Item = SnocElList> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: El, arg2: ElList) -> impl '_ + Iterator<Item = SnocElList> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = SnocElList> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = SnocElList> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<SnocElList> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<SnocElList> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SnocElListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("SnocElList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElStructure(pub El, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ElStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<ElStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<ElStructure>>,
}
impl ElStructureTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ElStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ElStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ElStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ElStructure {
    ElStructure(El::from(t.0), Structure::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ElStructure) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ElStructure {
    ElStructure(El::from(t.1), Structure::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ElStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ElStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: El) -> impl '_ + Iterator<Item = ElStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: El, arg1: Structure) -> impl '_ + Iterator<Item = ElStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: El, arg1: Structure) -> impl '_ + Iterator<Item = ElStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = ElStructure> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<ElStructure> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<ElStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ElStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("el_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElsStructure(pub ElList, pub Structure);
#[derive(Clone, Hash, Debug)]
struct ElsStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_el_list: BTreeMap<ElList, Vec<ElsStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<ElsStructure>>,
}
impl ElsStructureTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ElsStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_el_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ElsStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ElsStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ElsStructure {
    ElsStructure(ElList::from(t.0), Structure::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ElsStructure) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ElsStructure {
    ElsStructure(ElList::from(t.1), Structure::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ElsStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ElsStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ElsStructure> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ElList) -> impl '_ + Iterator<Item = ElsStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: ElList, arg1: Structure) -> impl '_ + Iterator<Item = ElsStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ElList, arg1: Structure) -> impl '_ + Iterator<Item = ElsStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = ElsStructure> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = ElsStructure> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<ElsStructure> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<ElsStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ElsStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("els_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientType(pub Type, pub ElementType);
#[derive(Clone, Hash, Debug)]
struct AmbientTypeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_element_type: BTreeMap<ElementType, Vec<AmbientType>>,
    element_index_type: BTreeMap<Type, Vec<AmbientType>>,
}
impl AmbientTypeTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_element_type: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: AmbientType) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_element_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: AmbientType) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: AmbientType) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> AmbientType {
    AmbientType(Type::from(t.0), ElementType::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: AmbientType) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> AmbientType {
    AmbientType(Type::from(t.1), ElementType::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = AmbientType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = AmbientType> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = AmbientType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Type) -> impl '_ + Iterator<Item = AmbientType> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = AmbientType> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: ElementType) -> impl '_ + Iterator<Item = AmbientType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ElementType) -> impl '_ + Iterator<Item = AmbientType> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: ElementType) -> impl '_ + Iterator<Item = AmbientType> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_element_type(&mut self, tm: ElementType) -> Vec<AmbientType> {
    let mut ts = match self.element_index_element_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<AmbientType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for AmbientTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("AmbientType"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct InstantiatedType(pub El, pub Type, pub ElementType);
#[derive(Clone, Hash, Debug)]
struct InstantiatedTypeTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<InstantiatedType>>,
    element_index_element_type: BTreeMap<ElementType, Vec<InstantiatedType>>,
    element_index_type: BTreeMap<Type, Vec<InstantiatedType>>,
}
impl InstantiatedTypeTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_element_type: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: InstantiatedType) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_2_0_1.insert(Self::permute_2_0_1(t)) {
return false;
}

self.index_new_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_el.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.1, vec![t]); },
            };
        

            match self.element_index_element_type.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: InstantiatedType) -> bool {
    self.index_new_2_0_1.contains(&Self::permute_2_0_1(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_2_0_1(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_2_0_1(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_2_0_1(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_2_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: InstantiatedType) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> InstantiatedType {
    InstantiatedType(El::from(t.0), Type::from(t.1), ElementType::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: InstantiatedType) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> InstantiatedType {
    InstantiatedType(El::from(t.1), Type::from(t.0), ElementType::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: InstantiatedType) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> InstantiatedType {
    InstantiatedType(El::from(t.1), Type::from(t.2), ElementType::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = InstantiatedType> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = InstantiatedType> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: El) -> impl '_ + Iterator<Item = InstantiatedType> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: El, arg1: Type) -> impl '_ + Iterator<Item = InstantiatedType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: El, arg1: Type, arg2: ElementType) -> impl '_ + Iterator<Item = InstantiatedType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Type) -> impl '_ + Iterator<Item = InstantiatedType> {
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: ElementType) -> impl '_ + Iterator<Item = InstantiatedType> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<InstantiatedType> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_element_type(&mut self, tm: ElementType) -> Vec<InstantiatedType> {
    let mut ts = match self.element_index_element_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<InstantiatedType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for InstantiatedTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("InstantiatedType"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct UnderlyingType(pub ElementType, pub Type);
#[derive(Clone, Hash, Debug)]
struct UnderlyingTypeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_element_type: BTreeMap<ElementType, Vec<UnderlyingType>>,
    element_index_type: BTreeMap<Type, Vec<UnderlyingType>>,
}
impl UnderlyingTypeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_element_type: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: UnderlyingType) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_element_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: UnderlyingType) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: UnderlyingType) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> UnderlyingType {
    UnderlyingType(ElementType::from(t.0), Type::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: UnderlyingType) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> UnderlyingType {
    UnderlyingType(ElementType::from(t.1), Type::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = UnderlyingType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = UnderlyingType> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ElementType) -> impl '_ + Iterator<Item = UnderlyingType> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ElementType, arg1: Type) -> impl '_ + Iterator<Item = UnderlyingType> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Type) -> impl '_ + Iterator<Item = UnderlyingType> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_element_type(&mut self, tm: ElementType) -> Vec<UnderlyingType> {
    let mut ts = match self.element_index_element_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<UnderlyingType> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for UnderlyingTypeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("underlying_type"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilElementTypeList(pub ElementTypeList);
#[derive(Clone, Hash, Debug)]
struct NilElementTypeListTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_element_type_list: BTreeMap<ElementTypeList, Vec<NilElementTypeList>>,
}
impl NilElementTypeListTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_element_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: NilElementTypeList) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_element_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type_list.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: NilElementTypeList) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: NilElementTypeList) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> NilElementTypeList {
    NilElementTypeList(ElementTypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = NilElementTypeList> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = NilElementTypeList> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ElementTypeList) -> impl '_ + Iterator<Item = NilElementTypeList> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_element_type_list(&mut self, tm: ElementTypeList) -> Vec<NilElementTypeList> {
    let mut ts = match self.element_index_element_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for NilElementTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("NilElementTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsElementTypeList(pub ElementType, pub ElementTypeList, pub ElementTypeList);
#[derive(Clone, Hash, Debug)]
struct ConsElementTypeListTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_element_type: BTreeMap<ElementType, Vec<ConsElementTypeList>>,
    element_index_element_type_list: BTreeMap<ElementTypeList, Vec<ConsElementTypeList>>,
}
impl ConsElementTypeListTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_element_type: BTreeMap::new(),
    element_index_element_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ConsElementTypeList) -> bool {
if self.index_old_2_0_1.contains(&Self::permute_2_0_1(t)) {
return false;
}
if !self.index_new_2_0_1.insert(Self::permute_2_0_1(t)) {
return false;
}

self.index_new_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_element_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_element_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type_list.insert(t.1, vec![t]); },
            };
        

            match self.element_index_element_type_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ConsElementTypeList) -> bool {
    self.index_new_2_0_1.contains(&Self::permute_2_0_1(t))
 || self.index_old_2_0_1.contains(&Self::permute_2_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_2_0_1(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_2_0_1(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_2_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ConsElementTypeList) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ConsElementTypeList {
    ConsElementTypeList(ElementType::from(t.0), ElementTypeList::from(t.1), ElementTypeList::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: ConsElementTypeList) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> ConsElementTypeList {
    ConsElementTypeList(ElementType::from(t.1), ElementTypeList::from(t.2), ElementTypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ConsElementTypeList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ConsElementTypeList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ElementType, arg1: ElementTypeList) -> impl '_ + Iterator<Item = ConsElementTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ElementType, arg1: ElementTypeList, arg2: ElementTypeList) -> impl '_ + Iterator<Item = ConsElementTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: ElementTypeList) -> impl '_ + Iterator<Item = ConsElementTypeList> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: ElementTypeList) -> impl '_ + Iterator<Item = ConsElementTypeList> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_element_type(&mut self, tm: ElementType) -> Vec<ConsElementTypeList> {
    let mut ts = match self.element_index_element_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_element_type_list(&mut self, tm: ElementTypeList) -> Vec<ConsElementTypeList> {
    let mut ts = match self.element_index_element_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ConsElementTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ConsElementTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocElementTypeList(pub ElementTypeList, pub ElementType, pub ElementTypeList);
#[derive(Clone, Hash, Debug)]
struct SnocElementTypeListTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_element_type: BTreeMap<ElementType, Vec<SnocElementTypeList>>,
    element_index_element_type_list: BTreeMap<ElementTypeList, Vec<SnocElementTypeList>>,
}
impl SnocElementTypeListTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_element_type: BTreeMap::new(),
    element_index_element_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SnocElementTypeList) -> bool {
if self.index_old_2_0_1.contains(&Self::permute_2_0_1(t)) {
return false;
}
if !self.index_new_2_0_1.insert(Self::permute_2_0_1(t)) {
return false;
}

self.index_new_0_1_2.insert(Self::permute_0_1_2(t));

            match self.element_index_element_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type_list.insert(t.0, vec![t]); },
            };
        

            match self.element_index_element_type.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type.insert(t.1, vec![t]); },
            };
        

            match self.element_index_element_type_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SnocElementTypeList) -> bool {
    self.index_new_2_0_1.contains(&Self::permute_2_0_1(t))
 || self.index_old_2_0_1.contains(&Self::permute_2_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_2_0_1(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_2_0_1
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_2_0_1(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_2_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SnocElementTypeList) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SnocElementTypeList {
    SnocElementTypeList(ElementTypeList::from(t.0), ElementType::from(t.1), ElementTypeList::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: SnocElementTypeList) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> SnocElementTypeList {
    SnocElementTypeList(ElementTypeList::from(t.1), ElementType::from(t.2), ElementTypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SnocElementTypeList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SnocElementTypeList> {

self.index_new_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ElementTypeList, arg1: ElementType) -> impl '_ + Iterator<Item = SnocElementTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ElementTypeList, arg1: ElementType, arg2: ElementTypeList) -> impl '_ + Iterator<Item = SnocElementTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: ElementTypeList) -> impl '_ + Iterator<Item = SnocElementTypeList> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: ElementTypeList) -> impl '_ + Iterator<Item = SnocElementTypeList> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_element_type(&mut self, tm: ElementType) -> Vec<SnocElementTypeList> {
    let mut ts = match self.element_index_element_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_element_type_list(&mut self, tm: ElementTypeList) -> Vec<SnocElementTypeList> {
    let mut ts = match self.element_index_element_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_new_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SnocElementTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("SnocElementTypeList"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientElTypeList(pub TypeList, pub ElementTypeList);
#[derive(Clone, Hash, Debug)]
struct AmbientElTypeListTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_element_type_list: BTreeMap<ElementTypeList, Vec<AmbientElTypeList>>,
    element_index_type_list: BTreeMap<TypeList, Vec<AmbientElTypeList>>,
}
impl AmbientElTypeListTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_element_type_list: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: AmbientElTypeList) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.0, vec![t]); },
            };
        

            match self.element_index_element_type_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_element_type_list.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: AmbientElTypeList) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: AmbientElTypeList) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> AmbientElTypeList {
    AmbientElTypeList(TypeList::from(t.0), ElementTypeList::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: AmbientElTypeList) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> AmbientElTypeList {
    AmbientElTypeList(TypeList::from(t.1), ElementTypeList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = AmbientElTypeList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = AmbientElTypeList> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = AmbientElTypeList> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = AmbientElTypeList> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeList, arg1: ElementTypeList) -> impl '_ + Iterator<Item = AmbientElTypeList> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: ElementTypeList) -> impl '_ + Iterator<Item = AmbientElTypeList> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_element_type_list(&mut self, tm: ElementTypeList) -> Vec<AmbientElTypeList> {
    let mut ts = match self.element_index_element_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<AmbientElTypeList> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for AmbientElTypeListTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ambient_el_type_list"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncApp(pub Func, pub ElList, pub El);
#[derive(Clone, Hash, Debug)]
struct FuncAppTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<FuncApp>>,
    element_index_el_list: BTreeMap<ElList, Vec<FuncApp>>,
    element_index_func: BTreeMap<Func, Vec<FuncApp>>,
}
impl FuncAppTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_func: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FuncApp) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_func.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_func.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FuncApp) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: FuncApp) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> FuncApp {
    FuncApp(Func::from(t.0), ElList::from(t.1), El::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FuncApp> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FuncApp> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Func, arg1: ElList) -> impl '_ + Iterator<Item = FuncApp> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Func, arg1: ElList, arg2: El) -> impl '_ + Iterator<Item = FuncApp> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<FuncApp> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<FuncApp> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_func(&mut self, tm: Func) -> Vec<FuncApp> {
    let mut ts = match self.element_index_func.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FuncAppTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("func_app"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapEl(pub Morphism, pub El, pub El);
#[derive(Clone, Hash, Debug)]
struct MapElTable {
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_new_0_2_1: BTreeSet<(u32, u32, u32, )>,
    index_new_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<MapEl>>,
    element_index_morphism: BTreeMap<Morphism, Vec<MapEl>>,
}
impl MapElTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_old_0_1_2: BTreeSet::new(),
        index_new_0_2_1: BTreeSet::new(),
        index_new_1_0_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_morphism: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MapEl) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_1_0_2.insert(Self::permute_1_0_2(t)) {
return false;
}

self.index_new_0_2_1.insert(Self::permute_0_2_1(t));

            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MapEl) -> bool {
    self.index_new_1_0_2.contains(&Self::permute_1_0_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_1_0_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_1_0_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_1_0_2(t)))
);

self.index_new_0_2_1.clear();

self.index_new_1_0_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_1_0_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: MapEl) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> MapEl {
    MapEl(Morphism::from(t.0), El::from(t.1), El::from(t.2))
}
#[allow(unused)]
fn permute_0_2_1(t: MapEl) -> (u32, u32, u32, ) {
    (t.0.into(), t.2.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_2_1(t: (u32, u32, u32, )) -> MapEl {
    MapEl(Morphism::from(t.0), El::from(t.2), El::from(t.1))
}
#[allow(unused)]
fn permute_1_0_2(t: MapEl) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> MapEl {
    MapEl(Morphism::from(t.1), El::from(t.0), El::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: MapEl) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> MapEl {
    MapEl(Morphism::from(t.2), El::from(t.0), El::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: MapEl) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> MapEl {
    MapEl(Morphism::from(t.1), El::from(t.2), El::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MapEl> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MapEl> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Morphism) -> impl '_ + Iterator<Item = MapEl> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Morphism, arg1: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Morphism, arg1: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Morphism, arg1: El, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0, arg2,  )),
        Bound::Included(&(arg1, arg0, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: Morphism, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_0_2(&self, arg0: Morphism, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_new_0_2_1
    .range((
        Bound::Included(&(arg0, arg2,  u32::MIN, )),
        Bound::Included(&(arg0, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_2_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
)}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: El, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: El) -> impl '_ + Iterator<Item = MapEl> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<MapEl> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            self.index_new_0_2_1.remove(&Self::permute_0_2_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<MapEl> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            self.index_new_0_2_1.remove(&Self::permute_0_2_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MapElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("map_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapEls(pub Morphism, pub ElList, pub ElList);
#[derive(Clone, Hash, Debug)]
struct MapElsTable {
    index_new_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el_list: BTreeMap<ElList, Vec<MapEls>>,
    element_index_morphism: BTreeMap<Morphism, Vec<MapEls>>,
}
impl MapElsTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_1_0_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_morphism: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MapEls) -> bool {
if self.index_old_1_0_2.contains(&Self::permute_1_0_2(t)) {
return false;
}
if !self.index_new_1_0_2.insert(Self::permute_1_0_2(t)) {
return false;
}



            match self.element_index_morphism.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MapEls) -> bool {
    self.index_new_1_0_2.contains(&Self::permute_1_0_2(t))
 || self.index_old_1_0_2.contains(&Self::permute_1_0_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0_2.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_1_0_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_1_0_2(t)))
);

self.index_new_1_0_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_1_0_2.is_empty()
}
#[allow(unused)]
fn permute_1_0_2(t: MapEls) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> MapEls {
    MapEls(Morphism::from(t.1), ElList::from(t.0), ElList::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: MapEls) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> MapEls {
    MapEls(Morphism::from(t.1), ElList::from(t.2), ElList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MapEls> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MapEls> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Morphism, arg1: ElList) -> impl '_ + Iterator<Item = MapEls> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Morphism, arg1: ElList) -> impl '_ + Iterator<Item = MapEls> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Morphism, arg1: ElList, arg2: ElList) -> impl '_ + Iterator<Item = MapEls> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0, arg2,  )),
        Bound::Included(&(arg1, arg0, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0, arg2,  )),
        Bound::Included(&(arg1, arg0, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: ElList) -> impl '_ + Iterator<Item = MapEls> {
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = MapEls> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<MapEls> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_1_0_2.remove(&Self::permute_1_0_2(t)) {
            self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<MapEls> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_1_0_2.remove(&Self::permute_1_0_2(t)) {
            self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MapElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("map_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientModelEl(pub SymbolScope, pub Structure, pub El);
#[derive(Clone, Hash, Debug)]
struct AmbientModelElTable {
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_new_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<AmbientModelEl>>,
    element_index_structure: BTreeMap<Structure, Vec<AmbientModelEl>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<AmbientModelEl>>,
}
impl AmbientModelElTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_old_0_1_2: BTreeSet::new(),
        index_new_1_0_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: AmbientModelEl) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_1_0_2.insert(Self::permute_1_0_2(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: AmbientModelEl) -> bool {
    self.index_new_1_0_2.contains(&Self::permute_1_0_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_1_0_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_1_0_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_1_0_2(t)))
);

self.index_new_1_0_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_1_0_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: AmbientModelEl) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> AmbientModelEl {
    AmbientModelEl(SymbolScope::from(t.0), Structure::from(t.1), El::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: AmbientModelEl) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> AmbientModelEl {
    AmbientModelEl(SymbolScope::from(t.1), Structure::from(t.0), El::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: AmbientModelEl) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> AmbientModelEl {
    AmbientModelEl(SymbolScope::from(t.2), Structure::from(t.0), El::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: AmbientModelEl) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> AmbientModelEl {
    AmbientModelEl(SymbolScope::from(t.1), Structure::from(t.2), El::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = AmbientModelEl> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = AmbientModelEl> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = AmbientModelEl> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: SymbolScope, arg1: Structure) -> impl '_ + Iterator<Item = AmbientModelEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: Structure) -> impl '_ + Iterator<Item = AmbientModelEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1_2(&self, arg0: SymbolScope, arg1: Structure, arg2: El) -> impl '_ + Iterator<Item = AmbientModelEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: SymbolScope, arg1: Structure, arg2: El) -> impl '_ + Iterator<Item = AmbientModelEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0, arg2,  )),
        Bound::Included(&(arg1, arg0, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = AmbientModelEl> {
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
)}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: Structure, arg2: El) -> impl '_ + Iterator<Item = AmbientModelEl> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: El) -> impl '_ + Iterator<Item = AmbientModelEl> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<AmbientModelEl> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<AmbientModelEl> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<AmbientModelEl> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for AmbientModelElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ambient_model_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct PredSymbolTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<PredSymbol>>,
}
impl PredSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_symbol_kind: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: PredSymbol) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: PredSymbol) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: PredSymbol) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> PredSymbol {
    PredSymbol(SymbolKind::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = PredSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = PredSymbol> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = PredSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = PredSymbol> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<PredSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for PredSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("PredSymbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct FuncSymbolTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<FuncSymbol>>,
}
impl FuncSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_symbol_kind: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: FuncSymbol) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: FuncSymbol) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: FuncSymbol) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> FuncSymbol {
    FuncSymbol(SymbolKind::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = FuncSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = FuncSymbol> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = FuncSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = FuncSymbol> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<FuncSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for FuncSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("FuncSymbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct RuleSymbolTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<RuleSymbol>>,
}
impl RuleSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_symbol_kind: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RuleSymbol) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RuleSymbol) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: RuleSymbol) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> RuleSymbol {
    RuleSymbol(SymbolKind::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RuleSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = RuleSymbol> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RuleSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = RuleSymbol> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<RuleSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RuleSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("RuleSymbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorSymbol(pub SymbolKind);
#[derive(Clone, Hash, Debug)]
struct CtorSymbolTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_symbol_kind: BTreeMap<SymbolKind, Vec<CtorSymbol>>,
}
impl CtorSymbolTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_symbol_kind: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CtorSymbol) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_symbol_kind.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_kind.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CtorSymbol) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: CtorSymbol) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> CtorSymbol {
    CtorSymbol(SymbolKind::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CtorSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = CtorSymbol> {

self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CtorSymbol> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolKind) -> impl '_ + Iterator<Item = CtorSymbol> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_kind(&mut self, tm: SymbolKind) -> Vec<CtorSymbol> {
    let mut ts = match self.element_index_symbol_kind.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CtorSymbolTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("CtorSymbol"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SymbolScopeParent(pub SymbolScope, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct SymbolScopeParentTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SymbolScopeParent>>,
}
impl SymbolScopeParentTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SymbolScopeParent) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SymbolScopeParent) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: SymbolScopeParent) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> SymbolScopeParent {
    SymbolScopeParent(SymbolScope::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: SymbolScopeParent) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> SymbolScopeParent {
    SymbolScopeParent(SymbolScope::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SymbolScopeParent> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SymbolScopeParent> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeParent> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeParent> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeParent> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeParent> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeParent> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SymbolScopeParent> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SymbolScopeParentTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("symbol_scope_parent"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclsSymbolScope(pub DeclListNode, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct DeclsSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_decl_list_node: BTreeMap<DeclListNode, Vec<DeclsSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<DeclsSymbolScope>>,
}
impl DeclsSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_decl_list_node: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: DeclsSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: DeclsSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: DeclsSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> DeclsSymbolScope {
    DeclsSymbolScope(DeclListNode::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: DeclsSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> DeclsSymbolScope {
    DeclsSymbolScope(DeclListNode::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = DeclsSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = DeclsSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: DeclListNode) -> impl '_ + Iterator<Item = DeclsSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: DeclListNode, arg1: SymbolScope) -> impl '_ + Iterator<Item = DeclsSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = DeclsSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_decl_list_node(&mut self, tm: DeclListNode) -> Vec<DeclsSymbolScope> {
    let mut ts = match self.element_index_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<DeclsSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for DeclsSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("decls_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgsSymbolScope(pub ArgDeclListNode, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct ArgsSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_arg_decl_list_node: BTreeMap<ArgDeclListNode, Vec<ArgsSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ArgsSymbolScope>>,
}
impl ArgsSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_arg_decl_list_node: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ArgsSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_arg_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_arg_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ArgsSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ArgsSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ArgsSymbolScope {
    ArgsSymbolScope(ArgDeclListNode::from(t.0), SymbolScope::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ArgsSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ArgsSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: ArgDeclListNode) -> impl '_ + Iterator<Item = ArgsSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ArgDeclListNode, arg1: SymbolScope) -> impl '_ + Iterator<Item = ArgsSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_arg_decl_list_node(&mut self, tm: ArgDeclListNode) -> Vec<ArgsSymbolScope> {
    let mut ts = match self.element_index_arg_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ArgsSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ArgsSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("args_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorsSymbolScope(pub CtorDeclListNode, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct CtorsSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_list_node: BTreeMap<CtorDeclListNode, Vec<CtorsSymbolScope>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<CtorsSymbolScope>>,
}
impl CtorsSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ctor_decl_list_node: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CtorsSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_ctor_decl_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CtorsSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CtorsSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CtorsSymbolScope {
    CtorsSymbolScope(CtorDeclListNode::from(t.0), SymbolScope::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CtorsSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CtorsSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: CtorDeclListNode) -> impl '_ + Iterator<Item = CtorsSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: CtorDeclListNode, arg1: SymbolScope) -> impl '_ + Iterator<Item = CtorsSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_list_node(&mut self, tm: CtorDeclListNode) -> Vec<CtorsSymbolScope> {
    let mut ts = match self.element_index_ctor_decl_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<CtorsSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CtorsSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ctors_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModelMemberSymbolScope(pub Type, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct ModelMemberSymbolScopeTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_new_1_0: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ModelMemberSymbolScope>>,
    element_index_type: BTreeMap<Type, Vec<ModelMemberSymbolScope>>,
}
impl ModelMemberSymbolScopeTable {
#[allow(unused)]
const WEIGHT: usize = 10;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_new_1_0: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_symbol_scope: BTreeMap::new(),
    element_index_type: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ModelMemberSymbolScope) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}

self.index_new_1_0.insert(Self::permute_1_0(t));

            match self.element_index_type.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ModelMemberSymbolScope) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

self.index_new_1_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ModelMemberSymbolScope) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ModelMemberSymbolScope {
    ModelMemberSymbolScope(Type::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ModelMemberSymbolScope) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ModelMemberSymbolScope {
    ModelMemberSymbolScope(Type::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ModelMemberSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = ModelMemberSymbolScope> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ModelMemberSymbolScope> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Type) -> impl '_ + Iterator<Item = ModelMemberSymbolScope> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Type, arg1: SymbolScope) -> impl '_ + Iterator<Item = ModelMemberSymbolScope> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = ModelMemberSymbolScope> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = ModelMemberSymbolScope> {
    let arg1 = arg1.0;
self.index_new_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
.chain(self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
)}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ModelMemberSymbolScope> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type(&mut self, tm: Type) -> Vec<ModelMemberSymbolScope> {
    let mut ts = match self.element_index_type.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            self.index_new_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ModelMemberSymbolScopeTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("model_member_symbol_scope"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SymbolScopeName(pub SymbolScope, pub Ident);
#[derive(Clone, Hash, Debug)]
struct SymbolScopeNameTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_ident: BTreeMap<Ident, Vec<SymbolScopeName>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<SymbolScopeName>>,
}
impl SymbolScopeNameTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_ident: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SymbolScopeName) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_symbol_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ident.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ident.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SymbolScopeName) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: SymbolScopeName) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> SymbolScopeName {
    SymbolScopeName(SymbolScope::from(t.0), Ident::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SymbolScopeName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SymbolScopeName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: SymbolScope) -> impl '_ + Iterator<Item = SymbolScopeName> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: SymbolScope, arg1: Ident) -> impl '_ + Iterator<Item = SymbolScopeName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_ident(&mut self, tm: Ident) -> Vec<SymbolScopeName> {
    let mut ts = match self.element_index_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<SymbolScopeName> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SymbolScopeNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("symbol_scope_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ScopeSymbols(pub Scope, pub SymbolScope);
#[derive(Clone, Hash, Debug)]
struct ScopeSymbolsTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_scope: BTreeMap<Scope, Vec<ScopeSymbols>>,
    element_index_symbol_scope: BTreeMap<SymbolScope, Vec<ScopeSymbols>>,
}
impl ScopeSymbolsTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_scope: BTreeMap::new(),
    element_index_symbol_scope: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ScopeSymbols) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_scope.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_scope.insert(t.0, vec![t]); },
            };
        

            match self.element_index_symbol_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_symbol_scope.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ScopeSymbols) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: ScopeSymbols) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> ScopeSymbols {
    ScopeSymbols(Scope::from(t.0), SymbolScope::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: ScopeSymbols) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> ScopeSymbols {
    ScopeSymbols(Scope::from(t.1), SymbolScope::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ScopeSymbols> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = ScopeSymbols> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ScopeSymbols> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: Scope) -> impl '_ + Iterator<Item = ScopeSymbols> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Scope) -> impl '_ + Iterator<Item = ScopeSymbols> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: Scope, arg1: SymbolScope) -> impl '_ + Iterator<Item = ScopeSymbols> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Scope, arg1: SymbolScope) -> impl '_ + Iterator<Item = ScopeSymbols> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: SymbolScope) -> impl '_ + Iterator<Item = ScopeSymbols> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<ScopeSymbols> {
    let mut ts = match self.element_index_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_symbol_scope(&mut self, tm: SymbolScope) -> Vec<ScopeSymbols> {
    let mut ts = match self.element_index_symbol_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ScopeSymbolsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("scope_symbols"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticEl(pub TermNode, pub Structure, pub El);
#[derive(Clone, Hash, Debug)]
struct SemanticElTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_2_0: BTreeSet<(u32, u32, u32, )>,
    index_new_2_0_1: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<SemanticEl>>,
    element_index_structure: BTreeMap<Structure, Vec<SemanticEl>>,
    element_index_term_node: BTreeMap<TermNode, Vec<SemanticEl>>,
}
impl SemanticElTable {
#[allow(unused)]
const WEIGHT: usize = 18;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_2_0: BTreeSet::new(),
        index_new_2_0_1: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticEl) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}

self.index_new_2_0_1.insert(Self::permute_2_0_1(t));

            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticEl) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_2_0.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_2_0(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

self.index_new_2_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SemanticEl) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SemanticEl {
    SemanticEl(TermNode::from(t.0), Structure::from(t.1), El::from(t.2))
}
#[allow(unused)]
fn permute_1_2_0(t: SemanticEl) -> (u32, u32, u32, ) {
    (t.1.into(), t.2.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_2_0(t: (u32, u32, u32, )) -> SemanticEl {
    SemanticEl(TermNode::from(t.2), Structure::from(t.0), El::from(t.1))
}
#[allow(unused)]
fn permute_2_0_1(t: SemanticEl) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> SemanticEl {
    SemanticEl(TermNode::from(t.1), Structure::from(t.2), El::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticEl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticEl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: TermNode, arg1: Structure) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermNode, arg1: Structure) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: TermNode, arg1: Structure, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0_2(&self, arg0: TermNode, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_0_2(&self, arg0: TermNode, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg0 = arg0.0;
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0,  u32::MIN, )),
        Bound::Included(&(arg2, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg1 = arg1.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_1_2(&self, arg1: Structure, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_old_1_2_0
    .range((
        Bound::Included(&(arg1, arg2,  u32::MIN, )),
        Bound::Included(&(arg1, arg2,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_2_0)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn iter_all_2(&self, arg2: El) -> impl '_ + Iterator<Item = SemanticEl> {
    let arg2 = arg2.0;
self.index_new_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<SemanticEl> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<SemanticEl> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<SemanticEl> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_new_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_2_0.remove(&Self::permute_1_2_0(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Zero(pub Nat);
#[derive(Clone, Hash, Debug)]
struct ZeroTable {
    index_new_0: BTreeSet<(u32, )>,
    index_old_0: BTreeSet<(u32, )>,
    element_index_nat: BTreeMap<Nat, Vec<Zero>>,
}
impl ZeroTable {
#[allow(unused)]
const WEIGHT: usize = 3;
fn new() -> Self {
    Self {
        index_new_0: BTreeSet::new(),
        index_old_0: BTreeSet::new(),
    element_index_nat: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Zero) -> bool {
if self.index_old_0.contains(&Self::permute_0(t)) {
return false;
}
if !self.index_new_0.insert(Self::permute_0(t)) {
return false;
}



            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.0, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: Zero) -> bool {
    self.index_new_0.contains(&Self::permute_0(t))
 || self.index_old_0.contains(&Self::permute_0(t))

}
fn drop_dirt(&mut self) {
self.index_old_0.extend(
    self.index_new_0
    .iter().copied()
    .map(|t| Self::permute_0(Self::permute_inverse_0(t)))
);

self.index_new_0.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0.is_empty()
}
#[allow(unused)]
fn permute_0(t: Zero) -> (u32, ) {
    (t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_0(t: (u32, )) -> Zero {
    Zero(Nat::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Zero> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Zero> {

self.index_new_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&( u32::MIN, )),
        Bound::Included(&( u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Nat) -> impl '_ + Iterator<Item = Zero> {
    let arg0 = arg0.0;
self.index_new_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
.chain(self.index_old_0
    .range((
        Bound::Included(&(arg0,  )),
        Bound::Included(&(arg0,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0)
)}
#[allow(dead_code)]
fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<Zero> {
    let mut ts = match self.element_index_nat.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else if self.index_old_0.remove(&Self::permute_0(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ZeroTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("zero"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct Succ(pub Nat, pub Nat);
#[derive(Clone, Hash, Debug)]
struct SuccTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_nat: BTreeMap<Nat, Vec<Succ>>,
}
impl SuccTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_nat: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: Succ) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_nat.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.0, vec![t]); },
            };
        

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: Succ) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: Succ) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> Succ {
    Succ(Nat::from(t.0), Nat::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = Succ> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = Succ> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: Nat) -> impl '_ + Iterator<Item = Succ> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Nat, arg1: Nat) -> impl '_ + Iterator<Item = Succ> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<Succ> {
    let mut ts = match self.element_index_nat.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SuccTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("succ"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeListLen(pub TypeList, pub Nat);
#[derive(Clone, Hash, Debug)]
struct TypeListLenTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_nat: BTreeMap<Nat, Vec<TypeListLen>>,
    element_index_type_list: BTreeMap<TypeList, Vec<TypeListLen>>,
}
impl TypeListLenTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_nat: BTreeMap::new(),
    element_index_type_list: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TypeListLen) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_type_list.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_type_list.insert(t.0, vec![t]); },
            };
        

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TypeListLen) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TypeListLen) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TypeListLen {
    TypeListLen(TypeList::from(t.0), Nat::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TypeListLen> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TypeListLen> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = TypeListLen> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TypeList) -> impl '_ + Iterator<Item = TypeListLen> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TypeList, arg1: Nat) -> impl '_ + Iterator<Item = TypeListLen> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<TypeListLen> {
    let mut ts = match self.element_index_nat.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_type_list(&mut self, tm: TypeList) -> Vec<TypeListLen> {
    let mut ts = match self.element_index_type_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TypeListLenTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("type_list_len"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListLen(pub TermListNode, pub Nat);
#[derive(Clone, Hash, Debug)]
struct TermListLenTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_nat: BTreeMap<Nat, Vec<TermListLen>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<TermListLen>>,
}
impl TermListLenTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_nat: BTreeMap::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: TermListLen) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_nat.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_nat.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: TermListLen) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: TermListLen) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> TermListLen {
    TermListLen(TermListNode::from(t.0), Nat::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = TermListLen> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = TermListLen> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = TermListLen> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermListLen> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = TermListLen> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermListNode, arg1: Nat) -> impl '_ + Iterator<Item = TermListLen> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_nat(&mut self, tm: Nat) -> Vec<TermListLen> {
    let mut ts = match self.element_index_nat.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<TermListLen> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for TermListLenTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("term_list_len"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BeforeRuleStructure(pub RuleDeclNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct BeforeRuleStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<BeforeRuleStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<BeforeRuleStructure>>,
}
impl BeforeRuleStructureTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_rule_decl_node: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: BeforeRuleStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: BeforeRuleStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: BeforeRuleStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> BeforeRuleStructure {
    BeforeRuleStructure(RuleDeclNode::from(t.0), Structure::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = BeforeRuleStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = BeforeRuleStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = BeforeRuleStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: RuleDeclNode, arg1: Structure) -> impl '_ + Iterator<Item = BeforeRuleStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDeclNode, arg1: Structure) -> impl '_ + Iterator<Item = BeforeRuleStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<BeforeRuleStructure> {
    let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<BeforeRuleStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for BeforeRuleStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("before_rule_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientModelElStructure(pub RuleDeclNode, pub Structure);
#[derive(Clone, Hash, Debug)]
struct AmbientModelElStructureTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<AmbientModelElStructure>>,
    element_index_structure: BTreeMap<Structure, Vec<AmbientModelElStructure>>,
}
impl AmbientModelElStructureTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_rule_decl_node: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: AmbientModelElStructure) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: AmbientModelElStructure) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: AmbientModelElStructure) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> AmbientModelElStructure {
    AmbientModelElStructure(RuleDeclNode::from(t.0), Structure::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: AmbientModelElStructure) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> AmbientModelElStructure {
    AmbientModelElStructure(RuleDeclNode::from(t.1), Structure::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = AmbientModelElStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = AmbientModelElStructure> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = AmbientModelElStructure> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = AmbientModelElStructure> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDeclNode, arg1: Structure) -> impl '_ + Iterator<Item = AmbientModelElStructure> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = AmbientModelElStructure> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<AmbientModelElStructure> {
    let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<AmbientModelElStructure> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for AmbientModelElStructureTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ambient_model_el_structure"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientModelElMorphism(pub RuleDeclNode, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct AmbientModelElMorphismTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<AmbientModelElMorphism>>,
    element_index_rule_decl_node: BTreeMap<RuleDeclNode, Vec<AmbientModelElMorphism>>,
}
impl AmbientModelElMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_rule_decl_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: AmbientModelElMorphism) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_rule_decl_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rule_decl_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_morphism.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: AmbientModelElMorphism) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: AmbientModelElMorphism) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> AmbientModelElMorphism {
    AmbientModelElMorphism(RuleDeclNode::from(t.0), Morphism::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = AmbientModelElMorphism> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = AmbientModelElMorphism> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = AmbientModelElMorphism> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: RuleDeclNode) -> impl '_ + Iterator<Item = AmbientModelElMorphism> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: RuleDeclNode, arg1: Morphism) -> impl '_ + Iterator<Item = AmbientModelElMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<AmbientModelElMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rule_decl_node(&mut self, tm: RuleDeclNode) -> Vec<AmbientModelElMorphism> {
    let mut ts = match self.element_index_rule_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for AmbientModelElMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("ambient_model_el_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomMorphism(pub IfAtomNode, pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct IfAtomMorphismTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_if_atom_node: BTreeMap<IfAtomNode, Vec<IfAtomMorphism>>,
    element_index_morphism: BTreeMap<Morphism, Vec<IfAtomMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<IfAtomMorphism>>,
}
impl IfAtomMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_if_atom_node: BTreeMap::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: IfAtomMorphism) -> bool {
if self.index_old_2_0_1.contains(&Self::permute_2_0_1(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_if_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_if_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        

            match self.element_index_morphism.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: IfAtomMorphism) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_2_0_1.contains(&Self::permute_2_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: IfAtomMorphism) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> IfAtomMorphism {
    IfAtomMorphism(IfAtomNode::from(t.0), Structure::from(t.1), Morphism::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: IfAtomMorphism) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> IfAtomMorphism {
    IfAtomMorphism(IfAtomNode::from(t.1), Structure::from(t.2), Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = IfAtomMorphism> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = IfAtomMorphism> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: IfAtomNode, arg1: Structure) -> impl '_ + Iterator<Item = IfAtomMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: IfAtomNode, arg1: Structure, arg2: Morphism) -> impl '_ + Iterator<Item = IfAtomMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: Morphism) -> impl '_ + Iterator<Item = IfAtomMorphism> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_if_atom_node(&mut self, tm: IfAtomNode) -> Vec<IfAtomMorphism> {
    let mut ts = match self.element_index_if_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<IfAtomMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<IfAtomMorphism> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for IfAtomMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("if_atom_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomMorphism(pub ThenAtomNode, pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct ThenAtomMorphismTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<ThenAtomMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<ThenAtomMorphism>>,
    element_index_then_atom_node: BTreeMap<ThenAtomNode, Vec<ThenAtomMorphism>>,
}
impl ThenAtomMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    element_index_then_atom_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: ThenAtomMorphism) -> bool {
if self.index_old_2_0_1.contains(&Self::permute_2_0_1(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_then_atom_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_then_atom_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        

            match self.element_index_morphism.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: ThenAtomMorphism) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_2_0_1.contains(&Self::permute_2_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: ThenAtomMorphism) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> ThenAtomMorphism {
    ThenAtomMorphism(ThenAtomNode::from(t.0), Structure::from(t.1), Morphism::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: ThenAtomMorphism) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> ThenAtomMorphism {
    ThenAtomMorphism(ThenAtomNode::from(t.1), Structure::from(t.2), Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = ThenAtomMorphism> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = ThenAtomMorphism> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: ThenAtomNode, arg1: Structure) -> impl '_ + Iterator<Item = ThenAtomMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: ThenAtomNode, arg1: Structure, arg2: Morphism) -> impl '_ + Iterator<Item = ThenAtomMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: Morphism) -> impl '_ + Iterator<Item = ThenAtomMorphism> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<ThenAtomMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<ThenAtomMorphism> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_then_atom_node(&mut self, tm: ThenAtomNode) -> Vec<ThenAtomMorphism> {
    let mut ts = match self.element_index_then_atom_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for ThenAtomMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("then_atom_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BranchStmtMorphism(pub StmtNode, pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct BranchStmtMorphismTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<BranchStmtMorphism>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<BranchStmtMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<BranchStmtMorphism>>,
}
impl BranchStmtMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: BranchStmtMorphism) -> bool {
if self.index_old_2_0_1.contains(&Self::permute_2_0_1(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        

            match self.element_index_morphism.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: BranchStmtMorphism) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_2_0_1.contains(&Self::permute_2_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: BranchStmtMorphism) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> BranchStmtMorphism {
    BranchStmtMorphism(StmtNode::from(t.0), Structure::from(t.1), Morphism::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: BranchStmtMorphism) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> BranchStmtMorphism {
    BranchStmtMorphism(StmtNode::from(t.1), Structure::from(t.2), Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = BranchStmtMorphism> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = BranchStmtMorphism> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: Structure) -> impl '_ + Iterator<Item = BranchStmtMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: StmtNode, arg1: Structure, arg2: Morphism) -> impl '_ + Iterator<Item = BranchStmtMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: Morphism) -> impl '_ + Iterator<Item = BranchStmtMorphism> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<BranchStmtMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<BranchStmtMorphism> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<BranchStmtMorphism> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for BranchStmtMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("branch_stmt_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtMorphism(pub StmtNode, pub Structure, pub Morphism);
#[derive(Clone, Hash, Debug)]
struct MatchStmtMorphismTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_morphism: BTreeMap<Morphism, Vec<MatchStmtMorphism>>,
    element_index_stmt_node: BTreeMap<StmtNode, Vec<MatchStmtMorphism>>,
    element_index_structure: BTreeMap<Structure, Vec<MatchStmtMorphism>>,
}
impl MatchStmtMorphismTable {
#[allow(unused)]
const WEIGHT: usize = 12;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_morphism: BTreeMap::new(),
    element_index_stmt_node: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MatchStmtMorphism) -> bool {
if self.index_old_2_0_1.contains(&Self::permute_2_0_1(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_stmt_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_stmt_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        

            match self.element_index_morphism.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_morphism.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MatchStmtMorphism) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_2_0_1.contains(&Self::permute_2_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: MatchStmtMorphism) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> MatchStmtMorphism {
    MatchStmtMorphism(StmtNode::from(t.0), Structure::from(t.1), Morphism::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: MatchStmtMorphism) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> MatchStmtMorphism {
    MatchStmtMorphism(StmtNode::from(t.1), Structure::from(t.2), Morphism::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MatchStmtMorphism> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MatchStmtMorphism> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: StmtNode, arg1: Structure) -> impl '_ + Iterator<Item = MatchStmtMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: StmtNode, arg1: Structure, arg2: Morphism) -> impl '_ + Iterator<Item = MatchStmtMorphism> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2, arg0, arg1,  )),
        Bound::Included(&(arg2, arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
)}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: Morphism) -> impl '_ + Iterator<Item = MatchStmtMorphism> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_morphism(&mut self, tm: Morphism) -> Vec<MatchStmtMorphism> {
    let mut ts = match self.element_index_morphism.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_stmt_node(&mut self, tm: StmtNode) -> Vec<MatchStmtMorphism> {
    let mut ts = match self.element_index_stmt_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<MatchStmtMorphism> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_2_0_1.remove(&Self::permute_2_0_1(t)) {
            self.index_old_0_1_2.remove(&Self::permute_0_1_2(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MatchStmtMorphismTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_stmt_morphism"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticName(pub VirtIdent, pub Scope, pub ElName);
#[derive(Clone, Hash, Debug)]
struct SemanticNameTable {
    index_new_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    element_index_el_name: BTreeMap<ElName, Vec<SemanticName>>,
    element_index_scope: BTreeMap<Scope, Vec<SemanticName>>,
    element_index_virt_ident: BTreeMap<VirtIdent, Vec<SemanticName>>,
}
impl SemanticNameTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_1_0_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
    element_index_el_name: BTreeMap::new(),
    element_index_scope: BTreeMap::new(),
    element_index_virt_ident: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticName) -> bool {
if self.index_old_1_0_2.contains(&Self::permute_1_0_2(t)) {
return false;
}
if !self.index_new_1_0_2.insert(Self::permute_1_0_2(t)) {
return false;
}



            match self.element_index_virt_ident.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_virt_ident.insert(t.0, vec![t]); },
            };
        

            match self.element_index_scope.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_scope.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el_name.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_name.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticName) -> bool {
    self.index_new_1_0_2.contains(&Self::permute_1_0_2(t))
 || self.index_old_1_0_2.contains(&Self::permute_1_0_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_1_0_2.extend(
    self.index_new_1_0_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_1_0_2(t)))
);

self.index_new_1_0_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_1_0_2.is_empty()
}
#[allow(unused)]
fn permute_1_0_2(t: SemanticName) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> SemanticName {
    SemanticName(VirtIdent::from(t.1), Scope::from(t.0), ElName::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticName> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticName> {

self.index_new_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_old_0_1(&self, arg0: VirtIdent, arg1: Scope) -> impl '_ + Iterator<Item = SemanticName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: VirtIdent, arg1: Scope) -> impl '_ + Iterator<Item = SemanticName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0,  u32::MIN, )),
        Bound::Included(&(arg1, arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: VirtIdent, arg1: Scope, arg2: ElName) -> impl '_ + Iterator<Item = SemanticName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1, arg0, arg2,  )),
        Bound::Included(&(arg1, arg0, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1, arg0, arg2,  )),
        Bound::Included(&(arg1, arg0, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn iter_all_1(&self, arg1: Scope) -> impl '_ + Iterator<Item = SemanticName> {
    let arg1 = arg1.0;
self.index_new_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
.chain(self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
)}
#[allow(dead_code)]
fn drain_with_element_el_name(&mut self, tm: ElName) -> Vec<SemanticName> {
    let mut ts = match self.element_index_el_name.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_scope(&mut self, tm: Scope) -> Vec<SemanticName> {
    let mut ts = match self.element_index_scope.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_virt_ident(&mut self, tm: VirtIdent) -> Vec<SemanticName> {
    let mut ts = match self.element_index_virt_ident.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else if self.index_old_1_0_2.remove(&Self::permute_1_0_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticEls(pub TermListNode, pub Structure, pub ElList);
#[derive(Clone, Hash, Debug)]
struct SemanticElsTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_1_0_2: BTreeSet<(u32, u32, u32, )>,
    index_old_2_0_1: BTreeSet<(u32, u32, u32, )>,
    element_index_el_list: BTreeMap<ElList, Vec<SemanticEls>>,
    element_index_structure: BTreeMap<Structure, Vec<SemanticEls>>,
    element_index_term_list_node: BTreeMap<TermListNode, Vec<SemanticEls>>,
}
impl SemanticElsTable {
#[allow(unused)]
const WEIGHT: usize = 15;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
        index_old_1_0_2: BTreeSet::new(),
        index_old_2_0_1: BTreeSet::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_structure: BTreeMap::new(),
    element_index_term_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: SemanticEls) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_term_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_structure.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_structure.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: SemanticEls) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_1_0_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_1_0_2(Self::permute_inverse_0_1_2(t)))
);

self.index_old_2_0_1.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_2_0_1(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: SemanticEls) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> SemanticEls {
    SemanticEls(TermListNode::from(t.0), Structure::from(t.1), ElList::from(t.2))
}
#[allow(unused)]
fn permute_1_0_2(t: SemanticEls) -> (u32, u32, u32, ) {
    (t.1.into(), t.0.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0_2(t: (u32, u32, u32, )) -> SemanticEls {
    SemanticEls(TermListNode::from(t.1), Structure::from(t.0), ElList::from(t.2))
}
#[allow(unused)]
fn permute_2_0_1(t: SemanticEls) -> (u32, u32, u32, ) {
    (t.2.into(), t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_2_0_1(t: (u32, u32, u32, )) -> SemanticEls {
    SemanticEls(TermListNode::from(t.1), Structure::from(t.2), ElList::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = SemanticEls> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = SemanticEls> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = SemanticEls> {
    let arg0 = arg0.0;
self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermListNode) -> impl '_ + Iterator<Item = SemanticEls> {
    let arg0 = arg0.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermListNode, arg1: Structure) -> impl '_ + Iterator<Item = SemanticEls> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: TermListNode, arg1: Structure, arg2: ElList) -> impl '_ + Iterator<Item = SemanticEls> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: Structure) -> impl '_ + Iterator<Item = SemanticEls> {
    let arg1 = arg1.0;
self.index_old_1_0_2
    .range((
        Bound::Included(&(arg1,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0_2)
}
#[allow(dead_code)]
fn iter_old_2(&self, arg2: ElList) -> impl '_ + Iterator<Item = SemanticEls> {
    let arg2 = arg2.0;
self.index_old_2_0_1
    .range((
        Bound::Included(&(arg2,  u32::MIN, u32::MIN, )),
        Bound::Included(&(arg2,  u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_2_0_1)
}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<SemanticEls> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_structure(&mut self, tm: Structure) -> Vec<SemanticEls> {
    let mut ts = match self.element_index_structure.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_list_node(&mut self, tm: TermListNode) -> Vec<SemanticEls> {
    let mut ts = match self.element_index_term_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            self.index_old_1_0_2.remove(&Self::permute_1_0_2(t));
self.index_old_2_0_1.remove(&Self::permute_2_0_1(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for SemanticElsTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("semantic_els"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct WildcardName(pub TermNode, pub ElName);
#[derive(Clone, Hash, Debug)]
struct WildcardNameTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    element_index_el_name: BTreeMap<ElName, Vec<WildcardName>>,
    element_index_term_node: BTreeMap<TermNode, Vec<WildcardName>>,
}
impl WildcardNameTable {
#[allow(unused)]
const WEIGHT: usize = 6;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
    element_index_el_name: BTreeMap::new(),
    element_index_term_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: WildcardName) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_term_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_term_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el_name.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_name.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: WildcardName) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: WildcardName) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> WildcardName {
    WildcardName(TermNode::from(t.0), ElName::from(t.1))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = WildcardName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = WildcardName> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = WildcardName> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: TermNode) -> impl '_ + Iterator<Item = WildcardName> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: TermNode, arg1: ElName) -> impl '_ + Iterator<Item = WildcardName> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn drain_with_element_el_name(&mut self, tm: ElName) -> Vec<WildcardName> {
    let mut ts = match self.element_index_el_name.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_term_node(&mut self, tm: TermNode) -> Vec<WildcardName> {
    let mut ts = match self.element_index_term_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for WildcardNameTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("wildcard_name"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelAppParentModelEl(pub Rel, pub ElList, pub El);
#[derive(Clone, Hash, Debug)]
struct RelAppParentModelElTable {
    index_new_0_1_2: BTreeSet<(u32, u32, u32, )>,
    index_old_0_1_2: BTreeSet<(u32, u32, u32, )>,
    element_index_el: BTreeMap<El, Vec<RelAppParentModelEl>>,
    element_index_el_list: BTreeMap<ElList, Vec<RelAppParentModelEl>>,
    element_index_rel: BTreeMap<Rel, Vec<RelAppParentModelEl>>,
}
impl RelAppParentModelElTable {
#[allow(unused)]
const WEIGHT: usize = 9;
fn new() -> Self {
    Self {
        index_new_0_1_2: BTreeSet::new(),
        index_old_0_1_2: BTreeSet::new(),
    element_index_el: BTreeMap::new(),
    element_index_el_list: BTreeMap::new(),
    element_index_rel: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: RelAppParentModelEl) -> bool {
if self.index_old_0_1_2.contains(&Self::permute_0_1_2(t)) {
return false;
}
if !self.index_new_0_1_2.insert(Self::permute_0_1_2(t)) {
return false;
}



            match self.element_index_rel.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_rel.insert(t.0, vec![t]); },
            };
        

            match self.element_index_el_list.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el_list.insert(t.1, vec![t]); },
            };
        

            match self.element_index_el.get_mut(&t.2) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_el.insert(t.2, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: RelAppParentModelEl) -> bool {
    self.index_new_0_1_2.contains(&Self::permute_0_1_2(t))
 || self.index_old_0_1_2.contains(&Self::permute_0_1_2(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1_2.extend(
    self.index_new_0_1_2
    .iter().copied()
    .map(|t| Self::permute_0_1_2(Self::permute_inverse_0_1_2(t)))
);

self.index_new_0_1_2.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1_2.is_empty()
}
#[allow(unused)]
fn permute_0_1_2(t: RelAppParentModelEl) -> (u32, u32, u32, ) {
    (t.0.into(), t.1.into(), t.2.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1_2(t: (u32, u32, u32, )) -> RelAppParentModelEl {
    RelAppParentModelEl(Rel::from(t.0), ElList::from(t.1), El::from(t.2))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = RelAppParentModelEl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = RelAppParentModelEl> {

self.index_new_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: Rel, arg1: ElList) -> impl '_ + Iterator<Item = RelAppParentModelEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1,  u32::MIN, )),
        Bound::Included(&(arg0, arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn iter_all_0_1_2(&self, arg0: Rel, arg1: ElList, arg2: El) -> impl '_ + Iterator<Item = RelAppParentModelEl> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
    let arg2 = arg2.0;
self.index_new_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
.chain(self.index_old_0_1_2
    .range((
        Bound::Included(&(arg0, arg1, arg2,  )),
        Bound::Included(&(arg0, arg1, arg2,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1_2)
)}
#[allow(dead_code)]
fn drain_with_element_el(&mut self, tm: El) -> Vec<RelAppParentModelEl> {
    let mut ts = match self.element_index_el.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_el_list(&mut self, tm: ElList) -> Vec<RelAppParentModelEl> {
    let mut ts = match self.element_index_el_list.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_rel(&mut self, tm: Rel) -> Vec<RelAppParentModelEl> {
    let mut ts = match self.element_index_rel.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else if self.index_old_0_1_2.remove(&Self::permute_0_1_2(t)) {
            
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for RelAppParentModelElTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("rel_app_parent_model_el"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCasePatternCtor(pub MatchCaseNode, pub CtorDeclNode);
#[derive(Clone, Hash, Debug)]
struct MatchCasePatternCtorTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_ctor_decl_node: BTreeMap<CtorDeclNode, Vec<MatchCasePatternCtor>>,
    element_index_match_case_node: BTreeMap<MatchCaseNode, Vec<MatchCasePatternCtor>>,
}
impl MatchCasePatternCtorTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_ctor_decl_node: BTreeMap::new(),
    element_index_match_case_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: MatchCasePatternCtor) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_ctor_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_ctor_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: MatchCasePatternCtor) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: MatchCasePatternCtor) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> MatchCasePatternCtor {
    MatchCasePatternCtor(MatchCaseNode::from(t.0), CtorDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: MatchCasePatternCtor) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> MatchCasePatternCtor {
    MatchCasePatternCtor(MatchCaseNode::from(t.1), CtorDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseNode) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseNode, arg1: CtorDeclNode) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: CtorDeclNode) -> impl '_ + Iterator<Item = MatchCasePatternCtor> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_ctor_decl_node(&mut self, tm: CtorDeclNode) -> Vec<MatchCasePatternCtor> {
    let mut ts = match self.element_index_ctor_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_match_case_node(&mut self, tm: MatchCaseNode) -> Vec<MatchCasePatternCtor> {
    let mut ts = match self.element_index_match_case_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for MatchCasePatternCtorTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("match_case_pattern_ctor"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesDeterminedEnum(pub MatchCaseListNode, pub EnumDeclNode);
#[derive(Clone, Hash, Debug)]
struct CasesDeterminedEnumTable {
    index_new_0_1: BTreeSet<(u32, u32, )>,
    index_old_0_1: BTreeSet<(u32, u32, )>,
    index_old_1_0: BTreeSet<(u32, u32, )>,
    element_index_enum_decl_node: BTreeMap<EnumDeclNode, Vec<CasesDeterminedEnum>>,
    element_index_match_case_list_node: BTreeMap<MatchCaseListNode, Vec<CasesDeterminedEnum>>,
}
impl CasesDeterminedEnumTable {
#[allow(unused)]
const WEIGHT: usize = 8;
fn new() -> Self {
    Self {
        index_new_0_1: BTreeSet::new(),
        index_old_0_1: BTreeSet::new(),
        index_old_1_0: BTreeSet::new(),
    element_index_enum_decl_node: BTreeMap::new(),
    element_index_match_case_list_node: BTreeMap::new(),
    }
}
#[allow(dead_code)]
fn insert(&mut self, t: CasesDeterminedEnum) -> bool {
if self.index_old_0_1.contains(&Self::permute_0_1(t)) {
return false;
}
if !self.index_new_0_1.insert(Self::permute_0_1(t)) {
return false;
}



            match self.element_index_match_case_list_node.get_mut(&t.0) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_match_case_list_node.insert(t.0, vec![t]); },
            };
        

            match self.element_index_enum_decl_node.get_mut(&t.1) {
                Some(tuple_vec) => tuple_vec.push(t),
                None => { self.element_index_enum_decl_node.insert(t.1, vec![t]); },
            };
        
true
}
#[allow(dead_code)]
fn contains(&self, t: CasesDeterminedEnum) -> bool {
    self.index_new_0_1.contains(&Self::permute_0_1(t))
 || self.index_old_0_1.contains(&Self::permute_0_1(t))

}
fn drop_dirt(&mut self) {
self.index_old_0_1.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_0_1(Self::permute_inverse_0_1(t)))
);

self.index_old_1_0.extend(
    self.index_new_0_1
    .iter().copied()
    .map(|t| Self::permute_1_0(Self::permute_inverse_0_1(t)))
);

self.index_new_0_1.clear();

}
fn is_dirty(&self) -> bool {
    !self.index_new_0_1.is_empty()
}
#[allow(unused)]
fn permute_0_1(t: CasesDeterminedEnum) -> (u32, u32, ) {
    (t.0.into(), t.1.into(), )
}
#[allow(unused)]
fn permute_inverse_0_1(t: (u32, u32, )) -> CasesDeterminedEnum {
    CasesDeterminedEnum(MatchCaseListNode::from(t.0), EnumDeclNode::from(t.1))
}
#[allow(unused)]
fn permute_1_0(t: CasesDeterminedEnum) -> (u32, u32, ) {
    (t.1.into(), t.0.into(), )
}
#[allow(unused)]
fn permute_inverse_1_0(t: (u32, u32, )) -> CasesDeterminedEnum {
    CasesDeterminedEnum(MatchCaseListNode::from(t.1), EnumDeclNode::from(t.0))
}
#[allow(dead_code)]
fn iter_new(&self, ) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_old(&self, ) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {

self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all(&self, ) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {

self.index_new_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&( u32::MIN, u32::MIN, )),
        Bound::Included(&( u32::MAX, u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
    let arg0 = arg0.0;
self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
}
#[allow(dead_code)]
fn iter_all_0(&self, arg0: MatchCaseListNode) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
    let arg0 = arg0.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0,  u32::MIN, )),
        Bound::Included(&(arg0,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_all_0_1(&self, arg0: MatchCaseListNode, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
    let arg0 = arg0.0;
    let arg1 = arg1.0;
self.index_new_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
.chain(self.index_old_0_1
    .range((
        Bound::Included(&(arg0, arg1,  )),
        Bound::Included(&(arg0, arg1,  ))
    ))
    .copied()
    .map(Self::permute_inverse_0_1)
)}
#[allow(dead_code)]
fn iter_old_1(&self, arg1: EnumDeclNode) -> impl '_ + Iterator<Item = CasesDeterminedEnum> {
    let arg1 = arg1.0;
self.index_old_1_0
    .range((
        Bound::Included(&(arg1,  u32::MIN, )),
        Bound::Included(&(arg1,  u32::MAX, ))
    ))
    .copied()
    .map(Self::permute_inverse_1_0)
}
#[allow(dead_code)]
fn drain_with_element_enum_decl_node(&mut self, tm: EnumDeclNode) -> Vec<CasesDeterminedEnum> {
    let mut ts = match self.element_index_enum_decl_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
#[allow(dead_code)]
fn drain_with_element_match_case_list_node(&mut self, tm: MatchCaseListNode) -> Vec<CasesDeterminedEnum> {
    let mut ts = match self.element_index_match_case_list_node.remove(&tm) {
        None => Vec::new(),
        Some(tuples) => tuples,
    };

    let mut i = 0;
    while i < ts.len() {
        let t = ts[i];
        if self.index_new_0_1.remove(&Self::permute_0_1(t)) {
            
            i += 1;
        } else if self.index_old_0_1.remove(&Self::permute_0_1(t)) {
            self.index_old_1_0.remove(&Self::permute_1_0(t));
            i += 1;
        } else {
            ts.swap_remove(i);
        }
    }

    ts
}
}
impl fmt::Display for CasesDeterminedEnumTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        Table::new(self.iter_all())
            .with(Extract::segment(1.., ..))
            .with(Header("cases_determined_enum"))
            .with(Modify::new(Segment::all()).with(Alignment::center()))
            .with(
                Style::modern()
                    .top_intersection('─')
                    .header_intersection('┬')
            )
            .fmt(f)
    }
}
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RealVirtIdentArgs(pub Ident);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VirtRealIdentArgs(pub VirtIdent);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VarArgs(pub Structure, pub ElName);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleNameArgs(pub RuleDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleNameArgs(pub ModuleNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDeclNodeLocArgs(pub TypeDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclNodeLocArgs(pub ArgDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgDeclListNodeLocArgs(pub ArgDeclListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredDeclNodeLocArgs(pub PredDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncDeclNodeLocArgs(pub FuncDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorDeclNodeLocArgs(pub CtorDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumDeclNodeLocArgs(pub EnumDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModelDeclNodeLocArgs(pub ModelDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermNodeLocArgs(pub TermNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListNodeLocArgs(pub TermListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCaseNodeLocArgs(pub MatchCaseNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct OptTermNodeLocArgs(pub OptTermNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomNodeLocArgs(pub IfAtomNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomNodeLocArgs(pub ThenAtomNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtNodeLocArgs(pub StmtNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct StmtListNodeLocArgs(pub StmtListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDeclNodeLocArgs(pub RuleDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclNodeLocArgs(pub DeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclListNodeLocArgs(pub DeclListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleNodeLocArgs(pub ModuleNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeExprNodeLocArgs(pub TypeExprNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantRuleArgs(pub RuleDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTermArgs(pub TermNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTermListArgs(pub TermListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantOptTermArgs(pub OptTermNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantIfAtomArgs(pub IfAtomNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantThenAtomArgs(pub ThenAtomNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantMatchCaseArgs(pub MatchCaseNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantMatchCaseListArgs(pub MatchCaseListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtArgs(pub StmtNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtListArgs(pub StmtListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantStmtBlockListArgs(pub StmtBlockListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleDescendantTypeExprArgs(pub TypeExprNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EntryScopeArgs(pub RuleDescendantNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ExitScopeArgs(pub RuleDescendantNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorEnumArgs(pub CtorDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorsEnumArgs(pub CtorDeclListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesDiscrimineeArgs(pub MatchCaseListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CaseDiscrimineeArgs(pub MatchCaseNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseEqualityAtomArgs(pub MatchCaseNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseEqualityStmtArgs(pub MatchCaseNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseBlockArgs(pub MatchCaseNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DesugaredCaseBlockListArgs(pub MatchCaseListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilTypeListArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsTypeListArgs(pub Type, pub TypeList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocTypeListArgs(pub TypeList, pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticTypeArgs(pub SymbolScope, pub Ident);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclSymbolScopeArgs(pub DeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MorTypeArgs(pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MorTypeDomFuncArgs(pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MorTypeCodFuncArgs(pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeDefinitionSymbolScopeArgs(pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncRelArgs(pub Func);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelDefinitionSymbolScopeArgs(pub Rel);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DomainArgs(pub Func);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CodomainArgs(pub Func);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeNameArgs(pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct VirtualSymbolScopeArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ParentModelFuncArgs(pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SymbolScopeModelArgs(pub SymbolScope);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FlatDomainArgs(pub Func);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticSignatureTypeExprArgs(pub SymbolScope, pub TypeExprNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeSymbolArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct EnumSymbolArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModelSymbolArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticArgTypeArgs(pub ArgDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgSymbolScopeArgs(pub ArgDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticArgTypesArgs(pub ArgDeclListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticPredArgs(pub SymbolScope, pub Ident);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredArityArgs(pub Pred);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticFuncArgs(pub SymbolScope, pub Ident);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorSymbolScopeArgs(pub CtorDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredRelArgs(pub Pred);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelNameArgs(pub Rel);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArityArgs(pub Rel);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DomArgs(pub Morphism);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CodArgs(pub Morphism);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FlatArityArgs(pub Rel);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModuleSymbolScopeArgs(pub ModuleNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilElListArgs(pub Structure);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsElListArgs(pub El, pub ElList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocElListArgs(pub ElList, pub El);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElStructureArgs(pub El);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ElsStructureArgs(pub ElList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientTypeArgs(pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct InstantiatedTypeArgs(pub El, pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct UnderlyingTypeArgs(pub ElementType);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct NilElementTypeListArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ConsElementTypeListArgs(pub ElementType, pub ElementTypeList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SnocElementTypeListArgs(pub ElementTypeList, pub ElementType);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientElTypeListArgs(pub TypeList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncAppArgs(pub Func, pub ElList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapElArgs(pub Morphism, pub El);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MapElsArgs(pub Morphism, pub ElList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientModelElArgs(pub SymbolScope, pub Structure);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct PredSymbolArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct FuncSymbolArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RuleSymbolArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorSymbolArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SymbolScopeParentArgs(pub SymbolScope);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct DeclsSymbolScopeArgs(pub DeclListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ArgsSymbolScopeArgs(pub ArgDeclListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CtorsSymbolScopeArgs(pub CtorDeclListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ModelMemberSymbolScopeArgs(pub Type);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SymbolScopeNameArgs(pub SymbolScope);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ScopeSymbolsArgs(pub Scope);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticElArgs(pub TermNode, pub Structure);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ZeroArgs();
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SuccArgs(pub Nat);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TypeListLenArgs(pub TypeList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct TermListLenArgs(pub TermListNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BeforeRuleStructureArgs(pub RuleDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientModelElStructureArgs(pub RuleDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct AmbientModelElMorphismArgs(pub RuleDeclNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct IfAtomMorphismArgs(pub IfAtomNode, pub Structure);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct ThenAtomMorphismArgs(pub ThenAtomNode, pub Structure);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct BranchStmtMorphismArgs(pub StmtNode, pub Structure);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchStmtMorphismArgs(pub StmtNode, pub Structure);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticNameArgs(pub VirtIdent, pub Scope);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct SemanticElsArgs(pub TermListNode, pub Structure);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct WildcardNameArgs(pub TermNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct RelAppParentModelElArgs(pub Rel, pub ElList);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct MatchCasePatternCtorArgs(pub MatchCaseNode);
#[allow(unused)]
#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, PartialOrd, Ord, Tabled)]
struct CasesDeterminedEnumArgs(pub MatchCaseListNode);

#[derive(Debug, Clone)]
struct ModelDelta {
    new_absurd: Vec<Absurd>,
    new_type_decl: Vec<TypeDecl>,
    new_arg_decl_node_name: Vec<ArgDeclNodeName>,
    new_arg_decl_node_type: Vec<ArgDeclNodeType>,
    new_nil_arg_decl_list_node: Vec<NilArgDeclListNode>,
    new_cons_arg_decl_list_node: Vec<ConsArgDeclListNode>,
    new_pred_decl: Vec<PredDecl>,
    new_func_decl: Vec<FuncDecl>,
    new_ctor_decl: Vec<CtorDecl>,
    new_nil_ctor_decl_list_node: Vec<NilCtorDeclListNode>,
    new_cons_ctor_decl_list_node: Vec<ConsCtorDeclListNode>,
    new_enum_decl: Vec<EnumDecl>,
    new_nil_term_list_node: Vec<NilTermListNode>,
    new_cons_term_list_node: Vec<ConsTermListNode>,
    new_ambient_type_expr: Vec<AmbientTypeExpr>,
    new_member_type_expr: Vec<MemberTypeExpr>,
    new_mor_type_expr: Vec<MorTypeExpr>,
    new_none_term_node: Vec<NoneTermNode>,
    new_some_term_node: Vec<SomeTermNode>,
    new_var_term_node: Vec<VarTermNode>,
    new_wildcard_term_node: Vec<WildcardTermNode>,
    new_app_term_node: Vec<AppTermNode>,
    new_match_case: Vec<MatchCase>,
    new_nil_match_case_list_node: Vec<NilMatchCaseListNode>,
    new_cons_match_case_list_node: Vec<ConsMatchCaseListNode>,
    new_equal_if_atom_node: Vec<EqualIfAtomNode>,
    new_defined_if_atom_node: Vec<DefinedIfAtomNode>,
    new_pred_if_atom_node: Vec<PredIfAtomNode>,
    new_var_if_atom_node: Vec<VarIfAtomNode>,
    new_equal_then_atom_node: Vec<EqualThenAtomNode>,
    new_defined_then_atom_node: Vec<DefinedThenAtomNode>,
    new_pred_then_atom_node: Vec<PredThenAtomNode>,
    new_if_stmt_node: Vec<IfStmtNode>,
    new_then_stmt_node: Vec<ThenStmtNode>,
    new_branch_stmt_node: Vec<BranchStmtNode>,
    new_match_stmt_node: Vec<MatchStmtNode>,
    new_nil_stmt_list_node: Vec<NilStmtListNode>,
    new_cons_stmt_list_node: Vec<ConsStmtListNode>,
    new_nil_stmt_block_list_node: Vec<NilStmtBlockListNode>,
    new_cons_stmt_block_list_node: Vec<ConsStmtBlockListNode>,
    new_rule_decl: Vec<RuleDecl>,
    new_model_decl: Vec<ModelDecl>,
    new_decl_node_type: Vec<DeclNodeType>,
    new_decl_node_pred: Vec<DeclNodePred>,
    new_decl_node_func: Vec<DeclNodeFunc>,
    new_decl_node_rule: Vec<DeclNodeRule>,
    new_decl_node_enum: Vec<DeclNodeEnum>,
    new_decl_node_model: Vec<DeclNodeModel>,
    new_nil_decl_list_node: Vec<NilDeclListNode>,
    new_cons_decl_list_node: Vec<ConsDeclListNode>,
    new_decls_module_node: Vec<DeclsModuleNode>,
    new_var_in_scope: Vec<VarInScope>,
    new_scope_extension: Vec<ScopeExtension>,
    new_scope_single_child: Vec<ScopeSingleChild>,
    new_scope_extension_siblings: Vec<ScopeExtensionSiblings>,
    new_is_normal_type: Vec<IsNormalType>,
    new_is_enum_type: Vec<IsEnumType>,
    new_is_model_type: Vec<IsModelType>,
    new_is_mor_type: Vec<IsMorType>,
    new_illegal_member_type_expr_in_signature: Vec<IllegalMemberTypeExprInSignature>,
    new_is_total_func: Vec<IsTotalFunc>,
    new_rel_app: Vec<RelApp>,
    new_el_type: Vec<ElType>,
    new_el_types: Vec<ElTypes>,
    new_constrained_el: Vec<ConstrainedEl>,
    new_constrained_els: Vec<ConstrainedEls>,
    new_in_ker: Vec<InKer>,
    new_el_in_img: Vec<ElInImg>,
    new_rel_tuple_in_img: Vec<RelTupleInImg>,
    new_symbol_scope_extension: Vec<SymbolScopeExtension>,
    new_symbol_scope_ancestor: Vec<SymbolScopeAncestor>,
    new_element_member_symbol_scope: Vec<ElementMemberSymbolScope>,
    new_defined_symbol: Vec<DefinedSymbol>,
    new_accessible_symbol: Vec<AccessibleSymbol>,
    new_should_be_symbol: Vec<ShouldBeSymbol>,
    new_should_be_symbol_2: Vec<ShouldBeSymbol2>,
    new_should_be_symbol_3: Vec<ShouldBeSymbol3>,
    new_pred_arg_num_should_match: Vec<PredArgNumShouldMatch>,
    new_func_arg_num_should_match: Vec<FuncArgNumShouldMatch>,
    new_cfg_edge: Vec<CfgEdge>,
    new_cfg_edge_stmts_stmt: Vec<CfgEdgeStmtsStmt>,
    new_cfg_edge_stmt_stmts: Vec<CfgEdgeStmtStmts>,
    new_cfg_edge_fork: Vec<CfgEdgeFork>,
    new_cfg_edge_join: Vec<CfgEdgeJoin>,
    new_before_stmt_structure: Vec<BeforeStmtStructure>,
    new_stmt_morphism: Vec<StmtMorphism>,
    new_if_morphism: Vec<IfMorphism>,
    new_surj_then_morphism: Vec<SurjThenMorphism>,
    new_non_surj_then_morphism: Vec<NonSurjThenMorphism>,
    new_noop_morphism: Vec<NoopMorphism>,
    new_stmt_structure: Vec<StmtStructure>,
    new_if_atom_structure: Vec<IfAtomStructure>,
    new_then_atom_structure: Vec<ThenAtomStructure>,
    new_term_structure: Vec<TermStructure>,
    new_terms_structure: Vec<TermsStructure>,
    new_opt_term_structure: Vec<OptTermStructure>,
    new_type_expr_structure: Vec<TypeExprStructure>,
    new_term_should_be_epic_ok: Vec<TermShouldBeEpicOk>,
    new_terms_should_be_epic_ok: Vec<TermsShouldBeEpicOk>,
    new_el_should_be_surjective_ok: Vec<ElShouldBeSurjectiveOk>,
    new_el_is_surjective_ok: Vec<ElIsSurjectiveOk>,
    new_should_be_obtained_by_ctor: Vec<ShouldBeObtainedByCtor>,
    new_is_given_by_ctor: Vec<IsGivenByCtor>,
    new_function_can_be_made_defined: Vec<FunctionCanBeMadeDefined>,
    new_case_pattern_is_variable: Vec<CasePatternIsVariable>,
    new_case_pattern_is_wildcard: Vec<CasePatternIsWildcard>,
    new_is_pattern_ctor_arg: Vec<IsPatternCtorArg>,
    new_are_pattern_ctor_args: Vec<ArePatternCtorArgs>,
    new_pattern_ctor_arg_is_app: Vec<PatternCtorArgIsApp>,
    new_pattern_ctor_arg_var_is_not_fresh: Vec<PatternCtorArgVarIsNotFresh>,
    new_cases_contain_ctor: Vec<CasesContainCtor>,
    new_match_stmt_contains_ctor_of_enum: Vec<MatchStmtContainsCtorOfEnum>,
    new_match_stmt_should_contain_ctor: Vec<MatchStmtShouldContainCtor>,
    new_match_stmt_contains_ctor: Vec<MatchStmtContainsCtor>,
    new_real_virt_ident: Vec<RealVirtIdent>,
    new_virt_real_ident: Vec<VirtRealIdent>,
    new_var: Vec<Var>,
    new_rule_name: Vec<RuleName>,
    new_module_name: Vec<ModuleName>,
    new_type_decl_node_loc: Vec<TypeDeclNodeLoc>,
    new_arg_decl_node_loc: Vec<ArgDeclNodeLoc>,
    new_arg_decl_list_node_loc: Vec<ArgDeclListNodeLoc>,
    new_pred_decl_node_loc: Vec<PredDeclNodeLoc>,
    new_func_decl_node_loc: Vec<FuncDeclNodeLoc>,
    new_ctor_decl_node_loc: Vec<CtorDeclNodeLoc>,
    new_enum_decl_node_loc: Vec<EnumDeclNodeLoc>,
    new_model_decl_node_loc: Vec<ModelDeclNodeLoc>,
    new_term_node_loc: Vec<TermNodeLoc>,
    new_term_list_node_loc: Vec<TermListNodeLoc>,
    new_match_case_node_loc: Vec<MatchCaseNodeLoc>,
    new_opt_term_node_loc: Vec<OptTermNodeLoc>,
    new_if_atom_node_loc: Vec<IfAtomNodeLoc>,
    new_then_atom_node_loc: Vec<ThenAtomNodeLoc>,
    new_stmt_node_loc: Vec<StmtNodeLoc>,
    new_stmt_list_node_loc: Vec<StmtListNodeLoc>,
    new_rule_decl_node_loc: Vec<RuleDeclNodeLoc>,
    new_decl_node_loc: Vec<DeclNodeLoc>,
    new_decl_list_node_loc: Vec<DeclListNodeLoc>,
    new_module_node_loc: Vec<ModuleNodeLoc>,
    new_type_expr_node_loc: Vec<TypeExprNodeLoc>,
    new_rule_descendant_rule: Vec<RuleDescendantRule>,
    new_rule_descendant_term: Vec<RuleDescendantTerm>,
    new_rule_descendant_term_list: Vec<RuleDescendantTermList>,
    new_rule_descendant_opt_term: Vec<RuleDescendantOptTerm>,
    new_rule_descendant_if_atom: Vec<RuleDescendantIfAtom>,
    new_rule_descendant_then_atom: Vec<RuleDescendantThenAtom>,
    new_rule_descendant_match_case: Vec<RuleDescendantMatchCase>,
    new_rule_descendant_match_case_list: Vec<RuleDescendantMatchCaseList>,
    new_rule_descendant_stmt: Vec<RuleDescendantStmt>,
    new_rule_descendant_stmt_list: Vec<RuleDescendantStmtList>,
    new_rule_descendant_stmt_block_list: Vec<RuleDescendantStmtBlockList>,
    new_rule_descendant_type_expr: Vec<RuleDescendantTypeExpr>,
    new_entry_scope: Vec<EntryScope>,
    new_exit_scope: Vec<ExitScope>,
    new_ctor_enum: Vec<CtorEnum>,
    new_ctors_enum: Vec<CtorsEnum>,
    new_cases_discriminee: Vec<CasesDiscriminee>,
    new_case_discriminee: Vec<CaseDiscriminee>,
    new_desugared_case_equality_atom: Vec<DesugaredCaseEqualityAtom>,
    new_desugared_case_equality_stmt: Vec<DesugaredCaseEqualityStmt>,
    new_desugared_case_block: Vec<DesugaredCaseBlock>,
    new_desugared_case_block_list: Vec<DesugaredCaseBlockList>,
    new_nil_type_list: Vec<NilTypeList>,
    new_cons_type_list: Vec<ConsTypeList>,
    new_snoc_type_list: Vec<SnocTypeList>,
    new_semantic_type: Vec<SemanticType>,
    new_decl_symbol_scope: Vec<DeclSymbolScope>,
    new_mor_type: Vec<MorType>,
    new_mor_type_dom_func: Vec<MorTypeDomFunc>,
    new_mor_type_cod_func: Vec<MorTypeCodFunc>,
    new_type_definition_symbol_scope: Vec<TypeDefinitionSymbolScope>,
    new_func_rel: Vec<FuncRel>,
    new_rel_definition_symbol_scope: Vec<RelDefinitionSymbolScope>,
    new_domain: Vec<Domain>,
    new_codomain: Vec<Codomain>,
    new_type_name: Vec<TypeName>,
    new_virtual_symbol_scope: Vec<VirtualSymbolScope>,
    new_parent_model_func: Vec<ParentModelFunc>,
    new_symbol_scope_model: Vec<SymbolScopeModel>,
    new_flat_domain: Vec<FlatDomain>,
    new_semantic_signature_type_expr: Vec<SemanticSignatureTypeExpr>,
    new_type_symbol: Vec<TypeSymbol>,
    new_enum_symbol: Vec<EnumSymbol>,
    new_model_symbol: Vec<ModelSymbol>,
    new_semantic_arg_type: Vec<SemanticArgType>,
    new_arg_symbol_scope: Vec<ArgSymbolScope>,
    new_semantic_arg_types: Vec<SemanticArgTypes>,
    new_semantic_pred: Vec<SemanticPred>,
    new_pred_arity: Vec<PredArity>,
    new_semantic_func: Vec<SemanticFunc>,
    new_ctor_symbol_scope: Vec<CtorSymbolScope>,
    new_pred_rel: Vec<PredRel>,
    new_rel_name: Vec<RelName>,
    new_arity: Vec<Arity>,
    new_dom: Vec<Dom>,
    new_cod: Vec<Cod>,
    new_flat_arity: Vec<FlatArity>,
    new_module_symbol_scope: Vec<ModuleSymbolScope>,
    new_nil_el_list: Vec<NilElList>,
    new_cons_el_list: Vec<ConsElList>,
    new_snoc_el_list: Vec<SnocElList>,
    new_el_structure: Vec<ElStructure>,
    new_els_structure: Vec<ElsStructure>,
    new_ambient_type: Vec<AmbientType>,
    new_instantiated_type: Vec<InstantiatedType>,
    new_underlying_type: Vec<UnderlyingType>,
    new_nil_element_type_list: Vec<NilElementTypeList>,
    new_cons_element_type_list: Vec<ConsElementTypeList>,
    new_snoc_element_type_list: Vec<SnocElementTypeList>,
    new_ambient_el_type_list: Vec<AmbientElTypeList>,
    new_func_app: Vec<FuncApp>,
    new_map_el: Vec<MapEl>,
    new_map_els: Vec<MapEls>,
    new_ambient_model_el: Vec<AmbientModelEl>,
    new_pred_symbol: Vec<PredSymbol>,
    new_func_symbol: Vec<FuncSymbol>,
    new_rule_symbol: Vec<RuleSymbol>,
    new_ctor_symbol: Vec<CtorSymbol>,
    new_symbol_scope_parent: Vec<SymbolScopeParent>,
    new_decls_symbol_scope: Vec<DeclsSymbolScope>,
    new_args_symbol_scope: Vec<ArgsSymbolScope>,
    new_ctors_symbol_scope: Vec<CtorsSymbolScope>,
    new_model_member_symbol_scope: Vec<ModelMemberSymbolScope>,
    new_symbol_scope_name: Vec<SymbolScopeName>,
    new_scope_symbols: Vec<ScopeSymbols>,
    new_semantic_el: Vec<SemanticEl>,
    new_zero: Vec<Zero>,
    new_succ: Vec<Succ>,
    new_type_list_len: Vec<TypeListLen>,
    new_term_list_len: Vec<TermListLen>,
    new_before_rule_structure: Vec<BeforeRuleStructure>,
    new_ambient_model_el_structure: Vec<AmbientModelElStructure>,
    new_ambient_model_el_morphism: Vec<AmbientModelElMorphism>,
    new_if_atom_morphism: Vec<IfAtomMorphism>,
    new_then_atom_morphism: Vec<ThenAtomMorphism>,
    new_branch_stmt_morphism: Vec<BranchStmtMorphism>,
    new_match_stmt_morphism: Vec<MatchStmtMorphism>,
    new_semantic_name: Vec<SemanticName>,
    new_semantic_els: Vec<SemanticEls>,
    new_wildcard_name: Vec<WildcardName>,
    new_rel_app_parent_model_el: Vec<RelAppParentModelEl>,
    new_match_case_pattern_ctor: Vec<MatchCasePatternCtor>,
    new_cases_determined_enum: Vec<CasesDeterminedEnum>,
    new_ident_equalities: Vec<(Ident, Ident)>,
    new_virt_ident_equalities: Vec<(VirtIdent, VirtIdent)>,
    new_type_decl_node_equalities: Vec<(TypeDeclNode, TypeDeclNode)>,
    new_arg_decl_node_equalities: Vec<(ArgDeclNode, ArgDeclNode)>,
    new_type_expr_node_equalities: Vec<(TypeExprNode, TypeExprNode)>,
    new_arg_decl_list_node_equalities: Vec<(ArgDeclListNode, ArgDeclListNode)>,
    new_pred_decl_node_equalities: Vec<(PredDeclNode, PredDeclNode)>,
    new_func_decl_node_equalities: Vec<(FuncDeclNode, FuncDeclNode)>,
    new_ctor_decl_node_equalities: Vec<(CtorDeclNode, CtorDeclNode)>,
    new_ctor_decl_list_node_equalities: Vec<(CtorDeclListNode, CtorDeclListNode)>,
    new_enum_decl_node_equalities: Vec<(EnumDeclNode, EnumDeclNode)>,
    new_term_node_equalities: Vec<(TermNode, TermNode)>,
    new_term_list_node_equalities: Vec<(TermListNode, TermListNode)>,
    new_opt_term_node_equalities: Vec<(OptTermNode, OptTermNode)>,
    new_match_case_node_equalities: Vec<(MatchCaseNode, MatchCaseNode)>,
    new_stmt_list_node_equalities: Vec<(StmtListNode, StmtListNode)>,
    new_match_case_list_node_equalities: Vec<(MatchCaseListNode, MatchCaseListNode)>,
    new_if_atom_node_equalities: Vec<(IfAtomNode, IfAtomNode)>,
    new_then_atom_node_equalities: Vec<(ThenAtomNode, ThenAtomNode)>,
    new_stmt_node_equalities: Vec<(StmtNode, StmtNode)>,
    new_stmt_block_list_node_equalities: Vec<(StmtBlockListNode, StmtBlockListNode)>,
    new_rule_decl_node_equalities: Vec<(RuleDeclNode, RuleDeclNode)>,
    new_model_decl_node_equalities: Vec<(ModelDeclNode, ModelDeclNode)>,
    new_decl_list_node_equalities: Vec<(DeclListNode, DeclListNode)>,
    new_decl_node_equalities: Vec<(DeclNode, DeclNode)>,
    new_module_node_equalities: Vec<(ModuleNode, ModuleNode)>,
    new_loc_equalities: Vec<(Loc, Loc)>,
    new_rule_descendant_node_equalities: Vec<(RuleDescendantNode, RuleDescendantNode)>,
    new_scope_equalities: Vec<(Scope, Scope)>,
    new_type_equalities: Vec<(Type, Type)>,
    new_type_list_equalities: Vec<(TypeList, TypeList)>,
    new_symbol_scope_equalities: Vec<(SymbolScope, SymbolScope)>,
    new_func_equalities: Vec<(Func, Func)>,
    new_pred_equalities: Vec<(Pred, Pred)>,
    new_rel_equalities: Vec<(Rel, Rel)>,
    new_structure_equalities: Vec<(Structure, Structure)>,
    new_el_equalities: Vec<(El, El)>,
    new_el_list_equalities: Vec<(ElList, ElList)>,
    new_el_name_equalities: Vec<(ElName, ElName)>,
    new_element_type_equalities: Vec<(ElementType, ElementType)>,
    new_element_type_list_equalities: Vec<(ElementTypeList, ElementTypeList)>,
    new_morphism_equalities: Vec<(Morphism, Morphism)>,
    new_symbol_kind_equalities: Vec<(SymbolKind, SymbolKind)>,
    new_nat_equalities: Vec<(Nat, Nat)>,
new_real_virt_ident_def: Vec<RealVirtIdentArgs>,
new_virt_real_ident_def: Vec<VirtRealIdentArgs>,
new_var_def: Vec<VarArgs>,
new_rule_name_def: Vec<RuleNameArgs>,
new_module_name_def: Vec<ModuleNameArgs>,
new_type_decl_node_loc_def: Vec<TypeDeclNodeLocArgs>,
new_arg_decl_node_loc_def: Vec<ArgDeclNodeLocArgs>,
new_arg_decl_list_node_loc_def: Vec<ArgDeclListNodeLocArgs>,
new_pred_decl_node_loc_def: Vec<PredDeclNodeLocArgs>,
new_func_decl_node_loc_def: Vec<FuncDeclNodeLocArgs>,
new_ctor_decl_node_loc_def: Vec<CtorDeclNodeLocArgs>,
new_enum_decl_node_loc_def: Vec<EnumDeclNodeLocArgs>,
new_model_decl_node_loc_def: Vec<ModelDeclNodeLocArgs>,
new_term_node_loc_def: Vec<TermNodeLocArgs>,
new_term_list_node_loc_def: Vec<TermListNodeLocArgs>,
new_match_case_node_loc_def: Vec<MatchCaseNodeLocArgs>,
new_opt_term_node_loc_def: Vec<OptTermNodeLocArgs>,
new_if_atom_node_loc_def: Vec<IfAtomNodeLocArgs>,
new_then_atom_node_loc_def: Vec<ThenAtomNodeLocArgs>,
new_stmt_node_loc_def: Vec<StmtNodeLocArgs>,
new_stmt_list_node_loc_def: Vec<StmtListNodeLocArgs>,
new_rule_decl_node_loc_def: Vec<RuleDeclNodeLocArgs>,
new_decl_node_loc_def: Vec<DeclNodeLocArgs>,
new_decl_list_node_loc_def: Vec<DeclListNodeLocArgs>,
new_module_node_loc_def: Vec<ModuleNodeLocArgs>,
new_type_expr_node_loc_def: Vec<TypeExprNodeLocArgs>,
new_rule_descendant_rule_def: Vec<RuleDescendantRuleArgs>,
new_rule_descendant_term_def: Vec<RuleDescendantTermArgs>,
new_rule_descendant_term_list_def: Vec<RuleDescendantTermListArgs>,
new_rule_descendant_opt_term_def: Vec<RuleDescendantOptTermArgs>,
new_rule_descendant_if_atom_def: Vec<RuleDescendantIfAtomArgs>,
new_rule_descendant_then_atom_def: Vec<RuleDescendantThenAtomArgs>,
new_rule_descendant_match_case_def: Vec<RuleDescendantMatchCaseArgs>,
new_rule_descendant_match_case_list_def: Vec<RuleDescendantMatchCaseListArgs>,
new_rule_descendant_stmt_def: Vec<RuleDescendantStmtArgs>,
new_rule_descendant_stmt_list_def: Vec<RuleDescendantStmtListArgs>,
new_rule_descendant_stmt_block_list_def: Vec<RuleDescendantStmtBlockListArgs>,
new_rule_descendant_type_expr_def: Vec<RuleDescendantTypeExprArgs>,
new_entry_scope_def: Vec<EntryScopeArgs>,
new_exit_scope_def: Vec<ExitScopeArgs>,
new_ctor_enum_def: Vec<CtorEnumArgs>,
new_ctors_enum_def: Vec<CtorsEnumArgs>,
new_cases_discriminee_def: Vec<CasesDiscrimineeArgs>,
new_case_discriminee_def: Vec<CaseDiscrimineeArgs>,
new_desugared_case_equality_atom_def: Vec<DesugaredCaseEqualityAtomArgs>,
new_desugared_case_equality_stmt_def: Vec<DesugaredCaseEqualityStmtArgs>,
new_desugared_case_block_def: Vec<DesugaredCaseBlockArgs>,
new_desugared_case_block_list_def: Vec<DesugaredCaseBlockListArgs>,
new_nil_type_list_def: Vec<NilTypeListArgs>,
new_cons_type_list_def: Vec<ConsTypeListArgs>,
new_snoc_type_list_def: Vec<SnocTypeListArgs>,
new_semantic_type_def: Vec<SemanticTypeArgs>,
new_decl_symbol_scope_def: Vec<DeclSymbolScopeArgs>,
new_mor_type_def: Vec<MorTypeArgs>,
new_mor_type_dom_func_def: Vec<MorTypeDomFuncArgs>,
new_mor_type_cod_func_def: Vec<MorTypeCodFuncArgs>,
new_type_definition_symbol_scope_def: Vec<TypeDefinitionSymbolScopeArgs>,
new_func_rel_def: Vec<FuncRelArgs>,
new_rel_definition_symbol_scope_def: Vec<RelDefinitionSymbolScopeArgs>,
new_codomain_def: Vec<CodomainArgs>,
new_type_name_def: Vec<TypeNameArgs>,
new_virtual_symbol_scope_def: Vec<VirtualSymbolScopeArgs>,
new_parent_model_func_def: Vec<ParentModelFuncArgs>,
new_symbol_scope_model_def: Vec<SymbolScopeModelArgs>,
new_semantic_signature_type_expr_def: Vec<SemanticSignatureTypeExprArgs>,
new_type_symbol_def: Vec<TypeSymbolArgs>,
new_enum_symbol_def: Vec<EnumSymbolArgs>,
new_model_symbol_def: Vec<ModelSymbolArgs>,
new_semantic_arg_type_def: Vec<SemanticArgTypeArgs>,
new_arg_symbol_scope_def: Vec<ArgSymbolScopeArgs>,
new_semantic_pred_def: Vec<SemanticPredArgs>,
new_semantic_func_def: Vec<SemanticFuncArgs>,
new_ctor_symbol_scope_def: Vec<CtorSymbolScopeArgs>,
new_pred_rel_def: Vec<PredRelArgs>,
new_rel_name_def: Vec<RelNameArgs>,
new_dom_def: Vec<DomArgs>,
new_cod_def: Vec<CodArgs>,
new_module_symbol_scope_def: Vec<ModuleSymbolScopeArgs>,
new_nil_el_list_def: Vec<NilElListArgs>,
new_cons_el_list_def: Vec<ConsElListArgs>,
new_snoc_el_list_def: Vec<SnocElListArgs>,
new_el_structure_def: Vec<ElStructureArgs>,
new_els_structure_def: Vec<ElsStructureArgs>,
new_ambient_type_def: Vec<AmbientTypeArgs>,
new_instantiated_type_def: Vec<InstantiatedTypeArgs>,
new_underlying_type_def: Vec<UnderlyingTypeArgs>,
new_nil_element_type_list_def: Vec<NilElementTypeListArgs>,
new_cons_element_type_list_def: Vec<ConsElementTypeListArgs>,
new_snoc_element_type_list_def: Vec<SnocElementTypeListArgs>,
new_func_app_def: Vec<FuncAppArgs>,
new_map_el_def: Vec<MapElArgs>,
new_ambient_model_el_def: Vec<AmbientModelElArgs>,
new_pred_symbol_def: Vec<PredSymbolArgs>,
new_func_symbol_def: Vec<FuncSymbolArgs>,
new_rule_symbol_def: Vec<RuleSymbolArgs>,
new_ctor_symbol_def: Vec<CtorSymbolArgs>,
new_symbol_scope_parent_def: Vec<SymbolScopeParentArgs>,
new_decls_symbol_scope_def: Vec<DeclsSymbolScopeArgs>,
new_args_symbol_scope_def: Vec<ArgsSymbolScopeArgs>,
new_ctors_symbol_scope_def: Vec<CtorsSymbolScopeArgs>,
new_model_member_symbol_scope_def: Vec<ModelMemberSymbolScopeArgs>,
new_symbol_scope_name_def: Vec<SymbolScopeNameArgs>,
new_scope_symbols_def: Vec<ScopeSymbolsArgs>,
new_semantic_el_def: Vec<SemanticElArgs>,
new_zero_def: Vec<ZeroArgs>,
new_succ_def: Vec<SuccArgs>,
new_type_list_len_def: Vec<TypeListLenArgs>,
new_term_list_len_def: Vec<TermListLenArgs>,
new_before_rule_structure_def: Vec<BeforeRuleStructureArgs>,
new_ambient_model_el_structure_def: Vec<AmbientModelElStructureArgs>,
new_ambient_model_el_morphism_def: Vec<AmbientModelElMorphismArgs>,
new_if_atom_morphism_def: Vec<IfAtomMorphismArgs>,
new_then_atom_morphism_def: Vec<ThenAtomMorphismArgs>,
new_branch_stmt_morphism_def: Vec<BranchStmtMorphismArgs>,
new_match_stmt_morphism_def: Vec<MatchStmtMorphismArgs>,
new_semantic_name_def: Vec<SemanticNameArgs>,
new_wildcard_name_def: Vec<WildcardNameArgs>,
new_rel_app_parent_model_el_def: Vec<RelAppParentModelElArgs>,
new_match_case_pattern_ctor_def: Vec<MatchCasePatternCtorArgs>,
new_cases_determined_enum_def: Vec<CasesDeterminedEnumArgs>,

}
/// A model of the `Eqlog` theory.
#[derive(Debug, Clone)]
pub struct Eqlog {
ident_equalities: Unification<Ident>,
ident_old: BTreeSet<Ident>,
ident_new: BTreeSet<Ident>,
ident_weights: Vec<usize>,
ident_uprooted: Vec<Ident>,

virt_ident_equalities: Unification<VirtIdent>,
virt_ident_old: BTreeSet<VirtIdent>,
virt_ident_new: BTreeSet<VirtIdent>,
virt_ident_weights: Vec<usize>,
virt_ident_uprooted: Vec<VirtIdent>,

type_decl_node_equalities: Unification<TypeDeclNode>,
type_decl_node_old: BTreeSet<TypeDeclNode>,
type_decl_node_new: BTreeSet<TypeDeclNode>,
type_decl_node_weights: Vec<usize>,
type_decl_node_uprooted: Vec<TypeDeclNode>,

arg_decl_node_equalities: Unification<ArgDeclNode>,
arg_decl_node_old: BTreeSet<ArgDeclNode>,
arg_decl_node_new: BTreeSet<ArgDeclNode>,
arg_decl_node_weights: Vec<usize>,
arg_decl_node_uprooted: Vec<ArgDeclNode>,

type_expr_node_equalities: Unification<TypeExprNode>,
type_expr_node_old: BTreeSet<TypeExprNode>,
type_expr_node_new: BTreeSet<TypeExprNode>,
type_expr_node_weights: Vec<usize>,
type_expr_node_uprooted: Vec<TypeExprNode>,

arg_decl_list_node_equalities: Unification<ArgDeclListNode>,
arg_decl_list_node_old: BTreeSet<ArgDeclListNode>,
arg_decl_list_node_new: BTreeSet<ArgDeclListNode>,
arg_decl_list_node_weights: Vec<usize>,
arg_decl_list_node_uprooted: Vec<ArgDeclListNode>,

pred_decl_node_equalities: Unification<PredDeclNode>,
pred_decl_node_old: BTreeSet<PredDeclNode>,
pred_decl_node_new: BTreeSet<PredDeclNode>,
pred_decl_node_weights: Vec<usize>,
pred_decl_node_uprooted: Vec<PredDeclNode>,

func_decl_node_equalities: Unification<FuncDeclNode>,
func_decl_node_old: BTreeSet<FuncDeclNode>,
func_decl_node_new: BTreeSet<FuncDeclNode>,
func_decl_node_weights: Vec<usize>,
func_decl_node_uprooted: Vec<FuncDeclNode>,

ctor_decl_node_equalities: Unification<CtorDeclNode>,
ctor_decl_node_old: BTreeSet<CtorDeclNode>,
ctor_decl_node_new: BTreeSet<CtorDeclNode>,
ctor_decl_node_weights: Vec<usize>,
ctor_decl_node_uprooted: Vec<CtorDeclNode>,

ctor_decl_list_node_equalities: Unification<CtorDeclListNode>,
ctor_decl_list_node_old: BTreeSet<CtorDeclListNode>,
ctor_decl_list_node_new: BTreeSet<CtorDeclListNode>,
ctor_decl_list_node_weights: Vec<usize>,
ctor_decl_list_node_uprooted: Vec<CtorDeclListNode>,

enum_decl_node_equalities: Unification<EnumDeclNode>,
enum_decl_node_old: BTreeSet<EnumDeclNode>,
enum_decl_node_new: BTreeSet<EnumDeclNode>,
enum_decl_node_weights: Vec<usize>,
enum_decl_node_uprooted: Vec<EnumDeclNode>,

term_node_equalities: Unification<TermNode>,
term_node_old: BTreeSet<TermNode>,
term_node_new: BTreeSet<TermNode>,
term_node_weights: Vec<usize>,
term_node_uprooted: Vec<TermNode>,

term_list_node_equalities: Unification<TermListNode>,
term_list_node_old: BTreeSet<TermListNode>,
term_list_node_new: BTreeSet<TermListNode>,
term_list_node_weights: Vec<usize>,
term_list_node_uprooted: Vec<TermListNode>,

opt_term_node_equalities: Unification<OptTermNode>,
opt_term_node_old: BTreeSet<OptTermNode>,
opt_term_node_new: BTreeSet<OptTermNode>,
opt_term_node_weights: Vec<usize>,
opt_term_node_uprooted: Vec<OptTermNode>,

match_case_node_equalities: Unification<MatchCaseNode>,
match_case_node_old: BTreeSet<MatchCaseNode>,
match_case_node_new: BTreeSet<MatchCaseNode>,
match_case_node_weights: Vec<usize>,
match_case_node_uprooted: Vec<MatchCaseNode>,

stmt_list_node_equalities: Unification<StmtListNode>,
stmt_list_node_old: BTreeSet<StmtListNode>,
stmt_list_node_new: BTreeSet<StmtListNode>,
stmt_list_node_weights: Vec<usize>,
stmt_list_node_uprooted: Vec<StmtListNode>,

match_case_list_node_equalities: Unification<MatchCaseListNode>,
match_case_list_node_old: BTreeSet<MatchCaseListNode>,
match_case_list_node_new: BTreeSet<MatchCaseListNode>,
match_case_list_node_weights: Vec<usize>,
match_case_list_node_uprooted: Vec<MatchCaseListNode>,

if_atom_node_equalities: Unification<IfAtomNode>,
if_atom_node_old: BTreeSet<IfAtomNode>,
if_atom_node_new: BTreeSet<IfAtomNode>,
if_atom_node_weights: Vec<usize>,
if_atom_node_uprooted: Vec<IfAtomNode>,

then_atom_node_equalities: Unification<ThenAtomNode>,
then_atom_node_old: BTreeSet<ThenAtomNode>,
then_atom_node_new: BTreeSet<ThenAtomNode>,
then_atom_node_weights: Vec<usize>,
then_atom_node_uprooted: Vec<ThenAtomNode>,

stmt_node_equalities: Unification<StmtNode>,
stmt_node_old: BTreeSet<StmtNode>,
stmt_node_new: BTreeSet<StmtNode>,
stmt_node_weights: Vec<usize>,
stmt_node_uprooted: Vec<StmtNode>,

stmt_block_list_node_equalities: Unification<StmtBlockListNode>,
stmt_block_list_node_old: BTreeSet<StmtBlockListNode>,
stmt_block_list_node_new: BTreeSet<StmtBlockListNode>,
stmt_block_list_node_weights: Vec<usize>,
stmt_block_list_node_uprooted: Vec<StmtBlockListNode>,

rule_decl_node_equalities: Unification<RuleDeclNode>,
rule_decl_node_old: BTreeSet<RuleDeclNode>,
rule_decl_node_new: BTreeSet<RuleDeclNode>,
rule_decl_node_weights: Vec<usize>,
rule_decl_node_uprooted: Vec<RuleDeclNode>,

model_decl_node_equalities: Unification<ModelDeclNode>,
model_decl_node_old: BTreeSet<ModelDeclNode>,
model_decl_node_new: BTreeSet<ModelDeclNode>,
model_decl_node_weights: Vec<usize>,
model_decl_node_uprooted: Vec<ModelDeclNode>,

decl_list_node_equalities: Unification<DeclListNode>,
decl_list_node_old: BTreeSet<DeclListNode>,
decl_list_node_new: BTreeSet<DeclListNode>,
decl_list_node_weights: Vec<usize>,
decl_list_node_uprooted: Vec<DeclListNode>,

decl_node_equalities: Unification<DeclNode>,
decl_node_old: BTreeSet<DeclNode>,
decl_node_new: BTreeSet<DeclNode>,
decl_node_weights: Vec<usize>,
decl_node_uprooted: Vec<DeclNode>,

module_node_equalities: Unification<ModuleNode>,
module_node_old: BTreeSet<ModuleNode>,
module_node_new: BTreeSet<ModuleNode>,
module_node_weights: Vec<usize>,
module_node_uprooted: Vec<ModuleNode>,

loc_equalities: Unification<Loc>,
loc_old: BTreeSet<Loc>,
loc_new: BTreeSet<Loc>,
loc_weights: Vec<usize>,
loc_uprooted: Vec<Loc>,

rule_descendant_node_equalities: Unification<RuleDescendantNode>,
rule_descendant_node_old: BTreeSet<RuleDescendantNode>,
rule_descendant_node_new: BTreeSet<RuleDescendantNode>,
rule_descendant_node_weights: Vec<usize>,
rule_descendant_node_uprooted: Vec<RuleDescendantNode>,

scope_equalities: Unification<Scope>,
scope_old: BTreeSet<Scope>,
scope_new: BTreeSet<Scope>,
scope_weights: Vec<usize>,
scope_uprooted: Vec<Scope>,

type_equalities: Unification<Type>,
type_old: BTreeSet<Type>,
type_new: BTreeSet<Type>,
type_weights: Vec<usize>,
type_uprooted: Vec<Type>,

type_list_equalities: Unification<TypeList>,
type_list_old: BTreeSet<TypeList>,
type_list_new: BTreeSet<TypeList>,
type_list_weights: Vec<usize>,
type_list_uprooted: Vec<TypeList>,

symbol_scope_equalities: Unification<SymbolScope>,
symbol_scope_old: BTreeSet<SymbolScope>,
symbol_scope_new: BTreeSet<SymbolScope>,
symbol_scope_weights: Vec<usize>,
symbol_scope_uprooted: Vec<SymbolScope>,

func_equalities: Unification<Func>,
func_old: BTreeSet<Func>,
func_new: BTreeSet<Func>,
func_weights: Vec<usize>,
func_uprooted: Vec<Func>,

pred_equalities: Unification<Pred>,
pred_old: BTreeSet<Pred>,
pred_new: BTreeSet<Pred>,
pred_weights: Vec<usize>,
pred_uprooted: Vec<Pred>,

rel_equalities: Unification<Rel>,
rel_old: BTreeSet<Rel>,
rel_new: BTreeSet<Rel>,
rel_weights: Vec<usize>,
rel_uprooted: Vec<Rel>,

structure_equalities: Unification<Structure>,
structure_old: BTreeSet<Structure>,
structure_new: BTreeSet<Structure>,
structure_weights: Vec<usize>,
structure_uprooted: Vec<Structure>,

el_equalities: Unification<El>,
el_old: BTreeSet<El>,
el_new: BTreeSet<El>,
el_weights: Vec<usize>,
el_uprooted: Vec<El>,

el_list_equalities: Unification<ElList>,
el_list_old: BTreeSet<ElList>,
el_list_new: BTreeSet<ElList>,
el_list_weights: Vec<usize>,
el_list_uprooted: Vec<ElList>,

el_name_equalities: Unification<ElName>,
el_name_old: BTreeSet<ElName>,
el_name_new: BTreeSet<ElName>,
el_name_weights: Vec<usize>,
el_name_uprooted: Vec<ElName>,

element_type_equalities: Unification<ElementType>,
element_type_old: BTreeSet<ElementType>,
element_type_new: BTreeSet<ElementType>,
element_type_weights: Vec<usize>,
element_type_uprooted: Vec<ElementType>,

element_type_list_equalities: Unification<ElementTypeList>,
element_type_list_old: BTreeSet<ElementTypeList>,
element_type_list_new: BTreeSet<ElementTypeList>,
element_type_list_weights: Vec<usize>,
element_type_list_uprooted: Vec<ElementTypeList>,

morphism_equalities: Unification<Morphism>,
morphism_old: BTreeSet<Morphism>,
morphism_new: BTreeSet<Morphism>,
morphism_weights: Vec<usize>,
morphism_uprooted: Vec<Morphism>,

symbol_kind_equalities: Unification<SymbolKind>,
symbol_kind_old: BTreeSet<SymbolKind>,
symbol_kind_new: BTreeSet<SymbolKind>,
symbol_kind_weights: Vec<usize>,
symbol_kind_uprooted: Vec<SymbolKind>,

nat_equalities: Unification<Nat>,
nat_old: BTreeSet<Nat>,
nat_new: BTreeSet<Nat>,
nat_weights: Vec<usize>,
nat_uprooted: Vec<Nat>,

  absurd: AbsurdTable,  type_decl: TypeDeclTable,  arg_decl_node_name: ArgDeclNodeNameTable,  arg_decl_node_type: ArgDeclNodeTypeTable,  nil_arg_decl_list_node: NilArgDeclListNodeTable,  cons_arg_decl_list_node: ConsArgDeclListNodeTable,  pred_decl: PredDeclTable,  func_decl: FuncDeclTable,  ctor_decl: CtorDeclTable,  nil_ctor_decl_list_node: NilCtorDeclListNodeTable,  cons_ctor_decl_list_node: ConsCtorDeclListNodeTable,  enum_decl: EnumDeclTable,  nil_term_list_node: NilTermListNodeTable,  cons_term_list_node: ConsTermListNodeTable,  ambient_type_expr: AmbientTypeExprTable,  member_type_expr: MemberTypeExprTable,  mor_type_expr: MorTypeExprTable,  none_term_node: NoneTermNodeTable,  some_term_node: SomeTermNodeTable,  var_term_node: VarTermNodeTable,  wildcard_term_node: WildcardTermNodeTable,  app_term_node: AppTermNodeTable,  match_case: MatchCaseTable,  nil_match_case_list_node: NilMatchCaseListNodeTable,  cons_match_case_list_node: ConsMatchCaseListNodeTable,  equal_if_atom_node: EqualIfAtomNodeTable,  defined_if_atom_node: DefinedIfAtomNodeTable,  pred_if_atom_node: PredIfAtomNodeTable,  var_if_atom_node: VarIfAtomNodeTable,  equal_then_atom_node: EqualThenAtomNodeTable,  defined_then_atom_node: DefinedThenAtomNodeTable,  pred_then_atom_node: PredThenAtomNodeTable,  if_stmt_node: IfStmtNodeTable,  then_stmt_node: ThenStmtNodeTable,  branch_stmt_node: BranchStmtNodeTable,  match_stmt_node: MatchStmtNodeTable,  nil_stmt_list_node: NilStmtListNodeTable,  cons_stmt_list_node: ConsStmtListNodeTable,  nil_stmt_block_list_node: NilStmtBlockListNodeTable,  cons_stmt_block_list_node: ConsStmtBlockListNodeTable,  rule_decl: RuleDeclTable,  model_decl: ModelDeclTable,  decl_node_type: DeclNodeTypeTable,  decl_node_pred: DeclNodePredTable,  decl_node_func: DeclNodeFuncTable,  decl_node_rule: DeclNodeRuleTable,  decl_node_enum: DeclNodeEnumTable,  decl_node_model: DeclNodeModelTable,  nil_decl_list_node: NilDeclListNodeTable,  cons_decl_list_node: ConsDeclListNodeTable,  decls_module_node: DeclsModuleNodeTable,  var_in_scope: VarInScopeTable,  scope_extension: ScopeExtensionTable,  scope_single_child: ScopeSingleChildTable,  scope_extension_siblings: ScopeExtensionSiblingsTable,  is_normal_type: IsNormalTypeTable,  is_enum_type: IsEnumTypeTable,  is_model_type: IsModelTypeTable,  is_mor_type: IsMorTypeTable,  illegal_member_type_expr_in_signature: IllegalMemberTypeExprInSignatureTable,  is_total_func: IsTotalFuncTable,  rel_app: RelAppTable,  el_type: ElTypeTable,  el_types: ElTypesTable,  constrained_el: ConstrainedElTable,  constrained_els: ConstrainedElsTable,  in_ker: InKerTable,  el_in_img: ElInImgTable,  rel_tuple_in_img: RelTupleInImgTable,  symbol_scope_extension: SymbolScopeExtensionTable,  symbol_scope_ancestor: SymbolScopeAncestorTable,  element_member_symbol_scope: ElementMemberSymbolScopeTable,  defined_symbol: DefinedSymbolTable,  accessible_symbol: AccessibleSymbolTable,  should_be_symbol: ShouldBeSymbolTable,  should_be_symbol_2: ShouldBeSymbol2Table,  should_be_symbol_3: ShouldBeSymbol3Table,  pred_arg_num_should_match: PredArgNumShouldMatchTable,  func_arg_num_should_match: FuncArgNumShouldMatchTable,  cfg_edge: CfgEdgeTable,  cfg_edge_stmts_stmt: CfgEdgeStmtsStmtTable,  cfg_edge_stmt_stmts: CfgEdgeStmtStmtsTable,  cfg_edge_fork: CfgEdgeForkTable,  cfg_edge_join: CfgEdgeJoinTable,  before_stmt_structure: BeforeStmtStructureTable,  stmt_morphism: StmtMorphismTable,  if_morphism: IfMorphismTable,  surj_then_morphism: SurjThenMorphismTable,  non_surj_then_morphism: NonSurjThenMorphismTable,  noop_morphism: NoopMorphismTable,  stmt_structure: StmtStructureTable,  if_atom_structure: IfAtomStructureTable,  then_atom_structure: ThenAtomStructureTable,  term_structure: TermStructureTable,  terms_structure: TermsStructureTable,  opt_term_structure: OptTermStructureTable,  type_expr_structure: TypeExprStructureTable,  term_should_be_epic_ok: TermShouldBeEpicOkTable,  terms_should_be_epic_ok: TermsShouldBeEpicOkTable,  el_should_be_surjective_ok: ElShouldBeSurjectiveOkTable,  el_is_surjective_ok: ElIsSurjectiveOkTable,  should_be_obtained_by_ctor: ShouldBeObtainedByCtorTable,  is_given_by_ctor: IsGivenByCtorTable,  function_can_be_made_defined: FunctionCanBeMadeDefinedTable,  case_pattern_is_variable: CasePatternIsVariableTable,  case_pattern_is_wildcard: CasePatternIsWildcardTable,  is_pattern_ctor_arg: IsPatternCtorArgTable,  are_pattern_ctor_args: ArePatternCtorArgsTable,  pattern_ctor_arg_is_app: PatternCtorArgIsAppTable,  pattern_ctor_arg_var_is_not_fresh: PatternCtorArgVarIsNotFreshTable,  cases_contain_ctor: CasesContainCtorTable,  match_stmt_contains_ctor_of_enum: MatchStmtContainsCtorOfEnumTable,  match_stmt_should_contain_ctor: MatchStmtShouldContainCtorTable,  match_stmt_contains_ctor: MatchStmtContainsCtorTable,  real_virt_ident: RealVirtIdentTable,  virt_real_ident: VirtRealIdentTable,  var: VarTable,  rule_name: RuleNameTable,  module_name: ModuleNameTable,  type_decl_node_loc: TypeDeclNodeLocTable,  arg_decl_node_loc: ArgDeclNodeLocTable,  arg_decl_list_node_loc: ArgDeclListNodeLocTable,  pred_decl_node_loc: PredDeclNodeLocTable,  func_decl_node_loc: FuncDeclNodeLocTable,  ctor_decl_node_loc: CtorDeclNodeLocTable,  enum_decl_node_loc: EnumDeclNodeLocTable,  model_decl_node_loc: ModelDeclNodeLocTable,  term_node_loc: TermNodeLocTable,  term_list_node_loc: TermListNodeLocTable,  match_case_node_loc: MatchCaseNodeLocTable,  opt_term_node_loc: OptTermNodeLocTable,  if_atom_node_loc: IfAtomNodeLocTable,  then_atom_node_loc: ThenAtomNodeLocTable,  stmt_node_loc: StmtNodeLocTable,  stmt_list_node_loc: StmtListNodeLocTable,  rule_decl_node_loc: RuleDeclNodeLocTable,  decl_node_loc: DeclNodeLocTable,  decl_list_node_loc: DeclListNodeLocTable,  module_node_loc: ModuleNodeLocTable,  type_expr_node_loc: TypeExprNodeLocTable,  rule_descendant_rule: RuleDescendantRuleTable,  rule_descendant_term: RuleDescendantTermTable,  rule_descendant_term_list: RuleDescendantTermListTable,  rule_descendant_opt_term: RuleDescendantOptTermTable,  rule_descendant_if_atom: RuleDescendantIfAtomTable,  rule_descendant_then_atom: RuleDescendantThenAtomTable,  rule_descendant_match_case: RuleDescendantMatchCaseTable,  rule_descendant_match_case_list: RuleDescendantMatchCaseListTable,  rule_descendant_stmt: RuleDescendantStmtTable,  rule_descendant_stmt_list: RuleDescendantStmtListTable,  rule_descendant_stmt_block_list: RuleDescendantStmtBlockListTable,  rule_descendant_type_expr: RuleDescendantTypeExprTable,  entry_scope: EntryScopeTable,  exit_scope: ExitScopeTable,  ctor_enum: CtorEnumTable,  ctors_enum: CtorsEnumTable,  cases_discriminee: CasesDiscrimineeTable,  case_discriminee: CaseDiscrimineeTable,  desugared_case_equality_atom: DesugaredCaseEqualityAtomTable,  desugared_case_equality_stmt: DesugaredCaseEqualityStmtTable,  desugared_case_block: DesugaredCaseBlockTable,  desugared_case_block_list: DesugaredCaseBlockListTable,  nil_type_list: NilTypeListTable,  cons_type_list: ConsTypeListTable,  snoc_type_list: SnocTypeListTable,  semantic_type: SemanticTypeTable,  decl_symbol_scope: DeclSymbolScopeTable,  mor_type: MorTypeTable,  mor_type_dom_func: MorTypeDomFuncTable,  mor_type_cod_func: MorTypeCodFuncTable,  type_definition_symbol_scope: TypeDefinitionSymbolScopeTable,  func_rel: FuncRelTable,  rel_definition_symbol_scope: RelDefinitionSymbolScopeTable,  domain: DomainTable,  codomain: CodomainTable,  type_name: TypeNameTable,  virtual_symbol_scope: VirtualSymbolScopeTable,  parent_model_func: ParentModelFuncTable,  symbol_scope_model: SymbolScopeModelTable,  flat_domain: FlatDomainTable,  semantic_signature_type_expr: SemanticSignatureTypeExprTable,  type_symbol: TypeSymbolTable,  enum_symbol: EnumSymbolTable,  model_symbol: ModelSymbolTable,  semantic_arg_type: SemanticArgTypeTable,  arg_symbol_scope: ArgSymbolScopeTable,  semantic_arg_types: SemanticArgTypesTable,  semantic_pred: SemanticPredTable,  pred_arity: PredArityTable,  semantic_func: SemanticFuncTable,  ctor_symbol_scope: CtorSymbolScopeTable,  pred_rel: PredRelTable,  rel_name: RelNameTable,  arity: ArityTable,  dom: DomTable,  cod: CodTable,  flat_arity: FlatArityTable,  module_symbol_scope: ModuleSymbolScopeTable,  nil_el_list: NilElListTable,  cons_el_list: ConsElListTable,  snoc_el_list: SnocElListTable,  el_structure: ElStructureTable,  els_structure: ElsStructureTable,  ambient_type: AmbientTypeTable,  instantiated_type: InstantiatedTypeTable,  underlying_type: UnderlyingTypeTable,  nil_element_type_list: NilElementTypeListTable,  cons_element_type_list: ConsElementTypeListTable,  snoc_element_type_list: SnocElementTypeListTable,  ambient_el_type_list: AmbientElTypeListTable,  func_app: FuncAppTable,  map_el: MapElTable,  map_els: MapElsTable,  ambient_model_el: AmbientModelElTable,  pred_symbol: PredSymbolTable,  func_symbol: FuncSymbolTable,  rule_symbol: RuleSymbolTable,  ctor_symbol: CtorSymbolTable,  symbol_scope_parent: SymbolScopeParentTable,  decls_symbol_scope: DeclsSymbolScopeTable,  args_symbol_scope: ArgsSymbolScopeTable,  ctors_symbol_scope: CtorsSymbolScopeTable,  model_member_symbol_scope: ModelMemberSymbolScopeTable,  symbol_scope_name: SymbolScopeNameTable,  scope_symbols: ScopeSymbolsTable,  semantic_el: SemanticElTable,  zero: ZeroTable,  succ: SuccTable,  type_list_len: TypeListLenTable,  term_list_len: TermListLenTable,  before_rule_structure: BeforeRuleStructureTable,  ambient_model_el_structure: AmbientModelElStructureTable,  ambient_model_el_morphism: AmbientModelElMorphismTable,  if_atom_morphism: IfAtomMorphismTable,  then_atom_morphism: ThenAtomMorphismTable,  branch_stmt_morphism: BranchStmtMorphismTable,  match_stmt_morphism: MatchStmtMorphismTable,  semantic_name: SemanticNameTable,  semantic_els: SemanticElsTable,  wildcard_name: WildcardNameTable,  rel_app_parent_model_el: RelAppParentModelElTable,  match_case_pattern_ctor: MatchCasePatternCtorTable,  cases_determined_enum: CasesDeterminedEnumTable,empty_join_is_dirty: bool,
}
type Model = Eqlog;impl ModelDelta {
fn new() -> ModelDelta {
    ModelDelta{
    new_absurd: Vec::new(),
    new_type_decl: Vec::new(),
    new_arg_decl_node_name: Vec::new(),
    new_arg_decl_node_type: Vec::new(),
    new_nil_arg_decl_list_node: Vec::new(),
    new_cons_arg_decl_list_node: Vec::new(),
    new_pred_decl: Vec::new(),
    new_func_decl: Vec::new(),
    new_ctor_decl: Vec::new(),
    new_nil_ctor_decl_list_node: Vec::new(),
    new_cons_ctor_decl_list_node: Vec::new(),
    new_enum_decl: Vec::new(),
    new_nil_term_list_node: Vec::new(),
    new_cons_term_list_node: Vec::new(),
    new_ambient_type_expr: Vec::new(),
    new_member_type_expr: Vec::new(),
    new_mor_type_expr: Vec::new(),
    new_none_term_node: Vec::new(),
    new_some_term_node: Vec::new(),
    new_var_term_node: Vec::new(),
    new_wildcard_term_node: Vec::new(),
    new_app_term_node: Vec::new(),
    new_match_case: Vec::new(),
    new_nil_match_case_list_node: Vec::new(),
    new_cons_match_case_list_node: Vec::new(),
    new_equal_if_atom_node: Vec::new(),
    new_defined_if_atom_node: Vec::new(),
    new_pred_if_atom_node: Vec::new(),
    new_var_if_atom_node: Vec::new(),
    new_equal_then_atom_node: Vec::new(),
    new_defined_then_atom_node: Vec::new(),
    new_pred_then_atom_node: Vec::new(),
    new_if_stmt_node: Vec::new(),
    new_then_stmt_node: Vec::new(),
    new_branch_stmt_node: Vec::new(),
    new_match_stmt_node: Vec::new(),
    new_nil_stmt_list_node: Vec::new(),
    new_cons_stmt_list_node: Vec::new(),
    new_nil_stmt_block_list_node: Vec::new(),
    new_cons_stmt_block_list_node: Vec::new(),
    new_rule_decl: Vec::new(),
    new_model_decl: Vec::new(),
    new_decl_node_type: Vec::new(),
    new_decl_node_pred: Vec::new(),
    new_decl_node_func: Vec::new(),
    new_decl_node_rule: Vec::new(),
    new_decl_node_enum: Vec::new(),
    new_decl_node_model: Vec::new(),
    new_nil_decl_list_node: Vec::new(),
    new_cons_decl_list_node: Vec::new(),
    new_decls_module_node: Vec::new(),
    new_var_in_scope: Vec::new(),
    new_scope_extension: Vec::new(),
    new_scope_single_child: Vec::new(),
    new_scope_extension_siblings: Vec::new(),
    new_is_normal_type: Vec::new(),
    new_is_enum_type: Vec::new(),
    new_is_model_type: Vec::new(),
    new_is_mor_type: Vec::new(),
    new_illegal_member_type_expr_in_signature: Vec::new(),
    new_is_total_func: Vec::new(),
    new_rel_app: Vec::new(),
    new_el_type: Vec::new(),
    new_el_types: Vec::new(),
    new_constrained_el: Vec::new(),
    new_constrained_els: Vec::new(),
    new_in_ker: Vec::new(),
    new_el_in_img: Vec::new(),
    new_rel_tuple_in_img: Vec::new(),
    new_symbol_scope_extension: Vec::new(),
    new_symbol_scope_ancestor: Vec::new(),
    new_element_member_symbol_scope: Vec::new(),
    new_defined_symbol: Vec::new(),
    new_accessible_symbol: Vec::new(),
    new_should_be_symbol: Vec::new(),
    new_should_be_symbol_2: Vec::new(),
    new_should_be_symbol_3: Vec::new(),
    new_pred_arg_num_should_match: Vec::new(),
    new_func_arg_num_should_match: Vec::new(),
    new_cfg_edge: Vec::new(),
    new_cfg_edge_stmts_stmt: Vec::new(),
    new_cfg_edge_stmt_stmts: Vec::new(),
    new_cfg_edge_fork: Vec::new(),
    new_cfg_edge_join: Vec::new(),
    new_before_stmt_structure: Vec::new(),
    new_stmt_morphism: Vec::new(),
    new_if_morphism: Vec::new(),
    new_surj_then_morphism: Vec::new(),
    new_non_surj_then_morphism: Vec::new(),
    new_noop_morphism: Vec::new(),
    new_stmt_structure: Vec::new(),
    new_if_atom_structure: Vec::new(),
    new_then_atom_structure: Vec::new(),
    new_term_structure: Vec::new(),
    new_terms_structure: Vec::new(),
    new_opt_term_structure: Vec::new(),
    new_type_expr_structure: Vec::new(),
    new_term_should_be_epic_ok: Vec::new(),
    new_terms_should_be_epic_ok: Vec::new(),
    new_el_should_be_surjective_ok: Vec::new(),
    new_el_is_surjective_ok: Vec::new(),
    new_should_be_obtained_by_ctor: Vec::new(),
    new_is_given_by_ctor: Vec::new(),
    new_function_can_be_made_defined: Vec::new(),
    new_case_pattern_is_variable: Vec::new(),
    new_case_pattern_is_wildcard: Vec::new(),
    new_is_pattern_ctor_arg: Vec::new(),
    new_are_pattern_ctor_args: Vec::new(),
    new_pattern_ctor_arg_is_app: Vec::new(),
    new_pattern_ctor_arg_var_is_not_fresh: Vec::new(),
    new_cases_contain_ctor: Vec::new(),
    new_match_stmt_contains_ctor_of_enum: Vec::new(),
    new_match_stmt_should_contain_ctor: Vec::new(),
    new_match_stmt_contains_ctor: Vec::new(),
    new_real_virt_ident: Vec::new(),
    new_virt_real_ident: Vec::new(),
    new_var: Vec::new(),
    new_rule_name: Vec::new(),
    new_module_name: Vec::new(),
    new_type_decl_node_loc: Vec::new(),
    new_arg_decl_node_loc: Vec::new(),
    new_arg_decl_list_node_loc: Vec::new(),
    new_pred_decl_node_loc: Vec::new(),
    new_func_decl_node_loc: Vec::new(),
    new_ctor_decl_node_loc: Vec::new(),
    new_enum_decl_node_loc: Vec::new(),
    new_model_decl_node_loc: Vec::new(),
    new_term_node_loc: Vec::new(),
    new_term_list_node_loc: Vec::new(),
    new_match_case_node_loc: Vec::new(),
    new_opt_term_node_loc: Vec::new(),
    new_if_atom_node_loc: Vec::new(),
    new_then_atom_node_loc: Vec::new(),
    new_stmt_node_loc: Vec::new(),
    new_stmt_list_node_loc: Vec::new(),
    new_rule_decl_node_loc: Vec::new(),
    new_decl_node_loc: Vec::new(),
    new_decl_list_node_loc: Vec::new(),
    new_module_node_loc: Vec::new(),
    new_type_expr_node_loc: Vec::new(),
    new_rule_descendant_rule: Vec::new(),
    new_rule_descendant_term: Vec::new(),
    new_rule_descendant_term_list: Vec::new(),
    new_rule_descendant_opt_term: Vec::new(),
    new_rule_descendant_if_atom: Vec::new(),
    new_rule_descendant_then_atom: Vec::new(),
    new_rule_descendant_match_case: Vec::new(),
    new_rule_descendant_match_case_list: Vec::new(),
    new_rule_descendant_stmt: Vec::new(),
    new_rule_descendant_stmt_list: Vec::new(),
    new_rule_descendant_stmt_block_list: Vec::new(),
    new_rule_descendant_type_expr: Vec::new(),
    new_entry_scope: Vec::new(),
    new_exit_scope: Vec::new(),
    new_ctor_enum: Vec::new(),
    new_ctors_enum: Vec::new(),
    new_cases_discriminee: Vec::new(),
    new_case_discriminee: Vec::new(),
    new_desugared_case_equality_atom: Vec::new(),
    new_desugared_case_equality_stmt: Vec::new(),
    new_desugared_case_block: Vec::new(),
    new_desugared_case_block_list: Vec::new(),
    new_nil_type_list: Vec::new(),
    new_cons_type_list: Vec::new(),
    new_snoc_type_list: Vec::new(),
    new_semantic_type: Vec::new(),
    new_decl_symbol_scope: Vec::new(),
    new_mor_type: Vec::new(),
    new_mor_type_dom_func: Vec::new(),
    new_mor_type_cod_func: Vec::new(),
    new_type_definition_symbol_scope: Vec::new(),
    new_func_rel: Vec::new(),
    new_rel_definition_symbol_scope: Vec::new(),
    new_domain: Vec::new(),
    new_codomain: Vec::new(),
    new_type_name: Vec::new(),
    new_virtual_symbol_scope: Vec::new(),
    new_parent_model_func: Vec::new(),
    new_symbol_scope_model: Vec::new(),
    new_flat_domain: Vec::new(),
    new_semantic_signature_type_expr: Vec::new(),
    new_type_symbol: Vec::new(),
    new_enum_symbol: Vec::new(),
    new_model_symbol: Vec::new(),
    new_semantic_arg_type: Vec::new(),
    new_arg_symbol_scope: Vec::new(),
    new_semantic_arg_types: Vec::new(),
    new_semantic_pred: Vec::new(),
    new_pred_arity: Vec::new(),
    new_semantic_func: Vec::new(),
    new_ctor_symbol_scope: Vec::new(),
    new_pred_rel: Vec::new(),
    new_rel_name: Vec::new(),
    new_arity: Vec::new(),
    new_dom: Vec::new(),
    new_cod: Vec::new(),
    new_flat_arity: Vec::new(),
    new_module_symbol_scope: Vec::new(),
    new_nil_el_list: Vec::new(),
    new_cons_el_list: Vec::new(),
    new_snoc_el_list: Vec::new(),
    new_el_structure: Vec::new(),
    new_els_structure: Vec::new(),
    new_ambient_type: Vec::new(),
    new_instantiated_type: Vec::new(),
    new_underlying_type: Vec::new(),
    new_nil_element_type_list: Vec::new(),
    new_cons_element_type_list: Vec::new(),
    new_snoc_element_type_list: Vec::new(),
    new_ambient_el_type_list: Vec::new(),
    new_func_app: Vec::new(),
    new_map_el: Vec::new(),
    new_map_els: Vec::new(),
    new_ambient_model_el: Vec::new(),
    new_pred_symbol: Vec::new(),
    new_func_symbol: Vec::new(),
    new_rule_symbol: Vec::new(),
    new_ctor_symbol: Vec::new(),
    new_symbol_scope_parent: Vec::new(),
    new_decls_symbol_scope: Vec::new(),
    new_args_symbol_scope: Vec::new(),
    new_ctors_symbol_scope: Vec::new(),
    new_model_member_symbol_scope: Vec::new(),
    new_symbol_scope_name: Vec::new(),
    new_scope_symbols: Vec::new(),
    new_semantic_el: Vec::new(),
    new_zero: Vec::new(),
    new_succ: Vec::new(),
    new_type_list_len: Vec::new(),
    new_term_list_len: Vec::new(),
    new_before_rule_structure: Vec::new(),
    new_ambient_model_el_structure: Vec::new(),
    new_ambient_model_el_morphism: Vec::new(),
    new_if_atom_morphism: Vec::new(),
    new_then_atom_morphism: Vec::new(),
    new_branch_stmt_morphism: Vec::new(),
    new_match_stmt_morphism: Vec::new(),
    new_semantic_name: Vec::new(),
    new_semantic_els: Vec::new(),
    new_wildcard_name: Vec::new(),
    new_rel_app_parent_model_el: Vec::new(),
    new_match_case_pattern_ctor: Vec::new(),
    new_cases_determined_enum: Vec::new(),
    new_ident_equalities: Vec::new(),
    new_virt_ident_equalities: Vec::new(),
    new_type_decl_node_equalities: Vec::new(),
    new_arg_decl_node_equalities: Vec::new(),
    new_type_expr_node_equalities: Vec::new(),
    new_arg_decl_list_node_equalities: Vec::new(),
    new_pred_decl_node_equalities: Vec::new(),
    new_func_decl_node_equalities: Vec::new(),
    new_ctor_decl_node_equalities: Vec::new(),
    new_ctor_decl_list_node_equalities: Vec::new(),
    new_enum_decl_node_equalities: Vec::new(),
    new_term_node_equalities: Vec::new(),
    new_term_list_node_equalities: Vec::new(),
    new_opt_term_node_equalities: Vec::new(),
    new_match_case_node_equalities: Vec::new(),
    new_stmt_list_node_equalities: Vec::new(),
    new_match_case_list_node_equalities: Vec::new(),
    new_if_atom_node_equalities: Vec::new(),
    new_then_atom_node_equalities: Vec::new(),
    new_stmt_node_equalities: Vec::new(),
    new_stmt_block_list_node_equalities: Vec::new(),
    new_rule_decl_node_equalities: Vec::new(),
    new_model_decl_node_equalities: Vec::new(),
    new_decl_list_node_equalities: Vec::new(),
    new_decl_node_equalities: Vec::new(),
    new_module_node_equalities: Vec::new(),
    new_loc_equalities: Vec::new(),
    new_rule_descendant_node_equalities: Vec::new(),
    new_scope_equalities: Vec::new(),
    new_type_equalities: Vec::new(),
    new_type_list_equalities: Vec::new(),
    new_symbol_scope_equalities: Vec::new(),
    new_func_equalities: Vec::new(),
    new_pred_equalities: Vec::new(),
    new_rel_equalities: Vec::new(),
    new_structure_equalities: Vec::new(),
    new_el_equalities: Vec::new(),
    new_el_list_equalities: Vec::new(),
    new_el_name_equalities: Vec::new(),
    new_element_type_equalities: Vec::new(),
    new_element_type_list_equalities: Vec::new(),
    new_morphism_equalities: Vec::new(),
    new_symbol_kind_equalities: Vec::new(),
    new_nat_equalities: Vec::new(),
new_real_virt_ident_def: Vec::new(),

new_virt_real_ident_def: Vec::new(),

new_var_def: Vec::new(),

new_rule_name_def: Vec::new(),

new_module_name_def: Vec::new(),

new_type_decl_node_loc_def: Vec::new(),

new_arg_decl_node_loc_def: Vec::new(),

new_arg_decl_list_node_loc_def: Vec::new(),

new_pred_decl_node_loc_def: Vec::new(),

new_func_decl_node_loc_def: Vec::new(),

new_ctor_decl_node_loc_def: Vec::new(),

new_enum_decl_node_loc_def: Vec::new(),

new_model_decl_node_loc_def: Vec::new(),

new_term_node_loc_def: Vec::new(),

new_term_list_node_loc_def: Vec::new(),

new_match_case_node_loc_def: Vec::new(),

new_opt_term_node_loc_def: Vec::new(),

new_if_atom_node_loc_def: Vec::new(),

new_then_atom_node_loc_def: Vec::new(),

new_stmt_node_loc_def: Vec::new(),

new_stmt_list_node_loc_def: Vec::new(),

new_rule_decl_node_loc_def: Vec::new(),

new_decl_node_loc_def: Vec::new(),

new_decl_list_node_loc_def: Vec::new(),

new_module_node_loc_def: Vec::new(),

new_type_expr_node_loc_def: Vec::new(),

new_rule_descendant_rule_def: Vec::new(),

new_rule_descendant_term_def: Vec::new(),

new_rule_descendant_term_list_def: Vec::new(),

new_rule_descendant_opt_term_def: Vec::new(),

new_rule_descendant_if_atom_def: Vec::new(),

new_rule_descendant_then_atom_def: Vec::new(),

new_rule_descendant_match_case_def: Vec::new(),

new_rule_descendant_match_case_list_def: Vec::new(),

new_rule_descendant_stmt_def: Vec::new(),

new_rule_descendant_stmt_list_def: Vec::new(),

new_rule_descendant_stmt_block_list_def: Vec::new(),

new_rule_descendant_type_expr_def: Vec::new(),

new_entry_scope_def: Vec::new(),

new_exit_scope_def: Vec::new(),

new_ctor_enum_def: Vec::new(),

new_ctors_enum_def: Vec::new(),

new_cases_discriminee_def: Vec::new(),

new_case_discriminee_def: Vec::new(),

new_desugared_case_equality_atom_def: Vec::new(),

new_desugared_case_equality_stmt_def: Vec::new(),

new_desugared_case_block_def: Vec::new(),

new_desugared_case_block_list_def: Vec::new(),

new_nil_type_list_def: Vec::new(),

new_cons_type_list_def: Vec::new(),

new_snoc_type_list_def: Vec::new(),

new_semantic_type_def: Vec::new(),

new_decl_symbol_scope_def: Vec::new(),

new_mor_type_def: Vec::new(),

new_mor_type_dom_func_def: Vec::new(),

new_mor_type_cod_func_def: Vec::new(),

new_type_definition_symbol_scope_def: Vec::new(),

new_func_rel_def: Vec::new(),

new_rel_definition_symbol_scope_def: Vec::new(),

new_codomain_def: Vec::new(),

new_type_name_def: Vec::new(),

new_virtual_symbol_scope_def: Vec::new(),

new_parent_model_func_def: Vec::new(),

new_symbol_scope_model_def: Vec::new(),

new_semantic_signature_type_expr_def: Vec::new(),

new_type_symbol_def: Vec::new(),

new_enum_symbol_def: Vec::new(),

new_model_symbol_def: Vec::new(),

new_semantic_arg_type_def: Vec::new(),

new_arg_symbol_scope_def: Vec::new(),

new_semantic_pred_def: Vec::new(),

new_semantic_func_def: Vec::new(),

new_ctor_symbol_scope_def: Vec::new(),

new_pred_rel_def: Vec::new(),

new_rel_name_def: Vec::new(),

new_dom_def: Vec::new(),

new_cod_def: Vec::new(),

new_module_symbol_scope_def: Vec::new(),

new_nil_el_list_def: Vec::new(),

new_cons_el_list_def: Vec::new(),

new_snoc_el_list_def: Vec::new(),

new_el_structure_def: Vec::new(),

new_els_structure_def: Vec::new(),

new_ambient_type_def: Vec::new(),

new_instantiated_type_def: Vec::new(),

new_underlying_type_def: Vec::new(),

new_nil_element_type_list_def: Vec::new(),

new_cons_element_type_list_def: Vec::new(),

new_snoc_element_type_list_def: Vec::new(),

new_func_app_def: Vec::new(),

new_map_el_def: Vec::new(),

new_ambient_model_el_def: Vec::new(),

new_pred_symbol_def: Vec::new(),

new_func_symbol_def: Vec::new(),

new_rule_symbol_def: Vec::new(),

new_ctor_symbol_def: Vec::new(),

new_symbol_scope_parent_def: Vec::new(),

new_decls_symbol_scope_def: Vec::new(),

new_args_symbol_scope_def: Vec::new(),

new_ctors_symbol_scope_def: Vec::new(),

new_model_member_symbol_scope_def: Vec::new(),

new_symbol_scope_name_def: Vec::new(),

new_scope_symbols_def: Vec::new(),

new_semantic_el_def: Vec::new(),

new_zero_def: Vec::new(),

new_succ_def: Vec::new(),

new_type_list_len_def: Vec::new(),

new_term_list_len_def: Vec::new(),

new_before_rule_structure_def: Vec::new(),

new_ambient_model_el_structure_def: Vec::new(),

new_ambient_model_el_morphism_def: Vec::new(),

new_if_atom_morphism_def: Vec::new(),

new_then_atom_morphism_def: Vec::new(),

new_branch_stmt_morphism_def: Vec::new(),

new_match_stmt_morphism_def: Vec::new(),

new_semantic_name_def: Vec::new(),

new_wildcard_name_def: Vec::new(),

new_rel_app_parent_model_el_def: Vec::new(),

new_match_case_pattern_ctor_def: Vec::new(),

new_cases_determined_enum_def: Vec::new(),

    }
}
fn apply_surjective(&mut self, model: &mut Model) {
    self.apply_equalities(model);
    self.apply_tuples(model);
}
fn apply_non_surjective(&mut self, model: &mut Model) {
    self.apply_func_defs(model);
}
#[allow(unused)]
fn apply_equalities(&mut self, model: &mut Model) {
for (lhs, rhs) in self.new_ident_equalities.iter().copied() {
    model.equate_ident(lhs, rhs);
}

for (lhs, rhs) in self.new_virt_ident_equalities.iter().copied() {
    model.equate_virt_ident(lhs, rhs);
}

for (lhs, rhs) in self.new_type_decl_node_equalities.iter().copied() {
    model.equate_type_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_arg_decl_node_equalities.iter().copied() {
    model.equate_arg_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_arg_decl_list_node_equalities.iter().copied() {
    model.equate_arg_decl_list_node(lhs, rhs);
}

for (lhs, rhs) in self.new_pred_decl_node_equalities.iter().copied() {
    model.equate_pred_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_func_decl_node_equalities.iter().copied() {
    model.equate_func_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_ctor_decl_node_equalities.iter().copied() {
    model.equate_ctor_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_ctor_decl_list_node_equalities.iter().copied() {
    model.equate_ctor_decl_list_node(lhs, rhs);
}

for (lhs, rhs) in self.new_enum_decl_node_equalities.iter().copied() {
    model.equate_enum_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_term_node_equalities.iter().copied() {
    model.equate_term_node(lhs, rhs);
}

for (lhs, rhs) in self.new_term_list_node_equalities.iter().copied() {
    model.equate_term_list_node(lhs, rhs);
}

for (lhs, rhs) in self.new_type_expr_node_equalities.iter().copied() {
    model.equate_type_expr_node(lhs, rhs);
}

for (lhs, rhs) in self.new_opt_term_node_equalities.iter().copied() {
    model.equate_opt_term_node(lhs, rhs);
}

for (lhs, rhs) in self.new_match_case_node_equalities.iter().copied() {
    model.equate_match_case_node(lhs, rhs);
}

for (lhs, rhs) in self.new_match_case_list_node_equalities.iter().copied() {
    model.equate_match_case_list_node(lhs, rhs);
}

for (lhs, rhs) in self.new_if_atom_node_equalities.iter().copied() {
    model.equate_if_atom_node(lhs, rhs);
}

for (lhs, rhs) in self.new_then_atom_node_equalities.iter().copied() {
    model.equate_then_atom_node(lhs, rhs);
}

for (lhs, rhs) in self.new_stmt_node_equalities.iter().copied() {
    model.equate_stmt_node(lhs, rhs);
}

for (lhs, rhs) in self.new_stmt_list_node_equalities.iter().copied() {
    model.equate_stmt_list_node(lhs, rhs);
}

for (lhs, rhs) in self.new_stmt_block_list_node_equalities.iter().copied() {
    model.equate_stmt_block_list_node(lhs, rhs);
}

for (lhs, rhs) in self.new_rule_decl_node_equalities.iter().copied() {
    model.equate_rule_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_model_decl_node_equalities.iter().copied() {
    model.equate_model_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_decl_node_equalities.iter().copied() {
    model.equate_decl_node(lhs, rhs);
}

for (lhs, rhs) in self.new_decl_list_node_equalities.iter().copied() {
    model.equate_decl_list_node(lhs, rhs);
}

for (lhs, rhs) in self.new_module_node_equalities.iter().copied() {
    model.equate_module_node(lhs, rhs);
}

for (lhs, rhs) in self.new_loc_equalities.iter().copied() {
    model.equate_loc(lhs, rhs);
}

for (lhs, rhs) in self.new_rule_descendant_node_equalities.iter().copied() {
    model.equate_rule_descendant_node(lhs, rhs);
}

for (lhs, rhs) in self.new_scope_equalities.iter().copied() {
    model.equate_scope(lhs, rhs);
}

for (lhs, rhs) in self.new_type_equalities.iter().copied() {
    model.equate_type(lhs, rhs);
}

for (lhs, rhs) in self.new_pred_equalities.iter().copied() {
    model.equate_pred(lhs, rhs);
}

for (lhs, rhs) in self.new_func_equalities.iter().copied() {
    model.equate_func(lhs, rhs);
}

for (lhs, rhs) in self.new_structure_equalities.iter().copied() {
    model.equate_structure(lhs, rhs);
}

for (lhs, rhs) in self.new_el_equalities.iter().copied() {
    model.equate_el(lhs, rhs);
}

for (lhs, rhs) in self.new_el_name_equalities.iter().copied() {
    model.equate_el_name(lhs, rhs);
}

for (lhs, rhs) in self.new_morphism_equalities.iter().copied() {
    model.equate_morphism(lhs, rhs);
}

for (lhs, rhs) in self.new_symbol_scope_equalities.iter().copied() {
    model.equate_symbol_scope(lhs, rhs);
}

for (lhs, rhs) in self.new_nat_equalities.iter().copied() {
    model.equate_nat(lhs, rhs);
}

for (lhs, rhs) in self.new_type_list_equalities.iter().copied() {
    model.equate_type_list(lhs, rhs);
}

for (lhs, rhs) in self.new_rel_equalities.iter().copied() {
    model.equate_rel(lhs, rhs);
}

for (lhs, rhs) in self.new_el_list_equalities.iter().copied() {
    model.equate_el_list(lhs, rhs);
}

for (lhs, rhs) in self.new_element_type_equalities.iter().copied() {
    model.equate_element_type(lhs, rhs);
}

for (lhs, rhs) in self.new_element_type_list_equalities.iter().copied() {
    model.equate_element_type_list(lhs, rhs);
}

for (lhs, rhs) in self.new_symbol_kind_equalities.iter().copied() {
    model.equate_symbol_kind(lhs, rhs);
}

}
fn apply_tuples(&mut self, model: &mut Model) {
    for Absurd() in self.new_absurd.drain(..) {
    model.insert_absurd();
}

for TypeDecl(tm0, tm1) in self.new_type_decl.drain(..) {
    model.insert_type_decl(tm0, tm1);
}

for ArgDeclNodeName(tm0, tm1) in self.new_arg_decl_node_name.drain(..) {
    model.insert_arg_decl_node_name(tm0, tm1);
}

for ArgDeclNodeType(tm0, tm1) in self.new_arg_decl_node_type.drain(..) {
    model.insert_arg_decl_node_type(tm0, tm1);
}

for NilArgDeclListNode(tm0) in self.new_nil_arg_decl_list_node.drain(..) {
    model.insert_nil_arg_decl_list_node(tm0);
}

for ConsArgDeclListNode(tm0, tm1, tm2) in self.new_cons_arg_decl_list_node.drain(..) {
    model.insert_cons_arg_decl_list_node(tm0, tm1, tm2);
}

for PredDecl(tm0, tm1, tm2) in self.new_pred_decl.drain(..) {
    model.insert_pred_decl(tm0, tm1, tm2);
}

for FuncDecl(tm0, tm1, tm2, tm3) in self.new_func_decl.drain(..) {
    model.insert_func_decl(tm0, tm1, tm2, tm3);
}

for CtorDecl(tm0, tm1, tm2) in self.new_ctor_decl.drain(..) {
    model.insert_ctor_decl(tm0, tm1, tm2);
}

for NilCtorDeclListNode(tm0) in self.new_nil_ctor_decl_list_node.drain(..) {
    model.insert_nil_ctor_decl_list_node(tm0);
}

for ConsCtorDeclListNode(tm0, tm1, tm2) in self.new_cons_ctor_decl_list_node.drain(..) {
    model.insert_cons_ctor_decl_list_node(tm0, tm1, tm2);
}

for EnumDecl(tm0, tm1, tm2) in self.new_enum_decl.drain(..) {
    model.insert_enum_decl(tm0, tm1, tm2);
}

for NilTermListNode(tm0) in self.new_nil_term_list_node.drain(..) {
    model.insert_nil_term_list_node(tm0);
}

for ConsTermListNode(tm0, tm1, tm2) in self.new_cons_term_list_node.drain(..) {
    model.insert_cons_term_list_node(tm0, tm1, tm2);
}

for AmbientTypeExpr(tm0, tm1) in self.new_ambient_type_expr.drain(..) {
    model.insert_ambient_type_expr(tm0, tm1);
}

for MemberTypeExpr(tm0, tm1, tm2) in self.new_member_type_expr.drain(..) {
    model.insert_member_type_expr(tm0, tm1, tm2);
}

for MorTypeExpr(tm0, tm1) in self.new_mor_type_expr.drain(..) {
    model.insert_mor_type_expr(tm0, tm1);
}

for NoneTermNode(tm0) in self.new_none_term_node.drain(..) {
    model.insert_none_term_node(tm0);
}

for SomeTermNode(tm0, tm1) in self.new_some_term_node.drain(..) {
    model.insert_some_term_node(tm0, tm1);
}

for VarTermNode(tm0, tm1) in self.new_var_term_node.drain(..) {
    model.insert_var_term_node(tm0, tm1);
}

for WildcardTermNode(tm0) in self.new_wildcard_term_node.drain(..) {
    model.insert_wildcard_term_node(tm0);
}

for AppTermNode(tm0, tm1, tm2) in self.new_app_term_node.drain(..) {
    model.insert_app_term_node(tm0, tm1, tm2);
}

for MatchCase(tm0, tm1, tm2) in self.new_match_case.drain(..) {
    model.insert_match_case(tm0, tm1, tm2);
}

for NilMatchCaseListNode(tm0) in self.new_nil_match_case_list_node.drain(..) {
    model.insert_nil_match_case_list_node(tm0);
}

for ConsMatchCaseListNode(tm0, tm1, tm2) in self.new_cons_match_case_list_node.drain(..) {
    model.insert_cons_match_case_list_node(tm0, tm1, tm2);
}

for EqualIfAtomNode(tm0, tm1, tm2) in self.new_equal_if_atom_node.drain(..) {
    model.insert_equal_if_atom_node(tm0, tm1, tm2);
}

for DefinedIfAtomNode(tm0, tm1) in self.new_defined_if_atom_node.drain(..) {
    model.insert_defined_if_atom_node(tm0, tm1);
}

for PredIfAtomNode(tm0, tm1, tm2) in self.new_pred_if_atom_node.drain(..) {
    model.insert_pred_if_atom_node(tm0, tm1, tm2);
}

for VarIfAtomNode(tm0, tm1, tm2) in self.new_var_if_atom_node.drain(..) {
    model.insert_var_if_atom_node(tm0, tm1, tm2);
}

for EqualThenAtomNode(tm0, tm1, tm2) in self.new_equal_then_atom_node.drain(..) {
    model.insert_equal_then_atom_node(tm0, tm1, tm2);
}

for DefinedThenAtomNode(tm0, tm1, tm2) in self.new_defined_then_atom_node.drain(..) {
    model.insert_defined_then_atom_node(tm0, tm1, tm2);
}

for PredThenAtomNode(tm0, tm1, tm2) in self.new_pred_then_atom_node.drain(..) {
    model.insert_pred_then_atom_node(tm0, tm1, tm2);
}

for IfStmtNode(tm0, tm1) in self.new_if_stmt_node.drain(..) {
    model.insert_if_stmt_node(tm0, tm1);
}

for ThenStmtNode(tm0, tm1) in self.new_then_stmt_node.drain(..) {
    model.insert_then_stmt_node(tm0, tm1);
}

for BranchStmtNode(tm0, tm1) in self.new_branch_stmt_node.drain(..) {
    model.insert_branch_stmt_node(tm0, tm1);
}

for MatchStmtNode(tm0, tm1, tm2) in self.new_match_stmt_node.drain(..) {
    model.insert_match_stmt_node(tm0, tm1, tm2);
}

for NilStmtListNode(tm0) in self.new_nil_stmt_list_node.drain(..) {
    model.insert_nil_stmt_list_node(tm0);
}

for ConsStmtListNode(tm0, tm1, tm2) in self.new_cons_stmt_list_node.drain(..) {
    model.insert_cons_stmt_list_node(tm0, tm1, tm2);
}

for NilStmtBlockListNode(tm0) in self.new_nil_stmt_block_list_node.drain(..) {
    model.insert_nil_stmt_block_list_node(tm0);
}

for ConsStmtBlockListNode(tm0, tm1, tm2) in self.new_cons_stmt_block_list_node.drain(..) {
    model.insert_cons_stmt_block_list_node(tm0, tm1, tm2);
}

for RuleDecl(tm0, tm1) in self.new_rule_decl.drain(..) {
    model.insert_rule_decl(tm0, tm1);
}

for ModelDecl(tm0, tm1, tm2) in self.new_model_decl.drain(..) {
    model.insert_model_decl(tm0, tm1, tm2);
}

for DeclNodeType(tm0, tm1) in self.new_decl_node_type.drain(..) {
    model.insert_decl_node_type(tm0, tm1);
}

for DeclNodePred(tm0, tm1) in self.new_decl_node_pred.drain(..) {
    model.insert_decl_node_pred(tm0, tm1);
}

for DeclNodeFunc(tm0, tm1) in self.new_decl_node_func.drain(..) {
    model.insert_decl_node_func(tm0, tm1);
}

for DeclNodeRule(tm0, tm1) in self.new_decl_node_rule.drain(..) {
    model.insert_decl_node_rule(tm0, tm1);
}

for DeclNodeEnum(tm0, tm1) in self.new_decl_node_enum.drain(..) {
    model.insert_decl_node_enum(tm0, tm1);
}

for DeclNodeModel(tm0, tm1) in self.new_decl_node_model.drain(..) {
    model.insert_decl_node_model(tm0, tm1);
}

for NilDeclListNode(tm0) in self.new_nil_decl_list_node.drain(..) {
    model.insert_nil_decl_list_node(tm0);
}

for ConsDeclListNode(tm0, tm1, tm2) in self.new_cons_decl_list_node.drain(..) {
    model.insert_cons_decl_list_node(tm0, tm1, tm2);
}

for DeclsModuleNode(tm0, tm1) in self.new_decls_module_node.drain(..) {
    model.insert_decls_module_node(tm0, tm1);
}

for VarInScope(tm0, tm1) in self.new_var_in_scope.drain(..) {
    model.insert_var_in_scope(tm0, tm1);
}

for ScopeExtension(tm0, tm1) in self.new_scope_extension.drain(..) {
    model.insert_scope_extension(tm0, tm1);
}

for ScopeSingleChild(tm0, tm1) in self.new_scope_single_child.drain(..) {
    model.insert_scope_single_child(tm0, tm1);
}

for ScopeExtensionSiblings(tm0, tm1, tm2) in self.new_scope_extension_siblings.drain(..) {
    model.insert_scope_extension_siblings(tm0, tm1, tm2);
}

for IsNormalType(tm0) in self.new_is_normal_type.drain(..) {
    model.insert_is_normal_type(tm0);
}

for IsEnumType(tm0) in self.new_is_enum_type.drain(..) {
    model.insert_is_enum_type(tm0);
}

for IsModelType(tm0) in self.new_is_model_type.drain(..) {
    model.insert_is_model_type(tm0);
}

for IsMorType(tm0) in self.new_is_mor_type.drain(..) {
    model.insert_is_mor_type(tm0);
}

for IllegalMemberTypeExprInSignature(tm0) in self.new_illegal_member_type_expr_in_signature.drain(..) {
    model.insert_illegal_member_type_expr_in_signature(tm0);
}

for IsTotalFunc(tm0) in self.new_is_total_func.drain(..) {
    model.insert_is_total_func(tm0);
}

for RelApp(tm0, tm1) in self.new_rel_app.drain(..) {
    model.insert_rel_app(tm0, tm1);
}

for ElType(tm0, tm1) in self.new_el_type.drain(..) {
    model.insert_el_type(tm0, tm1);
}

for ElTypes(tm0, tm1) in self.new_el_types.drain(..) {
    model.insert_el_types(tm0, tm1);
}

for ConstrainedEl(tm0) in self.new_constrained_el.drain(..) {
    model.insert_constrained_el(tm0);
}

for ConstrainedEls(tm0) in self.new_constrained_els.drain(..) {
    model.insert_constrained_els(tm0);
}

for InKer(tm0, tm1, tm2) in self.new_in_ker.drain(..) {
    model.insert_in_ker(tm0, tm1, tm2);
}

for ElInImg(tm0, tm1) in self.new_el_in_img.drain(..) {
    model.insert_el_in_img(tm0, tm1);
}

for RelTupleInImg(tm0, tm1, tm2) in self.new_rel_tuple_in_img.drain(..) {
    model.insert_rel_tuple_in_img(tm0, tm1, tm2);
}

for SymbolScopeExtension(tm0, tm1) in self.new_symbol_scope_extension.drain(..) {
    model.insert_symbol_scope_extension(tm0, tm1);
}

for SymbolScopeAncestor(tm0, tm1) in self.new_symbol_scope_ancestor.drain(..) {
    model.insert_symbol_scope_ancestor(tm0, tm1);
}

for ElementMemberSymbolScope(tm0, tm1) in self.new_element_member_symbol_scope.drain(..) {
    model.insert_element_member_symbol_scope(tm0, tm1);
}

for DefinedSymbol(tm0, tm1, tm2, tm3) in self.new_defined_symbol.drain(..) {
    model.insert_defined_symbol(tm0, tm1, tm2, tm3);
}

for AccessibleSymbol(tm0, tm1, tm2, tm3) in self.new_accessible_symbol.drain(..) {
    model.insert_accessible_symbol(tm0, tm1, tm2, tm3);
}

for ShouldBeSymbol(tm0, tm1, tm2, tm3) in self.new_should_be_symbol.drain(..) {
    model.insert_should_be_symbol(tm0, tm1, tm2, tm3);
}

for ShouldBeSymbol2(tm0, tm1, tm2, tm3, tm4) in self.new_should_be_symbol_2.drain(..) {
    model.insert_should_be_symbol_2(tm0, tm1, tm2, tm3, tm4);
}

for ShouldBeSymbol3(tm0, tm1, tm2, tm3, tm4, tm5) in self.new_should_be_symbol_3.drain(..) {
    model.insert_should_be_symbol_3(tm0, tm1, tm2, tm3, tm4, tm5);
}

for PredArgNumShouldMatch(tm0, tm1, tm2) in self.new_pred_arg_num_should_match.drain(..) {
    model.insert_pred_arg_num_should_match(tm0, tm1, tm2);
}

for FuncArgNumShouldMatch(tm0, tm1, tm2) in self.new_func_arg_num_should_match.drain(..) {
    model.insert_func_arg_num_should_match(tm0, tm1, tm2);
}

for CfgEdge(tm0, tm1) in self.new_cfg_edge.drain(..) {
    model.insert_cfg_edge(tm0, tm1);
}

for CfgEdgeStmtsStmt(tm0, tm1) in self.new_cfg_edge_stmts_stmt.drain(..) {
    model.insert_cfg_edge_stmts_stmt(tm0, tm1);
}

for CfgEdgeStmtStmts(tm0, tm1) in self.new_cfg_edge_stmt_stmts.drain(..) {
    model.insert_cfg_edge_stmt_stmts(tm0, tm1);
}

for CfgEdgeFork(tm0, tm1) in self.new_cfg_edge_fork.drain(..) {
    model.insert_cfg_edge_fork(tm0, tm1);
}

for CfgEdgeJoin(tm0, tm1) in self.new_cfg_edge_join.drain(..) {
    model.insert_cfg_edge_join(tm0, tm1);
}

for BeforeStmtStructure(tm0, tm1) in self.new_before_stmt_structure.drain(..) {
    model.insert_before_stmt_structure(tm0, tm1);
}

for StmtMorphism(tm0, tm1) in self.new_stmt_morphism.drain(..) {
    model.insert_stmt_morphism(tm0, tm1);
}

for IfMorphism(tm0) in self.new_if_morphism.drain(..) {
    model.insert_if_morphism(tm0);
}

for SurjThenMorphism(tm0) in self.new_surj_then_morphism.drain(..) {
    model.insert_surj_then_morphism(tm0);
}

for NonSurjThenMorphism(tm0) in self.new_non_surj_then_morphism.drain(..) {
    model.insert_non_surj_then_morphism(tm0);
}

for NoopMorphism(tm0) in self.new_noop_morphism.drain(..) {
    model.insert_noop_morphism(tm0);
}

for StmtStructure(tm0, tm1) in self.new_stmt_structure.drain(..) {
    model.insert_stmt_structure(tm0, tm1);
}

for IfAtomStructure(tm0, tm1) in self.new_if_atom_structure.drain(..) {
    model.insert_if_atom_structure(tm0, tm1);
}

for ThenAtomStructure(tm0, tm1) in self.new_then_atom_structure.drain(..) {
    model.insert_then_atom_structure(tm0, tm1);
}

for TermStructure(tm0, tm1) in self.new_term_structure.drain(..) {
    model.insert_term_structure(tm0, tm1);
}

for TermsStructure(tm0, tm1) in self.new_terms_structure.drain(..) {
    model.insert_terms_structure(tm0, tm1);
}

for OptTermStructure(tm0, tm1) in self.new_opt_term_structure.drain(..) {
    model.insert_opt_term_structure(tm0, tm1);
}

for TypeExprStructure(tm0, tm1) in self.new_type_expr_structure.drain(..) {
    model.insert_type_expr_structure(tm0, tm1);
}

for TermShouldBeEpicOk(tm0) in self.new_term_should_be_epic_ok.drain(..) {
    model.insert_term_should_be_epic_ok(tm0);
}

for TermsShouldBeEpicOk(tm0) in self.new_terms_should_be_epic_ok.drain(..) {
    model.insert_terms_should_be_epic_ok(tm0);
}

for ElShouldBeSurjectiveOk(tm0) in self.new_el_should_be_surjective_ok.drain(..) {
    model.insert_el_should_be_surjective_ok(tm0);
}

for ElIsSurjectiveOk(tm0) in self.new_el_is_surjective_ok.drain(..) {
    model.insert_el_is_surjective_ok(tm0);
}

for ShouldBeObtainedByCtor(tm0, tm1) in self.new_should_be_obtained_by_ctor.drain(..) {
    model.insert_should_be_obtained_by_ctor(tm0, tm1);
}

for IsGivenByCtor(tm0, tm1) in self.new_is_given_by_ctor.drain(..) {
    model.insert_is_given_by_ctor(tm0, tm1);
}

for FunctionCanBeMadeDefined(tm0) in self.new_function_can_be_made_defined.drain(..) {
    model.insert_function_can_be_made_defined(tm0);
}

for CasePatternIsVariable(tm0) in self.new_case_pattern_is_variable.drain(..) {
    model.insert_case_pattern_is_variable(tm0);
}

for CasePatternIsWildcard(tm0) in self.new_case_pattern_is_wildcard.drain(..) {
    model.insert_case_pattern_is_wildcard(tm0);
}

for IsPatternCtorArg(tm0) in self.new_is_pattern_ctor_arg.drain(..) {
    model.insert_is_pattern_ctor_arg(tm0);
}

for ArePatternCtorArgs(tm0) in self.new_are_pattern_ctor_args.drain(..) {
    model.insert_are_pattern_ctor_args(tm0);
}

for PatternCtorArgIsApp(tm0) in self.new_pattern_ctor_arg_is_app.drain(..) {
    model.insert_pattern_ctor_arg_is_app(tm0);
}

for PatternCtorArgVarIsNotFresh(tm0) in self.new_pattern_ctor_arg_var_is_not_fresh.drain(..) {
    model.insert_pattern_ctor_arg_var_is_not_fresh(tm0);
}

for CasesContainCtor(tm0, tm1) in self.new_cases_contain_ctor.drain(..) {
    model.insert_cases_contain_ctor(tm0, tm1);
}

for MatchStmtContainsCtorOfEnum(tm0, tm1, tm2) in self.new_match_stmt_contains_ctor_of_enum.drain(..) {
    model.insert_match_stmt_contains_ctor_of_enum(tm0, tm1, tm2);
}

for MatchStmtShouldContainCtor(tm0, tm1) in self.new_match_stmt_should_contain_ctor.drain(..) {
    model.insert_match_stmt_should_contain_ctor(tm0, tm1);
}

for MatchStmtContainsCtor(tm0, tm1) in self.new_match_stmt_contains_ctor.drain(..) {
    model.insert_match_stmt_contains_ctor(tm0, tm1);
}

for RealVirtIdent(tm0, tm1) in self.new_real_virt_ident.drain(..) {
    model.insert_real_virt_ident(tm0, tm1);
}

for VirtRealIdent(tm0, tm1) in self.new_virt_real_ident.drain(..) {
    model.insert_virt_real_ident(tm0, tm1);
}

for Var(tm0, tm1, tm2) in self.new_var.drain(..) {
    model.insert_var(tm0, tm1, tm2);
}

for RuleName(tm0, tm1) in self.new_rule_name.drain(..) {
    model.insert_rule_name(tm0, tm1);
}

for ModuleName(tm0, tm1) in self.new_module_name.drain(..) {
    model.insert_module_name(tm0, tm1);
}

for TypeDeclNodeLoc(tm0, tm1) in self.new_type_decl_node_loc.drain(..) {
    model.insert_type_decl_node_loc(tm0, tm1);
}

for ArgDeclNodeLoc(tm0, tm1) in self.new_arg_decl_node_loc.drain(..) {
    model.insert_arg_decl_node_loc(tm0, tm1);
}

for ArgDeclListNodeLoc(tm0, tm1) in self.new_arg_decl_list_node_loc.drain(..) {
    model.insert_arg_decl_list_node_loc(tm0, tm1);
}

for PredDeclNodeLoc(tm0, tm1) in self.new_pred_decl_node_loc.drain(..) {
    model.insert_pred_decl_node_loc(tm0, tm1);
}

for FuncDeclNodeLoc(tm0, tm1) in self.new_func_decl_node_loc.drain(..) {
    model.insert_func_decl_node_loc(tm0, tm1);
}

for CtorDeclNodeLoc(tm0, tm1) in self.new_ctor_decl_node_loc.drain(..) {
    model.insert_ctor_decl_node_loc(tm0, tm1);
}

for EnumDeclNodeLoc(tm0, tm1) in self.new_enum_decl_node_loc.drain(..) {
    model.insert_enum_decl_node_loc(tm0, tm1);
}

for ModelDeclNodeLoc(tm0, tm1) in self.new_model_decl_node_loc.drain(..) {
    model.insert_model_decl_node_loc(tm0, tm1);
}

for TermNodeLoc(tm0, tm1) in self.new_term_node_loc.drain(..) {
    model.insert_term_node_loc(tm0, tm1);
}

for TermListNodeLoc(tm0, tm1) in self.new_term_list_node_loc.drain(..) {
    model.insert_term_list_node_loc(tm0, tm1);
}

for MatchCaseNodeLoc(tm0, tm1) in self.new_match_case_node_loc.drain(..) {
    model.insert_match_case_node_loc(tm0, tm1);
}

for OptTermNodeLoc(tm0, tm1) in self.new_opt_term_node_loc.drain(..) {
    model.insert_opt_term_node_loc(tm0, tm1);
}

for IfAtomNodeLoc(tm0, tm1) in self.new_if_atom_node_loc.drain(..) {
    model.insert_if_atom_node_loc(tm0, tm1);
}

for ThenAtomNodeLoc(tm0, tm1) in self.new_then_atom_node_loc.drain(..) {
    model.insert_then_atom_node_loc(tm0, tm1);
}

for StmtNodeLoc(tm0, tm1) in self.new_stmt_node_loc.drain(..) {
    model.insert_stmt_node_loc(tm0, tm1);
}

for StmtListNodeLoc(tm0, tm1) in self.new_stmt_list_node_loc.drain(..) {
    model.insert_stmt_list_node_loc(tm0, tm1);
}

for RuleDeclNodeLoc(tm0, tm1) in self.new_rule_decl_node_loc.drain(..) {
    model.insert_rule_decl_node_loc(tm0, tm1);
}

for DeclNodeLoc(tm0, tm1) in self.new_decl_node_loc.drain(..) {
    model.insert_decl_node_loc(tm0, tm1);
}

for DeclListNodeLoc(tm0, tm1) in self.new_decl_list_node_loc.drain(..) {
    model.insert_decl_list_node_loc(tm0, tm1);
}

for ModuleNodeLoc(tm0, tm1) in self.new_module_node_loc.drain(..) {
    model.insert_module_node_loc(tm0, tm1);
}

for TypeExprNodeLoc(tm0, tm1) in self.new_type_expr_node_loc.drain(..) {
    model.insert_type_expr_node_loc(tm0, tm1);
}

for RuleDescendantRule(tm0, tm1) in self.new_rule_descendant_rule.drain(..) {
    model.insert_rule_descendant_rule(tm0, tm1);
}

for RuleDescendantTerm(tm0, tm1) in self.new_rule_descendant_term.drain(..) {
    model.insert_rule_descendant_term(tm0, tm1);
}

for RuleDescendantTermList(tm0, tm1) in self.new_rule_descendant_term_list.drain(..) {
    model.insert_rule_descendant_term_list(tm0, tm1);
}

for RuleDescendantOptTerm(tm0, tm1) in self.new_rule_descendant_opt_term.drain(..) {
    model.insert_rule_descendant_opt_term(tm0, tm1);
}

for RuleDescendantIfAtom(tm0, tm1) in self.new_rule_descendant_if_atom.drain(..) {
    model.insert_rule_descendant_if_atom(tm0, tm1);
}

for RuleDescendantThenAtom(tm0, tm1) in self.new_rule_descendant_then_atom.drain(..) {
    model.insert_rule_descendant_then_atom(tm0, tm1);
}

for RuleDescendantMatchCase(tm0, tm1) in self.new_rule_descendant_match_case.drain(..) {
    model.insert_rule_descendant_match_case(tm0, tm1);
}

for RuleDescendantMatchCaseList(tm0, tm1) in self.new_rule_descendant_match_case_list.drain(..) {
    model.insert_rule_descendant_match_case_list(tm0, tm1);
}

for RuleDescendantStmt(tm0, tm1) in self.new_rule_descendant_stmt.drain(..) {
    model.insert_rule_descendant_stmt(tm0, tm1);
}

for RuleDescendantStmtList(tm0, tm1) in self.new_rule_descendant_stmt_list.drain(..) {
    model.insert_rule_descendant_stmt_list(tm0, tm1);
}

for RuleDescendantStmtBlockList(tm0, tm1) in self.new_rule_descendant_stmt_block_list.drain(..) {
    model.insert_rule_descendant_stmt_block_list(tm0, tm1);
}

for RuleDescendantTypeExpr(tm0, tm1) in self.new_rule_descendant_type_expr.drain(..) {
    model.insert_rule_descendant_type_expr(tm0, tm1);
}

for EntryScope(tm0, tm1) in self.new_entry_scope.drain(..) {
    model.insert_entry_scope(tm0, tm1);
}

for ExitScope(tm0, tm1) in self.new_exit_scope.drain(..) {
    model.insert_exit_scope(tm0, tm1);
}

for CtorEnum(tm0, tm1) in self.new_ctor_enum.drain(..) {
    model.insert_ctor_enum(tm0, tm1);
}

for CtorsEnum(tm0, tm1) in self.new_ctors_enum.drain(..) {
    model.insert_ctors_enum(tm0, tm1);
}

for CasesDiscriminee(tm0, tm1) in self.new_cases_discriminee.drain(..) {
    model.insert_cases_discriminee(tm0, tm1);
}

for CaseDiscriminee(tm0, tm1) in self.new_case_discriminee.drain(..) {
    model.insert_case_discriminee(tm0, tm1);
}

for DesugaredCaseEqualityAtom(tm0, tm1) in self.new_desugared_case_equality_atom.drain(..) {
    model.insert_desugared_case_equality_atom(tm0, tm1);
}

for DesugaredCaseEqualityStmt(tm0, tm1) in self.new_desugared_case_equality_stmt.drain(..) {
    model.insert_desugared_case_equality_stmt(tm0, tm1);
}

for DesugaredCaseBlock(tm0, tm1) in self.new_desugared_case_block.drain(..) {
    model.insert_desugared_case_block(tm0, tm1);
}

for DesugaredCaseBlockList(tm0, tm1) in self.new_desugared_case_block_list.drain(..) {
    model.insert_desugared_case_block_list(tm0, tm1);
}

for NilTypeList(tm0) in self.new_nil_type_list.drain(..) {
    model.insert_nil_type_list(tm0);
}

for ConsTypeList(tm0, tm1, tm2) in self.new_cons_type_list.drain(..) {
    model.insert_cons_type_list(tm0, tm1, tm2);
}

for SnocTypeList(tm0, tm1, tm2) in self.new_snoc_type_list.drain(..) {
    model.insert_snoc_type_list(tm0, tm1, tm2);
}

for SemanticType(tm0, tm1, tm2) in self.new_semantic_type.drain(..) {
    model.insert_semantic_type(tm0, tm1, tm2);
}

for DeclSymbolScope(tm0, tm1) in self.new_decl_symbol_scope.drain(..) {
    model.insert_decl_symbol_scope(tm0, tm1);
}

for MorType(tm0, tm1) in self.new_mor_type.drain(..) {
    model.insert_mor_type(tm0, tm1);
}

for MorTypeDomFunc(tm0, tm1) in self.new_mor_type_dom_func.drain(..) {
    model.insert_mor_type_dom_func(tm0, tm1);
}

for MorTypeCodFunc(tm0, tm1) in self.new_mor_type_cod_func.drain(..) {
    model.insert_mor_type_cod_func(tm0, tm1);
}

for TypeDefinitionSymbolScope(tm0, tm1) in self.new_type_definition_symbol_scope.drain(..) {
    model.insert_type_definition_symbol_scope(tm0, tm1);
}

for FuncRel(tm0, tm1) in self.new_func_rel.drain(..) {
    model.insert_func_rel(tm0, tm1);
}

for RelDefinitionSymbolScope(tm0, tm1) in self.new_rel_definition_symbol_scope.drain(..) {
    model.insert_rel_definition_symbol_scope(tm0, tm1);
}

for Domain(tm0, tm1) in self.new_domain.drain(..) {
    model.insert_domain(tm0, tm1);
}

for Codomain(tm0, tm1) in self.new_codomain.drain(..) {
    model.insert_codomain(tm0, tm1);
}

for TypeName(tm0, tm1) in self.new_type_name.drain(..) {
    model.insert_type_name(tm0, tm1);
}

for VirtualSymbolScope(tm0) in self.new_virtual_symbol_scope.drain(..) {
    model.insert_virtual_symbol_scope(tm0);
}

for ParentModelFunc(tm0, tm1) in self.new_parent_model_func.drain(..) {
    model.insert_parent_model_func(tm0, tm1);
}

for SymbolScopeModel(tm0, tm1) in self.new_symbol_scope_model.drain(..) {
    model.insert_symbol_scope_model(tm0, tm1);
}

for FlatDomain(tm0, tm1) in self.new_flat_domain.drain(..) {
    model.insert_flat_domain(tm0, tm1);
}

for SemanticSignatureTypeExpr(tm0, tm1, tm2) in self.new_semantic_signature_type_expr.drain(..) {
    model.insert_semantic_signature_type_expr(tm0, tm1, tm2);
}

for TypeSymbol(tm0) in self.new_type_symbol.drain(..) {
    model.insert_type_symbol(tm0);
}

for EnumSymbol(tm0) in self.new_enum_symbol.drain(..) {
    model.insert_enum_symbol(tm0);
}

for ModelSymbol(tm0) in self.new_model_symbol.drain(..) {
    model.insert_model_symbol(tm0);
}

for SemanticArgType(tm0, tm1) in self.new_semantic_arg_type.drain(..) {
    model.insert_semantic_arg_type(tm0, tm1);
}

for ArgSymbolScope(tm0, tm1) in self.new_arg_symbol_scope.drain(..) {
    model.insert_arg_symbol_scope(tm0, tm1);
}

for SemanticArgTypes(tm0, tm1) in self.new_semantic_arg_types.drain(..) {
    model.insert_semantic_arg_types(tm0, tm1);
}

for SemanticPred(tm0, tm1, tm2) in self.new_semantic_pred.drain(..) {
    model.insert_semantic_pred(tm0, tm1, tm2);
}

for PredArity(tm0, tm1) in self.new_pred_arity.drain(..) {
    model.insert_pred_arity(tm0, tm1);
}

for SemanticFunc(tm0, tm1, tm2) in self.new_semantic_func.drain(..) {
    model.insert_semantic_func(tm0, tm1, tm2);
}

for CtorSymbolScope(tm0, tm1) in self.new_ctor_symbol_scope.drain(..) {
    model.insert_ctor_symbol_scope(tm0, tm1);
}

for PredRel(tm0, tm1) in self.new_pred_rel.drain(..) {
    model.insert_pred_rel(tm0, tm1);
}

for RelName(tm0, tm1) in self.new_rel_name.drain(..) {
    model.insert_rel_name(tm0, tm1);
}

for Arity(tm0, tm1) in self.new_arity.drain(..) {
    model.insert_arity(tm0, tm1);
}

for Dom(tm0, tm1) in self.new_dom.drain(..) {
    model.insert_dom(tm0, tm1);
}

for Cod(tm0, tm1) in self.new_cod.drain(..) {
    model.insert_cod(tm0, tm1);
}

for FlatArity(tm0, tm1) in self.new_flat_arity.drain(..) {
    model.insert_flat_arity(tm0, tm1);
}

for ModuleSymbolScope(tm0, tm1) in self.new_module_symbol_scope.drain(..) {
    model.insert_module_symbol_scope(tm0, tm1);
}

for NilElList(tm0, tm1) in self.new_nil_el_list.drain(..) {
    model.insert_nil_el_list(tm0, tm1);
}

for ConsElList(tm0, tm1, tm2) in self.new_cons_el_list.drain(..) {
    model.insert_cons_el_list(tm0, tm1, tm2);
}

for SnocElList(tm0, tm1, tm2) in self.new_snoc_el_list.drain(..) {
    model.insert_snoc_el_list(tm0, tm1, tm2);
}

for ElStructure(tm0, tm1) in self.new_el_structure.drain(..) {
    model.insert_el_structure(tm0, tm1);
}

for ElsStructure(tm0, tm1) in self.new_els_structure.drain(..) {
    model.insert_els_structure(tm0, tm1);
}

for AmbientType(tm0, tm1) in self.new_ambient_type.drain(..) {
    model.insert_ambient_type(tm0, tm1);
}

for InstantiatedType(tm0, tm1, tm2) in self.new_instantiated_type.drain(..) {
    model.insert_instantiated_type(tm0, tm1, tm2);
}

for UnderlyingType(tm0, tm1) in self.new_underlying_type.drain(..) {
    model.insert_underlying_type(tm0, tm1);
}

for NilElementTypeList(tm0) in self.new_nil_element_type_list.drain(..) {
    model.insert_nil_element_type_list(tm0);
}

for ConsElementTypeList(tm0, tm1, tm2) in self.new_cons_element_type_list.drain(..) {
    model.insert_cons_element_type_list(tm0, tm1, tm2);
}

for SnocElementTypeList(tm0, tm1, tm2) in self.new_snoc_element_type_list.drain(..) {
    model.insert_snoc_element_type_list(tm0, tm1, tm2);
}

for AmbientElTypeList(tm0, tm1) in self.new_ambient_el_type_list.drain(..) {
    model.insert_ambient_el_type_list(tm0, tm1);
}

for FuncApp(tm0, tm1, tm2) in self.new_func_app.drain(..) {
    model.insert_func_app(tm0, tm1, tm2);
}

for MapEl(tm0, tm1, tm2) in self.new_map_el.drain(..) {
    model.insert_map_el(tm0, tm1, tm2);
}

for MapEls(tm0, tm1, tm2) in self.new_map_els.drain(..) {
    model.insert_map_els(tm0, tm1, tm2);
}

for AmbientModelEl(tm0, tm1, tm2) in self.new_ambient_model_el.drain(..) {
    model.insert_ambient_model_el(tm0, tm1, tm2);
}

for PredSymbol(tm0) in self.new_pred_symbol.drain(..) {
    model.insert_pred_symbol(tm0);
}

for FuncSymbol(tm0) in self.new_func_symbol.drain(..) {
    model.insert_func_symbol(tm0);
}

for RuleSymbol(tm0) in self.new_rule_symbol.drain(..) {
    model.insert_rule_symbol(tm0);
}

for CtorSymbol(tm0) in self.new_ctor_symbol.drain(..) {
    model.insert_ctor_symbol(tm0);
}

for SymbolScopeParent(tm0, tm1) in self.new_symbol_scope_parent.drain(..) {
    model.insert_symbol_scope_parent(tm0, tm1);
}

for DeclsSymbolScope(tm0, tm1) in self.new_decls_symbol_scope.drain(..) {
    model.insert_decls_symbol_scope(tm0, tm1);
}

for ArgsSymbolScope(tm0, tm1) in self.new_args_symbol_scope.drain(..) {
    model.insert_args_symbol_scope(tm0, tm1);
}

for CtorsSymbolScope(tm0, tm1) in self.new_ctors_symbol_scope.drain(..) {
    model.insert_ctors_symbol_scope(tm0, tm1);
}

for ModelMemberSymbolScope(tm0, tm1) in self.new_model_member_symbol_scope.drain(..) {
    model.insert_model_member_symbol_scope(tm0, tm1);
}

for SymbolScopeName(tm0, tm1) in self.new_symbol_scope_name.drain(..) {
    model.insert_symbol_scope_name(tm0, tm1);
}

for ScopeSymbols(tm0, tm1) in self.new_scope_symbols.drain(..) {
    model.insert_scope_symbols(tm0, tm1);
}

for SemanticEl(tm0, tm1, tm2) in self.new_semantic_el.drain(..) {
    model.insert_semantic_el(tm0, tm1, tm2);
}

for Zero(tm0) in self.new_zero.drain(..) {
    model.insert_zero(tm0);
}

for Succ(tm0, tm1) in self.new_succ.drain(..) {
    model.insert_succ(tm0, tm1);
}

for TypeListLen(tm0, tm1) in self.new_type_list_len.drain(..) {
    model.insert_type_list_len(tm0, tm1);
}

for TermListLen(tm0, tm1) in self.new_term_list_len.drain(..) {
    model.insert_term_list_len(tm0, tm1);
}

for BeforeRuleStructure(tm0, tm1) in self.new_before_rule_structure.drain(..) {
    model.insert_before_rule_structure(tm0, tm1);
}

for AmbientModelElStructure(tm0, tm1) in self.new_ambient_model_el_structure.drain(..) {
    model.insert_ambient_model_el_structure(tm0, tm1);
}

for AmbientModelElMorphism(tm0, tm1) in self.new_ambient_model_el_morphism.drain(..) {
    model.insert_ambient_model_el_morphism(tm0, tm1);
}

for IfAtomMorphism(tm0, tm1, tm2) in self.new_if_atom_morphism.drain(..) {
    model.insert_if_atom_morphism(tm0, tm1, tm2);
}

for ThenAtomMorphism(tm0, tm1, tm2) in self.new_then_atom_morphism.drain(..) {
    model.insert_then_atom_morphism(tm0, tm1, tm2);
}

for BranchStmtMorphism(tm0, tm1, tm2) in self.new_branch_stmt_morphism.drain(..) {
    model.insert_branch_stmt_morphism(tm0, tm1, tm2);
}

for MatchStmtMorphism(tm0, tm1, tm2) in self.new_match_stmt_morphism.drain(..) {
    model.insert_match_stmt_morphism(tm0, tm1, tm2);
}

for SemanticName(tm0, tm1, tm2) in self.new_semantic_name.drain(..) {
    model.insert_semantic_name(tm0, tm1, tm2);
}

for SemanticEls(tm0, tm1, tm2) in self.new_semantic_els.drain(..) {
    model.insert_semantic_els(tm0, tm1, tm2);
}

for WildcardName(tm0, tm1) in self.new_wildcard_name.drain(..) {
    model.insert_wildcard_name(tm0, tm1);
}

for RelAppParentModelEl(tm0, tm1, tm2) in self.new_rel_app_parent_model_el.drain(..) {
    model.insert_rel_app_parent_model_el(tm0, tm1, tm2);
}

for MatchCasePatternCtor(tm0, tm1) in self.new_match_case_pattern_ctor.drain(..) {
    model.insert_match_case_pattern_ctor(tm0, tm1);
}

for CasesDeterminedEnum(tm0, tm1) in self.new_cases_determined_enum.drain(..) {
    model.insert_cases_determined_enum(tm0, tm1);
}

}
#[allow(unused_variables)]
fn apply_func_defs(&mut self, model: &mut Model) {
    for RealVirtIdentArgs(tm0) in self.new_real_virt_ident_def.drain(..) {
    model.define_real_virt_ident(tm0);
}

for VirtRealIdentArgs(tm0) in self.new_virt_real_ident_def.drain(..) {
    model.define_virt_real_ident(tm0);
}

for VarArgs(tm0, tm1) in self.new_var_def.drain(..) {
    model.define_var(tm0, tm1);
}

for RuleNameArgs(tm0) in self.new_rule_name_def.drain(..) {
    model.define_rule_name(tm0);
}

for ModuleNameArgs(tm0) in self.new_module_name_def.drain(..) {
    model.define_module_name(tm0);
}

for TypeDeclNodeLocArgs(tm0) in self.new_type_decl_node_loc_def.drain(..) {
    model.define_type_decl_node_loc(tm0);
}

for ArgDeclNodeLocArgs(tm0) in self.new_arg_decl_node_loc_def.drain(..) {
    model.define_arg_decl_node_loc(tm0);
}

for ArgDeclListNodeLocArgs(tm0) in self.new_arg_decl_list_node_loc_def.drain(..) {
    model.define_arg_decl_list_node_loc(tm0);
}

for PredDeclNodeLocArgs(tm0) in self.new_pred_decl_node_loc_def.drain(..) {
    model.define_pred_decl_node_loc(tm0);
}

for FuncDeclNodeLocArgs(tm0) in self.new_func_decl_node_loc_def.drain(..) {
    model.define_func_decl_node_loc(tm0);
}

for CtorDeclNodeLocArgs(tm0) in self.new_ctor_decl_node_loc_def.drain(..) {
    model.define_ctor_decl_node_loc(tm0);
}

for EnumDeclNodeLocArgs(tm0) in self.new_enum_decl_node_loc_def.drain(..) {
    model.define_enum_decl_node_loc(tm0);
}

for ModelDeclNodeLocArgs(tm0) in self.new_model_decl_node_loc_def.drain(..) {
    model.define_model_decl_node_loc(tm0);
}

for TermNodeLocArgs(tm0) in self.new_term_node_loc_def.drain(..) {
    model.define_term_node_loc(tm0);
}

for TermListNodeLocArgs(tm0) in self.new_term_list_node_loc_def.drain(..) {
    model.define_term_list_node_loc(tm0);
}

for MatchCaseNodeLocArgs(tm0) in self.new_match_case_node_loc_def.drain(..) {
    model.define_match_case_node_loc(tm0);
}

for OptTermNodeLocArgs(tm0) in self.new_opt_term_node_loc_def.drain(..) {
    model.define_opt_term_node_loc(tm0);
}

for IfAtomNodeLocArgs(tm0) in self.new_if_atom_node_loc_def.drain(..) {
    model.define_if_atom_node_loc(tm0);
}

for ThenAtomNodeLocArgs(tm0) in self.new_then_atom_node_loc_def.drain(..) {
    model.define_then_atom_node_loc(tm0);
}

for StmtNodeLocArgs(tm0) in self.new_stmt_node_loc_def.drain(..) {
    model.define_stmt_node_loc(tm0);
}

for StmtListNodeLocArgs(tm0) in self.new_stmt_list_node_loc_def.drain(..) {
    model.define_stmt_list_node_loc(tm0);
}

for RuleDeclNodeLocArgs(tm0) in self.new_rule_decl_node_loc_def.drain(..) {
    model.define_rule_decl_node_loc(tm0);
}

for DeclNodeLocArgs(tm0) in self.new_decl_node_loc_def.drain(..) {
    model.define_decl_node_loc(tm0);
}

for DeclListNodeLocArgs(tm0) in self.new_decl_list_node_loc_def.drain(..) {
    model.define_decl_list_node_loc(tm0);
}

for ModuleNodeLocArgs(tm0) in self.new_module_node_loc_def.drain(..) {
    model.define_module_node_loc(tm0);
}

for TypeExprNodeLocArgs(tm0) in self.new_type_expr_node_loc_def.drain(..) {
    model.define_type_expr_node_loc(tm0);
}

for RuleDescendantRuleArgs(tm0) in self.new_rule_descendant_rule_def.drain(..) {
    model.define_rule_descendant_rule(tm0);
}

for RuleDescendantTermArgs(tm0) in self.new_rule_descendant_term_def.drain(..) {
    model.define_rule_descendant_term(tm0);
}

for RuleDescendantTermListArgs(tm0) in self.new_rule_descendant_term_list_def.drain(..) {
    model.define_rule_descendant_term_list(tm0);
}

for RuleDescendantOptTermArgs(tm0) in self.new_rule_descendant_opt_term_def.drain(..) {
    model.define_rule_descendant_opt_term(tm0);
}

for RuleDescendantIfAtomArgs(tm0) in self.new_rule_descendant_if_atom_def.drain(..) {
    model.define_rule_descendant_if_atom(tm0);
}

for RuleDescendantThenAtomArgs(tm0) in self.new_rule_descendant_then_atom_def.drain(..) {
    model.define_rule_descendant_then_atom(tm0);
}

for RuleDescendantMatchCaseArgs(tm0) in self.new_rule_descendant_match_case_def.drain(..) {
    model.define_rule_descendant_match_case(tm0);
}

for RuleDescendantMatchCaseListArgs(tm0) in self.new_rule_descendant_match_case_list_def.drain(..) {
    model.define_rule_descendant_match_case_list(tm0);
}

for RuleDescendantStmtArgs(tm0) in self.new_rule_descendant_stmt_def.drain(..) {
    model.define_rule_descendant_stmt(tm0);
}

for RuleDescendantStmtListArgs(tm0) in self.new_rule_descendant_stmt_list_def.drain(..) {
    model.define_rule_descendant_stmt_list(tm0);
}

for RuleDescendantStmtBlockListArgs(tm0) in self.new_rule_descendant_stmt_block_list_def.drain(..) {
    model.define_rule_descendant_stmt_block_list(tm0);
}

for RuleDescendantTypeExprArgs(tm0) in self.new_rule_descendant_type_expr_def.drain(..) {
    model.define_rule_descendant_type_expr(tm0);
}

for EntryScopeArgs(tm0) in self.new_entry_scope_def.drain(..) {
    model.define_entry_scope(tm0);
}

for ExitScopeArgs(tm0) in self.new_exit_scope_def.drain(..) {
    model.define_exit_scope(tm0);
}

for CtorEnumArgs(tm0) in self.new_ctor_enum_def.drain(..) {
    model.define_ctor_enum(tm0);
}

for CtorsEnumArgs(tm0) in self.new_ctors_enum_def.drain(..) {
    model.define_ctors_enum(tm0);
}

for CasesDiscrimineeArgs(tm0) in self.new_cases_discriminee_def.drain(..) {
    model.define_cases_discriminee(tm0);
}

for CaseDiscrimineeArgs(tm0) in self.new_case_discriminee_def.drain(..) {
    model.define_case_discriminee(tm0);
}

for DesugaredCaseEqualityAtomArgs(tm0) in self.new_desugared_case_equality_atom_def.drain(..) {
    model.define_desugared_case_equality_atom(tm0);
}

for DesugaredCaseEqualityStmtArgs(tm0) in self.new_desugared_case_equality_stmt_def.drain(..) {
    model.define_desugared_case_equality_stmt(tm0);
}

for DesugaredCaseBlockArgs(tm0) in self.new_desugared_case_block_def.drain(..) {
    model.define_desugared_case_block(tm0);
}

for DesugaredCaseBlockListArgs(tm0) in self.new_desugared_case_block_list_def.drain(..) {
    model.define_desugared_case_block_list(tm0);
}

for NilTypeListArgs() in self.new_nil_type_list_def.drain(..) {
    model.define_nil_type_list();
}

for ConsTypeListArgs(tm0, tm1) in self.new_cons_type_list_def.drain(..) {
    model.define_cons_type_list(tm0, tm1);
}

for SnocTypeListArgs(tm0, tm1) in self.new_snoc_type_list_def.drain(..) {
    model.define_snoc_type_list(tm0, tm1);
}

for SemanticTypeArgs(tm0, tm1) in self.new_semantic_type_def.drain(..) {
    model.define_semantic_type(tm0, tm1);
}

for DeclSymbolScopeArgs(tm0) in self.new_decl_symbol_scope_def.drain(..) {
    model.define_decl_symbol_scope(tm0);
}

for MorTypeArgs(tm0) in self.new_mor_type_def.drain(..) {
    model.define_mor_type(tm0);
}

for MorTypeDomFuncArgs(tm0) in self.new_mor_type_dom_func_def.drain(..) {
    model.define_mor_type_dom_func(tm0);
}

for MorTypeCodFuncArgs(tm0) in self.new_mor_type_cod_func_def.drain(..) {
    model.define_mor_type_cod_func(tm0);
}

for TypeDefinitionSymbolScopeArgs(tm0) in self.new_type_definition_symbol_scope_def.drain(..) {
    model.define_type_definition_symbol_scope(tm0);
}

for FuncRelArgs(tm0) in self.new_func_rel_def.drain(..) {
    model.define_func_rel(tm0);
}

for RelDefinitionSymbolScopeArgs(tm0) in self.new_rel_definition_symbol_scope_def.drain(..) {
    model.define_rel_definition_symbol_scope(tm0);
}

for CodomainArgs(tm0) in self.new_codomain_def.drain(..) {
    model.define_codomain(tm0);
}

for TypeNameArgs(tm0) in self.new_type_name_def.drain(..) {
    model.define_type_name(tm0);
}

for VirtualSymbolScopeArgs() in self.new_virtual_symbol_scope_def.drain(..) {
    model.define_virtual_symbol_scope();
}

for ParentModelFuncArgs(tm0) in self.new_parent_model_func_def.drain(..) {
    model.define_parent_model_func(tm0);
}

for SymbolScopeModelArgs(tm0) in self.new_symbol_scope_model_def.drain(..) {
    model.define_symbol_scope_model(tm0);
}

for SemanticSignatureTypeExprArgs(tm0, tm1) in self.new_semantic_signature_type_expr_def.drain(..) {
    model.define_semantic_signature_type_expr(tm0, tm1);
}

for TypeSymbolArgs() in self.new_type_symbol_def.drain(..) {
    model.define_type_symbol();
}

for EnumSymbolArgs() in self.new_enum_symbol_def.drain(..) {
    model.define_enum_symbol();
}

for ModelSymbolArgs() in self.new_model_symbol_def.drain(..) {
    model.define_model_symbol();
}

for SemanticArgTypeArgs(tm0) in self.new_semantic_arg_type_def.drain(..) {
    model.define_semantic_arg_type(tm0);
}

for ArgSymbolScopeArgs(tm0) in self.new_arg_symbol_scope_def.drain(..) {
    model.define_arg_symbol_scope(tm0);
}

for SemanticPredArgs(tm0, tm1) in self.new_semantic_pred_def.drain(..) {
    model.define_semantic_pred(tm0, tm1);
}

for SemanticFuncArgs(tm0, tm1) in self.new_semantic_func_def.drain(..) {
    model.define_semantic_func(tm0, tm1);
}

for CtorSymbolScopeArgs(tm0) in self.new_ctor_symbol_scope_def.drain(..) {
    model.define_ctor_symbol_scope(tm0);
}

for PredRelArgs(tm0) in self.new_pred_rel_def.drain(..) {
    model.define_pred_rel(tm0);
}

for RelNameArgs(tm0) in self.new_rel_name_def.drain(..) {
    model.define_rel_name(tm0);
}

for DomArgs(tm0) in self.new_dom_def.drain(..) {
    model.define_dom(tm0);
}

for CodArgs(tm0) in self.new_cod_def.drain(..) {
    model.define_cod(tm0);
}

for ModuleSymbolScopeArgs(tm0) in self.new_module_symbol_scope_def.drain(..) {
    model.define_module_symbol_scope(tm0);
}

for NilElListArgs(tm0) in self.new_nil_el_list_def.drain(..) {
    model.define_nil_el_list(tm0);
}

for ConsElListArgs(tm0, tm1) in self.new_cons_el_list_def.drain(..) {
    model.define_cons_el_list(tm0, tm1);
}

for SnocElListArgs(tm0, tm1) in self.new_snoc_el_list_def.drain(..) {
    model.define_snoc_el_list(tm0, tm1);
}

for ElStructureArgs(tm0) in self.new_el_structure_def.drain(..) {
    model.define_el_structure(tm0);
}

for ElsStructureArgs(tm0) in self.new_els_structure_def.drain(..) {
    model.define_els_structure(tm0);
}

for AmbientTypeArgs(tm0) in self.new_ambient_type_def.drain(..) {
    model.define_ambient_type(tm0);
}

for InstantiatedTypeArgs(tm0, tm1) in self.new_instantiated_type_def.drain(..) {
    model.define_instantiated_type(tm0, tm1);
}

for UnderlyingTypeArgs(tm0) in self.new_underlying_type_def.drain(..) {
    model.define_underlying_type(tm0);
}

for NilElementTypeListArgs() in self.new_nil_element_type_list_def.drain(..) {
    model.define_nil_element_type_list();
}

for ConsElementTypeListArgs(tm0, tm1) in self.new_cons_element_type_list_def.drain(..) {
    model.define_cons_element_type_list(tm0, tm1);
}

for SnocElementTypeListArgs(tm0, tm1) in self.new_snoc_element_type_list_def.drain(..) {
    model.define_snoc_element_type_list(tm0, tm1);
}

for FuncAppArgs(tm0, tm1) in self.new_func_app_def.drain(..) {
    model.define_func_app(tm0, tm1);
}

for MapElArgs(tm0, tm1) in self.new_map_el_def.drain(..) {
    model.define_map_el(tm0, tm1);
}

for AmbientModelElArgs(tm0, tm1) in self.new_ambient_model_el_def.drain(..) {
    model.define_ambient_model_el(tm0, tm1);
}

for PredSymbolArgs() in self.new_pred_symbol_def.drain(..) {
    model.define_pred_symbol();
}

for FuncSymbolArgs() in self.new_func_symbol_def.drain(..) {
    model.define_func_symbol();
}

for RuleSymbolArgs() in self.new_rule_symbol_def.drain(..) {
    model.define_rule_symbol();
}

for CtorSymbolArgs() in self.new_ctor_symbol_def.drain(..) {
    model.define_ctor_symbol();
}

for SymbolScopeParentArgs(tm0) in self.new_symbol_scope_parent_def.drain(..) {
    model.define_symbol_scope_parent(tm0);
}

for DeclsSymbolScopeArgs(tm0) in self.new_decls_symbol_scope_def.drain(..) {
    model.define_decls_symbol_scope(tm0);
}

for ArgsSymbolScopeArgs(tm0) in self.new_args_symbol_scope_def.drain(..) {
    model.define_args_symbol_scope(tm0);
}

for CtorsSymbolScopeArgs(tm0) in self.new_ctors_symbol_scope_def.drain(..) {
    model.define_ctors_symbol_scope(tm0);
}

for ModelMemberSymbolScopeArgs(tm0) in self.new_model_member_symbol_scope_def.drain(..) {
    model.define_model_member_symbol_scope(tm0);
}

for SymbolScopeNameArgs(tm0) in self.new_symbol_scope_name_def.drain(..) {
    model.define_symbol_scope_name(tm0);
}

for ScopeSymbolsArgs(tm0) in self.new_scope_symbols_def.drain(..) {
    model.define_scope_symbols(tm0);
}

for SemanticElArgs(tm0, tm1) in self.new_semantic_el_def.drain(..) {
    model.define_semantic_el(tm0, tm1);
}

for ZeroArgs() in self.new_zero_def.drain(..) {
    model.define_zero();
}

for SuccArgs(tm0) in self.new_succ_def.drain(..) {
    model.define_succ(tm0);
}

for TypeListLenArgs(tm0) in self.new_type_list_len_def.drain(..) {
    model.define_type_list_len(tm0);
}

for TermListLenArgs(tm0) in self.new_term_list_len_def.drain(..) {
    model.define_term_list_len(tm0);
}

for BeforeRuleStructureArgs(tm0) in self.new_before_rule_structure_def.drain(..) {
    model.define_before_rule_structure(tm0);
}

for AmbientModelElStructureArgs(tm0) in self.new_ambient_model_el_structure_def.drain(..) {
    model.define_ambient_model_el_structure(tm0);
}

for AmbientModelElMorphismArgs(tm0) in self.new_ambient_model_el_morphism_def.drain(..) {
    model.define_ambient_model_el_morphism(tm0);
}

for IfAtomMorphismArgs(tm0, tm1) in self.new_if_atom_morphism_def.drain(..) {
    model.define_if_atom_morphism(tm0, tm1);
}

for ThenAtomMorphismArgs(tm0, tm1) in self.new_then_atom_morphism_def.drain(..) {
    model.define_then_atom_morphism(tm0, tm1);
}

for BranchStmtMorphismArgs(tm0, tm1) in self.new_branch_stmt_morphism_def.drain(..) {
    model.define_branch_stmt_morphism(tm0, tm1);
}

for MatchStmtMorphismArgs(tm0, tm1) in self.new_match_stmt_morphism_def.drain(..) {
    model.define_match_stmt_morphism(tm0, tm1);
}

for SemanticNameArgs(tm0, tm1) in self.new_semantic_name_def.drain(..) {
    model.define_semantic_name(tm0, tm1);
}

for WildcardNameArgs(tm0) in self.new_wildcard_name_def.drain(..) {
    model.define_wildcard_name(tm0);
}

for RelAppParentModelElArgs(tm0, tm1) in self.new_rel_app_parent_model_el_def.drain(..) {
    model.define_rel_app_parent_model_el(tm0, tm1);
}

for MatchCasePatternCtorArgs(tm0) in self.new_match_case_pattern_ctor_def.drain(..) {
    model.define_match_case_pattern_ctor(tm0);
}

for CasesDeterminedEnumArgs(tm0) in self.new_cases_determined_enum_def.drain(..) {
    model.define_cases_determined_enum(tm0);
}

}
}

impl Eqlog {
/// Creates an empty model.
#[allow(dead_code)]
pub fn new() -> Self {
Self {
ident_equalities: Unification::new(),
ident_weights: Vec::new(),
ident_new: BTreeSet::new(),
ident_old: BTreeSet::new(),
ident_uprooted: Vec::new(),
virt_ident_equalities: Unification::new(),
virt_ident_weights: Vec::new(),
virt_ident_new: BTreeSet::new(),
virt_ident_old: BTreeSet::new(),
virt_ident_uprooted: Vec::new(),
type_decl_node_equalities: Unification::new(),
type_decl_node_weights: Vec::new(),
type_decl_node_new: BTreeSet::new(),
type_decl_node_old: BTreeSet::new(),
type_decl_node_uprooted: Vec::new(),
arg_decl_node_equalities: Unification::new(),
arg_decl_node_weights: Vec::new(),
arg_decl_node_new: BTreeSet::new(),
arg_decl_node_old: BTreeSet::new(),
arg_decl_node_uprooted: Vec::new(),
type_expr_node_equalities: Unification::new(),
type_expr_node_weights: Vec::new(),
type_expr_node_new: BTreeSet::new(),
type_expr_node_old: BTreeSet::new(),
type_expr_node_uprooted: Vec::new(),
arg_decl_list_node_equalities: Unification::new(),
arg_decl_list_node_weights: Vec::new(),
arg_decl_list_node_new: BTreeSet::new(),
arg_decl_list_node_old: BTreeSet::new(),
arg_decl_list_node_uprooted: Vec::new(),
pred_decl_node_equalities: Unification::new(),
pred_decl_node_weights: Vec::new(),
pred_decl_node_new: BTreeSet::new(),
pred_decl_node_old: BTreeSet::new(),
pred_decl_node_uprooted: Vec::new(),
func_decl_node_equalities: Unification::new(),
func_decl_node_weights: Vec::new(),
func_decl_node_new: BTreeSet::new(),
func_decl_node_old: BTreeSet::new(),
func_decl_node_uprooted: Vec::new(),
ctor_decl_node_equalities: Unification::new(),
ctor_decl_node_weights: Vec::new(),
ctor_decl_node_new: BTreeSet::new(),
ctor_decl_node_old: BTreeSet::new(),
ctor_decl_node_uprooted: Vec::new(),
ctor_decl_list_node_equalities: Unification::new(),
ctor_decl_list_node_weights: Vec::new(),
ctor_decl_list_node_new: BTreeSet::new(),
ctor_decl_list_node_old: BTreeSet::new(),
ctor_decl_list_node_uprooted: Vec::new(),
enum_decl_node_equalities: Unification::new(),
enum_decl_node_weights: Vec::new(),
enum_decl_node_new: BTreeSet::new(),
enum_decl_node_old: BTreeSet::new(),
enum_decl_node_uprooted: Vec::new(),
term_node_equalities: Unification::new(),
term_node_weights: Vec::new(),
term_node_new: BTreeSet::new(),
term_node_old: BTreeSet::new(),
term_node_uprooted: Vec::new(),
term_list_node_equalities: Unification::new(),
term_list_node_weights: Vec::new(),
term_list_node_new: BTreeSet::new(),
term_list_node_old: BTreeSet::new(),
term_list_node_uprooted: Vec::new(),
opt_term_node_equalities: Unification::new(),
opt_term_node_weights: Vec::new(),
opt_term_node_new: BTreeSet::new(),
opt_term_node_old: BTreeSet::new(),
opt_term_node_uprooted: Vec::new(),
match_case_node_equalities: Unification::new(),
match_case_node_weights: Vec::new(),
match_case_node_new: BTreeSet::new(),
match_case_node_old: BTreeSet::new(),
match_case_node_uprooted: Vec::new(),
stmt_list_node_equalities: Unification::new(),
stmt_list_node_weights: Vec::new(),
stmt_list_node_new: BTreeSet::new(),
stmt_list_node_old: BTreeSet::new(),
stmt_list_node_uprooted: Vec::new(),
match_case_list_node_equalities: Unification::new(),
match_case_list_node_weights: Vec::new(),
match_case_list_node_new: BTreeSet::new(),
match_case_list_node_old: BTreeSet::new(),
match_case_list_node_uprooted: Vec::new(),
if_atom_node_equalities: Unification::new(),
if_atom_node_weights: Vec::new(),
if_atom_node_new: BTreeSet::new(),
if_atom_node_old: BTreeSet::new(),
if_atom_node_uprooted: Vec::new(),
then_atom_node_equalities: Unification::new(),
then_atom_node_weights: Vec::new(),
then_atom_node_new: BTreeSet::new(),
then_atom_node_old: BTreeSet::new(),
then_atom_node_uprooted: Vec::new(),
stmt_node_equalities: Unification::new(),
stmt_node_weights: Vec::new(),
stmt_node_new: BTreeSet::new(),
stmt_node_old: BTreeSet::new(),
stmt_node_uprooted: Vec::new(),
stmt_block_list_node_equalities: Unification::new(),
stmt_block_list_node_weights: Vec::new(),
stmt_block_list_node_new: BTreeSet::new(),
stmt_block_list_node_old: BTreeSet::new(),
stmt_block_list_node_uprooted: Vec::new(),
rule_decl_node_equalities: Unification::new(),
rule_decl_node_weights: Vec::new(),
rule_decl_node_new: BTreeSet::new(),
rule_decl_node_old: BTreeSet::new(),
rule_decl_node_uprooted: Vec::new(),
model_decl_node_equalities: Unification::new(),
model_decl_node_weights: Vec::new(),
model_decl_node_new: BTreeSet::new(),
model_decl_node_old: BTreeSet::new(),
model_decl_node_uprooted: Vec::new(),
decl_list_node_equalities: Unification::new(),
decl_list_node_weights: Vec::new(),
decl_list_node_new: BTreeSet::new(),
decl_list_node_old: BTreeSet::new(),
decl_list_node_uprooted: Vec::new(),
decl_node_equalities: Unification::new(),
decl_node_weights: Vec::new(),
decl_node_new: BTreeSet::new(),
decl_node_old: BTreeSet::new(),
decl_node_uprooted: Vec::new(),
module_node_equalities: Unification::new(),
module_node_weights: Vec::new(),
module_node_new: BTreeSet::new(),
module_node_old: BTreeSet::new(),
module_node_uprooted: Vec::new(),
loc_equalities: Unification::new(),
loc_weights: Vec::new(),
loc_new: BTreeSet::new(),
loc_old: BTreeSet::new(),
loc_uprooted: Vec::new(),
rule_descendant_node_equalities: Unification::new(),
rule_descendant_node_weights: Vec::new(),
rule_descendant_node_new: BTreeSet::new(),
rule_descendant_node_old: BTreeSet::new(),
rule_descendant_node_uprooted: Vec::new(),
scope_equalities: Unification::new(),
scope_weights: Vec::new(),
scope_new: BTreeSet::new(),
scope_old: BTreeSet::new(),
scope_uprooted: Vec::new(),
type_equalities: Unification::new(),
type_weights: Vec::new(),
type_new: BTreeSet::new(),
type_old: BTreeSet::new(),
type_uprooted: Vec::new(),
type_list_equalities: Unification::new(),
type_list_weights: Vec::new(),
type_list_new: BTreeSet::new(),
type_list_old: BTreeSet::new(),
type_list_uprooted: Vec::new(),
symbol_scope_equalities: Unification::new(),
symbol_scope_weights: Vec::new(),
symbol_scope_new: BTreeSet::new(),
symbol_scope_old: BTreeSet::new(),
symbol_scope_uprooted: Vec::new(),
func_equalities: Unification::new(),
func_weights: Vec::new(),
func_new: BTreeSet::new(),
func_old: BTreeSet::new(),
func_uprooted: Vec::new(),
pred_equalities: Unification::new(),
pred_weights: Vec::new(),
pred_new: BTreeSet::new(),
pred_old: BTreeSet::new(),
pred_uprooted: Vec::new(),
rel_equalities: Unification::new(),
rel_weights: Vec::new(),
rel_new: BTreeSet::new(),
rel_old: BTreeSet::new(),
rel_uprooted: Vec::new(),
structure_equalities: Unification::new(),
structure_weights: Vec::new(),
structure_new: BTreeSet::new(),
structure_old: BTreeSet::new(),
structure_uprooted: Vec::new(),
el_equalities: Unification::new(),
el_weights: Vec::new(),
el_new: BTreeSet::new(),
el_old: BTreeSet::new(),
el_uprooted: Vec::new(),
el_list_equalities: Unification::new(),
el_list_weights: Vec::new(),
el_list_new: BTreeSet::new(),
el_list_old: BTreeSet::new(),
el_list_uprooted: Vec::new(),
el_name_equalities: Unification::new(),
el_name_weights: Vec::new(),
el_name_new: BTreeSet::new(),
el_name_old: BTreeSet::new(),
el_name_uprooted: Vec::new(),
element_type_equalities: Unification::new(),
element_type_weights: Vec::new(),
element_type_new: BTreeSet::new(),
element_type_old: BTreeSet::new(),
element_type_uprooted: Vec::new(),
element_type_list_equalities: Unification::new(),
element_type_list_weights: Vec::new(),
element_type_list_new: BTreeSet::new(),
element_type_list_old: BTreeSet::new(),
element_type_list_uprooted: Vec::new(),
morphism_equalities: Unification::new(),
morphism_weights: Vec::new(),
morphism_new: BTreeSet::new(),
morphism_old: BTreeSet::new(),
morphism_uprooted: Vec::new(),
symbol_kind_equalities: Unification::new(),
symbol_kind_weights: Vec::new(),
symbol_kind_new: BTreeSet::new(),
symbol_kind_old: BTreeSet::new(),
symbol_kind_uprooted: Vec::new(),
nat_equalities: Unification::new(),
nat_weights: Vec::new(),
nat_new: BTreeSet::new(),
nat_old: BTreeSet::new(),
nat_uprooted: Vec::new(),
absurd: AbsurdTable::new(),type_decl: TypeDeclTable::new(),arg_decl_node_name: ArgDeclNodeNameTable::new(),arg_decl_node_type: ArgDeclNodeTypeTable::new(),nil_arg_decl_list_node: NilArgDeclListNodeTable::new(),cons_arg_decl_list_node: ConsArgDeclListNodeTable::new(),pred_decl: PredDeclTable::new(),func_decl: FuncDeclTable::new(),ctor_decl: CtorDeclTable::new(),nil_ctor_decl_list_node: NilCtorDeclListNodeTable::new(),cons_ctor_decl_list_node: ConsCtorDeclListNodeTable::new(),enum_decl: EnumDeclTable::new(),nil_term_list_node: NilTermListNodeTable::new(),cons_term_list_node: ConsTermListNodeTable::new(),ambient_type_expr: AmbientTypeExprTable::new(),member_type_expr: MemberTypeExprTable::new(),mor_type_expr: MorTypeExprTable::new(),none_term_node: NoneTermNodeTable::new(),some_term_node: SomeTermNodeTable::new(),var_term_node: VarTermNodeTable::new(),wildcard_term_node: WildcardTermNodeTable::new(),app_term_node: AppTermNodeTable::new(),match_case: MatchCaseTable::new(),nil_match_case_list_node: NilMatchCaseListNodeTable::new(),cons_match_case_list_node: ConsMatchCaseListNodeTable::new(),equal_if_atom_node: EqualIfAtomNodeTable::new(),defined_if_atom_node: DefinedIfAtomNodeTable::new(),pred_if_atom_node: PredIfAtomNodeTable::new(),var_if_atom_node: VarIfAtomNodeTable::new(),equal_then_atom_node: EqualThenAtomNodeTable::new(),defined_then_atom_node: DefinedThenAtomNodeTable::new(),pred_then_atom_node: PredThenAtomNodeTable::new(),if_stmt_node: IfStmtNodeTable::new(),then_stmt_node: ThenStmtNodeTable::new(),branch_stmt_node: BranchStmtNodeTable::new(),match_stmt_node: MatchStmtNodeTable::new(),nil_stmt_list_node: NilStmtListNodeTable::new(),cons_stmt_list_node: ConsStmtListNodeTable::new(),nil_stmt_block_list_node: NilStmtBlockListNodeTable::new(),cons_stmt_block_list_node: ConsStmtBlockListNodeTable::new(),rule_decl: RuleDeclTable::new(),model_decl: ModelDeclTable::new(),decl_node_type: DeclNodeTypeTable::new(),decl_node_pred: DeclNodePredTable::new(),decl_node_func: DeclNodeFuncTable::new(),decl_node_rule: DeclNodeRuleTable::new(),decl_node_enum: DeclNodeEnumTable::new(),decl_node_model: DeclNodeModelTable::new(),nil_decl_list_node: NilDeclListNodeTable::new(),cons_decl_list_node: ConsDeclListNodeTable::new(),decls_module_node: DeclsModuleNodeTable::new(),var_in_scope: VarInScopeTable::new(),scope_extension: ScopeExtensionTable::new(),scope_single_child: ScopeSingleChildTable::new(),scope_extension_siblings: ScopeExtensionSiblingsTable::new(),is_normal_type: IsNormalTypeTable::new(),is_enum_type: IsEnumTypeTable::new(),is_model_type: IsModelTypeTable::new(),is_mor_type: IsMorTypeTable::new(),illegal_member_type_expr_in_signature: IllegalMemberTypeExprInSignatureTable::new(),is_total_func: IsTotalFuncTable::new(),rel_app: RelAppTable::new(),el_type: ElTypeTable::new(),el_types: ElTypesTable::new(),constrained_el: ConstrainedElTable::new(),constrained_els: ConstrainedElsTable::new(),in_ker: InKerTable::new(),el_in_img: ElInImgTable::new(),rel_tuple_in_img: RelTupleInImgTable::new(),symbol_scope_extension: SymbolScopeExtensionTable::new(),symbol_scope_ancestor: SymbolScopeAncestorTable::new(),element_member_symbol_scope: ElementMemberSymbolScopeTable::new(),defined_symbol: DefinedSymbolTable::new(),accessible_symbol: AccessibleSymbolTable::new(),should_be_symbol: ShouldBeSymbolTable::new(),should_be_symbol_2: ShouldBeSymbol2Table::new(),should_be_symbol_3: ShouldBeSymbol3Table::new(),pred_arg_num_should_match: PredArgNumShouldMatchTable::new(),func_arg_num_should_match: FuncArgNumShouldMatchTable::new(),cfg_edge: CfgEdgeTable::new(),cfg_edge_stmts_stmt: CfgEdgeStmtsStmtTable::new(),cfg_edge_stmt_stmts: CfgEdgeStmtStmtsTable::new(),cfg_edge_fork: CfgEdgeForkTable::new(),cfg_edge_join: CfgEdgeJoinTable::new(),before_stmt_structure: BeforeStmtStructureTable::new(),stmt_morphism: StmtMorphismTable::new(),if_morphism: IfMorphismTable::new(),surj_then_morphism: SurjThenMorphismTable::new(),non_surj_then_morphism: NonSurjThenMorphismTable::new(),noop_morphism: NoopMorphismTable::new(),stmt_structure: StmtStructureTable::new(),if_atom_structure: IfAtomStructureTable::new(),then_atom_structure: ThenAtomStructureTable::new(),term_structure: TermStructureTable::new(),terms_structure: TermsStructureTable::new(),opt_term_structure: OptTermStructureTable::new(),type_expr_structure: TypeExprStructureTable::new(),term_should_be_epic_ok: TermShouldBeEpicOkTable::new(),terms_should_be_epic_ok: TermsShouldBeEpicOkTable::new(),el_should_be_surjective_ok: ElShouldBeSurjectiveOkTable::new(),el_is_surjective_ok: ElIsSurjectiveOkTable::new(),should_be_obtained_by_ctor: ShouldBeObtainedByCtorTable::new(),is_given_by_ctor: IsGivenByCtorTable::new(),function_can_be_made_defined: FunctionCanBeMadeDefinedTable::new(),case_pattern_is_variable: CasePatternIsVariableTable::new(),case_pattern_is_wildcard: CasePatternIsWildcardTable::new(),is_pattern_ctor_arg: IsPatternCtorArgTable::new(),are_pattern_ctor_args: ArePatternCtorArgsTable::new(),pattern_ctor_arg_is_app: PatternCtorArgIsAppTable::new(),pattern_ctor_arg_var_is_not_fresh: PatternCtorArgVarIsNotFreshTable::new(),cases_contain_ctor: CasesContainCtorTable::new(),match_stmt_contains_ctor_of_enum: MatchStmtContainsCtorOfEnumTable::new(),match_stmt_should_contain_ctor: MatchStmtShouldContainCtorTable::new(),match_stmt_contains_ctor: MatchStmtContainsCtorTable::new(),real_virt_ident: RealVirtIdentTable::new(),virt_real_ident: VirtRealIdentTable::new(),var: VarTable::new(),rule_name: RuleNameTable::new(),module_name: ModuleNameTable::new(),type_decl_node_loc: TypeDeclNodeLocTable::new(),arg_decl_node_loc: ArgDeclNodeLocTable::new(),arg_decl_list_node_loc: ArgDeclListNodeLocTable::new(),pred_decl_node_loc: PredDeclNodeLocTable::new(),func_decl_node_loc: FuncDeclNodeLocTable::new(),ctor_decl_node_loc: CtorDeclNodeLocTable::new(),enum_decl_node_loc: EnumDeclNodeLocTable::new(),model_decl_node_loc: ModelDeclNodeLocTable::new(),term_node_loc: TermNodeLocTable::new(),term_list_node_loc: TermListNodeLocTable::new(),match_case_node_loc: MatchCaseNodeLocTable::new(),opt_term_node_loc: OptTermNodeLocTable::new(),if_atom_node_loc: IfAtomNodeLocTable::new(),then_atom_node_loc: ThenAtomNodeLocTable::new(),stmt_node_loc: StmtNodeLocTable::new(),stmt_list_node_loc: StmtListNodeLocTable::new(),rule_decl_node_loc: RuleDeclNodeLocTable::new(),decl_node_loc: DeclNodeLocTable::new(),decl_list_node_loc: DeclListNodeLocTable::new(),module_node_loc: ModuleNodeLocTable::new(),type_expr_node_loc: TypeExprNodeLocTable::new(),rule_descendant_rule: RuleDescendantRuleTable::new(),rule_descendant_term: RuleDescendantTermTable::new(),rule_descendant_term_list: RuleDescendantTermListTable::new(),rule_descendant_opt_term: RuleDescendantOptTermTable::new(),rule_descendant_if_atom: RuleDescendantIfAtomTable::new(),rule_descendant_then_atom: RuleDescendantThenAtomTable::new(),rule_descendant_match_case: RuleDescendantMatchCaseTable::new(),rule_descendant_match_case_list: RuleDescendantMatchCaseListTable::new(),rule_descendant_stmt: RuleDescendantStmtTable::new(),rule_descendant_stmt_list: RuleDescendantStmtListTable::new(),rule_descendant_stmt_block_list: RuleDescendantStmtBlockListTable::new(),rule_descendant_type_expr: RuleDescendantTypeExprTable::new(),entry_scope: EntryScopeTable::new(),exit_scope: ExitScopeTable::new(),ctor_enum: CtorEnumTable::new(),ctors_enum: CtorsEnumTable::new(),cases_discriminee: CasesDiscrimineeTable::new(),case_discriminee: CaseDiscrimineeTable::new(),desugared_case_equality_atom: DesugaredCaseEqualityAtomTable::new(),desugared_case_equality_stmt: DesugaredCaseEqualityStmtTable::new(),desugared_case_block: DesugaredCaseBlockTable::new(),desugared_case_block_list: DesugaredCaseBlockListTable::new(),nil_type_list: NilTypeListTable::new(),cons_type_list: ConsTypeListTable::new(),snoc_type_list: SnocTypeListTable::new(),semantic_type: SemanticTypeTable::new(),decl_symbol_scope: DeclSymbolScopeTable::new(),mor_type: MorTypeTable::new(),mor_type_dom_func: MorTypeDomFuncTable::new(),mor_type_cod_func: MorTypeCodFuncTable::new(),type_definition_symbol_scope: TypeDefinitionSymbolScopeTable::new(),func_rel: FuncRelTable::new(),rel_definition_symbol_scope: RelDefinitionSymbolScopeTable::new(),domain: DomainTable::new(),codomain: CodomainTable::new(),type_name: TypeNameTable::new(),virtual_symbol_scope: VirtualSymbolScopeTable::new(),parent_model_func: ParentModelFuncTable::new(),symbol_scope_model: SymbolScopeModelTable::new(),flat_domain: FlatDomainTable::new(),semantic_signature_type_expr: SemanticSignatureTypeExprTable::new(),type_symbol: TypeSymbolTable::new(),enum_symbol: EnumSymbolTable::new(),model_symbol: ModelSymbolTable::new(),semantic_arg_type: SemanticArgTypeTable::new(),arg_symbol_scope: ArgSymbolScopeTable::new(),semantic_arg_types: SemanticArgTypesTable::new(),semantic_pred: SemanticPredTable::new(),pred_arity: PredArityTable::new(),semantic_func: SemanticFuncTable::new(),ctor_symbol_scope: CtorSymbolScopeTable::new(),pred_rel: PredRelTable::new(),rel_name: RelNameTable::new(),arity: ArityTable::new(),dom: DomTable::new(),cod: CodTable::new(),flat_arity: FlatArityTable::new(),module_symbol_scope: ModuleSymbolScopeTable::new(),nil_el_list: NilElListTable::new(),cons_el_list: ConsElListTable::new(),snoc_el_list: SnocElListTable::new(),el_structure: ElStructureTable::new(),els_structure: ElsStructureTable::new(),ambient_type: AmbientTypeTable::new(),instantiated_type: InstantiatedTypeTable::new(),underlying_type: UnderlyingTypeTable::new(),nil_element_type_list: NilElementTypeListTable::new(),cons_element_type_list: ConsElementTypeListTable::new(),snoc_element_type_list: SnocElementTypeListTable::new(),ambient_el_type_list: AmbientElTypeListTable::new(),func_app: FuncAppTable::new(),map_el: MapElTable::new(),map_els: MapElsTable::new(),ambient_model_el: AmbientModelElTable::new(),pred_symbol: PredSymbolTable::new(),func_symbol: FuncSymbolTable::new(),rule_symbol: RuleSymbolTable::new(),ctor_symbol: CtorSymbolTable::new(),symbol_scope_parent: SymbolScopeParentTable::new(),decls_symbol_scope: DeclsSymbolScopeTable::new(),args_symbol_scope: ArgsSymbolScopeTable::new(),ctors_symbol_scope: CtorsSymbolScopeTable::new(),model_member_symbol_scope: ModelMemberSymbolScopeTable::new(),symbol_scope_name: SymbolScopeNameTable::new(),scope_symbols: ScopeSymbolsTable::new(),semantic_el: SemanticElTable::new(),zero: ZeroTable::new(),succ: SuccTable::new(),type_list_len: TypeListLenTable::new(),term_list_len: TermListLenTable::new(),before_rule_structure: BeforeRuleStructureTable::new(),ambient_model_el_structure: AmbientModelElStructureTable::new(),ambient_model_el_morphism: AmbientModelElMorphismTable::new(),if_atom_morphism: IfAtomMorphismTable::new(),then_atom_morphism: ThenAtomMorphismTable::new(),branch_stmt_morphism: BranchStmtMorphismTable::new(),match_stmt_morphism: MatchStmtMorphismTable::new(),semantic_name: SemanticNameTable::new(),semantic_els: SemanticElsTable::new(),wildcard_name: WildcardNameTable::new(),rel_app_parent_model_el: RelAppParentModelElTable::new(),match_case_pattern_ctor: MatchCasePatternCtorTable::new(),cases_determined_enum: CasesDeterminedEnumTable::new(),empty_join_is_dirty: true,
}
}

/// Closes the model under all axioms.
/// Depending on the axioms and the model, this may run indefinitely.
#[allow(dead_code)]
pub fn close(&mut self) {
    self.close_until(|_: &Self| false);
}
/// Closes the model under all axioms until `condition` is satisfied.
/// Depending on the axioms and `condition`, this may run indefinitely.
/// Returns `true` if the `condition` eventually holds.
/// Returns `false` if the model could be closed under all axioms but `condition` still does not hold.
#[allow(dead_code)]
pub fn close_until(&mut self, condition: impl Fn(&Self) -> bool) -> bool
{
    let mut delta = ModelDelta::new();

    self.canonicalize();
    if condition(self) {
        return true;
    }

    while self.is_dirty() {
        loop {
self.implicit_functionality_0_0(&mut delta);
self.implicit_functionality_1_0(&mut delta);
self.implicit_functionality_2_0(&mut delta);
self.implicit_functionality_3_0(&mut delta);
self.implicit_functionality_4_0(&mut delta);
self.implicit_functionality_5_0(&mut delta);
self.implicit_functionality_6_0(&mut delta);
self.implicit_functionality_7_0(&mut delta);
self.implicit_functionality_8_0(&mut delta);
self.implicit_functionality_9_0(&mut delta);
self.implicit_functionality_10_0(&mut delta);
self.implicit_functionality_11_0(&mut delta);
self.implicit_functionality_12_0(&mut delta);
self.implicit_functionality_13_0(&mut delta);
self.implicit_functionality_14_0(&mut delta);
self.implicit_functionality_15_0(&mut delta);
self.implicit_functionality_16_0(&mut delta);
self.implicit_functionality_17_0(&mut delta);
self.implicit_functionality_18_0(&mut delta);
self.implicit_functionality_19_0(&mut delta);
self.implicit_functionality_20_0(&mut delta);
self.implicit_functionality_21_0(&mut delta);
self.implicit_functionality_22_0(&mut delta);
self.implicit_functionality_23_0(&mut delta);
self.implicit_functionality_24_0(&mut delta);
self.implicit_functionality_25_0(&mut delta);
self.implicit_functionality_26_0(&mut delta);
self.implicit_functionality_27_0(&mut delta);
self.implicit_functionality_28_0(&mut delta);
self.implicit_functionality_29_0(&mut delta);
self.implicit_functionality_30_0(&mut delta);
self.implicit_functionality_31_0(&mut delta);
self.implicit_functionality_32_0(&mut delta);
self.implicit_functionality_33_0(&mut delta);
self.implicit_functionality_34_0(&mut delta);
self.implicit_functionality_35_0(&mut delta);
self.implicit_functionality_36_0(&mut delta);
self.implicit_functionality_37_0(&mut delta);
self.implicit_functionality_38_0(&mut delta);
self.implicit_functionality_39_0(&mut delta);
self.implicit_functionality_40_0(&mut delta);
self.implicit_functionality_41_0(&mut delta);
self.implicit_functionality_42_0(&mut delta);
self.implicit_functionality_43_0(&mut delta);
self.implicit_functionality_44_0(&mut delta);
self.implicit_functionality_45_0(&mut delta);
self.implicit_functionality_46_0(&mut delta);
self.implicit_functionality_47_0(&mut delta);
self.implicit_functionality_48_0(&mut delta);
self.implicit_functionality_49_0(&mut delta);
self.implicit_functionality_50_0(&mut delta);
self.implicit_functionality_51_0(&mut delta);
self.implicit_functionality_52_0(&mut delta);
self.implicit_functionality_53_0(&mut delta);
self.implicit_functionality_54_0(&mut delta);
self.implicit_functionality_55_0(&mut delta);
self.implicit_functionality_56_0(&mut delta);
self.implicit_functionality_57_0(&mut delta);
self.implicit_functionality_58_0(&mut delta);
self.implicit_functionality_59_0(&mut delta);
self.implicit_functionality_60_0(&mut delta);
self.implicit_functionality_61_0(&mut delta);
self.implicit_functionality_62_0(&mut delta);
self.implicit_functionality_63_0(&mut delta);
self.implicit_functionality_64_0(&mut delta);
self.implicit_functionality_65_0(&mut delta);
self.implicit_functionality_66_0(&mut delta);
self.implicit_functionality_67_0(&mut delta);
self.implicit_functionality_68_0(&mut delta);
self.implicit_functionality_69_0(&mut delta);
self.implicit_functionality_70_0(&mut delta);
self.implicit_functionality_71_0(&mut delta);
self.implicit_functionality_72_0(&mut delta);
self.implicit_functionality_73_0(&mut delta);
self.implicit_functionality_74_0(&mut delta);
self.implicit_functionality_75_0(&mut delta);
self.implicit_functionality_76_0(&mut delta);
self.implicit_functionality_77_0(&mut delta);
self.implicit_functionality_78_0(&mut delta);
self.implicit_functionality_79_0(&mut delta);
self.implicit_functionality_80_0(&mut delta);
self.implicit_functionality_81_0(&mut delta);
self.implicit_functionality_82_0(&mut delta);
self.implicit_functionality_83_0(&mut delta);
self.implicit_functionality_84_0(&mut delta);
self.implicit_functionality_85_0(&mut delta);
self.implicit_functionality_86_0(&mut delta);
self.implicit_functionality_87_0(&mut delta);
self.implicit_functionality_88_0(&mut delta);
self.implicit_functionality_89_0(&mut delta);
self.implicit_functionality_90_0(&mut delta);
self.implicit_functionality_91_0(&mut delta);
self.implicit_functionality_92_0(&mut delta);
self.implicit_functionality_93_0(&mut delta);
self.implicit_functionality_94_0(&mut delta);
self.implicit_functionality_95_0(&mut delta);
self.implicit_functionality_96_0(&mut delta);
self.implicit_functionality_97_0(&mut delta);
self.implicit_functionality_98_0(&mut delta);
self.implicit_functionality_99_0(&mut delta);
self.implicit_functionality_100_0(&mut delta);
self.implicit_functionality_101_0(&mut delta);
self.implicit_functionality_102_0(&mut delta);
self.implicit_functionality_103_0(&mut delta);
self.implicit_functionality_104_0(&mut delta);
self.implicit_functionality_105_0(&mut delta);
self.implicit_functionality_106_0(&mut delta);
self.implicit_functionality_107_0(&mut delta);
self.implicit_functionality_108_0(&mut delta);
self.implicit_functionality_109_0(&mut delta);
self.implicit_functionality_110_0(&mut delta);
self.implicit_functionality_111_0(&mut delta);
self.implicit_functionality_112_0(&mut delta);
self.implicit_functionality_113_0(&mut delta);
self.implicit_functionality_114_0(&mut delta);
self.implicit_functionality_115_0(&mut delta);
self.implicit_functionality_116_0(&mut delta);
self.implicit_functionality_117_0(&mut delta);
self.implicit_functionality_118_0(&mut delta);
self.implicit_functionality_119_0(&mut delta);
self.implicit_functionality_120_0(&mut delta);
self.implicit_functionality_121_0(&mut delta);
self.implicit_functionality_122_0(&mut delta);
self.implicit_functionality_123_0(&mut delta);
self.implicit_functionality_124_0(&mut delta);
self.implicit_functionality_125_0(&mut delta);
self.implicit_functionality_126_0(&mut delta);
self.implicit_functionality_127_0(&mut delta);
self.implicit_functionality_128_0(&mut delta);
self.real_virt_ident_total_0(&mut delta);
self.virt_real_ident_retraction_0(&mut delta);
self.rule_descendant_rule_total_0(&mut delta);
self.rule_descendant_term_total_0(&mut delta);
self.rule_descendant_term_list_total_0(&mut delta);
self.rule_descendant_opt_term_total_0(&mut delta);
self.rule_descendant_if_atom_total_0(&mut delta);
self.rule_descendant_then_atom_total_0(&mut delta);
self.rule_descendant_match_case_total_0(&mut delta);
self.rule_descendant_match_case_list_total_0(&mut delta);
self.rule_descendant_stmt_total_0(&mut delta);
self.rule_descendant_stmt_list_total_0(&mut delta);
self.rule_descendant_stmt_block_list_total_0(&mut delta);
self.rule_descendant_type_expr_total_0(&mut delta);
self.scope_extension_vars_0(&mut delta);
self.entry_exit_scope_total_0(&mut delta);
self.exit_scope_extends_entry_scope_0(&mut delta);
self.scope_single_child_scopes_0(&mut delta);
self.scope_extension_siblings_parent_first_0(&mut delta);
self.scope_extension_siblings_first_second_0(&mut delta);
self.scope_extension_siblings_second_parent_0(&mut delta);
self.scopes_rule_stmts_0(&mut delta);
self.scopes_stmt_list_cons_0(&mut delta);
self.scopes_stmt_block_list_cons_0(&mut delta);
self.scopes_stmt_if_0(&mut delta);
self.scopes_stmt_then_0(&mut delta);
self.scopes_stmt_branch_0(&mut delta);
self.scopes_stmt_match_0(&mut delta);
self.scopes_if_atom_equal_0(&mut delta);
self.scopes_if_atom_defined_0(&mut delta);
self.scopes_if_atom_pred_0(&mut delta);
self.scopes_if_atom_var_0(&mut delta);
self.scopes_then_atom_equal_0(&mut delta);
self.scopes_then_atom_defined_0(&mut delta);
self.scopes_then_atom_pred_0(&mut delta);
self.scopes_term_list_cons_0(&mut delta);
self.scopes_opt_term_some_0(&mut delta);
self.scopes_term_app_0(&mut delta);
self.scopes_term_var_0(&mut delta);
self.scopes_member_type_expr_0(&mut delta);
self.enum_ctors_0(&mut delta);
self.enum_ctors_cons_0(&mut delta);
self.match_stmt_cases_discriminee_0(&mut delta);
self.cases_match_stmt_cons_0(&mut delta);
self.desugared_case_equality_stmt_loc_0(&mut delta);
self.desugared_case_defined_0(&mut delta);
self.desugared_case_block_list_defined_0(&mut delta);
self.desugared_case_equality_atom_stmt_0(&mut delta);
self.desugared_case_block_structure_0(&mut delta);
self.desugared_case_blocks_0(&mut delta);
self.scopes_desugared_case_0(&mut delta);
self.scopes_desugared_case_list_0(&mut delta);
self.type_list_nil_not_cons_0(&mut delta);
self.type_list_cons_injective_0(&mut delta);
self.semantic_decl_type_0(&mut delta);
self.semantic_decl_enum_0(&mut delta);
self.semantic_decl_model_0(&mut delta);
self.mor_type_defined_for_model_0(&mut delta);
self.mor_type_is_mor_type_0(&mut delta);
self.mor_type_symbol_scope_0(&mut delta);
self.mor_type_dom_func_symbol_scope_0(&mut delta);
self.mor_type_cod_func_symbol_scope_0(&mut delta);
self.mor_type_dom_cod_func_domains_0(&mut delta);
self.mor_type_dom_cod_func_codomains_0(&mut delta);
self.type_name_semantic_type_0(&mut delta);
self.virtual_symbol_scope_total_0(&mut delta);
self.parent_model_func_defined_and_codomain_0(&mut delta);
self.parent_model_func_def_scope_0(&mut delta);
self.parent_model_func_domain_0(&mut delta);
self.semantic_signature_type_expr_ambient_0(&mut delta);
self.semantic_arg_type_def_0(&mut delta);
self.semantic_arg_types_nil_0(&mut delta);
self.semantic_arg_types_cons_0(&mut delta);
self.semantic_decl_pred_0(&mut delta);
self.semantic_decl_func_0(&mut delta);
self.semantic_decl_ctor_0(&mut delta);
self.semantic_func_name_0(&mut delta);
self.semantic_pred_name_0(&mut delta);
self.rel_constructors_pred_total_0(&mut delta);
self.rel_constructors_func_total_0(&mut delta);
self.semantic_pred_scope_extension_0(&mut delta);
self.semantic_func_scope_extension_0(&mut delta);
self.semantic_type_scope_extension_0(&mut delta);
self.arity_laws_0(&mut delta);
self.top_level_flat_arity_law_0(&mut delta);
self.top_level_flat_domain_law_0(&mut delta);
self.member_flat_arity_law_0(&mut delta);
self.member_flat_domain_law_0(&mut delta);
self.parent_func_is_total_0(&mut delta);
self.el_list_cons_injective_0(&mut delta);
self.el_list_snoc_injective_0(&mut delta);
self.el_list_cons_nil_0(&mut delta);
self.el_list_snoc_nil_0(&mut delta);
self.nil_els_structure_0(&mut delta);
self.cons_els_structure_0(&mut delta);
self.snoc_els_structure_0(&mut delta);
self.var_structure_0(&mut delta);
self.ambient_type_total_0(&mut delta);
self.underlying_type_law_0(&mut delta);
self.ambient_el_type_list_nil_0(&mut delta);
self.ambient_el_type_list_cons_0(&mut delta);
self.ambient_el_type_list_snoc_0(&mut delta);
self.nil_el_types_0(&mut delta);
self.cons_el_types_0(&mut delta);
self.cons_el_types_reverse_0(&mut delta);
self.snoc_el_types_0(&mut delta);
self.snoc_el_types_reverse_0(&mut delta);
self.rel_app_types_0(&mut delta);
self.rel_app_func_app_0(&mut delta);
self.rel_app_constrained_0(&mut delta);
self.constrained_head_tail_0(&mut delta);
self.constrained_init_snoc_0(&mut delta);
self.dom_total_0(&mut delta);
self.cod_total_0(&mut delta);
self.map_el_structure_0(&mut delta);
self.map_el_defined_0(&mut delta);
self.map_els_defined_0(&mut delta);
self.map_var_0(&mut delta);
self.map_rel_app_0(&mut delta);
self.map_preserves_el_type_0(&mut delta);
self.map_reflects_el_type_0(&mut delta);
self.map_preserves_ambient_model_els_0(&mut delta);
self.in_ker_rule_0(&mut delta);
self.el_in_img_rule_0(&mut delta);
self.rel_tuple_in_img_law_0(&mut delta);
self.anonymous_rule_125_0(&mut delta);
self.symbol_scope_extension_parent_0(&mut delta);
self.symbol_scope_ancestor_reflexivity_0(&mut delta);
self.symbol_scope_ancestor_parent_0(&mut delta);
self.module_symbol_scope_rule_0(&mut delta);
self.decl_symbol_scope_total_0(&mut delta);
self.decls_symbol_scope_total_0(&mut delta);
self.arg_symbol_scope_total_0(&mut delta);
self.args_symbol_scope_total_0(&mut delta);
self.ctor_symbol_scope_total_0(&mut delta);
self.ctors_symbol_scope_total_0(&mut delta);
self.decl_nodes_symbol_cons_0(&mut delta);
self.pred_args_symbol_scope_0(&mut delta);
self.func_args_symbol_scope_0(&mut delta);
self.ctor_args_symbol_scope_0(&mut delta);
self.args_symbol_scope_cons_0(&mut delta);
self.enum_ctors_symbol_scope_0(&mut delta);
self.ctors_symbol_scope_cons_0(&mut delta);
self.model_symbol_scope_law_0(&mut delta);
self.element_member_symbol_scope_laws_0(&mut delta);
self.module_symbol_scope_name_0(&mut delta);
self.model_symbol_scope_name_0(&mut delta);
self.scope_extension_symbols_0(&mut delta);
self.rule_symbol_scope_0(&mut delta);
self.defined_symbol_is_accessible_0(&mut delta);
self.accessible_symbol_scope_extension_0(&mut delta);
self.type_decl_defines_symbol_0(&mut delta);
self.enum_decl_defines_symbol_0(&mut delta);
self.model_decl_defines_symbol_0(&mut delta);
self.type_definition_symbol_scope_rule_0(&mut delta);
self.pred_decl_defines_symbol_0(&mut delta);
self.func_decl_defines_symbol_0(&mut delta);
self.ctor_decl_defines_symbol_0(&mut delta);
self.pred_definition_symbol_scope_rule_0(&mut delta);
self.func_definition_symbol_scope_rule_0(&mut delta);
self.rule_decl_defines_symbol_0(&mut delta);
self.var_atom_should_be_type_ambient_0(&mut delta);
self.var_atom_should_be_type_member_0(&mut delta);
self.pred_if_atom_should_be_pred_0(&mut delta);
self.pred_then_atom_should_be_pred_0(&mut delta);
self.app_atom_should_be_func_0(&mut delta);
self.type_list_len_total_0(&mut delta);
self.type_list_len_nil_0(&mut delta);
self.type_list_len_cons_0(&mut delta);
self.type_list_len_snoc_0(&mut delta);
self.term_list_len_total_0(&mut delta);
self.term_list_len_nil_0(&mut delta);
self.term_list_len_cons_0(&mut delta);
self.pred_if_atom_arg_num_should_match_0(&mut delta);
self.pred_then_atom_arg_num_should_match_0(&mut delta);
self.app_term_arg_num_should_match_0(&mut delta);
self.cfg_edge_stmts_stmt_cons_0(&mut delta);
self.cfg_edge_stmts_stmt_singleton_0(&mut delta);
self.cfg_edge_stmt_stmts_cons_0(&mut delta);
self.cfg_edge_stmt_stmts_nil_0(&mut delta);
self.cfg_edge_fork_cons_0(&mut delta);
self.cfg_edge_join_cons_0(&mut delta);
self.cfg_edge_if_0(&mut delta);
self.cfg_edge_then_0(&mut delta);
self.cfg_edge_branch_fork_blocks_0(&mut delta);
self.cfg_edge_match_fork_blocks_0(&mut delta);
self.cfg_edge_branch_join_blocks_0(&mut delta);
self.cfg_edge_match_join_blocks_0(&mut delta);
self.before_rule_structure_total_0(&mut delta);
self.ambient_model_el_structure_module_scope_0(&mut delta);
self.ambient_model_el_structure_model_scope_0(&mut delta);
self.ambient_model_el_morphism_signature_0(&mut delta);
self.ambient_model_el_structure_els_0(&mut delta);
self.ambient_model_el_parent_law_0(&mut delta);
self.before_first_rule_stmt_0(&mut delta);
self.cfg_edge_stmt_structure_0(&mut delta);
self.if_atom_morphism_dom_0(&mut delta);
self.then_atom_morphism_dom_0(&mut delta);
self.branch_stmt_morphism_dom_0(&mut delta);
self.match_stmt_morphism_dom_0(&mut delta);
self.if_stmt_morphism_defined_0(&mut delta);
self.then_stmt_morphism_defined_0(&mut delta);
self.branch_stmt_morphism_defined_0(&mut delta);
self.match_stmt_morphism_defined_0(&mut delta);
self.ambient_model_el_morphism_is_if_0(&mut delta);
self.if_stmt_morphism_is_if_0(&mut delta);
self.then_equal_stmt_morphism_is_surj_0(&mut delta);
self.then_pred_stmt_morphism_is_surj_0(&mut delta);
self.then_defined_stmt_morphism_is_non_surj_0(&mut delta);
self.branch_stmt_morphism_is_noop_0(&mut delta);
self.match_stmt_morphism_is_if_0(&mut delta);
self.stmt_structure_morphism_0(&mut delta);
self.if_stmt_structure_0(&mut delta);
self.then_stmt_structure_0(&mut delta);
self.match_stmt_structure_0(&mut delta);
self.equal_if_atom_structure_0(&mut delta);
self.defined_if_atom_structure_0(&mut delta);
self.pred_if_atom_structure_0(&mut delta);
self.var_if_atom_structure_0(&mut delta);
self.equal_then_atom_structure_0(&mut delta);
self.defined_then_atom_structure_0(&mut delta);
self.pred_then_atom_structure_0(&mut delta);
self.member_type_expr_structure_0(&mut delta);
self.cons_term_list_structure_0(&mut delta);
self.some_opt_term_structure_0(&mut delta);
self.app_term_structure_0(&mut delta);
self.semantic_name_defined_0(&mut delta);
self.semantic_name_extension_scope_0(&mut delta);
self.semantic_el_defined_0(&mut delta);
self.semantic_els_nil_0(&mut delta);
self.semantic_els_cons_0(&mut delta);
self.semantic_el_struct_0(&mut delta);
self.semantic_els_struct_0(&mut delta);
self.ambient_model_el_struct_0(&mut delta);
self.ambient_model_el_type_0(&mut delta);
self.app_term_semantics_0(&mut delta);
self.var_term_semantics_0(&mut delta);
self.wildcard_name_defined_0(&mut delta);
self.wildcard_term_semantics_0(&mut delta);
self.equal_if_atom_semantics_0(&mut delta);
self.pred_if_atom_semantics_0(&mut delta);
self.var_if_atom_semantics_ambient_0(&mut delta);
self.var_if_atom_semantics_member_0(&mut delta);
self.equal_then_atom_semantics_0(&mut delta);
self.defined_then_atom_semantics_0(&mut delta);
self.pred_then_atom_semantics_0(&mut delta);
self.rel_app_parent_model_el_law_0(&mut delta);
self.terms_should_be_epic_ok_cons_0(&mut delta);
self.terms_should_be_epic_ok_app_0(&mut delta);
self.then_atom_epic_ok_equal_0(&mut delta);
self.then_atom_epic_ok_defined_0(&mut delta);
self.then_atom_epic_ok_pred_0(&mut delta);
self.surjective_codomain_should_be_ok_0(&mut delta);
self.non_surjective_codomain_should_be_ok_0(&mut delta);
self.surjective_img_el_is_ok_0(&mut delta);
self.surjective_exempted_then_defined_term_0(&mut delta);
self.defined_then_should_be_given_by_ctor_0(&mut delta);
self.ctor_app_is_given_by_ctor_0(&mut delta);
self.function_can_be_made_defined_if_codomain_normal_type_0(&mut delta);
self.function_can_be_defined_if_constructor_0(&mut delta);
self.case_pattern_is_variable_defined_0(&mut delta);
self.case_pattern_is_wildcard_defined_0(&mut delta);
self.case_pattern_app_should_be_constructor_0(&mut delta);
self.match_case_pattern_ctor_defined_0(&mut delta);
self.is_pattern_ctor_arg_cons_0(&mut delta);
self.are_pattern_ctor_args_defined_0(&mut delta);
self.pattern_ctor_arg_is_app_defined_0(&mut delta);
self.pattern_ctor_arg_var_is_not_fresh_defined_0(&mut delta);
self.contains_ctor_case_head_0(&mut delta);
self.contains_ctor_case_tail_0(&mut delta);
self.match_stmt_contains_ctor_of_enum_defined_0(&mut delta);
self.ctor_cases_determine_enum_singleton_0(&mut delta);
self.ctor_cases_determine_enum_cons_0(&mut delta);
self.match_term_type_if_cases_determine_enum_0(&mut delta);
self.match_stmt_should_contain_ctor_defined_0(&mut delta);
self.match_stmt_contains_ctor_defined_0(&mut delta);

            self.drop_dirt();
            delta.apply_surjective(self);
            self.canonicalize();

            if condition(self) {
                return true;
            }

            if !self.is_dirty() {
                break;
            }
        }

        delta.apply_non_surjective (self);
        if condition(self) {
            return true;
        }
    }

    false
}
/// Returns and iterator over elements of sort `Ident`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_ident(&self) -> impl '_ + Iterator<Item=Ident> {
    self.ident_new.iter().chain(self.ident_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_ident(&self, el: Ident) -> Ident {
    if el.0 as usize >= self.ident_equalities.len() {
        el
    } else {
        self.ident_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_ident(&self, lhs: Ident, rhs: Ident) -> bool {
    self.root_ident(lhs) == self.root_ident(rhs)
}

/// Returns and iterator over elements of sort `VirtIdent`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_virt_ident(&self) -> impl '_ + Iterator<Item=VirtIdent> {
    self.virt_ident_new.iter().chain(self.virt_ident_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_virt_ident(&self, el: VirtIdent) -> VirtIdent {
    if el.0 as usize >= self.virt_ident_equalities.len() {
        el
    } else {
        self.virt_ident_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_virt_ident(&self, lhs: VirtIdent, rhs: VirtIdent) -> bool {
    self.root_virt_ident(lhs) == self.root_virt_ident(rhs)
}

/// Returns and iterator over elements of sort `TypeDeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_type_decl_node(&self) -> impl '_ + Iterator<Item=TypeDeclNode> {
    self.type_decl_node_new.iter().chain(self.type_decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_type_decl_node(&self, el: TypeDeclNode) -> TypeDeclNode {
    if el.0 as usize >= self.type_decl_node_equalities.len() {
        el
    } else {
        self.type_decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_type_decl_node(&self, lhs: TypeDeclNode, rhs: TypeDeclNode) -> bool {
    self.root_type_decl_node(lhs) == self.root_type_decl_node(rhs)
}

/// Returns and iterator over elements of sort `ArgDeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_arg_decl_node(&self) -> impl '_ + Iterator<Item=ArgDeclNode> {
    self.arg_decl_node_new.iter().chain(self.arg_decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_arg_decl_node(&self, el: ArgDeclNode) -> ArgDeclNode {
    if el.0 as usize >= self.arg_decl_node_equalities.len() {
        el
    } else {
        self.arg_decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_arg_decl_node(&self, lhs: ArgDeclNode, rhs: ArgDeclNode) -> bool {
    self.root_arg_decl_node(lhs) == self.root_arg_decl_node(rhs)
}

/// Returns and iterator over elements of sort `TypeExprNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_type_expr_node(&self) -> impl '_ + Iterator<Item=TypeExprNode> {
    self.type_expr_node_new.iter().chain(self.type_expr_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_type_expr_node(&self, el: TypeExprNode) -> TypeExprNode {
    if el.0 as usize >= self.type_expr_node_equalities.len() {
        el
    } else {
        self.type_expr_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_type_expr_node(&self, lhs: TypeExprNode, rhs: TypeExprNode) -> bool {
    self.root_type_expr_node(lhs) == self.root_type_expr_node(rhs)
}

/// Returns and iterator over elements of sort `ArgDeclListNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_arg_decl_list_node(&self) -> impl '_ + Iterator<Item=ArgDeclListNode> {
    self.arg_decl_list_node_new.iter().chain(self.arg_decl_list_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_arg_decl_list_node(&self, el: ArgDeclListNode) -> ArgDeclListNode {
    if el.0 as usize >= self.arg_decl_list_node_equalities.len() {
        el
    } else {
        self.arg_decl_list_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_arg_decl_list_node(&self, lhs: ArgDeclListNode, rhs: ArgDeclListNode) -> bool {
    self.root_arg_decl_list_node(lhs) == self.root_arg_decl_list_node(rhs)
}

/// Returns and iterator over elements of sort `PredDeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_pred_decl_node(&self) -> impl '_ + Iterator<Item=PredDeclNode> {
    self.pred_decl_node_new.iter().chain(self.pred_decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_pred_decl_node(&self, el: PredDeclNode) -> PredDeclNode {
    if el.0 as usize >= self.pred_decl_node_equalities.len() {
        el
    } else {
        self.pred_decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_pred_decl_node(&self, lhs: PredDeclNode, rhs: PredDeclNode) -> bool {
    self.root_pred_decl_node(lhs) == self.root_pred_decl_node(rhs)
}

/// Returns and iterator over elements of sort `FuncDeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_func_decl_node(&self) -> impl '_ + Iterator<Item=FuncDeclNode> {
    self.func_decl_node_new.iter().chain(self.func_decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_func_decl_node(&self, el: FuncDeclNode) -> FuncDeclNode {
    if el.0 as usize >= self.func_decl_node_equalities.len() {
        el
    } else {
        self.func_decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_func_decl_node(&self, lhs: FuncDeclNode, rhs: FuncDeclNode) -> bool {
    self.root_func_decl_node(lhs) == self.root_func_decl_node(rhs)
}

/// Returns and iterator over elements of sort `CtorDeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_ctor_decl_node(&self) -> impl '_ + Iterator<Item=CtorDeclNode> {
    self.ctor_decl_node_new.iter().chain(self.ctor_decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_ctor_decl_node(&self, el: CtorDeclNode) -> CtorDeclNode {
    if el.0 as usize >= self.ctor_decl_node_equalities.len() {
        el
    } else {
        self.ctor_decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_ctor_decl_node(&self, lhs: CtorDeclNode, rhs: CtorDeclNode) -> bool {
    self.root_ctor_decl_node(lhs) == self.root_ctor_decl_node(rhs)
}

/// Returns and iterator over elements of sort `CtorDeclListNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_ctor_decl_list_node(&self) -> impl '_ + Iterator<Item=CtorDeclListNode> {
    self.ctor_decl_list_node_new.iter().chain(self.ctor_decl_list_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_ctor_decl_list_node(&self, el: CtorDeclListNode) -> CtorDeclListNode {
    if el.0 as usize >= self.ctor_decl_list_node_equalities.len() {
        el
    } else {
        self.ctor_decl_list_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_ctor_decl_list_node(&self, lhs: CtorDeclListNode, rhs: CtorDeclListNode) -> bool {
    self.root_ctor_decl_list_node(lhs) == self.root_ctor_decl_list_node(rhs)
}

/// Returns and iterator over elements of sort `EnumDeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_enum_decl_node(&self) -> impl '_ + Iterator<Item=EnumDeclNode> {
    self.enum_decl_node_new.iter().chain(self.enum_decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_enum_decl_node(&self, el: EnumDeclNode) -> EnumDeclNode {
    if el.0 as usize >= self.enum_decl_node_equalities.len() {
        el
    } else {
        self.enum_decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_enum_decl_node(&self, lhs: EnumDeclNode, rhs: EnumDeclNode) -> bool {
    self.root_enum_decl_node(lhs) == self.root_enum_decl_node(rhs)
}

/// Returns and iterator over elements of sort `TermNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_term_node(&self) -> impl '_ + Iterator<Item=TermNode> {
    self.term_node_new.iter().chain(self.term_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_term_node(&self, el: TermNode) -> TermNode {
    if el.0 as usize >= self.term_node_equalities.len() {
        el
    } else {
        self.term_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_term_node(&self, lhs: TermNode, rhs: TermNode) -> bool {
    self.root_term_node(lhs) == self.root_term_node(rhs)
}

/// Returns and iterator over elements of sort `TermListNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_term_list_node(&self) -> impl '_ + Iterator<Item=TermListNode> {
    self.term_list_node_new.iter().chain(self.term_list_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_term_list_node(&self, el: TermListNode) -> TermListNode {
    if el.0 as usize >= self.term_list_node_equalities.len() {
        el
    } else {
        self.term_list_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_term_list_node(&self, lhs: TermListNode, rhs: TermListNode) -> bool {
    self.root_term_list_node(lhs) == self.root_term_list_node(rhs)
}

/// Returns and iterator over elements of sort `OptTermNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_opt_term_node(&self) -> impl '_ + Iterator<Item=OptTermNode> {
    self.opt_term_node_new.iter().chain(self.opt_term_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_opt_term_node(&self, el: OptTermNode) -> OptTermNode {
    if el.0 as usize >= self.opt_term_node_equalities.len() {
        el
    } else {
        self.opt_term_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_opt_term_node(&self, lhs: OptTermNode, rhs: OptTermNode) -> bool {
    self.root_opt_term_node(lhs) == self.root_opt_term_node(rhs)
}

/// Returns and iterator over elements of sort `MatchCaseNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_match_case_node(&self) -> impl '_ + Iterator<Item=MatchCaseNode> {
    self.match_case_node_new.iter().chain(self.match_case_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_match_case_node(&self, el: MatchCaseNode) -> MatchCaseNode {
    if el.0 as usize >= self.match_case_node_equalities.len() {
        el
    } else {
        self.match_case_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_match_case_node(&self, lhs: MatchCaseNode, rhs: MatchCaseNode) -> bool {
    self.root_match_case_node(lhs) == self.root_match_case_node(rhs)
}

/// Returns and iterator over elements of sort `StmtListNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_stmt_list_node(&self) -> impl '_ + Iterator<Item=StmtListNode> {
    self.stmt_list_node_new.iter().chain(self.stmt_list_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_stmt_list_node(&self, el: StmtListNode) -> StmtListNode {
    if el.0 as usize >= self.stmt_list_node_equalities.len() {
        el
    } else {
        self.stmt_list_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_stmt_list_node(&self, lhs: StmtListNode, rhs: StmtListNode) -> bool {
    self.root_stmt_list_node(lhs) == self.root_stmt_list_node(rhs)
}

/// Returns and iterator over elements of sort `MatchCaseListNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_match_case_list_node(&self) -> impl '_ + Iterator<Item=MatchCaseListNode> {
    self.match_case_list_node_new.iter().chain(self.match_case_list_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_match_case_list_node(&self, el: MatchCaseListNode) -> MatchCaseListNode {
    if el.0 as usize >= self.match_case_list_node_equalities.len() {
        el
    } else {
        self.match_case_list_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_match_case_list_node(&self, lhs: MatchCaseListNode, rhs: MatchCaseListNode) -> bool {
    self.root_match_case_list_node(lhs) == self.root_match_case_list_node(rhs)
}

/// Returns and iterator over elements of sort `IfAtomNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_if_atom_node(&self) -> impl '_ + Iterator<Item=IfAtomNode> {
    self.if_atom_node_new.iter().chain(self.if_atom_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_if_atom_node(&self, el: IfAtomNode) -> IfAtomNode {
    if el.0 as usize >= self.if_atom_node_equalities.len() {
        el
    } else {
        self.if_atom_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_if_atom_node(&self, lhs: IfAtomNode, rhs: IfAtomNode) -> bool {
    self.root_if_atom_node(lhs) == self.root_if_atom_node(rhs)
}

/// Returns and iterator over elements of sort `ThenAtomNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_then_atom_node(&self) -> impl '_ + Iterator<Item=ThenAtomNode> {
    self.then_atom_node_new.iter().chain(self.then_atom_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_then_atom_node(&self, el: ThenAtomNode) -> ThenAtomNode {
    if el.0 as usize >= self.then_atom_node_equalities.len() {
        el
    } else {
        self.then_atom_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_then_atom_node(&self, lhs: ThenAtomNode, rhs: ThenAtomNode) -> bool {
    self.root_then_atom_node(lhs) == self.root_then_atom_node(rhs)
}

/// Returns and iterator over elements of sort `StmtNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_stmt_node(&self) -> impl '_ + Iterator<Item=StmtNode> {
    self.stmt_node_new.iter().chain(self.stmt_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_stmt_node(&self, el: StmtNode) -> StmtNode {
    if el.0 as usize >= self.stmt_node_equalities.len() {
        el
    } else {
        self.stmt_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_stmt_node(&self, lhs: StmtNode, rhs: StmtNode) -> bool {
    self.root_stmt_node(lhs) == self.root_stmt_node(rhs)
}

/// Returns and iterator over elements of sort `StmtBlockListNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_stmt_block_list_node(&self) -> impl '_ + Iterator<Item=StmtBlockListNode> {
    self.stmt_block_list_node_new.iter().chain(self.stmt_block_list_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_stmt_block_list_node(&self, el: StmtBlockListNode) -> StmtBlockListNode {
    if el.0 as usize >= self.stmt_block_list_node_equalities.len() {
        el
    } else {
        self.stmt_block_list_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_stmt_block_list_node(&self, lhs: StmtBlockListNode, rhs: StmtBlockListNode) -> bool {
    self.root_stmt_block_list_node(lhs) == self.root_stmt_block_list_node(rhs)
}

/// Returns and iterator over elements of sort `RuleDeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_rule_decl_node(&self) -> impl '_ + Iterator<Item=RuleDeclNode> {
    self.rule_decl_node_new.iter().chain(self.rule_decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_rule_decl_node(&self, el: RuleDeclNode) -> RuleDeclNode {
    if el.0 as usize >= self.rule_decl_node_equalities.len() {
        el
    } else {
        self.rule_decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_rule_decl_node(&self, lhs: RuleDeclNode, rhs: RuleDeclNode) -> bool {
    self.root_rule_decl_node(lhs) == self.root_rule_decl_node(rhs)
}

/// Returns and iterator over elements of sort `ModelDeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_model_decl_node(&self) -> impl '_ + Iterator<Item=ModelDeclNode> {
    self.model_decl_node_new.iter().chain(self.model_decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_model_decl_node(&self, el: ModelDeclNode) -> ModelDeclNode {
    if el.0 as usize >= self.model_decl_node_equalities.len() {
        el
    } else {
        self.model_decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_model_decl_node(&self, lhs: ModelDeclNode, rhs: ModelDeclNode) -> bool {
    self.root_model_decl_node(lhs) == self.root_model_decl_node(rhs)
}

/// Returns and iterator over elements of sort `DeclListNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_decl_list_node(&self) -> impl '_ + Iterator<Item=DeclListNode> {
    self.decl_list_node_new.iter().chain(self.decl_list_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_decl_list_node(&self, el: DeclListNode) -> DeclListNode {
    if el.0 as usize >= self.decl_list_node_equalities.len() {
        el
    } else {
        self.decl_list_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_decl_list_node(&self, lhs: DeclListNode, rhs: DeclListNode) -> bool {
    self.root_decl_list_node(lhs) == self.root_decl_list_node(rhs)
}

/// Returns and iterator over elements of sort `DeclNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_decl_node(&self) -> impl '_ + Iterator<Item=DeclNode> {
    self.decl_node_new.iter().chain(self.decl_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_decl_node(&self, el: DeclNode) -> DeclNode {
    if el.0 as usize >= self.decl_node_equalities.len() {
        el
    } else {
        self.decl_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_decl_node(&self, lhs: DeclNode, rhs: DeclNode) -> bool {
    self.root_decl_node(lhs) == self.root_decl_node(rhs)
}

/// Returns and iterator over elements of sort `ModuleNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_module_node(&self) -> impl '_ + Iterator<Item=ModuleNode> {
    self.module_node_new.iter().chain(self.module_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_module_node(&self, el: ModuleNode) -> ModuleNode {
    if el.0 as usize >= self.module_node_equalities.len() {
        el
    } else {
        self.module_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_module_node(&self, lhs: ModuleNode, rhs: ModuleNode) -> bool {
    self.root_module_node(lhs) == self.root_module_node(rhs)
}

/// Returns and iterator over elements of sort `Loc`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_loc(&self) -> impl '_ + Iterator<Item=Loc> {
    self.loc_new.iter().chain(self.loc_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_loc(&self, el: Loc) -> Loc {
    if el.0 as usize >= self.loc_equalities.len() {
        el
    } else {
        self.loc_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_loc(&self, lhs: Loc, rhs: Loc) -> bool {
    self.root_loc(lhs) == self.root_loc(rhs)
}

/// Returns and iterator over elements of sort `RuleDescendantNode`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_rule_descendant_node(&self) -> impl '_ + Iterator<Item=RuleDescendantNode> {
    self.rule_descendant_node_new.iter().chain(self.rule_descendant_node_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_rule_descendant_node(&self, el: RuleDescendantNode) -> RuleDescendantNode {
    if el.0 as usize >= self.rule_descendant_node_equalities.len() {
        el
    } else {
        self.rule_descendant_node_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_rule_descendant_node(&self, lhs: RuleDescendantNode, rhs: RuleDescendantNode) -> bool {
    self.root_rule_descendant_node(lhs) == self.root_rule_descendant_node(rhs)
}

/// Returns and iterator over elements of sort `Scope`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_scope(&self) -> impl '_ + Iterator<Item=Scope> {
    self.scope_new.iter().chain(self.scope_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_scope(&self, el: Scope) -> Scope {
    if el.0 as usize >= self.scope_equalities.len() {
        el
    } else {
        self.scope_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_scope(&self, lhs: Scope, rhs: Scope) -> bool {
    self.root_scope(lhs) == self.root_scope(rhs)
}

/// Returns and iterator over elements of sort `Type`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_type(&self) -> impl '_ + Iterator<Item=Type> {
    self.type_new.iter().chain(self.type_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_type(&self, el: Type) -> Type {
    if el.0 as usize >= self.type_equalities.len() {
        el
    } else {
        self.type_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_type(&self, lhs: Type, rhs: Type) -> bool {
    self.root_type(lhs) == self.root_type(rhs)
}

/// Returns and iterator over elements of sort `TypeList`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_type_list(&self) -> impl '_ + Iterator<Item=TypeList> {
    self.type_list_new.iter().chain(self.type_list_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_type_list(&self, el: TypeList) -> TypeList {
    if el.0 as usize >= self.type_list_equalities.len() {
        el
    } else {
        self.type_list_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_type_list(&self, lhs: TypeList, rhs: TypeList) -> bool {
    self.root_type_list(lhs) == self.root_type_list(rhs)
}

/// Returns and iterator over elements of sort `SymbolScope`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_symbol_scope(&self) -> impl '_ + Iterator<Item=SymbolScope> {
    self.symbol_scope_new.iter().chain(self.symbol_scope_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_symbol_scope(&self, el: SymbolScope) -> SymbolScope {
    if el.0 as usize >= self.symbol_scope_equalities.len() {
        el
    } else {
        self.symbol_scope_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_symbol_scope(&self, lhs: SymbolScope, rhs: SymbolScope) -> bool {
    self.root_symbol_scope(lhs) == self.root_symbol_scope(rhs)
}

/// Returns and iterator over elements of sort `Func`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_func(&self) -> impl '_ + Iterator<Item=Func> {
    self.func_new.iter().chain(self.func_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_func(&self, el: Func) -> Func {
    if el.0 as usize >= self.func_equalities.len() {
        el
    } else {
        self.func_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_func(&self, lhs: Func, rhs: Func) -> bool {
    self.root_func(lhs) == self.root_func(rhs)
}

/// Returns and iterator over elements of sort `Pred`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_pred(&self) -> impl '_ + Iterator<Item=Pred> {
    self.pred_new.iter().chain(self.pred_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_pred(&self, el: Pred) -> Pred {
    if el.0 as usize >= self.pred_equalities.len() {
        el
    } else {
        self.pred_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_pred(&self, lhs: Pred, rhs: Pred) -> bool {
    self.root_pred(lhs) == self.root_pred(rhs)
}

/// Returns and iterator over elements of sort `Rel`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_rel(&self) -> impl '_ + Iterator<Item=Rel> {
    self.rel_new.iter().chain(self.rel_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_rel(&self, el: Rel) -> Rel {
    if el.0 as usize >= self.rel_equalities.len() {
        el
    } else {
        self.rel_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_rel(&self, lhs: Rel, rhs: Rel) -> bool {
    self.root_rel(lhs) == self.root_rel(rhs)
}

/// Returns and iterator over elements of sort `Structure`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_structure(&self) -> impl '_ + Iterator<Item=Structure> {
    self.structure_new.iter().chain(self.structure_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_structure(&self, el: Structure) -> Structure {
    if el.0 as usize >= self.structure_equalities.len() {
        el
    } else {
        self.structure_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_structure(&self, lhs: Structure, rhs: Structure) -> bool {
    self.root_structure(lhs) == self.root_structure(rhs)
}

/// Returns and iterator over elements of sort `El`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_el(&self) -> impl '_ + Iterator<Item=El> {
    self.el_new.iter().chain(self.el_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_el(&self, el: El) -> El {
    if el.0 as usize >= self.el_equalities.len() {
        el
    } else {
        self.el_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_el(&self, lhs: El, rhs: El) -> bool {
    self.root_el(lhs) == self.root_el(rhs)
}

/// Returns and iterator over elements of sort `ElList`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_el_list(&self) -> impl '_ + Iterator<Item=ElList> {
    self.el_list_new.iter().chain(self.el_list_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_el_list(&self, el: ElList) -> ElList {
    if el.0 as usize >= self.el_list_equalities.len() {
        el
    } else {
        self.el_list_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_el_list(&self, lhs: ElList, rhs: ElList) -> bool {
    self.root_el_list(lhs) == self.root_el_list(rhs)
}

/// Returns and iterator over elements of sort `ElName`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_el_name(&self) -> impl '_ + Iterator<Item=ElName> {
    self.el_name_new.iter().chain(self.el_name_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_el_name(&self, el: ElName) -> ElName {
    if el.0 as usize >= self.el_name_equalities.len() {
        el
    } else {
        self.el_name_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_el_name(&self, lhs: ElName, rhs: ElName) -> bool {
    self.root_el_name(lhs) == self.root_el_name(rhs)
}

/// Returns and iterator over elements of sort `ElementType`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_element_type(&self) -> impl '_ + Iterator<Item=ElementType> {
    self.element_type_new.iter().chain(self.element_type_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_element_type(&self, el: ElementType) -> ElementType {
    if el.0 as usize >= self.element_type_equalities.len() {
        el
    } else {
        self.element_type_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_element_type(&self, lhs: ElementType, rhs: ElementType) -> bool {
    self.root_element_type(lhs) == self.root_element_type(rhs)
}

/// Returns and iterator over elements of sort `ElementTypeList`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_element_type_list(&self) -> impl '_ + Iterator<Item=ElementTypeList> {
    self.element_type_list_new.iter().chain(self.element_type_list_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_element_type_list(&self, el: ElementTypeList) -> ElementTypeList {
    if el.0 as usize >= self.element_type_list_equalities.len() {
        el
    } else {
        self.element_type_list_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_element_type_list(&self, lhs: ElementTypeList, rhs: ElementTypeList) -> bool {
    self.root_element_type_list(lhs) == self.root_element_type_list(rhs)
}

/// Returns and iterator over elements of sort `Morphism`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_morphism(&self) -> impl '_ + Iterator<Item=Morphism> {
    self.morphism_new.iter().chain(self.morphism_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_morphism(&self, el: Morphism) -> Morphism {
    if el.0 as usize >= self.morphism_equalities.len() {
        el
    } else {
        self.morphism_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_morphism(&self, lhs: Morphism, rhs: Morphism) -> bool {
    self.root_morphism(lhs) == self.root_morphism(rhs)
}

/// Returns and iterator over elements of sort `SymbolKind`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_symbol_kind(&self) -> impl '_ + Iterator<Item=SymbolKind> {
    self.symbol_kind_new.iter().chain(self.symbol_kind_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_symbol_kind(&self, el: SymbolKind) -> SymbolKind {
    if el.0 as usize >= self.symbol_kind_equalities.len() {
        el
    } else {
        self.symbol_kind_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_symbol_kind(&self, lhs: SymbolKind, rhs: SymbolKind) -> bool {
    self.root_symbol_kind(lhs) == self.root_symbol_kind(rhs)
}

/// Returns and iterator over elements of sort `Nat`.
/// The iterator yields canonical representatives only.
#[allow(dead_code)]
pub fn iter_nat(&self) -> impl '_ + Iterator<Item=Nat> {
    self.nat_new.iter().chain(self.nat_old.iter()).copied()
}
/// Returns the canonical representative of the equivalence class of `el`.
#[allow(dead_code)]
pub fn root_nat(&self, el: Nat) -> Nat {
    if el.0 as usize >= self.nat_equalities.len() {
        el
    } else {
        self.nat_equalities.root_const(el)
    }
}
/// Returns `true` if `lhs` and `rhs` are in the same equivalence class.
#[allow(dead_code)]
pub fn are_equal_nat(&self, lhs: Nat, rhs: Nat) -> bool {
    self.root_nat(lhs) == self.root_nat(rhs)
}

/// Adjoins a new element of type [Ident].
#[allow(dead_code)]
fn new_ident_internal(&mut self) -> Ident {
    let old_len = self.ident_equalities.len();
    self.ident_equalities.increase_size_to(old_len + 1);
    let el = Ident::from(u32::try_from(old_len).unwrap());

    self.ident_new.insert(el);

    assert!(self.ident_weights.len() == old_len);
    self.ident_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_ident(&mut self, mut lhs: Ident, mut rhs: Ident) {
    lhs = self.ident_equalities.root(lhs);
    rhs = self.ident_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.ident_weights[lhs.0 as usize];
    let rhs_weight = self.ident_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.ident_equalities.union_roots_into(child, root);
    
    self.ident_old.remove(&child);
    self.ident_new.remove(&child);
    self.ident_uprooted.push(child);
}
/// Adjoins a new element of type [VirtIdent].
#[allow(dead_code)]
fn new_virt_ident_internal(&mut self) -> VirtIdent {
    let old_len = self.virt_ident_equalities.len();
    self.virt_ident_equalities.increase_size_to(old_len + 1);
    let el = VirtIdent::from(u32::try_from(old_len).unwrap());

    self.virt_ident_new.insert(el);

    assert!(self.virt_ident_weights.len() == old_len);
    self.virt_ident_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_virt_ident(&mut self, mut lhs: VirtIdent, mut rhs: VirtIdent) {
    lhs = self.virt_ident_equalities.root(lhs);
    rhs = self.virt_ident_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.virt_ident_weights[lhs.0 as usize];
    let rhs_weight = self.virt_ident_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.virt_ident_equalities.union_roots_into(child, root);
    
    self.virt_ident_old.remove(&child);
    self.virt_ident_new.remove(&child);
    self.virt_ident_uprooted.push(child);
}
/// Adjoins a new element of type [TypeDeclNode].
#[allow(dead_code)]
fn new_type_decl_node_internal(&mut self) -> TypeDeclNode {
    let old_len = self.type_decl_node_equalities.len();
    self.type_decl_node_equalities.increase_size_to(old_len + 1);
    let el = TypeDeclNode::from(u32::try_from(old_len).unwrap());

    self.type_decl_node_new.insert(el);

    assert!(self.type_decl_node_weights.len() == old_len);
    self.type_decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_type_decl_node(&mut self, mut lhs: TypeDeclNode, mut rhs: TypeDeclNode) {
    lhs = self.type_decl_node_equalities.root(lhs);
    rhs = self.type_decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.type_decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.type_decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.type_decl_node_equalities.union_roots_into(child, root);
    
    self.type_decl_node_old.remove(&child);
    self.type_decl_node_new.remove(&child);
    self.type_decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [ArgDeclNode].
#[allow(dead_code)]
fn new_arg_decl_node_internal(&mut self) -> ArgDeclNode {
    let old_len = self.arg_decl_node_equalities.len();
    self.arg_decl_node_equalities.increase_size_to(old_len + 1);
    let el = ArgDeclNode::from(u32::try_from(old_len).unwrap());

    self.arg_decl_node_new.insert(el);

    assert!(self.arg_decl_node_weights.len() == old_len);
    self.arg_decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_arg_decl_node(&mut self, mut lhs: ArgDeclNode, mut rhs: ArgDeclNode) {
    lhs = self.arg_decl_node_equalities.root(lhs);
    rhs = self.arg_decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.arg_decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.arg_decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.arg_decl_node_equalities.union_roots_into(child, root);
    
    self.arg_decl_node_old.remove(&child);
    self.arg_decl_node_new.remove(&child);
    self.arg_decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [ArgDeclListNode].
#[allow(dead_code)]
fn new_arg_decl_list_node_internal(&mut self) -> ArgDeclListNode {
    let old_len = self.arg_decl_list_node_equalities.len();
    self.arg_decl_list_node_equalities.increase_size_to(old_len + 1);
    let el = ArgDeclListNode::from(u32::try_from(old_len).unwrap());

    self.arg_decl_list_node_new.insert(el);

    assert!(self.arg_decl_list_node_weights.len() == old_len);
    self.arg_decl_list_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_arg_decl_list_node(&mut self, mut lhs: ArgDeclListNode, mut rhs: ArgDeclListNode) {
    lhs = self.arg_decl_list_node_equalities.root(lhs);
    rhs = self.arg_decl_list_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.arg_decl_list_node_weights[lhs.0 as usize];
    let rhs_weight = self.arg_decl_list_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.arg_decl_list_node_equalities.union_roots_into(child, root);
    
    self.arg_decl_list_node_old.remove(&child);
    self.arg_decl_list_node_new.remove(&child);
    self.arg_decl_list_node_uprooted.push(child);
}
/// Adjoins a new element of type [PredDeclNode].
#[allow(dead_code)]
fn new_pred_decl_node_internal(&mut self) -> PredDeclNode {
    let old_len = self.pred_decl_node_equalities.len();
    self.pred_decl_node_equalities.increase_size_to(old_len + 1);
    let el = PredDeclNode::from(u32::try_from(old_len).unwrap());

    self.pred_decl_node_new.insert(el);

    assert!(self.pred_decl_node_weights.len() == old_len);
    self.pred_decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_pred_decl_node(&mut self, mut lhs: PredDeclNode, mut rhs: PredDeclNode) {
    lhs = self.pred_decl_node_equalities.root(lhs);
    rhs = self.pred_decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.pred_decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.pred_decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.pred_decl_node_equalities.union_roots_into(child, root);
    
    self.pred_decl_node_old.remove(&child);
    self.pred_decl_node_new.remove(&child);
    self.pred_decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [FuncDeclNode].
#[allow(dead_code)]
fn new_func_decl_node_internal(&mut self) -> FuncDeclNode {
    let old_len = self.func_decl_node_equalities.len();
    self.func_decl_node_equalities.increase_size_to(old_len + 1);
    let el = FuncDeclNode::from(u32::try_from(old_len).unwrap());

    self.func_decl_node_new.insert(el);

    assert!(self.func_decl_node_weights.len() == old_len);
    self.func_decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_func_decl_node(&mut self, mut lhs: FuncDeclNode, mut rhs: FuncDeclNode) {
    lhs = self.func_decl_node_equalities.root(lhs);
    rhs = self.func_decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.func_decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.func_decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.func_decl_node_equalities.union_roots_into(child, root);
    
    self.func_decl_node_old.remove(&child);
    self.func_decl_node_new.remove(&child);
    self.func_decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [CtorDeclNode].
#[allow(dead_code)]
fn new_ctor_decl_node_internal(&mut self) -> CtorDeclNode {
    let old_len = self.ctor_decl_node_equalities.len();
    self.ctor_decl_node_equalities.increase_size_to(old_len + 1);
    let el = CtorDeclNode::from(u32::try_from(old_len).unwrap());

    self.ctor_decl_node_new.insert(el);

    assert!(self.ctor_decl_node_weights.len() == old_len);
    self.ctor_decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_ctor_decl_node(&mut self, mut lhs: CtorDeclNode, mut rhs: CtorDeclNode) {
    lhs = self.ctor_decl_node_equalities.root(lhs);
    rhs = self.ctor_decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.ctor_decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.ctor_decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.ctor_decl_node_equalities.union_roots_into(child, root);
    
    self.ctor_decl_node_old.remove(&child);
    self.ctor_decl_node_new.remove(&child);
    self.ctor_decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [CtorDeclListNode].
#[allow(dead_code)]
fn new_ctor_decl_list_node_internal(&mut self) -> CtorDeclListNode {
    let old_len = self.ctor_decl_list_node_equalities.len();
    self.ctor_decl_list_node_equalities.increase_size_to(old_len + 1);
    let el = CtorDeclListNode::from(u32::try_from(old_len).unwrap());

    self.ctor_decl_list_node_new.insert(el);

    assert!(self.ctor_decl_list_node_weights.len() == old_len);
    self.ctor_decl_list_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_ctor_decl_list_node(&mut self, mut lhs: CtorDeclListNode, mut rhs: CtorDeclListNode) {
    lhs = self.ctor_decl_list_node_equalities.root(lhs);
    rhs = self.ctor_decl_list_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.ctor_decl_list_node_weights[lhs.0 as usize];
    let rhs_weight = self.ctor_decl_list_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.ctor_decl_list_node_equalities.union_roots_into(child, root);
    
    self.ctor_decl_list_node_old.remove(&child);
    self.ctor_decl_list_node_new.remove(&child);
    self.ctor_decl_list_node_uprooted.push(child);
}
/// Adjoins a new element of type [EnumDeclNode].
#[allow(dead_code)]
fn new_enum_decl_node_internal(&mut self) -> EnumDeclNode {
    let old_len = self.enum_decl_node_equalities.len();
    self.enum_decl_node_equalities.increase_size_to(old_len + 1);
    let el = EnumDeclNode::from(u32::try_from(old_len).unwrap());

    self.enum_decl_node_new.insert(el);

    assert!(self.enum_decl_node_weights.len() == old_len);
    self.enum_decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_enum_decl_node(&mut self, mut lhs: EnumDeclNode, mut rhs: EnumDeclNode) {
    lhs = self.enum_decl_node_equalities.root(lhs);
    rhs = self.enum_decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.enum_decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.enum_decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.enum_decl_node_equalities.union_roots_into(child, root);
    
    self.enum_decl_node_old.remove(&child);
    self.enum_decl_node_new.remove(&child);
    self.enum_decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [TermNode].
#[allow(dead_code)]
fn new_term_node_internal(&mut self) -> TermNode {
    let old_len = self.term_node_equalities.len();
    self.term_node_equalities.increase_size_to(old_len + 1);
    let el = TermNode::from(u32::try_from(old_len).unwrap());

    self.term_node_new.insert(el);

    assert!(self.term_node_weights.len() == old_len);
    self.term_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_term_node(&mut self, mut lhs: TermNode, mut rhs: TermNode) {
    lhs = self.term_node_equalities.root(lhs);
    rhs = self.term_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.term_node_weights[lhs.0 as usize];
    let rhs_weight = self.term_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.term_node_equalities.union_roots_into(child, root);
    
    self.term_node_old.remove(&child);
    self.term_node_new.remove(&child);
    self.term_node_uprooted.push(child);
}
/// Adjoins a new element of type [TermListNode].
#[allow(dead_code)]
fn new_term_list_node_internal(&mut self) -> TermListNode {
    let old_len = self.term_list_node_equalities.len();
    self.term_list_node_equalities.increase_size_to(old_len + 1);
    let el = TermListNode::from(u32::try_from(old_len).unwrap());

    self.term_list_node_new.insert(el);

    assert!(self.term_list_node_weights.len() == old_len);
    self.term_list_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_term_list_node(&mut self, mut lhs: TermListNode, mut rhs: TermListNode) {
    lhs = self.term_list_node_equalities.root(lhs);
    rhs = self.term_list_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.term_list_node_weights[lhs.0 as usize];
    let rhs_weight = self.term_list_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.term_list_node_equalities.union_roots_into(child, root);
    
    self.term_list_node_old.remove(&child);
    self.term_list_node_new.remove(&child);
    self.term_list_node_uprooted.push(child);
}
/// Adjoins a new element of type [TypeExprNode].
#[allow(dead_code)]
fn new_type_expr_node_internal(&mut self) -> TypeExprNode {
    let old_len = self.type_expr_node_equalities.len();
    self.type_expr_node_equalities.increase_size_to(old_len + 1);
    let el = TypeExprNode::from(u32::try_from(old_len).unwrap());

    self.type_expr_node_new.insert(el);

    assert!(self.type_expr_node_weights.len() == old_len);
    self.type_expr_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_type_expr_node(&mut self, mut lhs: TypeExprNode, mut rhs: TypeExprNode) {
    lhs = self.type_expr_node_equalities.root(lhs);
    rhs = self.type_expr_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.type_expr_node_weights[lhs.0 as usize];
    let rhs_weight = self.type_expr_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.type_expr_node_equalities.union_roots_into(child, root);
    
    self.type_expr_node_old.remove(&child);
    self.type_expr_node_new.remove(&child);
    self.type_expr_node_uprooted.push(child);
}
/// Adjoins a new element of type [OptTermNode].
#[allow(dead_code)]
fn new_opt_term_node_internal(&mut self) -> OptTermNode {
    let old_len = self.opt_term_node_equalities.len();
    self.opt_term_node_equalities.increase_size_to(old_len + 1);
    let el = OptTermNode::from(u32::try_from(old_len).unwrap());

    self.opt_term_node_new.insert(el);

    assert!(self.opt_term_node_weights.len() == old_len);
    self.opt_term_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_opt_term_node(&mut self, mut lhs: OptTermNode, mut rhs: OptTermNode) {
    lhs = self.opt_term_node_equalities.root(lhs);
    rhs = self.opt_term_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.opt_term_node_weights[lhs.0 as usize];
    let rhs_weight = self.opt_term_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.opt_term_node_equalities.union_roots_into(child, root);
    
    self.opt_term_node_old.remove(&child);
    self.opt_term_node_new.remove(&child);
    self.opt_term_node_uprooted.push(child);
}
/// Adjoins a new element of type [MatchCaseNode].
#[allow(dead_code)]
fn new_match_case_node_internal(&mut self) -> MatchCaseNode {
    let old_len = self.match_case_node_equalities.len();
    self.match_case_node_equalities.increase_size_to(old_len + 1);
    let el = MatchCaseNode::from(u32::try_from(old_len).unwrap());

    self.match_case_node_new.insert(el);

    assert!(self.match_case_node_weights.len() == old_len);
    self.match_case_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_match_case_node(&mut self, mut lhs: MatchCaseNode, mut rhs: MatchCaseNode) {
    lhs = self.match_case_node_equalities.root(lhs);
    rhs = self.match_case_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.match_case_node_weights[lhs.0 as usize];
    let rhs_weight = self.match_case_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.match_case_node_equalities.union_roots_into(child, root);
    
    self.match_case_node_old.remove(&child);
    self.match_case_node_new.remove(&child);
    self.match_case_node_uprooted.push(child);
}
/// Adjoins a new element of type [MatchCaseListNode].
#[allow(dead_code)]
fn new_match_case_list_node_internal(&mut self) -> MatchCaseListNode {
    let old_len = self.match_case_list_node_equalities.len();
    self.match_case_list_node_equalities.increase_size_to(old_len + 1);
    let el = MatchCaseListNode::from(u32::try_from(old_len).unwrap());

    self.match_case_list_node_new.insert(el);

    assert!(self.match_case_list_node_weights.len() == old_len);
    self.match_case_list_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_match_case_list_node(&mut self, mut lhs: MatchCaseListNode, mut rhs: MatchCaseListNode) {
    lhs = self.match_case_list_node_equalities.root(lhs);
    rhs = self.match_case_list_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.match_case_list_node_weights[lhs.0 as usize];
    let rhs_weight = self.match_case_list_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.match_case_list_node_equalities.union_roots_into(child, root);
    
    self.match_case_list_node_old.remove(&child);
    self.match_case_list_node_new.remove(&child);
    self.match_case_list_node_uprooted.push(child);
}
/// Adjoins a new element of type [IfAtomNode].
#[allow(dead_code)]
fn new_if_atom_node_internal(&mut self) -> IfAtomNode {
    let old_len = self.if_atom_node_equalities.len();
    self.if_atom_node_equalities.increase_size_to(old_len + 1);
    let el = IfAtomNode::from(u32::try_from(old_len).unwrap());

    self.if_atom_node_new.insert(el);

    assert!(self.if_atom_node_weights.len() == old_len);
    self.if_atom_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_if_atom_node(&mut self, mut lhs: IfAtomNode, mut rhs: IfAtomNode) {
    lhs = self.if_atom_node_equalities.root(lhs);
    rhs = self.if_atom_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.if_atom_node_weights[lhs.0 as usize];
    let rhs_weight = self.if_atom_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.if_atom_node_equalities.union_roots_into(child, root);
    
    self.if_atom_node_old.remove(&child);
    self.if_atom_node_new.remove(&child);
    self.if_atom_node_uprooted.push(child);
}
/// Adjoins a new element of type [ThenAtomNode].
#[allow(dead_code)]
fn new_then_atom_node_internal(&mut self) -> ThenAtomNode {
    let old_len = self.then_atom_node_equalities.len();
    self.then_atom_node_equalities.increase_size_to(old_len + 1);
    let el = ThenAtomNode::from(u32::try_from(old_len).unwrap());

    self.then_atom_node_new.insert(el);

    assert!(self.then_atom_node_weights.len() == old_len);
    self.then_atom_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_then_atom_node(&mut self, mut lhs: ThenAtomNode, mut rhs: ThenAtomNode) {
    lhs = self.then_atom_node_equalities.root(lhs);
    rhs = self.then_atom_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.then_atom_node_weights[lhs.0 as usize];
    let rhs_weight = self.then_atom_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.then_atom_node_equalities.union_roots_into(child, root);
    
    self.then_atom_node_old.remove(&child);
    self.then_atom_node_new.remove(&child);
    self.then_atom_node_uprooted.push(child);
}
/// Adjoins a new element of type [StmtNode].
#[allow(dead_code)]
fn new_stmt_node_internal(&mut self) -> StmtNode {
    let old_len = self.stmt_node_equalities.len();
    self.stmt_node_equalities.increase_size_to(old_len + 1);
    let el = StmtNode::from(u32::try_from(old_len).unwrap());

    self.stmt_node_new.insert(el);

    assert!(self.stmt_node_weights.len() == old_len);
    self.stmt_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_stmt_node(&mut self, mut lhs: StmtNode, mut rhs: StmtNode) {
    lhs = self.stmt_node_equalities.root(lhs);
    rhs = self.stmt_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.stmt_node_weights[lhs.0 as usize];
    let rhs_weight = self.stmt_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.stmt_node_equalities.union_roots_into(child, root);
    
    self.stmt_node_old.remove(&child);
    self.stmt_node_new.remove(&child);
    self.stmt_node_uprooted.push(child);
}
/// Adjoins a new element of type [StmtListNode].
#[allow(dead_code)]
fn new_stmt_list_node_internal(&mut self) -> StmtListNode {
    let old_len = self.stmt_list_node_equalities.len();
    self.stmt_list_node_equalities.increase_size_to(old_len + 1);
    let el = StmtListNode::from(u32::try_from(old_len).unwrap());

    self.stmt_list_node_new.insert(el);

    assert!(self.stmt_list_node_weights.len() == old_len);
    self.stmt_list_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_stmt_list_node(&mut self, mut lhs: StmtListNode, mut rhs: StmtListNode) {
    lhs = self.stmt_list_node_equalities.root(lhs);
    rhs = self.stmt_list_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.stmt_list_node_weights[lhs.0 as usize];
    let rhs_weight = self.stmt_list_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.stmt_list_node_equalities.union_roots_into(child, root);
    
    self.stmt_list_node_old.remove(&child);
    self.stmt_list_node_new.remove(&child);
    self.stmt_list_node_uprooted.push(child);
}
/// Adjoins a new element of type [StmtBlockListNode].
#[allow(dead_code)]
fn new_stmt_block_list_node_internal(&mut self) -> StmtBlockListNode {
    let old_len = self.stmt_block_list_node_equalities.len();
    self.stmt_block_list_node_equalities.increase_size_to(old_len + 1);
    let el = StmtBlockListNode::from(u32::try_from(old_len).unwrap());

    self.stmt_block_list_node_new.insert(el);

    assert!(self.stmt_block_list_node_weights.len() == old_len);
    self.stmt_block_list_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_stmt_block_list_node(&mut self, mut lhs: StmtBlockListNode, mut rhs: StmtBlockListNode) {
    lhs = self.stmt_block_list_node_equalities.root(lhs);
    rhs = self.stmt_block_list_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.stmt_block_list_node_weights[lhs.0 as usize];
    let rhs_weight = self.stmt_block_list_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.stmt_block_list_node_equalities.union_roots_into(child, root);
    
    self.stmt_block_list_node_old.remove(&child);
    self.stmt_block_list_node_new.remove(&child);
    self.stmt_block_list_node_uprooted.push(child);
}
/// Adjoins a new element of type [RuleDeclNode].
#[allow(dead_code)]
fn new_rule_decl_node_internal(&mut self) -> RuleDeclNode {
    let old_len = self.rule_decl_node_equalities.len();
    self.rule_decl_node_equalities.increase_size_to(old_len + 1);
    let el = RuleDeclNode::from(u32::try_from(old_len).unwrap());

    self.rule_decl_node_new.insert(el);

    assert!(self.rule_decl_node_weights.len() == old_len);
    self.rule_decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_rule_decl_node(&mut self, mut lhs: RuleDeclNode, mut rhs: RuleDeclNode) {
    lhs = self.rule_decl_node_equalities.root(lhs);
    rhs = self.rule_decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.rule_decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.rule_decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.rule_decl_node_equalities.union_roots_into(child, root);
    
    self.rule_decl_node_old.remove(&child);
    self.rule_decl_node_new.remove(&child);
    self.rule_decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [ModelDeclNode].
#[allow(dead_code)]
fn new_model_decl_node_internal(&mut self) -> ModelDeclNode {
    let old_len = self.model_decl_node_equalities.len();
    self.model_decl_node_equalities.increase_size_to(old_len + 1);
    let el = ModelDeclNode::from(u32::try_from(old_len).unwrap());

    self.model_decl_node_new.insert(el);

    assert!(self.model_decl_node_weights.len() == old_len);
    self.model_decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_model_decl_node(&mut self, mut lhs: ModelDeclNode, mut rhs: ModelDeclNode) {
    lhs = self.model_decl_node_equalities.root(lhs);
    rhs = self.model_decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.model_decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.model_decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.model_decl_node_equalities.union_roots_into(child, root);
    
    self.model_decl_node_old.remove(&child);
    self.model_decl_node_new.remove(&child);
    self.model_decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [DeclNode].
#[allow(dead_code)]
fn new_decl_node_internal(&mut self) -> DeclNode {
    let old_len = self.decl_node_equalities.len();
    self.decl_node_equalities.increase_size_to(old_len + 1);
    let el = DeclNode::from(u32::try_from(old_len).unwrap());

    self.decl_node_new.insert(el);

    assert!(self.decl_node_weights.len() == old_len);
    self.decl_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_decl_node(&mut self, mut lhs: DeclNode, mut rhs: DeclNode) {
    lhs = self.decl_node_equalities.root(lhs);
    rhs = self.decl_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.decl_node_weights[lhs.0 as usize];
    let rhs_weight = self.decl_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.decl_node_equalities.union_roots_into(child, root);
    
    self.decl_node_old.remove(&child);
    self.decl_node_new.remove(&child);
    self.decl_node_uprooted.push(child);
}
/// Adjoins a new element of type [DeclListNode].
#[allow(dead_code)]
fn new_decl_list_node_internal(&mut self) -> DeclListNode {
    let old_len = self.decl_list_node_equalities.len();
    self.decl_list_node_equalities.increase_size_to(old_len + 1);
    let el = DeclListNode::from(u32::try_from(old_len).unwrap());

    self.decl_list_node_new.insert(el);

    assert!(self.decl_list_node_weights.len() == old_len);
    self.decl_list_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_decl_list_node(&mut self, mut lhs: DeclListNode, mut rhs: DeclListNode) {
    lhs = self.decl_list_node_equalities.root(lhs);
    rhs = self.decl_list_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.decl_list_node_weights[lhs.0 as usize];
    let rhs_weight = self.decl_list_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.decl_list_node_equalities.union_roots_into(child, root);
    
    self.decl_list_node_old.remove(&child);
    self.decl_list_node_new.remove(&child);
    self.decl_list_node_uprooted.push(child);
}
/// Adjoins a new element of type [ModuleNode].
#[allow(dead_code)]
fn new_module_node_internal(&mut self) -> ModuleNode {
    let old_len = self.module_node_equalities.len();
    self.module_node_equalities.increase_size_to(old_len + 1);
    let el = ModuleNode::from(u32::try_from(old_len).unwrap());

    self.module_node_new.insert(el);

    assert!(self.module_node_weights.len() == old_len);
    self.module_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_module_node(&mut self, mut lhs: ModuleNode, mut rhs: ModuleNode) {
    lhs = self.module_node_equalities.root(lhs);
    rhs = self.module_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.module_node_weights[lhs.0 as usize];
    let rhs_weight = self.module_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.module_node_equalities.union_roots_into(child, root);
    
    self.module_node_old.remove(&child);
    self.module_node_new.remove(&child);
    self.module_node_uprooted.push(child);
}
/// Adjoins a new element of type [Loc].
#[allow(dead_code)]
fn new_loc_internal(&mut self) -> Loc {
    let old_len = self.loc_equalities.len();
    self.loc_equalities.increase_size_to(old_len + 1);
    let el = Loc::from(u32::try_from(old_len).unwrap());

    self.loc_new.insert(el);

    assert!(self.loc_weights.len() == old_len);
    self.loc_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_loc(&mut self, mut lhs: Loc, mut rhs: Loc) {
    lhs = self.loc_equalities.root(lhs);
    rhs = self.loc_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.loc_weights[lhs.0 as usize];
    let rhs_weight = self.loc_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.loc_equalities.union_roots_into(child, root);
    
    self.loc_old.remove(&child);
    self.loc_new.remove(&child);
    self.loc_uprooted.push(child);
}
/// Adjoins a new element of type [RuleDescendantNode].
#[allow(dead_code)]
fn new_rule_descendant_node_internal(&mut self) -> RuleDescendantNode {
    let old_len = self.rule_descendant_node_equalities.len();
    self.rule_descendant_node_equalities.increase_size_to(old_len + 1);
    let el = RuleDescendantNode::from(u32::try_from(old_len).unwrap());

    self.rule_descendant_node_new.insert(el);

    assert!(self.rule_descendant_node_weights.len() == old_len);
    self.rule_descendant_node_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_rule_descendant_node(&mut self, mut lhs: RuleDescendantNode, mut rhs: RuleDescendantNode) {
    lhs = self.rule_descendant_node_equalities.root(lhs);
    rhs = self.rule_descendant_node_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.rule_descendant_node_weights[lhs.0 as usize];
    let rhs_weight = self.rule_descendant_node_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.rule_descendant_node_equalities.union_roots_into(child, root);
    
    self.rule_descendant_node_old.remove(&child);
    self.rule_descendant_node_new.remove(&child);
    self.rule_descendant_node_uprooted.push(child);
}
/// Adjoins a new element of type [Scope].
#[allow(dead_code)]
fn new_scope_internal(&mut self) -> Scope {
    let old_len = self.scope_equalities.len();
    self.scope_equalities.increase_size_to(old_len + 1);
    let el = Scope::from(u32::try_from(old_len).unwrap());

    self.scope_new.insert(el);

    assert!(self.scope_weights.len() == old_len);
    self.scope_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_scope(&mut self, mut lhs: Scope, mut rhs: Scope) {
    lhs = self.scope_equalities.root(lhs);
    rhs = self.scope_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.scope_weights[lhs.0 as usize];
    let rhs_weight = self.scope_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.scope_equalities.union_roots_into(child, root);
    
    self.scope_old.remove(&child);
    self.scope_new.remove(&child);
    self.scope_uprooted.push(child);
}
/// Adjoins a new element of type [Type].
#[allow(dead_code)]
fn new_type_internal(&mut self) -> Type {
    let old_len = self.type_equalities.len();
    self.type_equalities.increase_size_to(old_len + 1);
    let el = Type::from(u32::try_from(old_len).unwrap());

    self.type_new.insert(el);

    assert!(self.type_weights.len() == old_len);
    self.type_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_type(&mut self, mut lhs: Type, mut rhs: Type) {
    lhs = self.type_equalities.root(lhs);
    rhs = self.type_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.type_weights[lhs.0 as usize];
    let rhs_weight = self.type_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.type_equalities.union_roots_into(child, root);
    
    self.type_old.remove(&child);
    self.type_new.remove(&child);
    self.type_uprooted.push(child);
}
/// Adjoins a new element of type [Pred].
#[allow(dead_code)]
fn new_pred_internal(&mut self) -> Pred {
    let old_len = self.pred_equalities.len();
    self.pred_equalities.increase_size_to(old_len + 1);
    let el = Pred::from(u32::try_from(old_len).unwrap());

    self.pred_new.insert(el);

    assert!(self.pred_weights.len() == old_len);
    self.pred_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_pred(&mut self, mut lhs: Pred, mut rhs: Pred) {
    lhs = self.pred_equalities.root(lhs);
    rhs = self.pred_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.pred_weights[lhs.0 as usize];
    let rhs_weight = self.pred_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.pred_equalities.union_roots_into(child, root);
    
    self.pred_old.remove(&child);
    self.pred_new.remove(&child);
    self.pred_uprooted.push(child);
}
/// Adjoins a new element of type [Func].
#[allow(dead_code)]
fn new_func_internal(&mut self) -> Func {
    let old_len = self.func_equalities.len();
    self.func_equalities.increase_size_to(old_len + 1);
    let el = Func::from(u32::try_from(old_len).unwrap());

    self.func_new.insert(el);

    assert!(self.func_weights.len() == old_len);
    self.func_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_func(&mut self, mut lhs: Func, mut rhs: Func) {
    lhs = self.func_equalities.root(lhs);
    rhs = self.func_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.func_weights[lhs.0 as usize];
    let rhs_weight = self.func_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.func_equalities.union_roots_into(child, root);
    
    self.func_old.remove(&child);
    self.func_new.remove(&child);
    self.func_uprooted.push(child);
}
/// Adjoins a new element of type [Structure].
#[allow(dead_code)]
fn new_structure_internal(&mut self) -> Structure {
    let old_len = self.structure_equalities.len();
    self.structure_equalities.increase_size_to(old_len + 1);
    let el = Structure::from(u32::try_from(old_len).unwrap());

    self.structure_new.insert(el);

    assert!(self.structure_weights.len() == old_len);
    self.structure_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_structure(&mut self, mut lhs: Structure, mut rhs: Structure) {
    lhs = self.structure_equalities.root(lhs);
    rhs = self.structure_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.structure_weights[lhs.0 as usize];
    let rhs_weight = self.structure_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.structure_equalities.union_roots_into(child, root);
    
    self.structure_old.remove(&child);
    self.structure_new.remove(&child);
    self.structure_uprooted.push(child);
}
/// Adjoins a new element of type [El].
#[allow(dead_code)]
fn new_el_internal(&mut self) -> El {
    let old_len = self.el_equalities.len();
    self.el_equalities.increase_size_to(old_len + 1);
    let el = El::from(u32::try_from(old_len).unwrap());

    self.el_new.insert(el);

    assert!(self.el_weights.len() == old_len);
    self.el_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_el(&mut self, mut lhs: El, mut rhs: El) {
    lhs = self.el_equalities.root(lhs);
    rhs = self.el_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.el_weights[lhs.0 as usize];
    let rhs_weight = self.el_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.el_equalities.union_roots_into(child, root);
    
    self.el_old.remove(&child);
    self.el_new.remove(&child);
    self.el_uprooted.push(child);
}
/// Adjoins a new element of type [ElName].
#[allow(dead_code)]
fn new_el_name_internal(&mut self) -> ElName {
    let old_len = self.el_name_equalities.len();
    self.el_name_equalities.increase_size_to(old_len + 1);
    let el = ElName::from(u32::try_from(old_len).unwrap());

    self.el_name_new.insert(el);

    assert!(self.el_name_weights.len() == old_len);
    self.el_name_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_el_name(&mut self, mut lhs: ElName, mut rhs: ElName) {
    lhs = self.el_name_equalities.root(lhs);
    rhs = self.el_name_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.el_name_weights[lhs.0 as usize];
    let rhs_weight = self.el_name_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.el_name_equalities.union_roots_into(child, root);
    
    self.el_name_old.remove(&child);
    self.el_name_new.remove(&child);
    self.el_name_uprooted.push(child);
}
/// Adjoins a new element of type [Morphism].
#[allow(dead_code)]
fn new_morphism_internal(&mut self) -> Morphism {
    let old_len = self.morphism_equalities.len();
    self.morphism_equalities.increase_size_to(old_len + 1);
    let el = Morphism::from(u32::try_from(old_len).unwrap());

    self.morphism_new.insert(el);

    assert!(self.morphism_weights.len() == old_len);
    self.morphism_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_morphism(&mut self, mut lhs: Morphism, mut rhs: Morphism) {
    lhs = self.morphism_equalities.root(lhs);
    rhs = self.morphism_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.morphism_weights[lhs.0 as usize];
    let rhs_weight = self.morphism_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.morphism_equalities.union_roots_into(child, root);
    
    self.morphism_old.remove(&child);
    self.morphism_new.remove(&child);
    self.morphism_uprooted.push(child);
}
/// Adjoins a new element of type [SymbolScope].
#[allow(dead_code)]
fn new_symbol_scope_internal(&mut self) -> SymbolScope {
    let old_len = self.symbol_scope_equalities.len();
    self.symbol_scope_equalities.increase_size_to(old_len + 1);
    let el = SymbolScope::from(u32::try_from(old_len).unwrap());

    self.symbol_scope_new.insert(el);

    assert!(self.symbol_scope_weights.len() == old_len);
    self.symbol_scope_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_symbol_scope(&mut self, mut lhs: SymbolScope, mut rhs: SymbolScope) {
    lhs = self.symbol_scope_equalities.root(lhs);
    rhs = self.symbol_scope_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.symbol_scope_weights[lhs.0 as usize];
    let rhs_weight = self.symbol_scope_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.symbol_scope_equalities.union_roots_into(child, root);
    
    self.symbol_scope_old.remove(&child);
    self.symbol_scope_new.remove(&child);
    self.symbol_scope_uprooted.push(child);
}
/// Adjoins a new element of type [Nat].
#[allow(dead_code)]
fn new_nat_internal(&mut self) -> Nat {
    let old_len = self.nat_equalities.len();
    self.nat_equalities.increase_size_to(old_len + 1);
    let el = Nat::from(u32::try_from(old_len).unwrap());

    self.nat_new.insert(el);

    assert!(self.nat_weights.len() == old_len);
    self.nat_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_nat(&mut self, mut lhs: Nat, mut rhs: Nat) {
    lhs = self.nat_equalities.root(lhs);
    rhs = self.nat_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.nat_weights[lhs.0 as usize];
    let rhs_weight = self.nat_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.nat_equalities.union_roots_into(child, root);
    
    self.nat_old.remove(&child);
    self.nat_new.remove(&child);
    self.nat_uprooted.push(child);
}
/// Adjoins a new element of type [TypeList].
#[allow(dead_code)]
fn new_type_list_internal(&mut self) -> TypeList {
    let old_len = self.type_list_equalities.len();
    self.type_list_equalities.increase_size_to(old_len + 1);
    let el = TypeList::from(u32::try_from(old_len).unwrap());

    self.type_list_new.insert(el);

    assert!(self.type_list_weights.len() == old_len);
    self.type_list_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_type_list(&mut self, mut lhs: TypeList, mut rhs: TypeList) {
    lhs = self.type_list_equalities.root(lhs);
    rhs = self.type_list_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.type_list_weights[lhs.0 as usize];
    let rhs_weight = self.type_list_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.type_list_equalities.union_roots_into(child, root);
    
    self.type_list_old.remove(&child);
    self.type_list_new.remove(&child);
    self.type_list_uprooted.push(child);
}
/// Adjoins a new element of type [Rel].
#[allow(dead_code)]
fn new_rel_internal(&mut self) -> Rel {
    let old_len = self.rel_equalities.len();
    self.rel_equalities.increase_size_to(old_len + 1);
    let el = Rel::from(u32::try_from(old_len).unwrap());

    self.rel_new.insert(el);

    assert!(self.rel_weights.len() == old_len);
    self.rel_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_rel(&mut self, mut lhs: Rel, mut rhs: Rel) {
    lhs = self.rel_equalities.root(lhs);
    rhs = self.rel_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.rel_weights[lhs.0 as usize];
    let rhs_weight = self.rel_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.rel_equalities.union_roots_into(child, root);
    
    self.rel_old.remove(&child);
    self.rel_new.remove(&child);
    self.rel_uprooted.push(child);
}
/// Adjoins a new element of type [ElList].
#[allow(dead_code)]
fn new_el_list_internal(&mut self) -> ElList {
    let old_len = self.el_list_equalities.len();
    self.el_list_equalities.increase_size_to(old_len + 1);
    let el = ElList::from(u32::try_from(old_len).unwrap());

    self.el_list_new.insert(el);

    assert!(self.el_list_weights.len() == old_len);
    self.el_list_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_el_list(&mut self, mut lhs: ElList, mut rhs: ElList) {
    lhs = self.el_list_equalities.root(lhs);
    rhs = self.el_list_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.el_list_weights[lhs.0 as usize];
    let rhs_weight = self.el_list_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.el_list_equalities.union_roots_into(child, root);
    
    self.el_list_old.remove(&child);
    self.el_list_new.remove(&child);
    self.el_list_uprooted.push(child);
}
/// Adjoins a new element of type [ElementType].
#[allow(dead_code)]
fn new_element_type_internal(&mut self) -> ElementType {
    let old_len = self.element_type_equalities.len();
    self.element_type_equalities.increase_size_to(old_len + 1);
    let el = ElementType::from(u32::try_from(old_len).unwrap());

    self.element_type_new.insert(el);

    assert!(self.element_type_weights.len() == old_len);
    self.element_type_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_element_type(&mut self, mut lhs: ElementType, mut rhs: ElementType) {
    lhs = self.element_type_equalities.root(lhs);
    rhs = self.element_type_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.element_type_weights[lhs.0 as usize];
    let rhs_weight = self.element_type_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.element_type_equalities.union_roots_into(child, root);
    
    self.element_type_old.remove(&child);
    self.element_type_new.remove(&child);
    self.element_type_uprooted.push(child);
}
/// Adjoins a new element of type [ElementTypeList].
#[allow(dead_code)]
fn new_element_type_list_internal(&mut self) -> ElementTypeList {
    let old_len = self.element_type_list_equalities.len();
    self.element_type_list_equalities.increase_size_to(old_len + 1);
    let el = ElementTypeList::from(u32::try_from(old_len).unwrap());

    self.element_type_list_new.insert(el);

    assert!(self.element_type_list_weights.len() == old_len);
    self.element_type_list_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_element_type_list(&mut self, mut lhs: ElementTypeList, mut rhs: ElementTypeList) {
    lhs = self.element_type_list_equalities.root(lhs);
    rhs = self.element_type_list_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.element_type_list_weights[lhs.0 as usize];
    let rhs_weight = self.element_type_list_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.element_type_list_equalities.union_roots_into(child, root);
    
    self.element_type_list_old.remove(&child);
    self.element_type_list_new.remove(&child);
    self.element_type_list_uprooted.push(child);
}
/// Adjoins a new element of type [SymbolKind].
#[allow(dead_code)]
fn new_symbol_kind_internal(&mut self) -> SymbolKind {
    let old_len = self.symbol_kind_equalities.len();
    self.symbol_kind_equalities.increase_size_to(old_len + 1);
    let el = SymbolKind::from(u32::try_from(old_len).unwrap());

    self.symbol_kind_new.insert(el);

    assert!(self.symbol_kind_weights.len() == old_len);
    self.symbol_kind_weights.push(0);

    el
}
/// Enforces the equality `lhs = rhs`.
#[allow(dead_code)]
pub fn equate_symbol_kind(&mut self, mut lhs: SymbolKind, mut rhs: SymbolKind) {
    lhs = self.symbol_kind_equalities.root(lhs);
    rhs = self.symbol_kind_equalities.root(rhs);
    if lhs == rhs {
        return;
    }

    let lhs_weight = self.symbol_kind_weights[lhs.0 as usize];
    let rhs_weight = self.symbol_kind_weights[rhs.0 as usize];
    let (root, child) =
        if lhs_weight >= rhs_weight {
            (lhs, rhs)
        } else {
            (rhs, lhs)
        };

    self.symbol_kind_equalities.union_roots_into(child, root);
    
    self.symbol_kind_old.remove(&child);
    self.symbol_kind_new.remove(&child);
    self.symbol_kind_uprooted.push(child);
}
/// Adjoins a new element of type [Ident].
#[allow(dead_code)]
pub fn new_ident(&mut self) -> Ident {
    self.new_ident_internal()
}
/// Adjoins a new element of type [VirtIdent].
#[allow(dead_code)]
pub fn new_virt_ident(&mut self) -> VirtIdent {
    self.new_virt_ident_internal()
}
/// Adjoins a new element of type [TypeDeclNode].
#[allow(dead_code)]
pub fn new_type_decl_node(&mut self) -> TypeDeclNode {
    self.new_type_decl_node_internal()
}
/// Adjoins a new element of type [ArgDeclNode].
#[allow(dead_code)]
pub fn new_arg_decl_node(&mut self) -> ArgDeclNode {
    self.new_arg_decl_node_internal()
}
/// Adjoins a new element of type [ArgDeclListNode].
#[allow(dead_code)]
pub fn new_arg_decl_list_node(&mut self) -> ArgDeclListNode {
    self.new_arg_decl_list_node_internal()
}
/// Adjoins a new element of type [PredDeclNode].
#[allow(dead_code)]
pub fn new_pred_decl_node(&mut self) -> PredDeclNode {
    self.new_pred_decl_node_internal()
}
/// Adjoins a new element of type [FuncDeclNode].
#[allow(dead_code)]
pub fn new_func_decl_node(&mut self) -> FuncDeclNode {
    self.new_func_decl_node_internal()
}
/// Adjoins a new element of type [CtorDeclNode].
#[allow(dead_code)]
pub fn new_ctor_decl_node(&mut self) -> CtorDeclNode {
    self.new_ctor_decl_node_internal()
}
/// Adjoins a new element of type [CtorDeclListNode].
#[allow(dead_code)]
pub fn new_ctor_decl_list_node(&mut self) -> CtorDeclListNode {
    self.new_ctor_decl_list_node_internal()
}
/// Adjoins a new element of type [EnumDeclNode].
#[allow(dead_code)]
pub fn new_enum_decl_node(&mut self) -> EnumDeclNode {
    self.new_enum_decl_node_internal()
}
/// Adjoins a new element of type [TermNode].
#[allow(dead_code)]
pub fn new_term_node(&mut self) -> TermNode {
    self.new_term_node_internal()
}
/// Adjoins a new element of type [TermListNode].
#[allow(dead_code)]
pub fn new_term_list_node(&mut self) -> TermListNode {
    self.new_term_list_node_internal()
}
/// Adjoins a new element of type [TypeExprNode].
#[allow(dead_code)]
pub fn new_type_expr_node(&mut self) -> TypeExprNode {
    self.new_type_expr_node_internal()
}
/// Adjoins a new element of type [OptTermNode].
#[allow(dead_code)]
pub fn new_opt_term_node(&mut self) -> OptTermNode {
    self.new_opt_term_node_internal()
}
/// Adjoins a new element of type [MatchCaseNode].
#[allow(dead_code)]
pub fn new_match_case_node(&mut self) -> MatchCaseNode {
    self.new_match_case_node_internal()
}
/// Adjoins a new element of type [MatchCaseListNode].
#[allow(dead_code)]
pub fn new_match_case_list_node(&mut self) -> MatchCaseListNode {
    self.new_match_case_list_node_internal()
}
/// Adjoins a new element of type [IfAtomNode].
#[allow(dead_code)]
pub fn new_if_atom_node(&mut self) -> IfAtomNode {
    self.new_if_atom_node_internal()
}
/// Adjoins a new element of type [ThenAtomNode].
#[allow(dead_code)]
pub fn new_then_atom_node(&mut self) -> ThenAtomNode {
    self.new_then_atom_node_internal()
}
/// Adjoins a new element of type [StmtNode].
#[allow(dead_code)]
pub fn new_stmt_node(&mut self) -> StmtNode {
    self.new_stmt_node_internal()
}
/// Adjoins a new element of type [StmtListNode].
#[allow(dead_code)]
pub fn new_stmt_list_node(&mut self) -> StmtListNode {
    self.new_stmt_list_node_internal()
}
/// Adjoins a new element of type [StmtBlockListNode].
#[allow(dead_code)]
pub fn new_stmt_block_list_node(&mut self) -> StmtBlockListNode {
    self.new_stmt_block_list_node_internal()
}
/// Adjoins a new element of type [RuleDeclNode].
#[allow(dead_code)]
pub fn new_rule_decl_node(&mut self) -> RuleDeclNode {
    self.new_rule_decl_node_internal()
}
/// Adjoins a new element of type [ModelDeclNode].
#[allow(dead_code)]
pub fn new_model_decl_node(&mut self) -> ModelDeclNode {
    self.new_model_decl_node_internal()
}
/// Adjoins a new element of type [DeclNode].
#[allow(dead_code)]
pub fn new_decl_node(&mut self) -> DeclNode {
    self.new_decl_node_internal()
}
/// Adjoins a new element of type [DeclListNode].
#[allow(dead_code)]
pub fn new_decl_list_node(&mut self) -> DeclListNode {
    self.new_decl_list_node_internal()
}
/// Adjoins a new element of type [ModuleNode].
#[allow(dead_code)]
pub fn new_module_node(&mut self) -> ModuleNode {
    self.new_module_node_internal()
}
/// Adjoins a new element of type [Loc].
#[allow(dead_code)]
pub fn new_loc(&mut self) -> Loc {
    self.new_loc_internal()
}
/// Adjoins a new element of type [RuleDescendantNode].
#[allow(dead_code)]
pub fn new_rule_descendant_node(&mut self) -> RuleDescendantNode {
    self.new_rule_descendant_node_internal()
}
/// Adjoins a new element of type [Scope].
#[allow(dead_code)]
pub fn new_scope(&mut self) -> Scope {
    self.new_scope_internal()
}
/// Adjoins a new element of type [Type].
#[allow(dead_code)]
pub fn new_type(&mut self) -> Type {
    self.new_type_internal()
}
/// Adjoins a new element of type [Pred].
#[allow(dead_code)]
pub fn new_pred(&mut self) -> Pred {
    self.new_pred_internal()
}
/// Adjoins a new element of type [Func].
#[allow(dead_code)]
pub fn new_func(&mut self) -> Func {
    self.new_func_internal()
}
/// Adjoins a new element of type [Structure].
#[allow(dead_code)]
pub fn new_structure(&mut self) -> Structure {
    self.new_structure_internal()
}
/// Adjoins a new element of type [El].
#[allow(dead_code)]
pub fn new_el(&mut self) -> El {
    self.new_el_internal()
}
/// Adjoins a new element of type [ElName].
#[allow(dead_code)]
pub fn new_el_name(&mut self) -> ElName {
    self.new_el_name_internal()
}
/// Adjoins a new element of type [Morphism].
#[allow(dead_code)]
pub fn new_morphism(&mut self) -> Morphism {
    self.new_morphism_internal()
}
/// Adjoins a new element of type [SymbolScope].
#[allow(dead_code)]
pub fn new_symbol_scope(&mut self) -> SymbolScope {
    self.new_symbol_scope_internal()
}
/// Adjoins a new element of type [Nat].
#[allow(dead_code)]
pub fn new_nat(&mut self) -> Nat {
    self.new_nat_internal()
}
/// Adjoins a new element of type [TypeList].
#[allow(dead_code)]
pub fn new_type_list(&mut self, value: TypeListCase) -> TypeList {
    match value {
        TypeListCase::NilTypeList() => {
    self.define_nil_type_list()
}
TypeListCase::ConsTypeList(tm0, tm1) => {
    self.define_cons_type_list(tm0, tm1)
}
TypeListCase::SnocTypeList(tm0, tm1) => {
    self.define_snoc_type_list(tm0, tm1)
}

    }
}
/// Returns an iterator over ways to destructure an [TypeList] element.
#[allow(dead_code)]
pub fn type_list_cases<'a>(&'a self, el: TypeList) -> impl 'a + Iterator<Item = TypeListCase> {
let el = self.type_list_equalities.root_const(el);
#[allow(unused_parens)]
[].into_iter().chain(self.iter_nil_type_list().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(TypeListCase::NilTypeList())
    } else {
        None
    }
}))

.chain(self.iter_cons_type_list().filter_map(move |(tm0, tm1, tm2)| {
    if el == tm2 {
        Some(TypeListCase::ConsTypeList(tm0, tm1))
    } else {
        None
    }
}))

.chain(self.iter_snoc_type_list().filter_map(move |(tm0, tm1, tm2)| {
    if el == tm2 {
        Some(TypeListCase::SnocTypeList(tm0, tm1))
    } else {
        None
    }
}))

}

/// Returns the first way to destructure an [TypeList] element.
#[allow(dead_code)]
pub fn type_list_case(&self, el: TypeList) -> TypeListCase {
    self.type_list_cases(el).next().unwrap()
}
/// Adjoins a new element of type [Rel].
#[allow(dead_code)]
pub fn new_rel(&mut self, value: RelCase) -> Rel {
    match value {
        RelCase::PredRel(tm0) => {
    self.define_pred_rel(tm0)
}
RelCase::FuncRel(tm0) => {
    self.define_func_rel(tm0)
}

    }
}
/// Returns an iterator over ways to destructure an [Rel] element.
#[allow(dead_code)]
pub fn rel_cases<'a>(&'a self, el: Rel) -> impl 'a + Iterator<Item = RelCase> {
let el = self.rel_equalities.root_const(el);
#[allow(unused_parens)]
[].into_iter().chain(self.iter_pred_rel().filter_map(move |(tm0, tm1)| {
    if el == tm1 {
        Some(RelCase::PredRel(tm0))
    } else {
        None
    }
}))

.chain(self.iter_func_rel().filter_map(move |(tm0, tm1)| {
    if el == tm1 {
        Some(RelCase::FuncRel(tm0))
    } else {
        None
    }
}))

}

/// Returns the first way to destructure an [Rel] element.
#[allow(dead_code)]
pub fn rel_case(&self, el: Rel) -> RelCase {
    self.rel_cases(el).next().unwrap()
}
/// Adjoins a new element of type [ElList].
#[allow(dead_code)]
pub fn new_el_list(&mut self, value: ElListCase) -> ElList {
    match value {
        ElListCase::NilElList(tm0) => {
    self.define_nil_el_list(tm0)
}
ElListCase::ConsElList(tm0, tm1) => {
    self.define_cons_el_list(tm0, tm1)
}
ElListCase::SnocElList(tm0, tm1) => {
    self.define_snoc_el_list(tm0, tm1)
}

    }
}
/// Returns an iterator over ways to destructure an [ElList] element.
#[allow(dead_code)]
pub fn el_list_cases<'a>(&'a self, el: ElList) -> impl 'a + Iterator<Item = ElListCase> {
let el = self.el_list_equalities.root_const(el);
#[allow(unused_parens)]
[].into_iter().chain(self.iter_nil_el_list().filter_map(move |(tm0, tm1)| {
    if el == tm1 {
        Some(ElListCase::NilElList(tm0))
    } else {
        None
    }
}))

.chain(self.iter_cons_el_list().filter_map(move |(tm0, tm1, tm2)| {
    if el == tm2 {
        Some(ElListCase::ConsElList(tm0, tm1))
    } else {
        None
    }
}))

.chain(self.iter_snoc_el_list().filter_map(move |(tm0, tm1, tm2)| {
    if el == tm2 {
        Some(ElListCase::SnocElList(tm0, tm1))
    } else {
        None
    }
}))

}

/// Returns the first way to destructure an [ElList] element.
#[allow(dead_code)]
pub fn el_list_case(&self, el: ElList) -> ElListCase {
    self.el_list_cases(el).next().unwrap()
}
/// Adjoins a new element of type [ElementType].
#[allow(dead_code)]
pub fn new_element_type(&mut self, value: ElementTypeCase) -> ElementType {
    match value {
        ElementTypeCase::AmbientType(tm0) => {
    self.define_ambient_type(tm0)
}
ElementTypeCase::InstantiatedType(tm0, tm1) => {
    self.define_instantiated_type(tm0, tm1)
}

    }
}
/// Returns an iterator over ways to destructure an [ElementType] element.
#[allow(dead_code)]
pub fn element_type_cases<'a>(&'a self, el: ElementType) -> impl 'a + Iterator<Item = ElementTypeCase> {
let el = self.element_type_equalities.root_const(el);
#[allow(unused_parens)]
[].into_iter().chain(self.iter_ambient_type().filter_map(move |(tm0, tm1)| {
    if el == tm1 {
        Some(ElementTypeCase::AmbientType(tm0))
    } else {
        None
    }
}))

.chain(self.iter_instantiated_type().filter_map(move |(tm0, tm1, tm2)| {
    if el == tm2 {
        Some(ElementTypeCase::InstantiatedType(tm0, tm1))
    } else {
        None
    }
}))

}

/// Returns the first way to destructure an [ElementType] element.
#[allow(dead_code)]
pub fn element_type_case(&self, el: ElementType) -> ElementTypeCase {
    self.element_type_cases(el).next().unwrap()
}
/// Adjoins a new element of type [ElementTypeList].
#[allow(dead_code)]
pub fn new_element_type_list(&mut self, value: ElementTypeListCase) -> ElementTypeList {
    match value {
        ElementTypeListCase::NilElementTypeList() => {
    self.define_nil_element_type_list()
}
ElementTypeListCase::ConsElementTypeList(tm0, tm1) => {
    self.define_cons_element_type_list(tm0, tm1)
}
ElementTypeListCase::SnocElementTypeList(tm0, tm1) => {
    self.define_snoc_element_type_list(tm0, tm1)
}

    }
}
/// Returns an iterator over ways to destructure an [ElementTypeList] element.
#[allow(dead_code)]
pub fn element_type_list_cases<'a>(&'a self, el: ElementTypeList) -> impl 'a + Iterator<Item = ElementTypeListCase> {
let el = self.element_type_list_equalities.root_const(el);
#[allow(unused_parens)]
[].into_iter().chain(self.iter_nil_element_type_list().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(ElementTypeListCase::NilElementTypeList())
    } else {
        None
    }
}))

.chain(self.iter_cons_element_type_list().filter_map(move |(tm0, tm1, tm2)| {
    if el == tm2 {
        Some(ElementTypeListCase::ConsElementTypeList(tm0, tm1))
    } else {
        None
    }
}))

.chain(self.iter_snoc_element_type_list().filter_map(move |(tm0, tm1, tm2)| {
    if el == tm2 {
        Some(ElementTypeListCase::SnocElementTypeList(tm0, tm1))
    } else {
        None
    }
}))

}

/// Returns the first way to destructure an [ElementTypeList] element.
#[allow(dead_code)]
pub fn element_type_list_case(&self, el: ElementTypeList) -> ElementTypeListCase {
    self.element_type_list_cases(el).next().unwrap()
}
/// Adjoins a new element of type [SymbolKind].
#[allow(dead_code)]
pub fn new_symbol_kind(&mut self, value: SymbolKindCase) -> SymbolKind {
    match value {
        SymbolKindCase::TypeSymbol() => {
    self.define_type_symbol()
}
SymbolKindCase::PredSymbol() => {
    self.define_pred_symbol()
}
SymbolKindCase::FuncSymbol() => {
    self.define_func_symbol()
}
SymbolKindCase::RuleSymbol() => {
    self.define_rule_symbol()
}
SymbolKindCase::EnumSymbol() => {
    self.define_enum_symbol()
}
SymbolKindCase::CtorSymbol() => {
    self.define_ctor_symbol()
}
SymbolKindCase::ModelSymbol() => {
    self.define_model_symbol()
}

    }
}
/// Returns an iterator over ways to destructure an [SymbolKind] element.
#[allow(dead_code)]
pub fn symbol_kind_cases<'a>(&'a self, el: SymbolKind) -> impl 'a + Iterator<Item = SymbolKindCase> {
let el = self.symbol_kind_equalities.root_const(el);
#[allow(unused_parens)]
[].into_iter().chain(self.iter_type_symbol().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(SymbolKindCase::TypeSymbol())
    } else {
        None
    }
}))

.chain(self.iter_pred_symbol().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(SymbolKindCase::PredSymbol())
    } else {
        None
    }
}))

.chain(self.iter_func_symbol().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(SymbolKindCase::FuncSymbol())
    } else {
        None
    }
}))

.chain(self.iter_rule_symbol().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(SymbolKindCase::RuleSymbol())
    } else {
        None
    }
}))

.chain(self.iter_enum_symbol().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(SymbolKindCase::EnumSymbol())
    } else {
        None
    }
}))

.chain(self.iter_ctor_symbol().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(SymbolKindCase::CtorSymbol())
    } else {
        None
    }
}))

.chain(self.iter_model_symbol().filter_map(move |(tm0)| {
    if el == tm0 {
        Some(SymbolKindCase::ModelSymbol())
    } else {
        None
    }
}))

}

/// Returns the first way to destructure an [SymbolKind] element.
#[allow(dead_code)]
pub fn symbol_kind_case(&self, el: SymbolKind) -> SymbolKindCase {
    self.symbol_kind_cases(el).next().unwrap()
}
/// Evaluates `real_virt_ident(arg0)`.
#[allow(dead_code)]
pub fn real_virt_ident(&self, mut arg0: Ident) -> Option<VirtIdent> {
    arg0 = self.root_ident(arg0);
    self.real_virt_ident.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `real_virt_ident` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_real_virt_ident(&self) -> impl '_ + Iterator<Item=(Ident, VirtIdent)> {
    self.real_virt_ident.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `real_virt_ident(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_real_virt_ident(&mut self, mut tm0: Ident, mut tm1: VirtIdent) {
    tm0 = self.ident_equalities.root(tm0);
tm1 = self.virt_ident_equalities.root(tm1);
    if self.real_virt_ident.insert(RealVirtIdent(tm0, tm1)) {
        let weight0 = &mut self.ident_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RealVirtIdentTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RealVirtIdentTable::WEIGHT);

    }
}

/// Evaluates `virt_real_ident(arg0)`.
#[allow(dead_code)]
pub fn virt_real_ident(&self, mut arg0: VirtIdent) -> Option<Ident> {
    arg0 = self.root_virt_ident(arg0);
    self.virt_real_ident.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `virt_real_ident` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_virt_real_ident(&self) -> impl '_ + Iterator<Item=(VirtIdent, Ident)> {
    self.virt_real_ident.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `virt_real_ident(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_virt_real_ident(&mut self, mut tm0: VirtIdent, mut tm1: Ident) {
    tm0 = self.virt_ident_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.virt_real_ident.insert(VirtRealIdent(tm0, tm1)) {
        let weight0 = &mut self.virt_ident_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(VirtRealIdentTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(VirtRealIdentTable::WEIGHT);

    }
}

/// Evaluates `var(arg0, arg1)`.
#[allow(dead_code)]
pub fn var(&self, mut arg0: Structure, mut arg1: ElName) -> Option<El> {
    arg0 = self.root_structure(arg0);
arg1 = self.root_el_name(arg1);
    self.var.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `var` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_var(&self) -> impl '_ + Iterator<Item=(Structure, ElName, El)> {
    self.var.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `var(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_var(&mut self, mut tm0: Structure, mut tm1: ElName, mut tm2: El) {
    tm0 = self.structure_equalities.root(tm0);
tm1 = self.el_name_equalities.root(tm1);
tm2 = self.el_equalities.root(tm2);
    if self.var.insert(Var(tm0, tm1, tm2)) {
        let weight0 = &mut self.structure_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(VarTable::WEIGHT);

let weight1 = &mut self.el_name_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(VarTable::WEIGHT);

let weight2 = &mut self.el_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(VarTable::WEIGHT);

    }
}

/// Evaluates `rule_name(arg0)`.
#[allow(dead_code)]
pub fn rule_name(&self, mut arg0: RuleDeclNode) -> Option<Ident> {
    arg0 = self.root_rule_decl_node(arg0);
    self.rule_name.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_name` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_name(&self) -> impl '_ + Iterator<Item=(RuleDeclNode, Ident)> {
    self.rule_name.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_name(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_name(&mut self, mut tm0: RuleDeclNode, mut tm1: Ident) {
    tm0 = self.rule_decl_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.rule_name.insert(RuleName(tm0, tm1)) {
        let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleNameTable::WEIGHT);

    }
}

/// Evaluates `module_name(arg0)`.
#[allow(dead_code)]
pub fn module_name(&self, mut arg0: ModuleNode) -> Option<Ident> {
    arg0 = self.root_module_node(arg0);
    self.module_name.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `module_name` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_module_name(&self) -> impl '_ + Iterator<Item=(ModuleNode, Ident)> {
    self.module_name.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `module_name(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_module_name(&mut self, mut tm0: ModuleNode, mut tm1: Ident) {
    tm0 = self.module_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.module_name.insert(ModuleName(tm0, tm1)) {
        let weight0 = &mut self.module_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ModuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ModuleNameTable::WEIGHT);

    }
}

/// Evaluates `type_decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn type_decl_node_loc(&self, mut arg0: TypeDeclNode) -> Option<Loc> {
    arg0 = self.root_type_decl_node(arg0);
    self.type_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `type_decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_type_decl_node_loc(&self) -> impl '_ + Iterator<Item=(TypeDeclNode, Loc)> {
    self.type_decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `type_decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_type_decl_node_loc(&mut self, mut tm0: TypeDeclNode, mut tm1: Loc) {
    tm0 = self.type_decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.type_decl_node_loc.insert(TypeDeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.type_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TypeDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TypeDeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `arg_decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn arg_decl_node_loc(&self, mut arg0: ArgDeclNode) -> Option<Loc> {
    arg0 = self.root_arg_decl_node(arg0);
    self.arg_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `arg_decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_arg_decl_node_loc(&self) -> impl '_ + Iterator<Item=(ArgDeclNode, Loc)> {
    self.arg_decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `arg_decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_arg_decl_node_loc(&mut self, mut tm0: ArgDeclNode, mut tm1: Loc) {
    tm0 = self.arg_decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.arg_decl_node_loc.insert(ArgDeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.arg_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `arg_decl_list_node_loc(arg0)`.
#[allow(dead_code)]
pub fn arg_decl_list_node_loc(&self, mut arg0: ArgDeclListNode) -> Option<Loc> {
    arg0 = self.root_arg_decl_list_node(arg0);
    self.arg_decl_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `arg_decl_list_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_arg_decl_list_node_loc(&self) -> impl '_ + Iterator<Item=(ArgDeclListNode, Loc)> {
    self.arg_decl_list_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `arg_decl_list_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_arg_decl_list_node_loc(&mut self, mut tm0: ArgDeclListNode, mut tm1: Loc) {
    tm0 = self.arg_decl_list_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.arg_decl_list_node_loc.insert(ArgDeclListNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

    }
}

/// Evaluates `pred_decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn pred_decl_node_loc(&self, mut arg0: PredDeclNode) -> Option<Loc> {
    arg0 = self.root_pred_decl_node(arg0);
    self.pred_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `pred_decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_pred_decl_node_loc(&self) -> impl '_ + Iterator<Item=(PredDeclNode, Loc)> {
    self.pred_decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `pred_decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_pred_decl_node_loc(&mut self, mut tm0: PredDeclNode, mut tm1: Loc) {
    tm0 = self.pred_decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.pred_decl_node_loc.insert(PredDeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.pred_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PredDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(PredDeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `func_decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn func_decl_node_loc(&self, mut arg0: FuncDeclNode) -> Option<Loc> {
    arg0 = self.root_func_decl_node(arg0);
    self.func_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `func_decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_func_decl_node_loc(&self) -> impl '_ + Iterator<Item=(FuncDeclNode, Loc)> {
    self.func_decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `func_decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_func_decl_node_loc(&mut self, mut tm0: FuncDeclNode, mut tm1: Loc) {
    tm0 = self.func_decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.func_decl_node_loc.insert(FuncDeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.func_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FuncDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(FuncDeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `ctor_decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn ctor_decl_node_loc(&self, mut arg0: CtorDeclNode) -> Option<Loc> {
    arg0 = self.root_ctor_decl_node(arg0);
    self.ctor_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `ctor_decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ctor_decl_node_loc(&self) -> impl '_ + Iterator<Item=(CtorDeclNode, Loc)> {
    self.ctor_decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ctor_decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ctor_decl_node_loc(&mut self, mut tm0: CtorDeclNode, mut tm1: Loc) {
    tm0 = self.ctor_decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.ctor_decl_node_loc.insert(CtorDeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.ctor_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CtorDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CtorDeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `enum_decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn enum_decl_node_loc(&self, mut arg0: EnumDeclNode) -> Option<Loc> {
    arg0 = self.root_enum_decl_node(arg0);
    self.enum_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `enum_decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_enum_decl_node_loc(&self) -> impl '_ + Iterator<Item=(EnumDeclNode, Loc)> {
    self.enum_decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `enum_decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_enum_decl_node_loc(&mut self, mut tm0: EnumDeclNode, mut tm1: Loc) {
    tm0 = self.enum_decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.enum_decl_node_loc.insert(EnumDeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.enum_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(EnumDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(EnumDeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `model_decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn model_decl_node_loc(&self, mut arg0: ModelDeclNode) -> Option<Loc> {
    arg0 = self.root_model_decl_node(arg0);
    self.model_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `model_decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_model_decl_node_loc(&self) -> impl '_ + Iterator<Item=(ModelDeclNode, Loc)> {
    self.model_decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `model_decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_model_decl_node_loc(&mut self, mut tm0: ModelDeclNode, mut tm1: Loc) {
    tm0 = self.model_decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.model_decl_node_loc.insert(ModelDeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.model_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ModelDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ModelDeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `term_node_loc(arg0)`.
#[allow(dead_code)]
pub fn term_node_loc(&self, mut arg0: TermNode) -> Option<Loc> {
    arg0 = self.root_term_node(arg0);
    self.term_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `term_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_term_node_loc(&self) -> impl '_ + Iterator<Item=(TermNode, Loc)> {
    self.term_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `term_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_term_node_loc(&mut self, mut tm0: TermNode, mut tm1: Loc) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.term_node_loc.insert(TermNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TermNodeLocTable::WEIGHT);

    }
}

/// Evaluates `term_list_node_loc(arg0)`.
#[allow(dead_code)]
pub fn term_list_node_loc(&self, mut arg0: TermListNode) -> Option<Loc> {
    arg0 = self.root_term_list_node(arg0);
    self.term_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `term_list_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_term_list_node_loc(&self) -> impl '_ + Iterator<Item=(TermListNode, Loc)> {
    self.term_list_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `term_list_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_term_list_node_loc(&mut self, mut tm0: TermListNode, mut tm1: Loc) {
    tm0 = self.term_list_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.term_list_node_loc.insert(TermListNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TermListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TermListNodeLocTable::WEIGHT);

    }
}

/// Evaluates `match_case_node_loc(arg0)`.
#[allow(dead_code)]
pub fn match_case_node_loc(&self, mut arg0: MatchCaseNode) -> Option<Loc> {
    arg0 = self.root_match_case_node(arg0);
    self.match_case_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `match_case_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_match_case_node_loc(&self) -> impl '_ + Iterator<Item=(MatchCaseNode, Loc)> {
    self.match_case_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `match_case_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_match_case_node_loc(&mut self, mut tm0: MatchCaseNode, mut tm1: Loc) {
    tm0 = self.match_case_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.match_case_node_loc.insert(MatchCaseNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MatchCaseNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MatchCaseNodeLocTable::WEIGHT);

    }
}

/// Evaluates `opt_term_node_loc(arg0)`.
#[allow(dead_code)]
pub fn opt_term_node_loc(&self, mut arg0: OptTermNode) -> Option<Loc> {
    arg0 = self.root_opt_term_node(arg0);
    self.opt_term_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `opt_term_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_opt_term_node_loc(&self) -> impl '_ + Iterator<Item=(OptTermNode, Loc)> {
    self.opt_term_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `opt_term_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_opt_term_node_loc(&mut self, mut tm0: OptTermNode, mut tm1: Loc) {
    tm0 = self.opt_term_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.opt_term_node_loc.insert(OptTermNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(OptTermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(OptTermNodeLocTable::WEIGHT);

    }
}

/// Evaluates `if_atom_node_loc(arg0)`.
#[allow(dead_code)]
pub fn if_atom_node_loc(&self, mut arg0: IfAtomNode) -> Option<Loc> {
    arg0 = self.root_if_atom_node(arg0);
    self.if_atom_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `if_atom_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_if_atom_node_loc(&self) -> impl '_ + Iterator<Item=(IfAtomNode, Loc)> {
    self.if_atom_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `if_atom_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_if_atom_node_loc(&mut self, mut tm0: IfAtomNode, mut tm1: Loc) {
    tm0 = self.if_atom_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.if_atom_node_loc.insert(IfAtomNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomNodeLocTable::WEIGHT);

    }
}

/// Evaluates `then_atom_node_loc(arg0)`.
#[allow(dead_code)]
pub fn then_atom_node_loc(&self, mut arg0: ThenAtomNode) -> Option<Loc> {
    arg0 = self.root_then_atom_node(arg0);
    self.then_atom_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `then_atom_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_then_atom_node_loc(&self) -> impl '_ + Iterator<Item=(ThenAtomNode, Loc)> {
    self.then_atom_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `then_atom_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_then_atom_node_loc(&mut self, mut tm0: ThenAtomNode, mut tm1: Loc) {
    tm0 = self.then_atom_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.then_atom_node_loc.insert(ThenAtomNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomNodeLocTable::WEIGHT);

    }
}

/// Evaluates `stmt_node_loc(arg0)`.
#[allow(dead_code)]
pub fn stmt_node_loc(&self, mut arg0: StmtNode) -> Option<Loc> {
    arg0 = self.root_stmt_node(arg0);
    self.stmt_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `stmt_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_stmt_node_loc(&self) -> impl '_ + Iterator<Item=(StmtNode, Loc)> {
    self.stmt_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `stmt_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_stmt_node_loc(&mut self, mut tm0: StmtNode, mut tm1: Loc) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.stmt_node_loc.insert(StmtNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(StmtNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(StmtNodeLocTable::WEIGHT);

    }
}

/// Evaluates `stmt_list_node_loc(arg0)`.
#[allow(dead_code)]
pub fn stmt_list_node_loc(&self, mut arg0: StmtListNode) -> Option<Loc> {
    arg0 = self.root_stmt_list_node(arg0);
    self.stmt_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `stmt_list_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_stmt_list_node_loc(&self) -> impl '_ + Iterator<Item=(StmtListNode, Loc)> {
    self.stmt_list_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `stmt_list_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_stmt_list_node_loc(&mut self, mut tm0: StmtListNode, mut tm1: Loc) {
    tm0 = self.stmt_list_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.stmt_list_node_loc.insert(StmtListNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(StmtListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(StmtListNodeLocTable::WEIGHT);

    }
}

/// Evaluates `rule_decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn rule_decl_node_loc(&self, mut arg0: RuleDeclNode) -> Option<Loc> {
    arg0 = self.root_rule_decl_node(arg0);
    self.rule_decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_decl_node_loc(&self) -> impl '_ + Iterator<Item=(RuleDeclNode, Loc)> {
    self.rule_decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_decl_node_loc(&mut self, mut tm0: RuleDeclNode, mut tm1: Loc) {
    tm0 = self.rule_decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.rule_decl_node_loc.insert(RuleDeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `decl_node_loc(arg0)`.
#[allow(dead_code)]
pub fn decl_node_loc(&self, mut arg0: DeclNode) -> Option<Loc> {
    arg0 = self.root_decl_node(arg0);
    self.decl_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `decl_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_decl_node_loc(&self) -> impl '_ + Iterator<Item=(DeclNode, Loc)> {
    self.decl_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `decl_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_decl_node_loc(&mut self, mut tm0: DeclNode, mut tm1: Loc) {
    tm0 = self.decl_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.decl_node_loc.insert(DeclNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeLocTable::WEIGHT);

    }
}

/// Evaluates `decl_list_node_loc(arg0)`.
#[allow(dead_code)]
pub fn decl_list_node_loc(&self, mut arg0: DeclListNode) -> Option<Loc> {
    arg0 = self.root_decl_list_node(arg0);
    self.decl_list_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `decl_list_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_decl_list_node_loc(&self) -> impl '_ + Iterator<Item=(DeclListNode, Loc)> {
    self.decl_list_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `decl_list_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_decl_list_node_loc(&mut self, mut tm0: DeclListNode, mut tm1: Loc) {
    tm0 = self.decl_list_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.decl_list_node_loc.insert(DeclListNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclListNodeLocTable::WEIGHT);

    }
}

/// Evaluates `module_node_loc(arg0)`.
#[allow(dead_code)]
pub fn module_node_loc(&self, mut arg0: ModuleNode) -> Option<Loc> {
    arg0 = self.root_module_node(arg0);
    self.module_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `module_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_module_node_loc(&self) -> impl '_ + Iterator<Item=(ModuleNode, Loc)> {
    self.module_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `module_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_module_node_loc(&mut self, mut tm0: ModuleNode, mut tm1: Loc) {
    tm0 = self.module_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.module_node_loc.insert(ModuleNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.module_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ModuleNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ModuleNodeLocTable::WEIGHT);

    }
}

/// Evaluates `type_expr_node_loc(arg0)`.
#[allow(dead_code)]
pub fn type_expr_node_loc(&self, mut arg0: TypeExprNode) -> Option<Loc> {
    arg0 = self.root_type_expr_node(arg0);
    self.type_expr_node_loc.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `type_expr_node_loc` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_type_expr_node_loc(&self) -> impl '_ + Iterator<Item=(TypeExprNode, Loc)> {
    self.type_expr_node_loc.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `type_expr_node_loc(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_type_expr_node_loc(&mut self, mut tm0: TypeExprNode, mut tm1: Loc) {
    tm0 = self.type_expr_node_equalities.root(tm0);
tm1 = self.loc_equalities.root(tm1);
    if self.type_expr_node_loc.insert(TypeExprNodeLoc(tm0, tm1)) {
        let weight0 = &mut self.type_expr_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TypeExprNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TypeExprNodeLocTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_rule(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_rule(&self, mut arg0: RuleDeclNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_rule_decl_node(arg0);
    self.rule_descendant_rule.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_rule` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_rule(&self) -> impl '_ + Iterator<Item=(RuleDeclNode, RuleDescendantNode)> {
    self.rule_descendant_rule.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_rule(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_rule(&mut self, mut tm0: RuleDeclNode, mut tm1: RuleDescendantNode) {
    tm0 = self.rule_decl_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_rule.insert(RuleDescendantRule(tm0, tm1)) {
        let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantRuleTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantRuleTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_term(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_term(&self, mut arg0: TermNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_term_node(arg0);
    self.rule_descendant_term.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_term` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_term(&self) -> impl '_ + Iterator<Item=(TermNode, RuleDescendantNode)> {
    self.rule_descendant_term.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_term(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_term(&mut self, mut tm0: TermNode, mut tm1: RuleDescendantNode) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_term.insert(RuleDescendantTerm(tm0, tm1)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTermTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_term_list(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_term_list(&self, mut arg0: TermListNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_term_list_node(arg0);
    self.rule_descendant_term_list.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_term_list` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_term_list(&self) -> impl '_ + Iterator<Item=(TermListNode, RuleDescendantNode)> {
    self.rule_descendant_term_list.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_term_list(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_term_list(&mut self, mut tm0: TermListNode, mut tm1: RuleDescendantNode) {
    tm0 = self.term_list_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_term_list.insert(RuleDescendantTermList(tm0, tm1)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTermListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTermListTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_opt_term(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_opt_term(&self, mut arg0: OptTermNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_opt_term_node(arg0);
    self.rule_descendant_opt_term.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_opt_term` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_opt_term(&self) -> impl '_ + Iterator<Item=(OptTermNode, RuleDescendantNode)> {
    self.rule_descendant_opt_term.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_opt_term(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_opt_term(&mut self, mut tm0: OptTermNode, mut tm1: RuleDescendantNode) {
    tm0 = self.opt_term_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_opt_term.insert(RuleDescendantOptTerm(tm0, tm1)) {
        let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantOptTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantOptTermTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_if_atom(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_if_atom(&self, mut arg0: IfAtomNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_if_atom_node(arg0);
    self.rule_descendant_if_atom.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_if_atom` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_if_atom(&self) -> impl '_ + Iterator<Item=(IfAtomNode, RuleDescendantNode)> {
    self.rule_descendant_if_atom.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_if_atom(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_if_atom(&mut self, mut tm0: IfAtomNode, mut tm1: RuleDescendantNode) {
    tm0 = self.if_atom_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_if_atom.insert(RuleDescendantIfAtom(tm0, tm1)) {
        let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_then_atom(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_then_atom(&self, mut arg0: ThenAtomNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_then_atom_node(arg0);
    self.rule_descendant_then_atom.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_then_atom` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_then_atom(&self) -> impl '_ + Iterator<Item=(ThenAtomNode, RuleDescendantNode)> {
    self.rule_descendant_then_atom.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_then_atom(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_then_atom(&mut self, mut tm0: ThenAtomNode, mut tm1: RuleDescendantNode) {
    tm0 = self.then_atom_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_then_atom.insert(RuleDescendantThenAtom(tm0, tm1)) {
        let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_match_case(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_match_case(&self, mut arg0: MatchCaseNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_match_case_node(arg0);
    self.rule_descendant_match_case.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_match_case` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_match_case(&self) -> impl '_ + Iterator<Item=(MatchCaseNode, RuleDescendantNode)> {
    self.rule_descendant_match_case.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_match_case(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_match_case(&mut self, mut tm0: MatchCaseNode, mut tm1: RuleDescendantNode) {
    tm0 = self.match_case_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_match_case.insert(RuleDescendantMatchCase(tm0, tm1)) {
        let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_match_case_list(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_match_case_list(&self, mut arg0: MatchCaseListNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_match_case_list_node(arg0);
    self.rule_descendant_match_case_list.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_match_case_list` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_match_case_list(&self) -> impl '_ + Iterator<Item=(MatchCaseListNode, RuleDescendantNode)> {
    self.rule_descendant_match_case_list.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_match_case_list(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_match_case_list(&mut self, mut tm0: MatchCaseListNode, mut tm1: RuleDescendantNode) {
    tm0 = self.match_case_list_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_match_case_list.insert(RuleDescendantMatchCaseList(tm0, tm1)) {
        let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_stmt(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_stmt(&self, mut arg0: StmtNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_stmt_node(arg0);
    self.rule_descendant_stmt.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_stmt` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_stmt(&self) -> impl '_ + Iterator<Item=(StmtNode, RuleDescendantNode)> {
    self.rule_descendant_stmt.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_stmt(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_stmt(&mut self, mut tm0: StmtNode, mut tm1: RuleDescendantNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_stmt.insert(RuleDescendantStmt(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_stmt_list(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_stmt_list(&self, mut arg0: StmtListNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_stmt_list_node(arg0);
    self.rule_descendant_stmt_list.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_stmt_list` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_stmt_list(&self) -> impl '_ + Iterator<Item=(StmtListNode, RuleDescendantNode)> {
    self.rule_descendant_stmt_list.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_stmt_list(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_stmt_list(&mut self, mut tm0: StmtListNode, mut tm1: RuleDescendantNode) {
    tm0 = self.stmt_list_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_stmt_list.insert(RuleDescendantStmtList(tm0, tm1)) {
        let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtListTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_stmt_block_list(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_stmt_block_list(&self, mut arg0: StmtBlockListNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_stmt_block_list_node(arg0);
    self.rule_descendant_stmt_block_list.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_stmt_block_list` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_stmt_block_list(&self) -> impl '_ + Iterator<Item=(StmtBlockListNode, RuleDescendantNode)> {
    self.rule_descendant_stmt_block_list.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_stmt_block_list(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_stmt_block_list(&mut self, mut tm0: StmtBlockListNode, mut tm1: RuleDescendantNode) {
    tm0 = self.stmt_block_list_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_stmt_block_list.insert(RuleDescendantStmtBlockList(tm0, tm1)) {
        let weight0 = &mut self.stmt_block_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

    }
}

/// Evaluates `rule_descendant_type_expr(arg0)`.
#[allow(dead_code)]
pub fn rule_descendant_type_expr(&self, mut arg0: TypeExprNode) -> Option<RuleDescendantNode> {
    arg0 = self.root_type_expr_node(arg0);
    self.rule_descendant_type_expr.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rule_descendant_type_expr` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_descendant_type_expr(&self) -> impl '_ + Iterator<Item=(TypeExprNode, RuleDescendantNode)> {
    self.rule_descendant_type_expr.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rule_descendant_type_expr(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rule_descendant_type_expr(&mut self, mut tm0: TypeExprNode, mut tm1: RuleDescendantNode) {
    tm0 = self.type_expr_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.rule_descendant_type_expr.insert(RuleDescendantTypeExpr(tm0, tm1)) {
        let weight0 = &mut self.type_expr_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTypeExprTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTypeExprTable::WEIGHT);

    }
}

/// Evaluates `entry_scope(arg0)`.
#[allow(dead_code)]
pub fn entry_scope(&self, mut arg0: RuleDescendantNode) -> Option<Scope> {
    arg0 = self.root_rule_descendant_node(arg0);
    self.entry_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `entry_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_entry_scope(&self) -> impl '_ + Iterator<Item=(RuleDescendantNode, Scope)> {
    self.entry_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `entry_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_entry_scope(&mut self, mut tm0: RuleDescendantNode, mut tm1: Scope) {
    tm0 = self.rule_descendant_node_equalities.root(tm0);
tm1 = self.scope_equalities.root(tm1);
    if self.entry_scope.insert(EntryScope(tm0, tm1)) {
        let weight0 = &mut self.rule_descendant_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(EntryScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(EntryScopeTable::WEIGHT);

    }
}

/// Evaluates `exit_scope(arg0)`.
#[allow(dead_code)]
pub fn exit_scope(&self, mut arg0: RuleDescendantNode) -> Option<Scope> {
    arg0 = self.root_rule_descendant_node(arg0);
    self.exit_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `exit_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_exit_scope(&self) -> impl '_ + Iterator<Item=(RuleDescendantNode, Scope)> {
    self.exit_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `exit_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_exit_scope(&mut self, mut tm0: RuleDescendantNode, mut tm1: Scope) {
    tm0 = self.rule_descendant_node_equalities.root(tm0);
tm1 = self.scope_equalities.root(tm1);
    if self.exit_scope.insert(ExitScope(tm0, tm1)) {
        let weight0 = &mut self.rule_descendant_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ExitScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ExitScopeTable::WEIGHT);

    }
}

/// Evaluates `ctor_enum(arg0)`.
#[allow(dead_code)]
pub fn ctor_enum(&self, mut arg0: CtorDeclNode) -> Option<EnumDeclNode> {
    arg0 = self.root_ctor_decl_node(arg0);
    self.ctor_enum.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `ctor_enum` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ctor_enum(&self) -> impl '_ + Iterator<Item=(CtorDeclNode, EnumDeclNode)> {
    self.ctor_enum.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ctor_enum(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ctor_enum(&mut self, mut tm0: CtorDeclNode, mut tm1: EnumDeclNode) {
    tm0 = self.ctor_decl_node_equalities.root(tm0);
tm1 = self.enum_decl_node_equalities.root(tm1);
    if self.ctor_enum.insert(CtorEnum(tm0, tm1)) {
        let weight0 = &mut self.ctor_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CtorEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CtorEnumTable::WEIGHT);

    }
}

/// Evaluates `ctors_enum(arg0)`.
#[allow(dead_code)]
pub fn ctors_enum(&self, mut arg0: CtorDeclListNode) -> Option<EnumDeclNode> {
    arg0 = self.root_ctor_decl_list_node(arg0);
    self.ctors_enum.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `ctors_enum` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ctors_enum(&self) -> impl '_ + Iterator<Item=(CtorDeclListNode, EnumDeclNode)> {
    self.ctors_enum.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ctors_enum(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ctors_enum(&mut self, mut tm0: CtorDeclListNode, mut tm1: EnumDeclNode) {
    tm0 = self.ctor_decl_list_node_equalities.root(tm0);
tm1 = self.enum_decl_node_equalities.root(tm1);
    if self.ctors_enum.insert(CtorsEnum(tm0, tm1)) {
        let weight0 = &mut self.ctor_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CtorsEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CtorsEnumTable::WEIGHT);

    }
}

/// Evaluates `cases_discriminee(arg0)`.
#[allow(dead_code)]
pub fn cases_discriminee(&self, mut arg0: MatchCaseListNode) -> Option<TermNode> {
    arg0 = self.root_match_case_list_node(arg0);
    self.cases_discriminee.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `cases_discriminee` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_cases_discriminee(&self) -> impl '_ + Iterator<Item=(MatchCaseListNode, TermNode)> {
    self.cases_discriminee.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `cases_discriminee(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_cases_discriminee(&mut self, mut tm0: MatchCaseListNode, mut tm1: TermNode) {
    tm0 = self.match_case_list_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
    if self.cases_discriminee.insert(CasesDiscriminee(tm0, tm1)) {
        let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CasesDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CasesDiscrimineeTable::WEIGHT);

    }
}

/// Evaluates `case_discriminee(arg0)`.
#[allow(dead_code)]
pub fn case_discriminee(&self, mut arg0: MatchCaseNode) -> Option<TermNode> {
    arg0 = self.root_match_case_node(arg0);
    self.case_discriminee.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `case_discriminee` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_case_discriminee(&self) -> impl '_ + Iterator<Item=(MatchCaseNode, TermNode)> {
    self.case_discriminee.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `case_discriminee(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_case_discriminee(&mut self, mut tm0: MatchCaseNode, mut tm1: TermNode) {
    tm0 = self.match_case_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
    if self.case_discriminee.insert(CaseDiscriminee(tm0, tm1)) {
        let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CaseDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CaseDiscrimineeTable::WEIGHT);

    }
}

/// Evaluates `desugared_case_equality_atom(arg0)`.
#[allow(dead_code)]
pub fn desugared_case_equality_atom(&self, mut arg0: MatchCaseNode) -> Option<IfAtomNode> {
    arg0 = self.root_match_case_node(arg0);
    self.desugared_case_equality_atom.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `desugared_case_equality_atom` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_desugared_case_equality_atom(&self) -> impl '_ + Iterator<Item=(MatchCaseNode, IfAtomNode)> {
    self.desugared_case_equality_atom.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `desugared_case_equality_atom(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_desugared_case_equality_atom(&mut self, mut tm0: MatchCaseNode, mut tm1: IfAtomNode) {
    tm0 = self.match_case_node_equalities.root(tm0);
tm1 = self.if_atom_node_equalities.root(tm1);
    if self.desugared_case_equality_atom.insert(DesugaredCaseEqualityAtom(tm0, tm1)) {
        let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

    }
}

/// Evaluates `desugared_case_equality_stmt(arg0)`.
#[allow(dead_code)]
pub fn desugared_case_equality_stmt(&self, mut arg0: MatchCaseNode) -> Option<StmtNode> {
    arg0 = self.root_match_case_node(arg0);
    self.desugared_case_equality_stmt.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `desugared_case_equality_stmt` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_desugared_case_equality_stmt(&self) -> impl '_ + Iterator<Item=(MatchCaseNode, StmtNode)> {
    self.desugared_case_equality_stmt.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `desugared_case_equality_stmt(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_desugared_case_equality_stmt(&mut self, mut tm0: MatchCaseNode, mut tm1: StmtNode) {
    tm0 = self.match_case_node_equalities.root(tm0);
tm1 = self.stmt_node_equalities.root(tm1);
    if self.desugared_case_equality_stmt.insert(DesugaredCaseEqualityStmt(tm0, tm1)) {
        let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

    }
}

/// Evaluates `desugared_case_block(arg0)`.
#[allow(dead_code)]
pub fn desugared_case_block(&self, mut arg0: MatchCaseNode) -> Option<StmtListNode> {
    arg0 = self.root_match_case_node(arg0);
    self.desugared_case_block.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `desugared_case_block` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_desugared_case_block(&self) -> impl '_ + Iterator<Item=(MatchCaseNode, StmtListNode)> {
    self.desugared_case_block.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `desugared_case_block(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_desugared_case_block(&mut self, mut tm0: MatchCaseNode, mut tm1: StmtListNode) {
    tm0 = self.match_case_node_equalities.root(tm0);
tm1 = self.stmt_list_node_equalities.root(tm1);
    if self.desugared_case_block.insert(DesugaredCaseBlock(tm0, tm1)) {
        let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseBlockTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseBlockTable::WEIGHT);

    }
}

/// Evaluates `desugared_case_block_list(arg0)`.
#[allow(dead_code)]
pub fn desugared_case_block_list(&self, mut arg0: MatchCaseListNode) -> Option<StmtBlockListNode> {
    arg0 = self.root_match_case_list_node(arg0);
    self.desugared_case_block_list.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `desugared_case_block_list` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_desugared_case_block_list(&self) -> impl '_ + Iterator<Item=(MatchCaseListNode, StmtBlockListNode)> {
    self.desugared_case_block_list.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `desugared_case_block_list(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_desugared_case_block_list(&mut self, mut tm0: MatchCaseListNode, mut tm1: StmtBlockListNode) {
    tm0 = self.match_case_list_node_equalities.root(tm0);
tm1 = self.stmt_block_list_node_equalities.root(tm1);
    if self.desugared_case_block_list.insert(DesugaredCaseBlockList(tm0, tm1)) {
        let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

    }
}

/// Evaluates `NilTypeList()`.
#[allow(dead_code)]
pub fn nil_type_list(&self) -> Option<TypeList> {
    
    self.nil_type_list.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `NilTypeList` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_nil_type_list(&self) -> impl '_ + Iterator<Item=TypeList> {
    self.nil_type_list.iter_all().map(|t| t.0)
}
/// Makes the equation `nil_type_list() = tm0` hold.

#[allow(dead_code)]
pub fn insert_nil_type_list(&mut self, mut tm0: TypeList) {
    tm0 = self.type_list_equalities.root(tm0);
    if self.nil_type_list.insert(NilTypeList(tm0)) {
        let weight0 = &mut self.type_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilTypeListTable::WEIGHT);

    }
}

/// Evaluates `ConsTypeList(arg0, arg1)`.
#[allow(dead_code)]
pub fn cons_type_list(&self, mut arg0: Type, mut arg1: TypeList) -> Option<TypeList> {
    arg0 = self.root_type(arg0);
arg1 = self.root_type_list(arg1);
    self.cons_type_list.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `ConsTypeList` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_cons_type_list(&self) -> impl '_ + Iterator<Item=(Type, TypeList, TypeList)> {
    self.cons_type_list.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `cons_type_list(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_cons_type_list(&mut self, mut tm0: Type, mut tm1: TypeList, mut tm2: TypeList) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.type_list_equalities.root(tm1);
tm2 = self.type_list_equalities.root(tm2);
    if self.cons_type_list.insert(ConsTypeList(tm0, tm1, tm2)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsTypeListTable::WEIGHT);

let weight1 = &mut self.type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsTypeListTable::WEIGHT);

    }
}

/// Evaluates `SnocTypeList(arg0, arg1)`.
#[allow(dead_code)]
pub fn snoc_type_list(&self, mut arg0: TypeList, mut arg1: Type) -> Option<TypeList> {
    arg0 = self.root_type_list(arg0);
arg1 = self.root_type(arg1);
    self.snoc_type_list.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `SnocTypeList` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_snoc_type_list(&self) -> impl '_ + Iterator<Item=(TypeList, Type, TypeList)> {
    self.snoc_type_list.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `snoc_type_list(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_snoc_type_list(&mut self, mut tm0: TypeList, mut tm1: Type, mut tm2: TypeList) {
    tm0 = self.type_list_equalities.root(tm0);
tm1 = self.type_equalities.root(tm1);
tm2 = self.type_list_equalities.root(tm2);
    if self.snoc_type_list.insert(SnocTypeList(tm0, tm1, tm2)) {
        let weight0 = &mut self.type_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SnocTypeListTable::WEIGHT);

let weight1 = &mut self.type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SnocTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SnocTypeListTable::WEIGHT);

    }
}

/// Evaluates `semantic_type(arg0, arg1)`.
#[allow(dead_code)]
pub fn semantic_type(&self, mut arg0: SymbolScope, mut arg1: Ident) -> Option<Type> {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_ident(arg1);
    self.semantic_type.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `semantic_type` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_type(&self) -> impl '_ + Iterator<Item=(SymbolScope, Ident, Type)> {
    self.semantic_type.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `semantic_type(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_semantic_type(&mut self, mut tm0: SymbolScope, mut tm1: Ident, mut tm2: Type) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.type_equalities.root(tm2);
    if self.semantic_type.insert(SemanticType(tm0, tm1, tm2)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticTypeTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticTypeTable::WEIGHT);

let weight2 = &mut self.type_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SemanticTypeTable::WEIGHT);

    }
}

/// Evaluates `decl_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn decl_symbol_scope(&self, mut arg0: DeclNode) -> Option<SymbolScope> {
    arg0 = self.root_decl_node(arg0);
    self.decl_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `decl_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_decl_symbol_scope(&self) -> impl '_ + Iterator<Item=(DeclNode, SymbolScope)> {
    self.decl_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `decl_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_decl_symbol_scope(&mut self, mut tm0: DeclNode, mut tm1: SymbolScope) {
    tm0 = self.decl_node_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.decl_symbol_scope.insert(DeclSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `mor_type(arg0)`.
#[allow(dead_code)]
pub fn mor_type(&self, mut arg0: Type) -> Option<Type> {
    arg0 = self.root_type(arg0);
    self.mor_type.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `mor_type` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_mor_type(&self) -> impl '_ + Iterator<Item=(Type, Type)> {
    self.mor_type.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `mor_type(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_mor_type(&mut self, mut tm0: Type, mut tm1: Type) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.type_equalities.root(tm1);
    if self.mor_type.insert(MorType(tm0, tm1)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeTable::WEIGHT);

    }
}

/// Evaluates `mor_type_dom_func(arg0)`.
#[allow(dead_code)]
pub fn mor_type_dom_func(&self, mut arg0: Type) -> Option<Func> {
    arg0 = self.root_type(arg0);
    self.mor_type_dom_func.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `mor_type_dom_func` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_mor_type_dom_func(&self) -> impl '_ + Iterator<Item=(Type, Func)> {
    self.mor_type_dom_func.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `mor_type_dom_func(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_mor_type_dom_func(&mut self, mut tm0: Type, mut tm1: Func) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.func_equalities.root(tm1);
    if self.mor_type_dom_func.insert(MorTypeDomFunc(tm0, tm1)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeDomFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeDomFuncTable::WEIGHT);

    }
}

/// Evaluates `mor_type_cod_func(arg0)`.
#[allow(dead_code)]
pub fn mor_type_cod_func(&self, mut arg0: Type) -> Option<Func> {
    arg0 = self.root_type(arg0);
    self.mor_type_cod_func.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `mor_type_cod_func` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_mor_type_cod_func(&self) -> impl '_ + Iterator<Item=(Type, Func)> {
    self.mor_type_cod_func.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `mor_type_cod_func(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_mor_type_cod_func(&mut self, mut tm0: Type, mut tm1: Func) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.func_equalities.root(tm1);
    if self.mor_type_cod_func.insert(MorTypeCodFunc(tm0, tm1)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeCodFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeCodFuncTable::WEIGHT);

    }
}

/// Evaluates `type_definition_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn type_definition_symbol_scope(&self, mut arg0: Type) -> Option<SymbolScope> {
    arg0 = self.root_type(arg0);
    self.type_definition_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `type_definition_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_type_definition_symbol_scope(&self) -> impl '_ + Iterator<Item=(Type, SymbolScope)> {
    self.type_definition_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `type_definition_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_type_definition_symbol_scope(&mut self, mut tm0: Type, mut tm1: SymbolScope) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.type_definition_symbol_scope.insert(TypeDefinitionSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TypeDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TypeDefinitionSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `FuncRel(arg0)`.
#[allow(dead_code)]
pub fn func_rel(&self, mut arg0: Func) -> Option<Rel> {
    arg0 = self.root_func(arg0);
    self.func_rel.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `FuncRel` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_func_rel(&self) -> impl '_ + Iterator<Item=(Func, Rel)> {
    self.func_rel.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `func_rel(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_func_rel(&mut self, mut tm0: Func, mut tm1: Rel) {
    tm0 = self.func_equalities.root(tm0);
tm1 = self.rel_equalities.root(tm1);
    if self.func_rel.insert(FuncRel(tm0, tm1)) {
        let weight0 = &mut self.func_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FuncRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(FuncRelTable::WEIGHT);

    }
}

/// Evaluates `rel_definition_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn rel_definition_symbol_scope(&self, mut arg0: Rel) -> Option<SymbolScope> {
    arg0 = self.root_rel(arg0);
    self.rel_definition_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rel_definition_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rel_definition_symbol_scope(&self) -> impl '_ + Iterator<Item=(Rel, SymbolScope)> {
    self.rel_definition_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rel_definition_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rel_definition_symbol_scope(&mut self, mut tm0: Rel, mut tm1: SymbolScope) {
    tm0 = self.rel_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.rel_definition_symbol_scope.insert(RelDefinitionSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.rel_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RelDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RelDefinitionSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `domain(arg0)`.
#[allow(dead_code)]
pub fn domain(&self, mut arg0: Func) -> Option<TypeList> {
    arg0 = self.root_func(arg0);
    self.domain.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `domain` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_domain(&self) -> impl '_ + Iterator<Item=(Func, TypeList)> {
    self.domain.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `domain(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_domain(&mut self, mut tm0: Func, mut tm1: TypeList) {
    tm0 = self.func_equalities.root(tm0);
tm1 = self.type_list_equalities.root(tm1);
    if self.domain.insert(Domain(tm0, tm1)) {
        let weight0 = &mut self.func_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DomainTable::WEIGHT);

    }
}

/// Evaluates `codomain(arg0)`.
#[allow(dead_code)]
pub fn codomain(&self, mut arg0: Func) -> Option<Type> {
    arg0 = self.root_func(arg0);
    self.codomain.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `codomain` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_codomain(&self) -> impl '_ + Iterator<Item=(Func, Type)> {
    self.codomain.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `codomain(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_codomain(&mut self, mut tm0: Func, mut tm1: Type) {
    tm0 = self.func_equalities.root(tm0);
tm1 = self.type_equalities.root(tm1);
    if self.codomain.insert(Codomain(tm0, tm1)) {
        let weight0 = &mut self.func_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CodomainTable::WEIGHT);

let weight1 = &mut self.type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CodomainTable::WEIGHT);

    }
}

/// Evaluates `type_name(arg0)`.
#[allow(dead_code)]
pub fn type_name(&self, mut arg0: Type) -> Option<Ident> {
    arg0 = self.root_type(arg0);
    self.type_name.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `type_name` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_type_name(&self) -> impl '_ + Iterator<Item=(Type, Ident)> {
    self.type_name.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `type_name(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_type_name(&mut self, mut tm0: Type, mut tm1: Ident) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.type_name.insert(TypeName(tm0, tm1)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TypeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TypeNameTable::WEIGHT);

    }
}

/// Evaluates `virtual_symbol_scope()`.
#[allow(dead_code)]
pub fn virtual_symbol_scope(&self) -> Option<SymbolScope> {
    
    self.virtual_symbol_scope.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `virtual_symbol_scope` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_virtual_symbol_scope(&self) -> impl '_ + Iterator<Item=SymbolScope> {
    self.virtual_symbol_scope.iter_all().map(|t| t.0)
}
/// Makes the equation `virtual_symbol_scope() = tm0` hold.

#[allow(dead_code)]
pub fn insert_virtual_symbol_scope(&mut self, mut tm0: SymbolScope) {
    tm0 = self.symbol_scope_equalities.root(tm0);
    if self.virtual_symbol_scope.insert(VirtualSymbolScope(tm0)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(VirtualSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `parent_model_func(arg0)`.
#[allow(dead_code)]
pub fn parent_model_func(&self, mut arg0: Type) -> Option<Func> {
    arg0 = self.root_type(arg0);
    self.parent_model_func.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `parent_model_func` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_parent_model_func(&self) -> impl '_ + Iterator<Item=(Type, Func)> {
    self.parent_model_func.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `parent_model_func(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_parent_model_func(&mut self, mut tm0: Type, mut tm1: Func) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.func_equalities.root(tm1);
    if self.parent_model_func.insert(ParentModelFunc(tm0, tm1)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ParentModelFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ParentModelFuncTable::WEIGHT);

    }
}

/// Evaluates `symbol_scope_model(arg0)`.
#[allow(dead_code)]
pub fn symbol_scope_model(&self, mut arg0: SymbolScope) -> Option<Type> {
    arg0 = self.root_symbol_scope(arg0);
    self.symbol_scope_model.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `symbol_scope_model` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_symbol_scope_model(&self) -> impl '_ + Iterator<Item=(SymbolScope, Type)> {
    self.symbol_scope_model.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `symbol_scope_model(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_symbol_scope_model(&mut self, mut tm0: SymbolScope, mut tm1: Type) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.type_equalities.root(tm1);
    if self.symbol_scope_model.insert(SymbolScopeModel(tm0, tm1)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeModelTable::WEIGHT);

let weight1 = &mut self.type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeModelTable::WEIGHT);

    }
}

/// Evaluates `flat_domain(arg0)`.
#[allow(dead_code)]
pub fn flat_domain(&self, mut arg0: Func) -> Option<TypeList> {
    arg0 = self.root_func(arg0);
    self.flat_domain.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `flat_domain` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_flat_domain(&self) -> impl '_ + Iterator<Item=(Func, TypeList)> {
    self.flat_domain.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `flat_domain(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_flat_domain(&mut self, mut tm0: Func, mut tm1: TypeList) {
    tm0 = self.func_equalities.root(tm0);
tm1 = self.type_list_equalities.root(tm1);
    if self.flat_domain.insert(FlatDomain(tm0, tm1)) {
        let weight0 = &mut self.func_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FlatDomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(FlatDomainTable::WEIGHT);

    }
}

/// Evaluates `semantic_signature_type_expr(arg0, arg1)`.
#[allow(dead_code)]
pub fn semantic_signature_type_expr(&self, mut arg0: SymbolScope, mut arg1: TypeExprNode) -> Option<Type> {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_type_expr_node(arg1);
    self.semantic_signature_type_expr.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `semantic_signature_type_expr` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_signature_type_expr(&self) -> impl '_ + Iterator<Item=(SymbolScope, TypeExprNode, Type)> {
    self.semantic_signature_type_expr.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `semantic_signature_type_expr(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_semantic_signature_type_expr(&mut self, mut tm0: SymbolScope, mut tm1: TypeExprNode, mut tm2: Type) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.type_expr_node_equalities.root(tm1);
tm2 = self.type_equalities.root(tm2);
    if self.semantic_signature_type_expr.insert(SemanticSignatureTypeExpr(tm0, tm1, tm2)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

let weight2 = &mut self.type_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

    }
}

/// Evaluates `TypeSymbol()`.
#[allow(dead_code)]
pub fn type_symbol(&self) -> Option<SymbolKind> {
    
    self.type_symbol.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `TypeSymbol` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_type_symbol(&self) -> impl '_ + Iterator<Item=SymbolKind> {
    self.type_symbol.iter_all().map(|t| t.0)
}
/// Makes the equation `type_symbol() = tm0` hold.

#[allow(dead_code)]
pub fn insert_type_symbol(&mut self, mut tm0: SymbolKind) {
    tm0 = self.symbol_kind_equalities.root(tm0);
    if self.type_symbol.insert(TypeSymbol(tm0)) {
        let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TypeSymbolTable::WEIGHT);

    }
}

/// Evaluates `EnumSymbol()`.
#[allow(dead_code)]
pub fn enum_symbol(&self) -> Option<SymbolKind> {
    
    self.enum_symbol.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `EnumSymbol` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_enum_symbol(&self) -> impl '_ + Iterator<Item=SymbolKind> {
    self.enum_symbol.iter_all().map(|t| t.0)
}
/// Makes the equation `enum_symbol() = tm0` hold.

#[allow(dead_code)]
pub fn insert_enum_symbol(&mut self, mut tm0: SymbolKind) {
    tm0 = self.symbol_kind_equalities.root(tm0);
    if self.enum_symbol.insert(EnumSymbol(tm0)) {
        let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(EnumSymbolTable::WEIGHT);

    }
}

/// Evaluates `ModelSymbol()`.
#[allow(dead_code)]
pub fn model_symbol(&self) -> Option<SymbolKind> {
    
    self.model_symbol.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `ModelSymbol` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_model_symbol(&self) -> impl '_ + Iterator<Item=SymbolKind> {
    self.model_symbol.iter_all().map(|t| t.0)
}
/// Makes the equation `model_symbol() = tm0` hold.

#[allow(dead_code)]
pub fn insert_model_symbol(&mut self, mut tm0: SymbolKind) {
    tm0 = self.symbol_kind_equalities.root(tm0);
    if self.model_symbol.insert(ModelSymbol(tm0)) {
        let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ModelSymbolTable::WEIGHT);

    }
}

/// Evaluates `semantic_arg_type(arg0)`.
#[allow(dead_code)]
pub fn semantic_arg_type(&self, mut arg0: ArgDeclNode) -> Option<Type> {
    arg0 = self.root_arg_decl_node(arg0);
    self.semantic_arg_type.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `semantic_arg_type` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_arg_type(&self) -> impl '_ + Iterator<Item=(ArgDeclNode, Type)> {
    self.semantic_arg_type.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `semantic_arg_type(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_semantic_arg_type(&mut self, mut tm0: ArgDeclNode, mut tm1: Type) {
    tm0 = self.arg_decl_node_equalities.root(tm0);
tm1 = self.type_equalities.root(tm1);
    if self.semantic_arg_type.insert(SemanticArgType(tm0, tm1)) {
        let weight0 = &mut self.arg_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticArgTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticArgTypeTable::WEIGHT);

    }
}

/// Evaluates `arg_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn arg_symbol_scope(&self, mut arg0: ArgDeclNode) -> Option<SymbolScope> {
    arg0 = self.root_arg_decl_node(arg0);
    self.arg_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `arg_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_arg_symbol_scope(&self) -> impl '_ + Iterator<Item=(ArgDeclNode, SymbolScope)> {
    self.arg_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `arg_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_arg_symbol_scope(&mut self, mut tm0: ArgDeclNode, mut tm1: SymbolScope) {
    tm0 = self.arg_decl_node_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.arg_symbol_scope.insert(ArgSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.arg_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ArgSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ArgSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `semantic_arg_types(arg0)`.
#[allow(dead_code)]
pub fn semantic_arg_types(&self, mut arg0: ArgDeclListNode) -> Option<TypeList> {
    arg0 = self.root_arg_decl_list_node(arg0);
    self.semantic_arg_types.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `semantic_arg_types` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_arg_types(&self) -> impl '_ + Iterator<Item=(ArgDeclListNode, TypeList)> {
    self.semantic_arg_types.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `semantic_arg_types(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_semantic_arg_types(&mut self, mut tm0: ArgDeclListNode, mut tm1: TypeList) {
    tm0 = self.arg_decl_list_node_equalities.root(tm0);
tm1 = self.type_list_equalities.root(tm1);
    if self.semantic_arg_types.insert(SemanticArgTypes(tm0, tm1)) {
        let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticArgTypesTable::WEIGHT);

let weight1 = &mut self.type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticArgTypesTable::WEIGHT);

    }
}

/// Evaluates `semantic_pred(arg0, arg1)`.
#[allow(dead_code)]
pub fn semantic_pred(&self, mut arg0: SymbolScope, mut arg1: Ident) -> Option<Pred> {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_ident(arg1);
    self.semantic_pred.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `semantic_pred` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_pred(&self) -> impl '_ + Iterator<Item=(SymbolScope, Ident, Pred)> {
    self.semantic_pred.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `semantic_pred(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_semantic_pred(&mut self, mut tm0: SymbolScope, mut tm1: Ident, mut tm2: Pred) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.pred_equalities.root(tm2);
    if self.semantic_pred.insert(SemanticPred(tm0, tm1, tm2)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticPredTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticPredTable::WEIGHT);

let weight2 = &mut self.pred_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SemanticPredTable::WEIGHT);

    }
}

/// Evaluates `pred_arity(arg0)`.
#[allow(dead_code)]
pub fn pred_arity(&self, mut arg0: Pred) -> Option<TypeList> {
    arg0 = self.root_pred(arg0);
    self.pred_arity.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `pred_arity` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_pred_arity(&self) -> impl '_ + Iterator<Item=(Pred, TypeList)> {
    self.pred_arity.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `pred_arity(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_pred_arity(&mut self, mut tm0: Pred, mut tm1: TypeList) {
    tm0 = self.pred_equalities.root(tm0);
tm1 = self.type_list_equalities.root(tm1);
    if self.pred_arity.insert(PredArity(tm0, tm1)) {
        let weight0 = &mut self.pred_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PredArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(PredArityTable::WEIGHT);

    }
}

/// Evaluates `semantic_func(arg0, arg1)`.
#[allow(dead_code)]
pub fn semantic_func(&self, mut arg0: SymbolScope, mut arg1: Ident) -> Option<Func> {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_ident(arg1);
    self.semantic_func.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `semantic_func` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_func(&self) -> impl '_ + Iterator<Item=(SymbolScope, Ident, Func)> {
    self.semantic_func.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `semantic_func(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_semantic_func(&mut self, mut tm0: SymbolScope, mut tm1: Ident, mut tm2: Func) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.func_equalities.root(tm2);
    if self.semantic_func.insert(SemanticFunc(tm0, tm1, tm2)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticFuncTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticFuncTable::WEIGHT);

let weight2 = &mut self.func_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SemanticFuncTable::WEIGHT);

    }
}

/// Evaluates `ctor_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn ctor_symbol_scope(&self, mut arg0: CtorDeclNode) -> Option<SymbolScope> {
    arg0 = self.root_ctor_decl_node(arg0);
    self.ctor_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `ctor_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ctor_symbol_scope(&self) -> impl '_ + Iterator<Item=(CtorDeclNode, SymbolScope)> {
    self.ctor_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ctor_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ctor_symbol_scope(&mut self, mut tm0: CtorDeclNode, mut tm1: SymbolScope) {
    tm0 = self.ctor_decl_node_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.ctor_symbol_scope.insert(CtorSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.ctor_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CtorSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CtorSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `PredRel(arg0)`.
#[allow(dead_code)]
pub fn pred_rel(&self, mut arg0: Pred) -> Option<Rel> {
    arg0 = self.root_pred(arg0);
    self.pred_rel.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `PredRel` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_pred_rel(&self) -> impl '_ + Iterator<Item=(Pred, Rel)> {
    self.pred_rel.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `pred_rel(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_pred_rel(&mut self, mut tm0: Pred, mut tm1: Rel) {
    tm0 = self.pred_equalities.root(tm0);
tm1 = self.rel_equalities.root(tm1);
    if self.pred_rel.insert(PredRel(tm0, tm1)) {
        let weight0 = &mut self.pred_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PredRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(PredRelTable::WEIGHT);

    }
}

/// Evaluates `rel_name(arg0)`.
#[allow(dead_code)]
pub fn rel_name(&self, mut arg0: Rel) -> Option<Ident> {
    arg0 = self.root_rel(arg0);
    self.rel_name.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `rel_name` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rel_name(&self) -> impl '_ + Iterator<Item=(Rel, Ident)> {
    self.rel_name.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `rel_name(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_rel_name(&mut self, mut tm0: Rel, mut tm1: Ident) {
    tm0 = self.rel_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.rel_name.insert(RelName(tm0, tm1)) {
        let weight0 = &mut self.rel_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RelNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RelNameTable::WEIGHT);

    }
}

/// Evaluates `arity(arg0)`.
#[allow(dead_code)]
pub fn arity(&self, mut arg0: Rel) -> Option<TypeList> {
    arg0 = self.root_rel(arg0);
    self.arity.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `arity` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_arity(&self) -> impl '_ + Iterator<Item=(Rel, TypeList)> {
    self.arity.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `arity(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_arity(&mut self, mut tm0: Rel, mut tm1: TypeList) {
    tm0 = self.rel_equalities.root(tm0);
tm1 = self.type_list_equalities.root(tm1);
    if self.arity.insert(Arity(tm0, tm1)) {
        let weight0 = &mut self.rel_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ArityTable::WEIGHT);

    }
}

/// Evaluates `dom(arg0)`.
#[allow(dead_code)]
pub fn dom(&self, mut arg0: Morphism) -> Option<Structure> {
    arg0 = self.root_morphism(arg0);
    self.dom.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `dom` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_dom(&self) -> impl '_ + Iterator<Item=(Morphism, Structure)> {
    self.dom.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `dom(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_dom(&mut self, mut tm0: Morphism, mut tm1: Structure) {
    tm0 = self.morphism_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.dom.insert(Dom(tm0, tm1)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DomTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DomTable::WEIGHT);

    }
}

/// Evaluates `cod(arg0)`.
#[allow(dead_code)]
pub fn cod(&self, mut arg0: Morphism) -> Option<Structure> {
    arg0 = self.root_morphism(arg0);
    self.cod.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `cod` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_cod(&self) -> impl '_ + Iterator<Item=(Morphism, Structure)> {
    self.cod.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `cod(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_cod(&mut self, mut tm0: Morphism, mut tm1: Structure) {
    tm0 = self.morphism_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.cod.insert(Cod(tm0, tm1)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CodTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CodTable::WEIGHT);

    }
}

/// Evaluates `flat_arity(arg0)`.
#[allow(dead_code)]
pub fn flat_arity(&self, mut arg0: Rel) -> Option<TypeList> {
    arg0 = self.root_rel(arg0);
    self.flat_arity.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `flat_arity` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_flat_arity(&self) -> impl '_ + Iterator<Item=(Rel, TypeList)> {
    self.flat_arity.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `flat_arity(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_flat_arity(&mut self, mut tm0: Rel, mut tm1: TypeList) {
    tm0 = self.rel_equalities.root(tm0);
tm1 = self.type_list_equalities.root(tm1);
    if self.flat_arity.insert(FlatArity(tm0, tm1)) {
        let weight0 = &mut self.rel_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FlatArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(FlatArityTable::WEIGHT);

    }
}

/// Evaluates `module_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn module_symbol_scope(&self, mut arg0: ModuleNode) -> Option<SymbolScope> {
    arg0 = self.root_module_node(arg0);
    self.module_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `module_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_module_symbol_scope(&self) -> impl '_ + Iterator<Item=(ModuleNode, SymbolScope)> {
    self.module_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `module_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_module_symbol_scope(&mut self, mut tm0: ModuleNode, mut tm1: SymbolScope) {
    tm0 = self.module_node_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.module_symbol_scope.insert(ModuleSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.module_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ModuleSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ModuleSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `NilElList(arg0)`.
#[allow(dead_code)]
pub fn nil_el_list(&self, mut arg0: Structure) -> Option<ElList> {
    arg0 = self.root_structure(arg0);
    self.nil_el_list.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `NilElList` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_nil_el_list(&self) -> impl '_ + Iterator<Item=(Structure, ElList)> {
    self.nil_el_list.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `nil_el_list(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_nil_el_list(&mut self, mut tm0: Structure, mut tm1: ElList) {
    tm0 = self.structure_equalities.root(tm0);
tm1 = self.el_list_equalities.root(tm1);
    if self.nil_el_list.insert(NilElList(tm0, tm1)) {
        let weight0 = &mut self.structure_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(NilElListTable::WEIGHT);

    }
}

/// Evaluates `ConsElList(arg0, arg1)`.
#[allow(dead_code)]
pub fn cons_el_list(&self, mut arg0: El, mut arg1: ElList) -> Option<ElList> {
    arg0 = self.root_el(arg0);
arg1 = self.root_el_list(arg1);
    self.cons_el_list.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `ConsElList` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_cons_el_list(&self) -> impl '_ + Iterator<Item=(El, ElList, ElList)> {
    self.cons_el_list.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `cons_el_list(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_cons_el_list(&mut self, mut tm0: El, mut tm1: ElList, mut tm2: ElList) {
    tm0 = self.el_equalities.root(tm0);
tm1 = self.el_list_equalities.root(tm1);
tm2 = self.el_list_equalities.root(tm2);
    if self.cons_el_list.insert(ConsElList(tm0, tm1, tm2)) {
        let weight0 = &mut self.el_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsElListTable::WEIGHT);

    }
}

/// Evaluates `SnocElList(arg0, arg1)`.
#[allow(dead_code)]
pub fn snoc_el_list(&self, mut arg0: ElList, mut arg1: El) -> Option<ElList> {
    arg0 = self.root_el_list(arg0);
arg1 = self.root_el(arg1);
    self.snoc_el_list.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `SnocElList` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_snoc_el_list(&self) -> impl '_ + Iterator<Item=(ElList, El, ElList)> {
    self.snoc_el_list.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `snoc_el_list(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_snoc_el_list(&mut self, mut tm0: ElList, mut tm1: El, mut tm2: ElList) {
    tm0 = self.el_list_equalities.root(tm0);
tm1 = self.el_equalities.root(tm1);
tm2 = self.el_list_equalities.root(tm2);
    if self.snoc_el_list.insert(SnocElList(tm0, tm1, tm2)) {
        let weight0 = &mut self.el_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SnocElListTable::WEIGHT);

let weight1 = &mut self.el_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SnocElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SnocElListTable::WEIGHT);

    }
}

/// Evaluates `el_structure(arg0)`.
#[allow(dead_code)]
pub fn el_structure(&self, mut arg0: El) -> Option<Structure> {
    arg0 = self.root_el(arg0);
    self.el_structure.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `el_structure` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_el_structure(&self) -> impl '_ + Iterator<Item=(El, Structure)> {
    self.el_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `el_structure(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_el_structure(&mut self, mut tm0: El, mut tm1: Structure) {
    tm0 = self.el_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.el_structure.insert(ElStructure(tm0, tm1)) {
        let weight0 = &mut self.el_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ElStructureTable::WEIGHT);

    }
}

/// Evaluates `els_structure(arg0)`.
#[allow(dead_code)]
pub fn els_structure(&self, mut arg0: ElList) -> Option<Structure> {
    arg0 = self.root_el_list(arg0);
    self.els_structure.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `els_structure` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_els_structure(&self) -> impl '_ + Iterator<Item=(ElList, Structure)> {
    self.els_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `els_structure(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_els_structure(&mut self, mut tm0: ElList, mut tm1: Structure) {
    tm0 = self.el_list_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.els_structure.insert(ElsStructure(tm0, tm1)) {
        let weight0 = &mut self.el_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ElsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ElsStructureTable::WEIGHT);

    }
}

/// Evaluates `AmbientType(arg0)`.
#[allow(dead_code)]
pub fn ambient_type(&self, mut arg0: Type) -> Option<ElementType> {
    arg0 = self.root_type(arg0);
    self.ambient_type.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `AmbientType` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ambient_type(&self) -> impl '_ + Iterator<Item=(Type, ElementType)> {
    self.ambient_type.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ambient_type(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ambient_type(&mut self, mut tm0: Type, mut tm1: ElementType) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.element_type_equalities.root(tm1);
    if self.ambient_type.insert(AmbientType(tm0, tm1)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(AmbientTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(AmbientTypeTable::WEIGHT);

    }
}

/// Evaluates `InstantiatedType(arg0, arg1)`.
#[allow(dead_code)]
pub fn instantiated_type(&self, mut arg0: El, mut arg1: Type) -> Option<ElementType> {
    arg0 = self.root_el(arg0);
arg1 = self.root_type(arg1);
    self.instantiated_type.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `InstantiatedType` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_instantiated_type(&self) -> impl '_ + Iterator<Item=(El, Type, ElementType)> {
    self.instantiated_type.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `instantiated_type(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_instantiated_type(&mut self, mut tm0: El, mut tm1: Type, mut tm2: ElementType) {
    tm0 = self.el_equalities.root(tm0);
tm1 = self.type_equalities.root(tm1);
tm2 = self.element_type_equalities.root(tm2);
    if self.instantiated_type.insert(InstantiatedType(tm0, tm1, tm2)) {
        let weight0 = &mut self.el_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(InstantiatedTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(InstantiatedTypeTable::WEIGHT);

let weight2 = &mut self.element_type_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(InstantiatedTypeTable::WEIGHT);

    }
}

/// Evaluates `underlying_type(arg0)`.
#[allow(dead_code)]
pub fn underlying_type(&self, mut arg0: ElementType) -> Option<Type> {
    arg0 = self.root_element_type(arg0);
    self.underlying_type.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `underlying_type` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_underlying_type(&self) -> impl '_ + Iterator<Item=(ElementType, Type)> {
    self.underlying_type.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `underlying_type(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_underlying_type(&mut self, mut tm0: ElementType, mut tm1: Type) {
    tm0 = self.element_type_equalities.root(tm0);
tm1 = self.type_equalities.root(tm1);
    if self.underlying_type.insert(UnderlyingType(tm0, tm1)) {
        let weight0 = &mut self.element_type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(UnderlyingTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(UnderlyingTypeTable::WEIGHT);

    }
}

/// Evaluates `NilElementTypeList()`.
#[allow(dead_code)]
pub fn nil_element_type_list(&self) -> Option<ElementTypeList> {
    
    self.nil_element_type_list.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `NilElementTypeList` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_nil_element_type_list(&self) -> impl '_ + Iterator<Item=ElementTypeList> {
    self.nil_element_type_list.iter_all().map(|t| t.0)
}
/// Makes the equation `nil_element_type_list() = tm0` hold.

#[allow(dead_code)]
pub fn insert_nil_element_type_list(&mut self, mut tm0: ElementTypeList) {
    tm0 = self.element_type_list_equalities.root(tm0);
    if self.nil_element_type_list.insert(NilElementTypeList(tm0)) {
        let weight0 = &mut self.element_type_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilElementTypeListTable::WEIGHT);

    }
}

/// Evaluates `ConsElementTypeList(arg0, arg1)`.
#[allow(dead_code)]
pub fn cons_element_type_list(&self, mut arg0: ElementType, mut arg1: ElementTypeList) -> Option<ElementTypeList> {
    arg0 = self.root_element_type(arg0);
arg1 = self.root_element_type_list(arg1);
    self.cons_element_type_list.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `ConsElementTypeList` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_cons_element_type_list(&self) -> impl '_ + Iterator<Item=(ElementType, ElementTypeList, ElementTypeList)> {
    self.cons_element_type_list.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `cons_element_type_list(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_cons_element_type_list(&mut self, mut tm0: ElementType, mut tm1: ElementTypeList, mut tm2: ElementTypeList) {
    tm0 = self.element_type_equalities.root(tm0);
tm1 = self.element_type_list_equalities.root(tm1);
tm2 = self.element_type_list_equalities.root(tm2);
    if self.cons_element_type_list.insert(ConsElementTypeList(tm0, tm1, tm2)) {
        let weight0 = &mut self.element_type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsElementTypeListTable::WEIGHT);

    }
}

/// Evaluates `SnocElementTypeList(arg0, arg1)`.
#[allow(dead_code)]
pub fn snoc_element_type_list(&self, mut arg0: ElementTypeList, mut arg1: ElementType) -> Option<ElementTypeList> {
    arg0 = self.root_element_type_list(arg0);
arg1 = self.root_element_type(arg1);
    self.snoc_element_type_list.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `SnocElementTypeList` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_snoc_element_type_list(&self) -> impl '_ + Iterator<Item=(ElementTypeList, ElementType, ElementTypeList)> {
    self.snoc_element_type_list.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `snoc_element_type_list(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_snoc_element_type_list(&mut self, mut tm0: ElementTypeList, mut tm1: ElementType, mut tm2: ElementTypeList) {
    tm0 = self.element_type_list_equalities.root(tm0);
tm1 = self.element_type_equalities.root(tm1);
tm2 = self.element_type_list_equalities.root(tm2);
    if self.snoc_element_type_list.insert(SnocElementTypeList(tm0, tm1, tm2)) {
        let weight0 = &mut self.element_type_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SnocElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SnocElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SnocElementTypeListTable::WEIGHT);

    }
}

/// Evaluates `ambient_el_type_list(arg0)`.
#[allow(dead_code)]
pub fn ambient_el_type_list(&self, mut arg0: TypeList) -> Option<ElementTypeList> {
    arg0 = self.root_type_list(arg0);
    self.ambient_el_type_list.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `ambient_el_type_list` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ambient_el_type_list(&self) -> impl '_ + Iterator<Item=(TypeList, ElementTypeList)> {
    self.ambient_el_type_list.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ambient_el_type_list(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ambient_el_type_list(&mut self, mut tm0: TypeList, mut tm1: ElementTypeList) {
    tm0 = self.type_list_equalities.root(tm0);
tm1 = self.element_type_list_equalities.root(tm1);
    if self.ambient_el_type_list.insert(AmbientElTypeList(tm0, tm1)) {
        let weight0 = &mut self.type_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(AmbientElTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(AmbientElTypeListTable::WEIGHT);

    }
}

/// Evaluates `func_app(arg0, arg1)`.
#[allow(dead_code)]
pub fn func_app(&self, mut arg0: Func, mut arg1: ElList) -> Option<El> {
    arg0 = self.root_func(arg0);
arg1 = self.root_el_list(arg1);
    self.func_app.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `func_app` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_func_app(&self) -> impl '_ + Iterator<Item=(Func, ElList, El)> {
    self.func_app.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `func_app(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_func_app(&mut self, mut tm0: Func, mut tm1: ElList, mut tm2: El) {
    tm0 = self.func_equalities.root(tm0);
tm1 = self.el_list_equalities.root(tm1);
tm2 = self.el_equalities.root(tm2);
    if self.func_app.insert(FuncApp(tm0, tm1, tm2)) {
        let weight0 = &mut self.func_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FuncAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(FuncAppTable::WEIGHT);

let weight2 = &mut self.el_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(FuncAppTable::WEIGHT);

    }
}

/// Evaluates `map_el(arg0, arg1)`.
#[allow(dead_code)]
pub fn map_el(&self, mut arg0: Morphism, mut arg1: El) -> Option<El> {
    arg0 = self.root_morphism(arg0);
arg1 = self.root_el(arg1);
    self.map_el.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `map_el` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_map_el(&self) -> impl '_ + Iterator<Item=(Morphism, El, El)> {
    self.map_el.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `map_el(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_map_el(&mut self, mut tm0: Morphism, mut tm1: El, mut tm2: El) {
    tm0 = self.morphism_equalities.root(tm0);
tm1 = self.el_equalities.root(tm1);
tm2 = self.el_equalities.root(tm2);
    if self.map_el.insert(MapEl(tm0, tm1, tm2)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MapElTable::WEIGHT);

let weight1 = &mut self.el_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MapElTable::WEIGHT);

let weight2 = &mut self.el_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(MapElTable::WEIGHT);

    }
}

/// Evaluates `map_els(arg0, arg1)`.
#[allow(dead_code)]
pub fn map_els(&self, mut arg0: Morphism, mut arg1: ElList) -> Option<ElList> {
    arg0 = self.root_morphism(arg0);
arg1 = self.root_el_list(arg1);
    self.map_els.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `map_els` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_map_els(&self) -> impl '_ + Iterator<Item=(Morphism, ElList, ElList)> {
    self.map_els.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `map_els(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_map_els(&mut self, mut tm0: Morphism, mut tm1: ElList, mut tm2: ElList) {
    tm0 = self.morphism_equalities.root(tm0);
tm1 = self.el_list_equalities.root(tm1);
tm2 = self.el_list_equalities.root(tm2);
    if self.map_els.insert(MapEls(tm0, tm1, tm2)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MapElsTable::WEIGHT);

let weight1 = &mut self.el_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MapElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(MapElsTable::WEIGHT);

    }
}

/// Evaluates `ambient_model_el(arg0, arg1)`.
#[allow(dead_code)]
pub fn ambient_model_el(&self, mut arg0: SymbolScope, mut arg1: Structure) -> Option<El> {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_structure(arg1);
    self.ambient_model_el.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `ambient_model_el` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ambient_model_el(&self) -> impl '_ + Iterator<Item=(SymbolScope, Structure, El)> {
    self.ambient_model_el.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `ambient_model_el(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_ambient_model_el(&mut self, mut tm0: SymbolScope, mut tm1: Structure, mut tm2: El) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
tm2 = self.el_equalities.root(tm2);
    if self.ambient_model_el.insert(AmbientModelEl(tm0, tm1, tm2)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(AmbientModelElTable::WEIGHT);

    }
}

/// Evaluates `PredSymbol()`.
#[allow(dead_code)]
pub fn pred_symbol(&self) -> Option<SymbolKind> {
    
    self.pred_symbol.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `PredSymbol` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_pred_symbol(&self) -> impl '_ + Iterator<Item=SymbolKind> {
    self.pred_symbol.iter_all().map(|t| t.0)
}
/// Makes the equation `pred_symbol() = tm0` hold.

#[allow(dead_code)]
pub fn insert_pred_symbol(&mut self, mut tm0: SymbolKind) {
    tm0 = self.symbol_kind_equalities.root(tm0);
    if self.pred_symbol.insert(PredSymbol(tm0)) {
        let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PredSymbolTable::WEIGHT);

    }
}

/// Evaluates `FuncSymbol()`.
#[allow(dead_code)]
pub fn func_symbol(&self) -> Option<SymbolKind> {
    
    self.func_symbol.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `FuncSymbol` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_func_symbol(&self) -> impl '_ + Iterator<Item=SymbolKind> {
    self.func_symbol.iter_all().map(|t| t.0)
}
/// Makes the equation `func_symbol() = tm0` hold.

#[allow(dead_code)]
pub fn insert_func_symbol(&mut self, mut tm0: SymbolKind) {
    tm0 = self.symbol_kind_equalities.root(tm0);
    if self.func_symbol.insert(FuncSymbol(tm0)) {
        let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FuncSymbolTable::WEIGHT);

    }
}

/// Evaluates `RuleSymbol()`.
#[allow(dead_code)]
pub fn rule_symbol(&self) -> Option<SymbolKind> {
    
    self.rule_symbol.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `RuleSymbol` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_rule_symbol(&self) -> impl '_ + Iterator<Item=SymbolKind> {
    self.rule_symbol.iter_all().map(|t| t.0)
}
/// Makes the equation `rule_symbol() = tm0` hold.

#[allow(dead_code)]
pub fn insert_rule_symbol(&mut self, mut tm0: SymbolKind) {
    tm0 = self.symbol_kind_equalities.root(tm0);
    if self.rule_symbol.insert(RuleSymbol(tm0)) {
        let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleSymbolTable::WEIGHT);

    }
}

/// Evaluates `CtorSymbol()`.
#[allow(dead_code)]
pub fn ctor_symbol(&self) -> Option<SymbolKind> {
    
    self.ctor_symbol.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `CtorSymbol` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_ctor_symbol(&self) -> impl '_ + Iterator<Item=SymbolKind> {
    self.ctor_symbol.iter_all().map(|t| t.0)
}
/// Makes the equation `ctor_symbol() = tm0` hold.

#[allow(dead_code)]
pub fn insert_ctor_symbol(&mut self, mut tm0: SymbolKind) {
    tm0 = self.symbol_kind_equalities.root(tm0);
    if self.ctor_symbol.insert(CtorSymbol(tm0)) {
        let weight0 = &mut self.symbol_kind_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CtorSymbolTable::WEIGHT);

    }
}

/// Evaluates `symbol_scope_parent(arg0)`.
#[allow(dead_code)]
pub fn symbol_scope_parent(&self, mut arg0: SymbolScope) -> Option<SymbolScope> {
    arg0 = self.root_symbol_scope(arg0);
    self.symbol_scope_parent.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `symbol_scope_parent` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_symbol_scope_parent(&self) -> impl '_ + Iterator<Item=(SymbolScope, SymbolScope)> {
    self.symbol_scope_parent.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `symbol_scope_parent(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_symbol_scope_parent(&mut self, mut tm0: SymbolScope, mut tm1: SymbolScope) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.symbol_scope_parent.insert(SymbolScopeParent(tm0, tm1)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeParentTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeParentTable::WEIGHT);

    }
}

/// Evaluates `decls_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn decls_symbol_scope(&self, mut arg0: DeclListNode) -> Option<SymbolScope> {
    arg0 = self.root_decl_list_node(arg0);
    self.decls_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `decls_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_decls_symbol_scope(&self) -> impl '_ + Iterator<Item=(DeclListNode, SymbolScope)> {
    self.decls_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `decls_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_decls_symbol_scope(&mut self, mut tm0: DeclListNode, mut tm1: SymbolScope) {
    tm0 = self.decl_list_node_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.decls_symbol_scope.insert(DeclsSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclsSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `args_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn args_symbol_scope(&self, mut arg0: ArgDeclListNode) -> Option<SymbolScope> {
    arg0 = self.root_arg_decl_list_node(arg0);
    self.args_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `args_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_args_symbol_scope(&self) -> impl '_ + Iterator<Item=(ArgDeclListNode, SymbolScope)> {
    self.args_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `args_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_args_symbol_scope(&mut self, mut tm0: ArgDeclListNode, mut tm1: SymbolScope) {
    tm0 = self.arg_decl_list_node_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.args_symbol_scope.insert(ArgsSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ArgsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ArgsSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `ctors_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn ctors_symbol_scope(&self, mut arg0: CtorDeclListNode) -> Option<SymbolScope> {
    arg0 = self.root_ctor_decl_list_node(arg0);
    self.ctors_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `ctors_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ctors_symbol_scope(&self) -> impl '_ + Iterator<Item=(CtorDeclListNode, SymbolScope)> {
    self.ctors_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ctors_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ctors_symbol_scope(&mut self, mut tm0: CtorDeclListNode, mut tm1: SymbolScope) {
    tm0 = self.ctor_decl_list_node_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.ctors_symbol_scope.insert(CtorsSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.ctor_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CtorsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CtorsSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `model_member_symbol_scope(arg0)`.
#[allow(dead_code)]
pub fn model_member_symbol_scope(&self, mut arg0: Type) -> Option<SymbolScope> {
    arg0 = self.root_type(arg0);
    self.model_member_symbol_scope.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `model_member_symbol_scope` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_model_member_symbol_scope(&self) -> impl '_ + Iterator<Item=(Type, SymbolScope)> {
    self.model_member_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `model_member_symbol_scope(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_model_member_symbol_scope(&mut self, mut tm0: Type, mut tm1: SymbolScope) {
    tm0 = self.type_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.model_member_symbol_scope.insert(ModelMemberSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ModelMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ModelMemberSymbolScopeTable::WEIGHT);

    }
}

/// Evaluates `symbol_scope_name(arg0)`.
#[allow(dead_code)]
pub fn symbol_scope_name(&self, mut arg0: SymbolScope) -> Option<Ident> {
    arg0 = self.root_symbol_scope(arg0);
    self.symbol_scope_name.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `symbol_scope_name` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_symbol_scope_name(&self) -> impl '_ + Iterator<Item=(SymbolScope, Ident)> {
    self.symbol_scope_name.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `symbol_scope_name(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_symbol_scope_name(&mut self, mut tm0: SymbolScope, mut tm1: Ident) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.symbol_scope_name.insert(SymbolScopeName(tm0, tm1)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeNameTable::WEIGHT);

    }
}

/// Evaluates `scope_symbols(arg0)`.
#[allow(dead_code)]
pub fn scope_symbols(&self, mut arg0: Scope) -> Option<SymbolScope> {
    arg0 = self.root_scope(arg0);
    self.scope_symbols.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `scope_symbols` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_scope_symbols(&self) -> impl '_ + Iterator<Item=(Scope, SymbolScope)> {
    self.scope_symbols.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `scope_symbols(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_scope_symbols(&mut self, mut tm0: Scope, mut tm1: SymbolScope) {
    tm0 = self.scope_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.scope_symbols.insert(ScopeSymbols(tm0, tm1)) {
        let weight0 = &mut self.scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ScopeSymbolsTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ScopeSymbolsTable::WEIGHT);

    }
}

/// Evaluates `semantic_el(arg0, arg1)`.
#[allow(dead_code)]
pub fn semantic_el(&self, mut arg0: TermNode, mut arg1: Structure) -> Option<El> {
    arg0 = self.root_term_node(arg0);
arg1 = self.root_structure(arg1);
    self.semantic_el.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `semantic_el` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_el(&self) -> impl '_ + Iterator<Item=(TermNode, Structure, El)> {
    self.semantic_el.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `semantic_el(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_semantic_el(&mut self, mut tm0: TermNode, mut tm1: Structure, mut tm2: El) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
tm2 = self.el_equalities.root(tm2);
    if self.semantic_el.insert(SemanticEl(tm0, tm1, tm2)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticElTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticElTable::WEIGHT);

let weight2 = &mut self.el_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SemanticElTable::WEIGHT);

    }
}

/// Evaluates `zero()`.
#[allow(dead_code)]
pub fn zero(&self) -> Option<Nat> {
    
    self.zero.iter_all().next().map(|t| t.0)
}
/// Returns an iterator over `zero` constants.
/// The iterator may yield more than one element if the model is not closed.

#[allow(dead_code)]
pub fn iter_zero(&self) -> impl '_ + Iterator<Item=Nat> {
    self.zero.iter_all().map(|t| t.0)
}
/// Makes the equation `zero() = tm0` hold.

#[allow(dead_code)]
pub fn insert_zero(&mut self, mut tm0: Nat) {
    tm0 = self.nat_equalities.root(tm0);
    if self.zero.insert(Zero(tm0)) {
        let weight0 = &mut self.nat_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ZeroTable::WEIGHT);

    }
}

/// Evaluates `succ(arg0)`.
#[allow(dead_code)]
pub fn succ(&self, mut arg0: Nat) -> Option<Nat> {
    arg0 = self.root_nat(arg0);
    self.succ.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `succ` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_succ(&self) -> impl '_ + Iterator<Item=(Nat, Nat)> {
    self.succ.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `succ(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_succ(&mut self, mut tm0: Nat, mut tm1: Nat) {
    tm0 = self.nat_equalities.root(tm0);
tm1 = self.nat_equalities.root(tm1);
    if self.succ.insert(Succ(tm0, tm1)) {
        let weight0 = &mut self.nat_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SuccTable::WEIGHT);

let weight1 = &mut self.nat_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SuccTable::WEIGHT);

    }
}

/// Evaluates `type_list_len(arg0)`.
#[allow(dead_code)]
pub fn type_list_len(&self, mut arg0: TypeList) -> Option<Nat> {
    arg0 = self.root_type_list(arg0);
    self.type_list_len.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `type_list_len` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_type_list_len(&self) -> impl '_ + Iterator<Item=(TypeList, Nat)> {
    self.type_list_len.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `type_list_len(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_type_list_len(&mut self, mut tm0: TypeList, mut tm1: Nat) {
    tm0 = self.type_list_equalities.root(tm0);
tm1 = self.nat_equalities.root(tm1);
    if self.type_list_len.insert(TypeListLen(tm0, tm1)) {
        let weight0 = &mut self.type_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TypeListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TypeListLenTable::WEIGHT);

    }
}

/// Evaluates `term_list_len(arg0)`.
#[allow(dead_code)]
pub fn term_list_len(&self, mut arg0: TermListNode) -> Option<Nat> {
    arg0 = self.root_term_list_node(arg0);
    self.term_list_len.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `term_list_len` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_term_list_len(&self) -> impl '_ + Iterator<Item=(TermListNode, Nat)> {
    self.term_list_len.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `term_list_len(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_term_list_len(&mut self, mut tm0: TermListNode, mut tm1: Nat) {
    tm0 = self.term_list_node_equalities.root(tm0);
tm1 = self.nat_equalities.root(tm1);
    if self.term_list_len.insert(TermListLen(tm0, tm1)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TermListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TermListLenTable::WEIGHT);

    }
}

/// Evaluates `before_rule_structure(arg0)`.
#[allow(dead_code)]
pub fn before_rule_structure(&self, mut arg0: RuleDeclNode) -> Option<Structure> {
    arg0 = self.root_rule_decl_node(arg0);
    self.before_rule_structure.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `before_rule_structure` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_before_rule_structure(&self) -> impl '_ + Iterator<Item=(RuleDeclNode, Structure)> {
    self.before_rule_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `before_rule_structure(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_before_rule_structure(&mut self, mut tm0: RuleDeclNode, mut tm1: Structure) {
    tm0 = self.rule_decl_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.before_rule_structure.insert(BeforeRuleStructure(tm0, tm1)) {
        let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(BeforeRuleStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(BeforeRuleStructureTable::WEIGHT);

    }
}

/// Evaluates `ambient_model_el_structure(arg0)`.
#[allow(dead_code)]
pub fn ambient_model_el_structure(&self, mut arg0: RuleDeclNode) -> Option<Structure> {
    arg0 = self.root_rule_decl_node(arg0);
    self.ambient_model_el_structure.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `ambient_model_el_structure` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ambient_model_el_structure(&self) -> impl '_ + Iterator<Item=(RuleDeclNode, Structure)> {
    self.ambient_model_el_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ambient_model_el_structure(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ambient_model_el_structure(&mut self, mut tm0: RuleDeclNode, mut tm1: Structure) {
    tm0 = self.rule_decl_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.ambient_model_el_structure.insert(AmbientModelElStructure(tm0, tm1)) {
        let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElStructureTable::WEIGHT);

    }
}

/// Evaluates `ambient_model_el_morphism(arg0)`.
#[allow(dead_code)]
pub fn ambient_model_el_morphism(&self, mut arg0: RuleDeclNode) -> Option<Morphism> {
    arg0 = self.root_rule_decl_node(arg0);
    self.ambient_model_el_morphism.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `ambient_model_el_morphism` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_ambient_model_el_morphism(&self) -> impl '_ + Iterator<Item=(RuleDeclNode, Morphism)> {
    self.ambient_model_el_morphism.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `ambient_model_el_morphism(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_ambient_model_el_morphism(&mut self, mut tm0: RuleDeclNode, mut tm1: Morphism) {
    tm0 = self.rule_decl_node_equalities.root(tm0);
tm1 = self.morphism_equalities.root(tm1);
    if self.ambient_model_el_morphism.insert(AmbientModelElMorphism(tm0, tm1)) {
        let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElMorphismTable::WEIGHT);

    }
}

/// Evaluates `if_atom_morphism(arg0, arg1)`.
#[allow(dead_code)]
pub fn if_atom_morphism(&self, mut arg0: IfAtomNode, mut arg1: Structure) -> Option<Morphism> {
    arg0 = self.root_if_atom_node(arg0);
arg1 = self.root_structure(arg1);
    self.if_atom_morphism.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `if_atom_morphism` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_if_atom_morphism(&self) -> impl '_ + Iterator<Item=(IfAtomNode, Structure, Morphism)> {
    self.if_atom_morphism.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `if_atom_morphism(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_if_atom_morphism(&mut self, mut tm0: IfAtomNode, mut tm1: Structure, mut tm2: Morphism) {
    tm0 = self.if_atom_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
tm2 = self.morphism_equalities.root(tm2);
    if self.if_atom_morphism.insert(IfAtomMorphism(tm0, tm1, tm2)) {
        let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(IfAtomMorphismTable::WEIGHT);

    }
}

/// Evaluates `then_atom_morphism(arg0, arg1)`.
#[allow(dead_code)]
pub fn then_atom_morphism(&self, mut arg0: ThenAtomNode, mut arg1: Structure) -> Option<Morphism> {
    arg0 = self.root_then_atom_node(arg0);
arg1 = self.root_structure(arg1);
    self.then_atom_morphism.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `then_atom_morphism` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_then_atom_morphism(&self) -> impl '_ + Iterator<Item=(ThenAtomNode, Structure, Morphism)> {
    self.then_atom_morphism.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `then_atom_morphism(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_then_atom_morphism(&mut self, mut tm0: ThenAtomNode, mut tm1: Structure, mut tm2: Morphism) {
    tm0 = self.then_atom_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
tm2 = self.morphism_equalities.root(tm2);
    if self.then_atom_morphism.insert(ThenAtomMorphism(tm0, tm1, tm2)) {
        let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ThenAtomMorphismTable::WEIGHT);

    }
}

/// Evaluates `branch_stmt_morphism(arg0, arg1)`.
#[allow(dead_code)]
pub fn branch_stmt_morphism(&self, mut arg0: StmtNode, mut arg1: Structure) -> Option<Morphism> {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_structure(arg1);
    self.branch_stmt_morphism.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `branch_stmt_morphism` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_branch_stmt_morphism(&self) -> impl '_ + Iterator<Item=(StmtNode, Structure, Morphism)> {
    self.branch_stmt_morphism.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `branch_stmt_morphism(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_branch_stmt_morphism(&mut self, mut tm0: StmtNode, mut tm1: Structure, mut tm2: Morphism) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
tm2 = self.morphism_equalities.root(tm2);
    if self.branch_stmt_morphism.insert(BranchStmtMorphism(tm0, tm1, tm2)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(BranchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(BranchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(BranchStmtMorphismTable::WEIGHT);

    }
}

/// Evaluates `match_stmt_morphism(arg0, arg1)`.
#[allow(dead_code)]
pub fn match_stmt_morphism(&self, mut arg0: StmtNode, mut arg1: Structure) -> Option<Morphism> {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_structure(arg1);
    self.match_stmt_morphism.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `match_stmt_morphism` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_match_stmt_morphism(&self) -> impl '_ + Iterator<Item=(StmtNode, Structure, Morphism)> {
    self.match_stmt_morphism.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `match_stmt_morphism(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_match_stmt_morphism(&mut self, mut tm0: StmtNode, mut tm1: Structure, mut tm2: Morphism) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
tm2 = self.morphism_equalities.root(tm2);
    if self.match_stmt_morphism.insert(MatchStmtMorphism(tm0, tm1, tm2)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtMorphismTable::WEIGHT);

    }
}

/// Evaluates `semantic_name(arg0, arg1)`.
#[allow(dead_code)]
pub fn semantic_name(&self, mut arg0: VirtIdent, mut arg1: Scope) -> Option<ElName> {
    arg0 = self.root_virt_ident(arg0);
arg1 = self.root_scope(arg1);
    self.semantic_name.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `semantic_name` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_name(&self) -> impl '_ + Iterator<Item=(VirtIdent, Scope, ElName)> {
    self.semantic_name.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `semantic_name(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_semantic_name(&mut self, mut tm0: VirtIdent, mut tm1: Scope, mut tm2: ElName) {
    tm0 = self.virt_ident_equalities.root(tm0);
tm1 = self.scope_equalities.root(tm1);
tm2 = self.el_name_equalities.root(tm2);
    if self.semantic_name.insert(SemanticName(tm0, tm1, tm2)) {
        let weight0 = &mut self.virt_ident_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticNameTable::WEIGHT);

let weight1 = &mut self.scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticNameTable::WEIGHT);

let weight2 = &mut self.el_name_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SemanticNameTable::WEIGHT);

    }
}

/// Evaluates `semantic_els(arg0, arg1)`.
#[allow(dead_code)]
pub fn semantic_els(&self, mut arg0: TermListNode, mut arg1: Structure) -> Option<ElList> {
    arg0 = self.root_term_list_node(arg0);
arg1 = self.root_structure(arg1);
    self.semantic_els.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `semantic_els` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_semantic_els(&self) -> impl '_ + Iterator<Item=(TermListNode, Structure, ElList)> {
    self.semantic_els.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `semantic_els(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_semantic_els(&mut self, mut tm0: TermListNode, mut tm1: Structure, mut tm2: ElList) {
    tm0 = self.term_list_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
tm2 = self.el_list_equalities.root(tm2);
    if self.semantic_els.insert(SemanticEls(tm0, tm1, tm2)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SemanticElsTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SemanticElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(SemanticElsTable::WEIGHT);

    }
}

/// Evaluates `wildcard_name(arg0)`.
#[allow(dead_code)]
pub fn wildcard_name(&self, mut arg0: TermNode) -> Option<ElName> {
    arg0 = self.root_term_node(arg0);
    self.wildcard_name.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `wildcard_name` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_wildcard_name(&self) -> impl '_ + Iterator<Item=(TermNode, ElName)> {
    self.wildcard_name.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `wildcard_name(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_wildcard_name(&mut self, mut tm0: TermNode, mut tm1: ElName) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.el_name_equalities.root(tm1);
    if self.wildcard_name.insert(WildcardName(tm0, tm1)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(WildcardNameTable::WEIGHT);

let weight1 = &mut self.el_name_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(WildcardNameTable::WEIGHT);

    }
}

/// Evaluates `rel_app_parent_model_el(arg0, arg1)`.
#[allow(dead_code)]
pub fn rel_app_parent_model_el(&self, mut arg0: Rel, mut arg1: ElList) -> Option<El> {
    arg0 = self.root_rel(arg0);
arg1 = self.root_el_list(arg1);
    self.rel_app_parent_model_el.iter_all_0_1(arg0, arg1).next().map(|t| t.2)
}
/// Returns an iterator over tuples in the graph of the `rel_app_parent_model_el` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_rel_app_parent_model_el(&self) -> impl '_ + Iterator<Item=(Rel, ElList, El)> {
    self.rel_app_parent_model_el.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes the equation `rel_app_parent_model_el(tm0, tm1) = tm2` hold.

#[allow(dead_code)]
pub fn insert_rel_app_parent_model_el(&mut self, mut tm0: Rel, mut tm1: ElList, mut tm2: El) {
    tm0 = self.rel_equalities.root(tm0);
tm1 = self.el_list_equalities.root(tm1);
tm2 = self.el_equalities.root(tm2);
    if self.rel_app_parent_model_el.insert(RelAppParentModelEl(tm0, tm1, tm2)) {
        let weight0 = &mut self.rel_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RelAppParentModelElTable::WEIGHT);

let weight1 = &mut self.el_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RelAppParentModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(RelAppParentModelElTable::WEIGHT);

    }
}

/// Evaluates `match_case_pattern_ctor(arg0)`.
#[allow(dead_code)]
pub fn match_case_pattern_ctor(&self, mut arg0: MatchCaseNode) -> Option<CtorDeclNode> {
    arg0 = self.root_match_case_node(arg0);
    self.match_case_pattern_ctor.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `match_case_pattern_ctor` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_match_case_pattern_ctor(&self) -> impl '_ + Iterator<Item=(MatchCaseNode, CtorDeclNode)> {
    self.match_case_pattern_ctor.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `match_case_pattern_ctor(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_match_case_pattern_ctor(&mut self, mut tm0: MatchCaseNode, mut tm1: CtorDeclNode) {
    tm0 = self.match_case_node_equalities.root(tm0);
tm1 = self.ctor_decl_node_equalities.root(tm1);
    if self.match_case_pattern_ctor.insert(MatchCasePatternCtor(tm0, tm1)) {
        let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MatchCasePatternCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MatchCasePatternCtorTable::WEIGHT);

    }
}

/// Evaluates `cases_determined_enum(arg0)`.
#[allow(dead_code)]
pub fn cases_determined_enum(&self, mut arg0: MatchCaseListNode) -> Option<EnumDeclNode> {
    arg0 = self.root_match_case_list_node(arg0);
    self.cases_determined_enum.iter_all_0(arg0).next().map(|t| t.1)
}
/// Returns an iterator over tuples in the graph of the `cases_determined_enum` function.
/// The relation yielded by the iterator need not be functional if the model is not closed.

#[allow(dead_code)]
pub fn iter_cases_determined_enum(&self) -> impl '_ + Iterator<Item=(MatchCaseListNode, EnumDeclNode)> {
    self.cases_determined_enum.iter_all().map(|t| (t.0, t.1))
}
/// Makes the equation `cases_determined_enum(tm0) = tm1` hold.

#[allow(dead_code)]
pub fn insert_cases_determined_enum(&mut self, mut tm0: MatchCaseListNode, mut tm1: EnumDeclNode) {
    tm0 = self.match_case_list_node_equalities.root(tm0);
tm1 = self.enum_decl_node_equalities.root(tm1);
    if self.cases_determined_enum.insert(CasesDeterminedEnum(tm0, tm1)) {
        let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CasesDeterminedEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CasesDeterminedEnumTable::WEIGHT);

    }
}

/// Enforces that `real_virt_ident(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_real_virt_ident(&mut self, tm0: Ident) -> VirtIdent {
    match self.real_virt_ident(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_virt_ident_internal();
            self.insert_real_virt_ident(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `virt_real_ident(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_virt_real_ident(&mut self, tm0: VirtIdent) -> Ident {
    match self.virt_real_ident(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_ident_internal();
            self.insert_virt_real_ident(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_name(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_name(&mut self, tm0: RuleDeclNode) -> Ident {
    match self.rule_name(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_ident_internal();
            self.insert_rule_name(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `module_name(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_module_name(&mut self, tm0: ModuleNode) -> Ident {
    match self.module_name(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_ident_internal();
            self.insert_module_name(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `type_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_type_decl_node_loc(&mut self, tm0: TypeDeclNode) -> Loc {
    match self.type_decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_type_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `arg_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_arg_decl_node_loc(&mut self, tm0: ArgDeclNode) -> Loc {
    match self.arg_decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_arg_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `arg_decl_list_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_arg_decl_list_node_loc(&mut self, tm0: ArgDeclListNode) -> Loc {
    match self.arg_decl_list_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_arg_decl_list_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `pred_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_pred_decl_node_loc(&mut self, tm0: PredDeclNode) -> Loc {
    match self.pred_decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_pred_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `func_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_func_decl_node_loc(&mut self, tm0: FuncDeclNode) -> Loc {
    match self.func_decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_func_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `ctor_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ctor_decl_node_loc(&mut self, tm0: CtorDeclNode) -> Loc {
    match self.ctor_decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_ctor_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `enum_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_enum_decl_node_loc(&mut self, tm0: EnumDeclNode) -> Loc {
    match self.enum_decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_enum_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `model_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_model_decl_node_loc(&mut self, tm0: ModelDeclNode) -> Loc {
    match self.model_decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_model_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `term_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_term_node_loc(&mut self, tm0: TermNode) -> Loc {
    match self.term_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_term_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `term_list_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_term_list_node_loc(&mut self, tm0: TermListNode) -> Loc {
    match self.term_list_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_term_list_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `match_case_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_match_case_node_loc(&mut self, tm0: MatchCaseNode) -> Loc {
    match self.match_case_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_match_case_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `opt_term_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_opt_term_node_loc(&mut self, tm0: OptTermNode) -> Loc {
    match self.opt_term_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_opt_term_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `if_atom_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_if_atom_node_loc(&mut self, tm0: IfAtomNode) -> Loc {
    match self.if_atom_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_if_atom_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `then_atom_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_then_atom_node_loc(&mut self, tm0: ThenAtomNode) -> Loc {
    match self.then_atom_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_then_atom_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `stmt_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_stmt_node_loc(&mut self, tm0: StmtNode) -> Loc {
    match self.stmt_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_stmt_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `stmt_list_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_stmt_list_node_loc(&mut self, tm0: StmtListNode) -> Loc {
    match self.stmt_list_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_stmt_list_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_decl_node_loc(&mut self, tm0: RuleDeclNode) -> Loc {
    match self.rule_decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_rule_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `decl_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_decl_node_loc(&mut self, tm0: DeclNode) -> Loc {
    match self.decl_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_decl_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `decl_list_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_decl_list_node_loc(&mut self, tm0: DeclListNode) -> Loc {
    match self.decl_list_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_decl_list_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `module_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_module_node_loc(&mut self, tm0: ModuleNode) -> Loc {
    match self.module_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_module_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `type_expr_node_loc(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_type_expr_node_loc(&mut self, tm0: TypeExprNode) -> Loc {
    match self.type_expr_node_loc(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_loc_internal();
            self.insert_type_expr_node_loc(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_rule(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_rule(&mut self, tm0: RuleDeclNode) -> RuleDescendantNode {
    match self.rule_descendant_rule(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_rule(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_term(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_term(&mut self, tm0: TermNode) -> RuleDescendantNode {
    match self.rule_descendant_term(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_term(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_term_list(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_term_list(&mut self, tm0: TermListNode) -> RuleDescendantNode {
    match self.rule_descendant_term_list(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_term_list(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_opt_term(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_opt_term(&mut self, tm0: OptTermNode) -> RuleDescendantNode {
    match self.rule_descendant_opt_term(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_opt_term(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_if_atom(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_if_atom(&mut self, tm0: IfAtomNode) -> RuleDescendantNode {
    match self.rule_descendant_if_atom(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_if_atom(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_then_atom(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_then_atom(&mut self, tm0: ThenAtomNode) -> RuleDescendantNode {
    match self.rule_descendant_then_atom(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_then_atom(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_match_case(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_match_case(&mut self, tm0: MatchCaseNode) -> RuleDescendantNode {
    match self.rule_descendant_match_case(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_match_case(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_match_case_list(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_match_case_list(&mut self, tm0: MatchCaseListNode) -> RuleDescendantNode {
    match self.rule_descendant_match_case_list(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_match_case_list(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_stmt(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_stmt(&mut self, tm0: StmtNode) -> RuleDescendantNode {
    match self.rule_descendant_stmt(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_stmt(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_stmt_list(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_stmt_list(&mut self, tm0: StmtListNode) -> RuleDescendantNode {
    match self.rule_descendant_stmt_list(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_stmt_list(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_stmt_block_list(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_stmt_block_list(&mut self, tm0: StmtBlockListNode) -> RuleDescendantNode {
    match self.rule_descendant_stmt_block_list(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_stmt_block_list(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rule_descendant_type_expr(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_descendant_type_expr(&mut self, tm0: TypeExprNode) -> RuleDescendantNode {
    match self.rule_descendant_type_expr(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rule_descendant_node_internal();
            self.insert_rule_descendant_type_expr(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `entry_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_entry_scope(&mut self, tm0: RuleDescendantNode) -> Scope {
    match self.entry_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_scope_internal();
            self.insert_entry_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `exit_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_exit_scope(&mut self, tm0: RuleDescendantNode) -> Scope {
    match self.exit_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_scope_internal();
            self.insert_exit_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `ctor_enum(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ctor_enum(&mut self, tm0: CtorDeclNode) -> EnumDeclNode {
    match self.ctor_enum(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_enum_decl_node_internal();
            self.insert_ctor_enum(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `ctors_enum(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ctors_enum(&mut self, tm0: CtorDeclListNode) -> EnumDeclNode {
    match self.ctors_enum(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_enum_decl_node_internal();
            self.insert_ctors_enum(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `cases_discriminee(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_cases_discriminee(&mut self, tm0: MatchCaseListNode) -> TermNode {
    match self.cases_discriminee(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_term_node_internal();
            self.insert_cases_discriminee(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `case_discriminee(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_case_discriminee(&mut self, tm0: MatchCaseNode) -> TermNode {
    match self.case_discriminee(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_term_node_internal();
            self.insert_case_discriminee(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `desugared_case_equality_atom(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_desugared_case_equality_atom(&mut self, tm0: MatchCaseNode) -> IfAtomNode {
    match self.desugared_case_equality_atom(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_if_atom_node_internal();
            self.insert_desugared_case_equality_atom(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `desugared_case_equality_stmt(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_desugared_case_equality_stmt(&mut self, tm0: MatchCaseNode) -> StmtNode {
    match self.desugared_case_equality_stmt(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_stmt_node_internal();
            self.insert_desugared_case_equality_stmt(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `desugared_case_block(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_desugared_case_block(&mut self, tm0: MatchCaseNode) -> StmtListNode {
    match self.desugared_case_block(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_stmt_list_node_internal();
            self.insert_desugared_case_block(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `desugared_case_block_list(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_desugared_case_block_list(&mut self, tm0: MatchCaseListNode) -> StmtBlockListNode {
    match self.desugared_case_block_list(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_stmt_block_list_node_internal();
            self.insert_desugared_case_block_list(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `semantic_type(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_semantic_type(&mut self, tm0: SymbolScope, tm1: Ident) -> Type {
    match self.semantic_type(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_type_internal();
            self.insert_semantic_type(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `mor_type(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_mor_type(&mut self, tm0: Type) -> Type {
    match self.mor_type(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_type_internal();
            self.insert_mor_type(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `mor_type_dom_func(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_mor_type_dom_func(&mut self, tm0: Type) -> Func {
    match self.mor_type_dom_func(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_func_internal();
            self.insert_mor_type_dom_func(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `mor_type_cod_func(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_mor_type_cod_func(&mut self, tm0: Type) -> Func {
    match self.mor_type_cod_func(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_func_internal();
            self.insert_mor_type_cod_func(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `type_name(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_type_name(&mut self, tm0: Type) -> Ident {
    match self.type_name(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_ident_internal();
            self.insert_type_name(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `virtual_symbol_scope()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_virtual_symbol_scope(&mut self, ) -> SymbolScope {
    match self.virtual_symbol_scope() {
        Some(result) => result,
        None => {
            let tm0 = self.new_symbol_scope_internal();
            self.insert_virtual_symbol_scope(tm0);
            tm0
        }
    }
}
/// Enforces that `parent_model_func(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_parent_model_func(&mut self, tm0: Type) -> Func {
    match self.parent_model_func(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_func_internal();
            self.insert_parent_model_func(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `semantic_signature_type_expr(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_semantic_signature_type_expr(&mut self, tm0: SymbolScope, tm1: TypeExprNode) -> Type {
    match self.semantic_signature_type_expr(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_type_internal();
            self.insert_semantic_signature_type_expr(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `semantic_arg_type(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_semantic_arg_type(&mut self, tm0: ArgDeclNode) -> Type {
    match self.semantic_arg_type(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_type_internal();
            self.insert_semantic_arg_type(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `semantic_pred(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_semantic_pred(&mut self, tm0: SymbolScope, tm1: Ident) -> Pred {
    match self.semantic_pred(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_pred_internal();
            self.insert_semantic_pred(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `semantic_func(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_semantic_func(&mut self, tm0: SymbolScope, tm1: Ident) -> Func {
    match self.semantic_func(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_func_internal();
            self.insert_semantic_func(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `codomain(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_codomain(&mut self, tm0: Func) -> Type {
    match self.codomain(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_type_internal();
            self.insert_codomain(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rel_name(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rel_name(&mut self, tm0: Rel) -> Ident {
    match self.rel_name(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_ident_internal();
            self.insert_rel_name(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `var(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_var(&mut self, tm0: Structure, tm1: ElName) -> El {
    match self.var(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_internal();
            self.insert_var(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `el_structure(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_el_structure(&mut self, tm0: El) -> Structure {
    match self.el_structure(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_structure_internal();
            self.insert_el_structure(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `els_structure(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_els_structure(&mut self, tm0: ElList) -> Structure {
    match self.els_structure(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_structure_internal();
            self.insert_els_structure(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `underlying_type(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_underlying_type(&mut self, tm0: ElementType) -> Type {
    match self.underlying_type(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_type_internal();
            self.insert_underlying_type(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `func_app(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_func_app(&mut self, tm0: Func, tm1: ElList) -> El {
    match self.func_app(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_internal();
            self.insert_func_app(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `dom(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_dom(&mut self, tm0: Morphism) -> Structure {
    match self.dom(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_structure_internal();
            self.insert_dom(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `cod(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_cod(&mut self, tm0: Morphism) -> Structure {
    match self.cod(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_structure_internal();
            self.insert_cod(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `map_el(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_map_el(&mut self, tm0: Morphism, tm1: El) -> El {
    match self.map_el(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_internal();
            self.insert_map_el(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `symbol_scope_parent(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_symbol_scope_parent(&mut self, tm0: SymbolScope) -> SymbolScope {
    match self.symbol_scope_parent(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_symbol_scope_parent(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `module_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_module_symbol_scope(&mut self, tm0: ModuleNode) -> SymbolScope {
    match self.module_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_module_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `decl_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_decl_symbol_scope(&mut self, tm0: DeclNode) -> SymbolScope {
    match self.decl_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_decl_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `decls_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_decls_symbol_scope(&mut self, tm0: DeclListNode) -> SymbolScope {
    match self.decls_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_decls_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `arg_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_arg_symbol_scope(&mut self, tm0: ArgDeclNode) -> SymbolScope {
    match self.arg_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_arg_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `args_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_args_symbol_scope(&mut self, tm0: ArgDeclListNode) -> SymbolScope {
    match self.args_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_args_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `ctor_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ctor_symbol_scope(&mut self, tm0: CtorDeclNode) -> SymbolScope {
    match self.ctor_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_ctor_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `ctors_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ctors_symbol_scope(&mut self, tm0: CtorDeclListNode) -> SymbolScope {
    match self.ctors_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_ctors_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `model_member_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_model_member_symbol_scope(&mut self, tm0: Type) -> SymbolScope {
    match self.model_member_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_model_member_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `symbol_scope_model(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_symbol_scope_model(&mut self, tm0: SymbolScope) -> Type {
    match self.symbol_scope_model(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_type_internal();
            self.insert_symbol_scope_model(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `symbol_scope_name(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_symbol_scope_name(&mut self, tm0: SymbolScope) -> Ident {
    match self.symbol_scope_name(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_ident_internal();
            self.insert_symbol_scope_name(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `scope_symbols(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_scope_symbols(&mut self, tm0: Scope) -> SymbolScope {
    match self.scope_symbols(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_scope_symbols(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `type_definition_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_type_definition_symbol_scope(&mut self, tm0: Type) -> SymbolScope {
    match self.type_definition_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_type_definition_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rel_definition_symbol_scope(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rel_definition_symbol_scope(&mut self, tm0: Rel) -> SymbolScope {
    match self.rel_definition_symbol_scope(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_symbol_scope_internal();
            self.insert_rel_definition_symbol_scope(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `zero()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_zero(&mut self, ) -> Nat {
    match self.zero() {
        Some(result) => result,
        None => {
            let tm0 = self.new_nat_internal();
            self.insert_zero(tm0);
            tm0
        }
    }
}
/// Enforces that `succ(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_succ(&mut self, tm0: Nat) -> Nat {
    match self.succ(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_nat_internal();
            self.insert_succ(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `type_list_len(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_type_list_len(&mut self, tm0: TypeList) -> Nat {
    match self.type_list_len(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_nat_internal();
            self.insert_type_list_len(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `term_list_len(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_term_list_len(&mut self, tm0: TermListNode) -> Nat {
    match self.term_list_len(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_nat_internal();
            self.insert_term_list_len(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `before_rule_structure(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_before_rule_structure(&mut self, tm0: RuleDeclNode) -> Structure {
    match self.before_rule_structure(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_structure_internal();
            self.insert_before_rule_structure(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `ambient_model_el_structure(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ambient_model_el_structure(&mut self, tm0: RuleDeclNode) -> Structure {
    match self.ambient_model_el_structure(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_structure_internal();
            self.insert_ambient_model_el_structure(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `ambient_model_el_morphism(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ambient_model_el_morphism(&mut self, tm0: RuleDeclNode) -> Morphism {
    match self.ambient_model_el_morphism(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_morphism_internal();
            self.insert_ambient_model_el_morphism(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `if_atom_morphism(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_if_atom_morphism(&mut self, tm0: IfAtomNode, tm1: Structure) -> Morphism {
    match self.if_atom_morphism(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_morphism_internal();
            self.insert_if_atom_morphism(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `then_atom_morphism(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_then_atom_morphism(&mut self, tm0: ThenAtomNode, tm1: Structure) -> Morphism {
    match self.then_atom_morphism(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_morphism_internal();
            self.insert_then_atom_morphism(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `branch_stmt_morphism(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_branch_stmt_morphism(&mut self, tm0: StmtNode, tm1: Structure) -> Morphism {
    match self.branch_stmt_morphism(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_morphism_internal();
            self.insert_branch_stmt_morphism(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `match_stmt_morphism(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_match_stmt_morphism(&mut self, tm0: StmtNode, tm1: Structure) -> Morphism {
    match self.match_stmt_morphism(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_morphism_internal();
            self.insert_match_stmt_morphism(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `semantic_name(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_semantic_name(&mut self, tm0: VirtIdent, tm1: Scope) -> ElName {
    match self.semantic_name(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_name_internal();
            self.insert_semantic_name(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `semantic_el(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_semantic_el(&mut self, tm0: TermNode, tm1: Structure) -> El {
    match self.semantic_el(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_internal();
            self.insert_semantic_el(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `ambient_model_el(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ambient_model_el(&mut self, tm0: SymbolScope, tm1: Structure) -> El {
    match self.ambient_model_el(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_internal();
            self.insert_ambient_model_el(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `wildcard_name(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_wildcard_name(&mut self, tm0: TermNode) -> ElName {
    match self.wildcard_name(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_el_name_internal();
            self.insert_wildcard_name(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `rel_app_parent_model_el(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rel_app_parent_model_el(&mut self, tm0: Rel, tm1: ElList) -> El {
    match self.rel_app_parent_model_el(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_internal();
            self.insert_rel_app_parent_model_el(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `match_case_pattern_ctor(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_match_case_pattern_ctor(&mut self, tm0: MatchCaseNode) -> CtorDeclNode {
    match self.match_case_pattern_ctor(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_ctor_decl_node_internal();
            self.insert_match_case_pattern_ctor(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `cases_determined_enum(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_cases_determined_enum(&mut self, tm0: MatchCaseListNode) -> EnumDeclNode {
    match self.cases_determined_enum(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_enum_decl_node_internal();
            self.insert_cases_determined_enum(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `nil_type_list()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_nil_type_list(&mut self, ) -> TypeList {
    match self.nil_type_list() {
        Some(result) => result,
        None => {
            let tm0 = self.new_type_list_internal();
            self.insert_nil_type_list(tm0);
            tm0
        }
    }
}
/// Enforces that `cons_type_list(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_cons_type_list(&mut self, tm0: Type, tm1: TypeList) -> TypeList {
    match self.cons_type_list(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_type_list_internal();
            self.insert_cons_type_list(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `snoc_type_list(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_snoc_type_list(&mut self, tm0: TypeList, tm1: Type) -> TypeList {
    match self.snoc_type_list(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_type_list_internal();
            self.insert_snoc_type_list(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `pred_rel(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_pred_rel(&mut self, tm0: Pred) -> Rel {
    match self.pred_rel(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rel_internal();
            self.insert_pred_rel(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `func_rel(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_func_rel(&mut self, tm0: Func) -> Rel {
    match self.func_rel(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_rel_internal();
            self.insert_func_rel(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `nil_el_list(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_nil_el_list(&mut self, tm0: Structure) -> ElList {
    match self.nil_el_list(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_el_list_internal();
            self.insert_nil_el_list(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `cons_el_list(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_cons_el_list(&mut self, tm0: El, tm1: ElList) -> ElList {
    match self.cons_el_list(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_list_internal();
            self.insert_cons_el_list(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `snoc_el_list(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_snoc_el_list(&mut self, tm0: ElList, tm1: El) -> ElList {
    match self.snoc_el_list(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_el_list_internal();
            self.insert_snoc_el_list(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `ambient_type(tm0)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ambient_type(&mut self, tm0: Type) -> ElementType {
    match self.ambient_type(tm0) {
        Some(result) => result,
        None => {
            let tm1 = self.new_element_type_internal();
            self.insert_ambient_type(tm0, tm1);
            tm1
        }
    }
}
/// Enforces that `instantiated_type(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_instantiated_type(&mut self, tm0: El, tm1: Type) -> ElementType {
    match self.instantiated_type(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_element_type_internal();
            self.insert_instantiated_type(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `nil_element_type_list()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_nil_element_type_list(&mut self, ) -> ElementTypeList {
    match self.nil_element_type_list() {
        Some(result) => result,
        None => {
            let tm0 = self.new_element_type_list_internal();
            self.insert_nil_element_type_list(tm0);
            tm0
        }
    }
}
/// Enforces that `cons_element_type_list(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_cons_element_type_list(&mut self, tm0: ElementType, tm1: ElementTypeList) -> ElementTypeList {
    match self.cons_element_type_list(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_element_type_list_internal();
            self.insert_cons_element_type_list(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `snoc_element_type_list(tm0, tm1)` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_snoc_element_type_list(&mut self, tm0: ElementTypeList, tm1: ElementType) -> ElementTypeList {
    match self.snoc_element_type_list(tm0, tm1) {
        Some(result) => result,
        None => {
            let tm2 = self.new_element_type_list_internal();
            self.insert_snoc_element_type_list(tm0, tm1, tm2);
            tm2
        }
    }
}
/// Enforces that `type_symbol()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_type_symbol(&mut self, ) -> SymbolKind {
    match self.type_symbol() {
        Some(result) => result,
        None => {
            let tm0 = self.new_symbol_kind_internal();
            self.insert_type_symbol(tm0);
            tm0
        }
    }
}
/// Enforces that `pred_symbol()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_pred_symbol(&mut self, ) -> SymbolKind {
    match self.pred_symbol() {
        Some(result) => result,
        None => {
            let tm0 = self.new_symbol_kind_internal();
            self.insert_pred_symbol(tm0);
            tm0
        }
    }
}
/// Enforces that `func_symbol()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_func_symbol(&mut self, ) -> SymbolKind {
    match self.func_symbol() {
        Some(result) => result,
        None => {
            let tm0 = self.new_symbol_kind_internal();
            self.insert_func_symbol(tm0);
            tm0
        }
    }
}
/// Enforces that `rule_symbol()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_rule_symbol(&mut self, ) -> SymbolKind {
    match self.rule_symbol() {
        Some(result) => result,
        None => {
            let tm0 = self.new_symbol_kind_internal();
            self.insert_rule_symbol(tm0);
            tm0
        }
    }
}
/// Enforces that `enum_symbol()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_enum_symbol(&mut self, ) -> SymbolKind {
    match self.enum_symbol() {
        Some(result) => result,
        None => {
            let tm0 = self.new_symbol_kind_internal();
            self.insert_enum_symbol(tm0);
            tm0
        }
    }
}
/// Enforces that `ctor_symbol()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_ctor_symbol(&mut self, ) -> SymbolKind {
    match self.ctor_symbol() {
        Some(result) => result,
        None => {
            let tm0 = self.new_symbol_kind_internal();
            self.insert_ctor_symbol(tm0);
            tm0
        }
    }
}
/// Enforces that `model_symbol()` is defined, adjoining a new element if necessary.
#[allow(dead_code)]
pub fn define_model_symbol(&mut self, ) -> SymbolKind {
    match self.model_symbol() {
        Some(result) => result,
        None => {
            let tm0 = self.new_symbol_kind_internal();
            self.insert_model_symbol(tm0);
            tm0
        }
    }
}
/// Returns `true` if `absurd()` holds.
#[allow(dead_code)]
pub fn absurd(&self) -> bool {
    
    self.absurd.contains(Absurd())
}
/// Makes `absurd()` hold.

#[allow(dead_code)]
pub fn insert_absurd(&mut self, ) {
    
    if self.absurd.insert(Absurd()) {
        
    }
}

/// Returns `true` if `type_decl(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn type_decl(&self, mut arg0: TypeDeclNode, mut arg1: Ident) -> bool {
    arg0 = self.root_type_decl_node(arg0);
arg1 = self.root_ident(arg1);
    self.type_decl.contains(TypeDecl(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `type_decl` predicate.

#[allow(dead_code)]
pub fn iter_type_decl(&self) -> impl '_ + Iterator<Item=(TypeDeclNode, Ident)> {
    self.type_decl.iter_all().map(|t| (t.0, t.1))
}
/// Makes `type_decl(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_type_decl(&mut self, mut tm0: TypeDeclNode, mut tm1: Ident) {
    tm0 = self.type_decl_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.type_decl.insert(TypeDecl(tm0, tm1)) {
        let weight0 = &mut self.type_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TypeDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TypeDeclTable::WEIGHT);

    }
}

/// Returns `true` if `arg_decl_node_name(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn arg_decl_node_name(&self, mut arg0: ArgDeclNode, mut arg1: Ident) -> bool {
    arg0 = self.root_arg_decl_node(arg0);
arg1 = self.root_ident(arg1);
    self.arg_decl_node_name.contains(ArgDeclNodeName(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `arg_decl_node_name` predicate.

#[allow(dead_code)]
pub fn iter_arg_decl_node_name(&self) -> impl '_ + Iterator<Item=(ArgDeclNode, Ident)> {
    self.arg_decl_node_name.iter_all().map(|t| (t.0, t.1))
}
/// Makes `arg_decl_node_name(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_arg_decl_node_name(&mut self, mut tm0: ArgDeclNode, mut tm1: Ident) {
    tm0 = self.arg_decl_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.arg_decl_node_name.insert(ArgDeclNodeName(tm0, tm1)) {
        let weight0 = &mut self.arg_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeNameTable::WEIGHT);

    }
}

/// Returns `true` if `arg_decl_node_type(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn arg_decl_node_type(&self, mut arg0: ArgDeclNode, mut arg1: TypeExprNode) -> bool {
    arg0 = self.root_arg_decl_node(arg0);
arg1 = self.root_type_expr_node(arg1);
    self.arg_decl_node_type.contains(ArgDeclNodeType(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `arg_decl_node_type` predicate.

#[allow(dead_code)]
pub fn iter_arg_decl_node_type(&self) -> impl '_ + Iterator<Item=(ArgDeclNode, TypeExprNode)> {
    self.arg_decl_node_type.iter_all().map(|t| (t.0, t.1))
}
/// Makes `arg_decl_node_type(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_arg_decl_node_type(&mut self, mut tm0: ArgDeclNode, mut tm1: TypeExprNode) {
    tm0 = self.arg_decl_node_equalities.root(tm0);
tm1 = self.type_expr_node_equalities.root(tm1);
    if self.arg_decl_node_type.insert(ArgDeclNodeType(tm0, tm1)) {
        let weight0 = &mut self.arg_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

    }
}

/// Returns `true` if `nil_arg_decl_list_node(arg0)` holds.
#[allow(dead_code)]
pub fn nil_arg_decl_list_node(&self, mut arg0: ArgDeclListNode) -> bool {
    arg0 = self.root_arg_decl_list_node(arg0);
    self.nil_arg_decl_list_node.contains(NilArgDeclListNode(arg0))
}
/// Returns an iterator over elements satisfying the `nil_arg_decl_list_node` predicate.

#[allow(dead_code)]
pub fn iter_nil_arg_decl_list_node(&self) -> impl '_ + Iterator<Item=ArgDeclListNode> {
    self.nil_arg_decl_list_node.iter_all().map(|t| t.0)
}
/// Makes `nil_arg_decl_list_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_nil_arg_decl_list_node(&mut self, mut tm0: ArgDeclListNode) {
    tm0 = self.arg_decl_list_node_equalities.root(tm0);
    if self.nil_arg_decl_list_node.insert(NilArgDeclListNode(tm0)) {
        let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilArgDeclListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `cons_arg_decl_list_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn cons_arg_decl_list_node(&self, mut arg0: ArgDeclListNode, mut arg1: ArgDeclNode, mut arg2: ArgDeclListNode) -> bool {
    arg0 = self.root_arg_decl_list_node(arg0);
arg1 = self.root_arg_decl_node(arg1);
arg2 = self.root_arg_decl_list_node(arg2);
    self.cons_arg_decl_list_node.contains(ConsArgDeclListNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `cons_arg_decl_list_node` predicate.

#[allow(dead_code)]
pub fn iter_cons_arg_decl_list_node(&self) -> impl '_ + Iterator<Item=(ArgDeclListNode, ArgDeclNode, ArgDeclListNode)> {
    self.cons_arg_decl_list_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `cons_arg_decl_list_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_cons_arg_decl_list_node(&mut self, mut tm0: ArgDeclListNode, mut tm1: ArgDeclNode, mut tm2: ArgDeclListNode) {
    tm0 = self.arg_decl_list_node_equalities.root(tm0);
tm1 = self.arg_decl_node_equalities.root(tm1);
tm2 = self.arg_decl_list_node_equalities.root(tm2);
    if self.cons_arg_decl_list_node.insert(ConsArgDeclListNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.arg_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

let weight1 = &mut self.arg_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `pred_decl(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn pred_decl(&self, mut arg0: PredDeclNode, mut arg1: Ident, mut arg2: ArgDeclListNode) -> bool {
    arg0 = self.root_pred_decl_node(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_arg_decl_list_node(arg2);
    self.pred_decl.contains(PredDecl(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `pred_decl` predicate.

#[allow(dead_code)]
pub fn iter_pred_decl(&self) -> impl '_ + Iterator<Item=(PredDeclNode, Ident, ArgDeclListNode)> {
    self.pred_decl.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `pred_decl(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_pred_decl(&mut self, mut tm0: PredDeclNode, mut tm1: Ident, mut tm2: ArgDeclListNode) {
    tm0 = self.pred_decl_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.arg_decl_list_node_equalities.root(tm2);
    if self.pred_decl.insert(PredDecl(tm0, tm1, tm2)) {
        let weight0 = &mut self.pred_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PredDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(PredDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(PredDeclTable::WEIGHT);

    }
}

/// Returns `true` if `func_decl(arg0, arg1, arg2, arg3)` holds.
#[allow(dead_code)]
pub fn func_decl(&self, mut arg0: FuncDeclNode, mut arg1: Ident, mut arg2: ArgDeclListNode, mut arg3: TypeExprNode) -> bool {
    arg0 = self.root_func_decl_node(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_arg_decl_list_node(arg2);
arg3 = self.root_type_expr_node(arg3);
    self.func_decl.contains(FuncDecl(arg0, arg1, arg2, arg3))
}
/// Returns an iterator over tuples of elements satisfying the `func_decl` predicate.

#[allow(dead_code)]
pub fn iter_func_decl(&self) -> impl '_ + Iterator<Item=(FuncDeclNode, Ident, ArgDeclListNode, TypeExprNode)> {
    self.func_decl.iter_all().map(|t| (t.0, t.1, t.2, t.3))
}
/// Makes `func_decl(tm0, tm1, tm2, tm3)` hold.

#[allow(dead_code)]
pub fn insert_func_decl(&mut self, mut tm0: FuncDeclNode, mut tm1: Ident, mut tm2: ArgDeclListNode, mut tm3: TypeExprNode) {
    tm0 = self.func_decl_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.arg_decl_list_node_equalities.root(tm2);
tm3 = self.type_expr_node_equalities.root(tm3);
    if self.func_decl.insert(FuncDecl(tm0, tm1, tm2, tm3)) {
        let weight0 = &mut self.func_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[tm3.0 as usize];
*weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);

    }
}

/// Returns `true` if `ctor_decl(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn ctor_decl(&self, mut arg0: CtorDeclNode, mut arg1: Ident, mut arg2: ArgDeclListNode) -> bool {
    arg0 = self.root_ctor_decl_node(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_arg_decl_list_node(arg2);
    self.ctor_decl.contains(CtorDecl(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `ctor_decl` predicate.

#[allow(dead_code)]
pub fn iter_ctor_decl(&self) -> impl '_ + Iterator<Item=(CtorDeclNode, Ident, ArgDeclListNode)> {
    self.ctor_decl.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `ctor_decl(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_ctor_decl(&mut self, mut tm0: CtorDeclNode, mut tm1: Ident, mut tm2: ArgDeclListNode) {
    tm0 = self.ctor_decl_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.arg_decl_list_node_equalities.root(tm2);
    if self.ctor_decl.insert(CtorDecl(tm0, tm1, tm2)) {
        let weight0 = &mut self.ctor_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CtorDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CtorDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(CtorDeclTable::WEIGHT);

    }
}

/// Returns `true` if `nil_ctor_decl_list_node(arg0)` holds.
#[allow(dead_code)]
pub fn nil_ctor_decl_list_node(&self, mut arg0: CtorDeclListNode) -> bool {
    arg0 = self.root_ctor_decl_list_node(arg0);
    self.nil_ctor_decl_list_node.contains(NilCtorDeclListNode(arg0))
}
/// Returns an iterator over elements satisfying the `nil_ctor_decl_list_node` predicate.

#[allow(dead_code)]
pub fn iter_nil_ctor_decl_list_node(&self) -> impl '_ + Iterator<Item=CtorDeclListNode> {
    self.nil_ctor_decl_list_node.iter_all().map(|t| t.0)
}
/// Makes `nil_ctor_decl_list_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_nil_ctor_decl_list_node(&mut self, mut tm0: CtorDeclListNode) {
    tm0 = self.ctor_decl_list_node_equalities.root(tm0);
    if self.nil_ctor_decl_list_node.insert(NilCtorDeclListNode(tm0)) {
        let weight0 = &mut self.ctor_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilCtorDeclListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `cons_ctor_decl_list_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn cons_ctor_decl_list_node(&self, mut arg0: CtorDeclListNode, mut arg1: CtorDeclNode, mut arg2: CtorDeclListNode) -> bool {
    arg0 = self.root_ctor_decl_list_node(arg0);
arg1 = self.root_ctor_decl_node(arg1);
arg2 = self.root_ctor_decl_list_node(arg2);
    self.cons_ctor_decl_list_node.contains(ConsCtorDeclListNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `cons_ctor_decl_list_node` predicate.

#[allow(dead_code)]
pub fn iter_cons_ctor_decl_list_node(&self) -> impl '_ + Iterator<Item=(CtorDeclListNode, CtorDeclNode, CtorDeclListNode)> {
    self.cons_ctor_decl_list_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `cons_ctor_decl_list_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_cons_ctor_decl_list_node(&mut self, mut tm0: CtorDeclListNode, mut tm1: CtorDeclNode, mut tm2: CtorDeclListNode) {
    tm0 = self.ctor_decl_list_node_equalities.root(tm0);
tm1 = self.ctor_decl_node_equalities.root(tm1);
tm2 = self.ctor_decl_list_node_equalities.root(tm2);
    if self.cons_ctor_decl_list_node.insert(ConsCtorDeclListNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.ctor_decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `enum_decl(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn enum_decl(&self, mut arg0: EnumDeclNode, mut arg1: Ident, mut arg2: CtorDeclListNode) -> bool {
    arg0 = self.root_enum_decl_node(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_ctor_decl_list_node(arg2);
    self.enum_decl.contains(EnumDecl(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `enum_decl` predicate.

#[allow(dead_code)]
pub fn iter_enum_decl(&self) -> impl '_ + Iterator<Item=(EnumDeclNode, Ident, CtorDeclListNode)> {
    self.enum_decl.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `enum_decl(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_enum_decl(&mut self, mut tm0: EnumDeclNode, mut tm1: Ident, mut tm2: CtorDeclListNode) {
    tm0 = self.enum_decl_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.ctor_decl_list_node_equalities.root(tm2);
    if self.enum_decl.insert(EnumDecl(tm0, tm1, tm2)) {
        let weight0 = &mut self.enum_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(EnumDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(EnumDeclTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(EnumDeclTable::WEIGHT);

    }
}

/// Returns `true` if `nil_term_list_node(arg0)` holds.
#[allow(dead_code)]
pub fn nil_term_list_node(&self, mut arg0: TermListNode) -> bool {
    arg0 = self.root_term_list_node(arg0);
    self.nil_term_list_node.contains(NilTermListNode(arg0))
}
/// Returns an iterator over elements satisfying the `nil_term_list_node` predicate.

#[allow(dead_code)]
pub fn iter_nil_term_list_node(&self) -> impl '_ + Iterator<Item=TermListNode> {
    self.nil_term_list_node.iter_all().map(|t| t.0)
}
/// Makes `nil_term_list_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_nil_term_list_node(&mut self, mut tm0: TermListNode) {
    tm0 = self.term_list_node_equalities.root(tm0);
    if self.nil_term_list_node.insert(NilTermListNode(tm0)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilTermListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `cons_term_list_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn cons_term_list_node(&self, mut arg0: TermListNode, mut arg1: TermNode, mut arg2: TermListNode) -> bool {
    arg0 = self.root_term_list_node(arg0);
arg1 = self.root_term_node(arg1);
arg2 = self.root_term_list_node(arg2);
    self.cons_term_list_node.contains(ConsTermListNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `cons_term_list_node` predicate.

#[allow(dead_code)]
pub fn iter_cons_term_list_node(&self) -> impl '_ + Iterator<Item=(TermListNode, TermNode, TermListNode)> {
    self.cons_term_list_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `cons_term_list_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_cons_term_list_node(&mut self, mut tm0: TermListNode, mut tm1: TermNode, mut tm2: TermListNode) {
    tm0 = self.term_list_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
tm2 = self.term_list_node_equalities.root(tm2);
    if self.cons_term_list_node.insert(ConsTermListNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsTermListNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsTermListNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsTermListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `ambient_type_expr(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn ambient_type_expr(&self, mut arg0: TypeExprNode, mut arg1: Ident) -> bool {
    arg0 = self.root_type_expr_node(arg0);
arg1 = self.root_ident(arg1);
    self.ambient_type_expr.contains(AmbientTypeExpr(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `ambient_type_expr` predicate.

#[allow(dead_code)]
pub fn iter_ambient_type_expr(&self) -> impl '_ + Iterator<Item=(TypeExprNode, Ident)> {
    self.ambient_type_expr.iter_all().map(|t| (t.0, t.1))
}
/// Makes `ambient_type_expr(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_ambient_type_expr(&mut self, mut tm0: TypeExprNode, mut tm1: Ident) {
    tm0 = self.type_expr_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.ambient_type_expr.insert(AmbientTypeExpr(tm0, tm1)) {
        let weight0 = &mut self.type_expr_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(AmbientTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(AmbientTypeExprTable::WEIGHT);

    }
}

/// Returns `true` if `member_type_expr(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn member_type_expr(&self, mut arg0: TypeExprNode, mut arg1: TermNode, mut arg2: Ident) -> bool {
    arg0 = self.root_type_expr_node(arg0);
arg1 = self.root_term_node(arg1);
arg2 = self.root_ident(arg2);
    self.member_type_expr.contains(MemberTypeExpr(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `member_type_expr` predicate.

#[allow(dead_code)]
pub fn iter_member_type_expr(&self) -> impl '_ + Iterator<Item=(TypeExprNode, TermNode, Ident)> {
    self.member_type_expr.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `member_type_expr(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_member_type_expr(&mut self, mut tm0: TypeExprNode, mut tm1: TermNode, mut tm2: Ident) {
    tm0 = self.type_expr_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
tm2 = self.ident_equalities.root(tm2);
    if self.member_type_expr.insert(MemberTypeExpr(tm0, tm1, tm2)) {
        let weight0 = &mut self.type_expr_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MemberTypeExprTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MemberTypeExprTable::WEIGHT);

let weight2 = &mut self.ident_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(MemberTypeExprTable::WEIGHT);

    }
}

/// Returns `true` if `mor_type_expr(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn mor_type_expr(&self, mut arg0: TypeExprNode, mut arg1: Ident) -> bool {
    arg0 = self.root_type_expr_node(arg0);
arg1 = self.root_ident(arg1);
    self.mor_type_expr.contains(MorTypeExpr(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `mor_type_expr` predicate.

#[allow(dead_code)]
pub fn iter_mor_type_expr(&self) -> impl '_ + Iterator<Item=(TypeExprNode, Ident)> {
    self.mor_type_expr.iter_all().map(|t| (t.0, t.1))
}
/// Makes `mor_type_expr(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_mor_type_expr(&mut self, mut tm0: TypeExprNode, mut tm1: Ident) {
    tm0 = self.type_expr_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
    if self.mor_type_expr.insert(MorTypeExpr(tm0, tm1)) {
        let weight0 = &mut self.type_expr_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeExprTable::WEIGHT);

    }
}

/// Returns `true` if `none_term_node(arg0)` holds.
#[allow(dead_code)]
pub fn none_term_node(&self, mut arg0: OptTermNode) -> bool {
    arg0 = self.root_opt_term_node(arg0);
    self.none_term_node.contains(NoneTermNode(arg0))
}
/// Returns an iterator over elements satisfying the `none_term_node` predicate.

#[allow(dead_code)]
pub fn iter_none_term_node(&self) -> impl '_ + Iterator<Item=OptTermNode> {
    self.none_term_node.iter_all().map(|t| t.0)
}
/// Makes `none_term_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_none_term_node(&mut self, mut tm0: OptTermNode) {
    tm0 = self.opt_term_node_equalities.root(tm0);
    if self.none_term_node.insert(NoneTermNode(tm0)) {
        let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NoneTermNodeTable::WEIGHT);

    }
}

/// Returns `true` if `some_term_node(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn some_term_node(&self, mut arg0: OptTermNode, mut arg1: TermNode) -> bool {
    arg0 = self.root_opt_term_node(arg0);
arg1 = self.root_term_node(arg1);
    self.some_term_node.contains(SomeTermNode(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `some_term_node` predicate.

#[allow(dead_code)]
pub fn iter_some_term_node(&self) -> impl '_ + Iterator<Item=(OptTermNode, TermNode)> {
    self.some_term_node.iter_all().map(|t| (t.0, t.1))
}
/// Makes `some_term_node(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_some_term_node(&mut self, mut tm0: OptTermNode, mut tm1: TermNode) {
    tm0 = self.opt_term_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
    if self.some_term_node.insert(SomeTermNode(tm0, tm1)) {
        let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SomeTermNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SomeTermNodeTable::WEIGHT);

    }
}

/// Returns `true` if `var_term_node(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn var_term_node(&self, mut arg0: TermNode, mut arg1: VirtIdent) -> bool {
    arg0 = self.root_term_node(arg0);
arg1 = self.root_virt_ident(arg1);
    self.var_term_node.contains(VarTermNode(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `var_term_node` predicate.

#[allow(dead_code)]
pub fn iter_var_term_node(&self) -> impl '_ + Iterator<Item=(TermNode, VirtIdent)> {
    self.var_term_node.iter_all().map(|t| (t.0, t.1))
}
/// Makes `var_term_node(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_var_term_node(&mut self, mut tm0: TermNode, mut tm1: VirtIdent) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.virt_ident_equalities.root(tm1);
    if self.var_term_node.insert(VarTermNode(tm0, tm1)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(VarTermNodeTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(VarTermNodeTable::WEIGHT);

    }
}

/// Returns `true` if `wildcard_term_node(arg0)` holds.
#[allow(dead_code)]
pub fn wildcard_term_node(&self, mut arg0: TermNode) -> bool {
    arg0 = self.root_term_node(arg0);
    self.wildcard_term_node.contains(WildcardTermNode(arg0))
}
/// Returns an iterator over elements satisfying the `wildcard_term_node` predicate.

#[allow(dead_code)]
pub fn iter_wildcard_term_node(&self) -> impl '_ + Iterator<Item=TermNode> {
    self.wildcard_term_node.iter_all().map(|t| t.0)
}
/// Makes `wildcard_term_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_wildcard_term_node(&mut self, mut tm0: TermNode) {
    tm0 = self.term_node_equalities.root(tm0);
    if self.wildcard_term_node.insert(WildcardTermNode(tm0)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(WildcardTermNodeTable::WEIGHT);

    }
}

/// Returns `true` if `app_term_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn app_term_node(&self, mut arg0: TermNode, mut arg1: Ident, mut arg2: TermListNode) -> bool {
    arg0 = self.root_term_node(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_term_list_node(arg2);
    self.app_term_node.contains(AppTermNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `app_term_node` predicate.

#[allow(dead_code)]
pub fn iter_app_term_node(&self) -> impl '_ + Iterator<Item=(TermNode, Ident, TermListNode)> {
    self.app_term_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `app_term_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_app_term_node(&mut self, mut tm0: TermNode, mut tm1: Ident, mut tm2: TermListNode) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.term_list_node_equalities.root(tm2);
    if self.app_term_node.insert(AppTermNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(AppTermNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(AppTermNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(AppTermNodeTable::WEIGHT);

    }
}

/// Returns `true` if `match_case(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn match_case(&self, mut arg0: MatchCaseNode, mut arg1: TermNode, mut arg2: StmtListNode) -> bool {
    arg0 = self.root_match_case_node(arg0);
arg1 = self.root_term_node(arg1);
arg2 = self.root_stmt_list_node(arg2);
    self.match_case.contains(MatchCase(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `match_case` predicate.

#[allow(dead_code)]
pub fn iter_match_case(&self) -> impl '_ + Iterator<Item=(MatchCaseNode, TermNode, StmtListNode)> {
    self.match_case.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `match_case(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_match_case(&mut self, mut tm0: MatchCaseNode, mut tm1: TermNode, mut tm2: StmtListNode) {
    tm0 = self.match_case_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
tm2 = self.stmt_list_node_equalities.root(tm2);
    if self.match_case.insert(MatchCase(tm0, tm1, tm2)) {
        let weight0 = &mut self.match_case_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MatchCaseTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MatchCaseTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(MatchCaseTable::WEIGHT);

    }
}

/// Returns `true` if `nil_match_case_list_node(arg0)` holds.
#[allow(dead_code)]
pub fn nil_match_case_list_node(&self, mut arg0: MatchCaseListNode) -> bool {
    arg0 = self.root_match_case_list_node(arg0);
    self.nil_match_case_list_node.contains(NilMatchCaseListNode(arg0))
}
/// Returns an iterator over elements satisfying the `nil_match_case_list_node` predicate.

#[allow(dead_code)]
pub fn iter_nil_match_case_list_node(&self) -> impl '_ + Iterator<Item=MatchCaseListNode> {
    self.nil_match_case_list_node.iter_all().map(|t| t.0)
}
/// Makes `nil_match_case_list_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_nil_match_case_list_node(&mut self, mut tm0: MatchCaseListNode) {
    tm0 = self.match_case_list_node_equalities.root(tm0);
    if self.nil_match_case_list_node.insert(NilMatchCaseListNode(tm0)) {
        let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilMatchCaseListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `cons_match_case_list_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn cons_match_case_list_node(&self, mut arg0: MatchCaseListNode, mut arg1: MatchCaseNode, mut arg2: MatchCaseListNode) -> bool {
    arg0 = self.root_match_case_list_node(arg0);
arg1 = self.root_match_case_node(arg1);
arg2 = self.root_match_case_list_node(arg2);
    self.cons_match_case_list_node.contains(ConsMatchCaseListNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `cons_match_case_list_node` predicate.

#[allow(dead_code)]
pub fn iter_cons_match_case_list_node(&self) -> impl '_ + Iterator<Item=(MatchCaseListNode, MatchCaseNode, MatchCaseListNode)> {
    self.cons_match_case_list_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `cons_match_case_list_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_cons_match_case_list_node(&mut self, mut tm0: MatchCaseListNode, mut tm1: MatchCaseNode, mut tm2: MatchCaseListNode) {
    tm0 = self.match_case_list_node_equalities.root(tm0);
tm1 = self.match_case_node_equalities.root(tm1);
tm2 = self.match_case_list_node_equalities.root(tm2);
    if self.cons_match_case_list_node.insert(ConsMatchCaseListNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

let weight1 = &mut self.match_case_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `equal_if_atom_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn equal_if_atom_node(&self, mut arg0: IfAtomNode, mut arg1: TermNode, mut arg2: TermNode) -> bool {
    arg0 = self.root_if_atom_node(arg0);
arg1 = self.root_term_node(arg1);
arg2 = self.root_term_node(arg2);
    self.equal_if_atom_node.contains(EqualIfAtomNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `equal_if_atom_node` predicate.

#[allow(dead_code)]
pub fn iter_equal_if_atom_node(&self) -> impl '_ + Iterator<Item=(IfAtomNode, TermNode, TermNode)> {
    self.equal_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `equal_if_atom_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_equal_if_atom_node(&mut self, mut tm0: IfAtomNode, mut tm1: TermNode, mut tm2: TermNode) {
    tm0 = self.if_atom_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
tm2 = self.term_node_equalities.root(tm2);
    if self.equal_if_atom_node.insert(EqualIfAtomNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(EqualIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(EqualIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(EqualIfAtomNodeTable::WEIGHT);

    }
}

/// Returns `true` if `defined_if_atom_node(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn defined_if_atom_node(&self, mut arg0: IfAtomNode, mut arg1: TermNode) -> bool {
    arg0 = self.root_if_atom_node(arg0);
arg1 = self.root_term_node(arg1);
    self.defined_if_atom_node.contains(DefinedIfAtomNode(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `defined_if_atom_node` predicate.

#[allow(dead_code)]
pub fn iter_defined_if_atom_node(&self) -> impl '_ + Iterator<Item=(IfAtomNode, TermNode)> {
    self.defined_if_atom_node.iter_all().map(|t| (t.0, t.1))
}
/// Makes `defined_if_atom_node(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_defined_if_atom_node(&mut self, mut tm0: IfAtomNode, mut tm1: TermNode) {
    tm0 = self.if_atom_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
    if self.defined_if_atom_node.insert(DefinedIfAtomNode(tm0, tm1)) {
        let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

    }
}

/// Returns `true` if `pred_if_atom_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn pred_if_atom_node(&self, mut arg0: IfAtomNode, mut arg1: Ident, mut arg2: TermListNode) -> bool {
    arg0 = self.root_if_atom_node(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_term_list_node(arg2);
    self.pred_if_atom_node.contains(PredIfAtomNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `pred_if_atom_node` predicate.

#[allow(dead_code)]
pub fn iter_pred_if_atom_node(&self) -> impl '_ + Iterator<Item=(IfAtomNode, Ident, TermListNode)> {
    self.pred_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `pred_if_atom_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_pred_if_atom_node(&mut self, mut tm0: IfAtomNode, mut tm1: Ident, mut tm2: TermListNode) {
    tm0 = self.if_atom_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.term_list_node_equalities.root(tm2);
    if self.pred_if_atom_node.insert(PredIfAtomNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PredIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(PredIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(PredIfAtomNodeTable::WEIGHT);

    }
}

/// Returns `true` if `var_if_atom_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn var_if_atom_node(&self, mut arg0: IfAtomNode, mut arg1: TermNode, mut arg2: TypeExprNode) -> bool {
    arg0 = self.root_if_atom_node(arg0);
arg1 = self.root_term_node(arg1);
arg2 = self.root_type_expr_node(arg2);
    self.var_if_atom_node.contains(VarIfAtomNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `var_if_atom_node` predicate.

#[allow(dead_code)]
pub fn iter_var_if_atom_node(&self) -> impl '_ + Iterator<Item=(IfAtomNode, TermNode, TypeExprNode)> {
    self.var_if_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `var_if_atom_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_var_if_atom_node(&mut self, mut tm0: IfAtomNode, mut tm1: TermNode, mut tm2: TypeExprNode) {
    tm0 = self.if_atom_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
tm2 = self.type_expr_node_equalities.root(tm2);
    if self.var_if_atom_node.insert(VarIfAtomNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(VarIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(VarIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.type_expr_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(VarIfAtomNodeTable::WEIGHT);

    }
}

/// Returns `true` if `equal_then_atom_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn equal_then_atom_node(&self, mut arg0: ThenAtomNode, mut arg1: TermNode, mut arg2: TermNode) -> bool {
    arg0 = self.root_then_atom_node(arg0);
arg1 = self.root_term_node(arg1);
arg2 = self.root_term_node(arg2);
    self.equal_then_atom_node.contains(EqualThenAtomNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `equal_then_atom_node` predicate.

#[allow(dead_code)]
pub fn iter_equal_then_atom_node(&self) -> impl '_ + Iterator<Item=(ThenAtomNode, TermNode, TermNode)> {
    self.equal_then_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `equal_then_atom_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_equal_then_atom_node(&mut self, mut tm0: ThenAtomNode, mut tm1: TermNode, mut tm2: TermNode) {
    tm0 = self.then_atom_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
tm2 = self.term_node_equalities.root(tm2);
    if self.equal_then_atom_node.insert(EqualThenAtomNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(EqualThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(EqualThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(EqualThenAtomNodeTable::WEIGHT);

    }
}

/// Returns `true` if `defined_then_atom_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn defined_then_atom_node(&self, mut arg0: ThenAtomNode, mut arg1: OptTermNode, mut arg2: TermNode) -> bool {
    arg0 = self.root_then_atom_node(arg0);
arg1 = self.root_opt_term_node(arg1);
arg2 = self.root_term_node(arg2);
    self.defined_then_atom_node.contains(DefinedThenAtomNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `defined_then_atom_node` predicate.

#[allow(dead_code)]
pub fn iter_defined_then_atom_node(&self) -> impl '_ + Iterator<Item=(ThenAtomNode, OptTermNode, TermNode)> {
    self.defined_then_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `defined_then_atom_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_defined_then_atom_node(&mut self, mut tm0: ThenAtomNode, mut tm1: OptTermNode, mut tm2: TermNode) {
    tm0 = self.then_atom_node_equalities.root(tm0);
tm1 = self.opt_term_node_equalities.root(tm1);
tm2 = self.term_node_equalities.root(tm2);
    if self.defined_then_atom_node.insert(DefinedThenAtomNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.opt_term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

    }
}

/// Returns `true` if `pred_then_atom_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn pred_then_atom_node(&self, mut arg0: ThenAtomNode, mut arg1: Ident, mut arg2: TermListNode) -> bool {
    arg0 = self.root_then_atom_node(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_term_list_node(arg2);
    self.pred_then_atom_node.contains(PredThenAtomNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `pred_then_atom_node` predicate.

#[allow(dead_code)]
pub fn iter_pred_then_atom_node(&self) -> impl '_ + Iterator<Item=(ThenAtomNode, Ident, TermListNode)> {
    self.pred_then_atom_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `pred_then_atom_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_pred_then_atom_node(&mut self, mut tm0: ThenAtomNode, mut tm1: Ident, mut tm2: TermListNode) {
    tm0 = self.then_atom_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.term_list_node_equalities.root(tm2);
    if self.pred_then_atom_node.insert(PredThenAtomNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PredThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(PredThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(PredThenAtomNodeTable::WEIGHT);

    }
}

/// Returns `true` if `if_stmt_node(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn if_stmt_node(&self, mut arg0: StmtNode, mut arg1: IfAtomNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_if_atom_node(arg1);
    self.if_stmt_node.contains(IfStmtNode(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `if_stmt_node` predicate.

#[allow(dead_code)]
pub fn iter_if_stmt_node(&self) -> impl '_ + Iterator<Item=(StmtNode, IfAtomNode)> {
    self.if_stmt_node.iter_all().map(|t| (t.0, t.1))
}
/// Makes `if_stmt_node(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_if_stmt_node(&mut self, mut tm0: StmtNode, mut tm1: IfAtomNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.if_atom_node_equalities.root(tm1);
    if self.if_stmt_node.insert(IfStmtNode(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IfStmtNodeTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(IfStmtNodeTable::WEIGHT);

    }
}

/// Returns `true` if `then_stmt_node(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn then_stmt_node(&self, mut arg0: StmtNode, mut arg1: ThenAtomNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_then_atom_node(arg1);
    self.then_stmt_node.contains(ThenStmtNode(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `then_stmt_node` predicate.

#[allow(dead_code)]
pub fn iter_then_stmt_node(&self) -> impl '_ + Iterator<Item=(StmtNode, ThenAtomNode)> {
    self.then_stmt_node.iter_all().map(|t| (t.0, t.1))
}
/// Makes `then_stmt_node(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_then_stmt_node(&mut self, mut tm0: StmtNode, mut tm1: ThenAtomNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.then_atom_node_equalities.root(tm1);
    if self.then_stmt_node.insert(ThenStmtNode(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ThenStmtNodeTable::WEIGHT);

let weight1 = &mut self.then_atom_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ThenStmtNodeTable::WEIGHT);

    }
}

/// Returns `true` if `branch_stmt_node(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn branch_stmt_node(&self, mut arg0: StmtNode, mut arg1: StmtBlockListNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_stmt_block_list_node(arg1);
    self.branch_stmt_node.contains(BranchStmtNode(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `branch_stmt_node` predicate.

#[allow(dead_code)]
pub fn iter_branch_stmt_node(&self) -> impl '_ + Iterator<Item=(StmtNode, StmtBlockListNode)> {
    self.branch_stmt_node.iter_all().map(|t| (t.0, t.1))
}
/// Makes `branch_stmt_node(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_branch_stmt_node(&mut self, mut tm0: StmtNode, mut tm1: StmtBlockListNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.stmt_block_list_node_equalities.root(tm1);
    if self.branch_stmt_node.insert(BranchStmtNode(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(BranchStmtNodeTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(BranchStmtNodeTable::WEIGHT);

    }
}

/// Returns `true` if `match_stmt_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn match_stmt_node(&self, mut arg0: StmtNode, mut arg1: TermNode, mut arg2: MatchCaseListNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_term_node(arg1);
arg2 = self.root_match_case_list_node(arg2);
    self.match_stmt_node.contains(MatchStmtNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `match_stmt_node` predicate.

#[allow(dead_code)]
pub fn iter_match_stmt_node(&self) -> impl '_ + Iterator<Item=(StmtNode, TermNode, MatchCaseListNode)> {
    self.match_stmt_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `match_stmt_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_match_stmt_node(&mut self, mut tm0: StmtNode, mut tm1: TermNode, mut tm2: MatchCaseListNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.term_node_equalities.root(tm1);
tm2 = self.match_case_list_node_equalities.root(tm2);
    if self.match_stmt_node.insert(MatchStmtNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtNodeTable::WEIGHT);

    }
}

/// Returns `true` if `nil_stmt_list_node(arg0)` holds.
#[allow(dead_code)]
pub fn nil_stmt_list_node(&self, mut arg0: StmtListNode) -> bool {
    arg0 = self.root_stmt_list_node(arg0);
    self.nil_stmt_list_node.contains(NilStmtListNode(arg0))
}
/// Returns an iterator over elements satisfying the `nil_stmt_list_node` predicate.

#[allow(dead_code)]
pub fn iter_nil_stmt_list_node(&self) -> impl '_ + Iterator<Item=StmtListNode> {
    self.nil_stmt_list_node.iter_all().map(|t| t.0)
}
/// Makes `nil_stmt_list_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_nil_stmt_list_node(&mut self, mut tm0: StmtListNode) {
    tm0 = self.stmt_list_node_equalities.root(tm0);
    if self.nil_stmt_list_node.insert(NilStmtListNode(tm0)) {
        let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilStmtListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `cons_stmt_list_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn cons_stmt_list_node(&self, mut arg0: StmtListNode, mut arg1: StmtNode, mut arg2: StmtListNode) -> bool {
    arg0 = self.root_stmt_list_node(arg0);
arg1 = self.root_stmt_node(arg1);
arg2 = self.root_stmt_list_node(arg2);
    self.cons_stmt_list_node.contains(ConsStmtListNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `cons_stmt_list_node` predicate.

#[allow(dead_code)]
pub fn iter_cons_stmt_list_node(&self) -> impl '_ + Iterator<Item=(StmtListNode, StmtNode, StmtListNode)> {
    self.cons_stmt_list_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `cons_stmt_list_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_cons_stmt_list_node(&mut self, mut tm0: StmtListNode, mut tm1: StmtNode, mut tm2: StmtListNode) {
    tm0 = self.stmt_list_node_equalities.root(tm0);
tm1 = self.stmt_node_equalities.root(tm1);
tm2 = self.stmt_list_node_equalities.root(tm2);
    if self.cons_stmt_list_node.insert(ConsStmtListNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsStmtListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsStmtListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsStmtListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `nil_stmt_block_list_node(arg0)` holds.
#[allow(dead_code)]
pub fn nil_stmt_block_list_node(&self, mut arg0: StmtBlockListNode) -> bool {
    arg0 = self.root_stmt_block_list_node(arg0);
    self.nil_stmt_block_list_node.contains(NilStmtBlockListNode(arg0))
}
/// Returns an iterator over elements satisfying the `nil_stmt_block_list_node` predicate.

#[allow(dead_code)]
pub fn iter_nil_stmt_block_list_node(&self) -> impl '_ + Iterator<Item=StmtBlockListNode> {
    self.nil_stmt_block_list_node.iter_all().map(|t| t.0)
}
/// Makes `nil_stmt_block_list_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_nil_stmt_block_list_node(&mut self, mut tm0: StmtBlockListNode) {
    tm0 = self.stmt_block_list_node_equalities.root(tm0);
    if self.nil_stmt_block_list_node.insert(NilStmtBlockListNode(tm0)) {
        let weight0 = &mut self.stmt_block_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilStmtBlockListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `cons_stmt_block_list_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn cons_stmt_block_list_node(&self, mut arg0: StmtBlockListNode, mut arg1: StmtListNode, mut arg2: StmtBlockListNode) -> bool {
    arg0 = self.root_stmt_block_list_node(arg0);
arg1 = self.root_stmt_list_node(arg1);
arg2 = self.root_stmt_block_list_node(arg2);
    self.cons_stmt_block_list_node.contains(ConsStmtBlockListNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `cons_stmt_block_list_node` predicate.

#[allow(dead_code)]
pub fn iter_cons_stmt_block_list_node(&self) -> impl '_ + Iterator<Item=(StmtBlockListNode, StmtListNode, StmtBlockListNode)> {
    self.cons_stmt_block_list_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `cons_stmt_block_list_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_cons_stmt_block_list_node(&mut self, mut tm0: StmtBlockListNode, mut tm1: StmtListNode, mut tm2: StmtBlockListNode) {
    tm0 = self.stmt_block_list_node_equalities.root(tm0);
tm1 = self.stmt_list_node_equalities.root(tm1);
tm2 = self.stmt_block_list_node_equalities.root(tm2);
    if self.cons_stmt_block_list_node.insert(ConsStmtBlockListNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.stmt_block_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_block_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `rule_decl(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn rule_decl(&self, mut arg0: RuleDeclNode, mut arg1: StmtListNode) -> bool {
    arg0 = self.root_rule_decl_node(arg0);
arg1 = self.root_stmt_list_node(arg1);
    self.rule_decl.contains(RuleDecl(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `rule_decl` predicate.

#[allow(dead_code)]
pub fn iter_rule_decl(&self) -> impl '_ + Iterator<Item=(RuleDeclNode, StmtListNode)> {
    self.rule_decl.iter_all().map(|t| (t.0, t.1))
}
/// Makes `rule_decl(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_rule_decl(&mut self, mut tm0: RuleDeclNode, mut tm1: StmtListNode) {
    tm0 = self.rule_decl_node_equalities.root(tm0);
tm1 = self.stmt_list_node_equalities.root(tm1);
    if self.rule_decl.insert(RuleDecl(tm0, tm1)) {
        let weight0 = &mut self.rule_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RuleDeclTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RuleDeclTable::WEIGHT);

    }
}

/// Returns `true` if `model_decl(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn model_decl(&self, mut arg0: ModelDeclNode, mut arg1: Ident, mut arg2: DeclListNode) -> bool {
    arg0 = self.root_model_decl_node(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_decl_list_node(arg2);
    self.model_decl.contains(ModelDecl(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `model_decl` predicate.

#[allow(dead_code)]
pub fn iter_model_decl(&self) -> impl '_ + Iterator<Item=(ModelDeclNode, Ident, DeclListNode)> {
    self.model_decl.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `model_decl(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_model_decl(&mut self, mut tm0: ModelDeclNode, mut tm1: Ident, mut tm2: DeclListNode) {
    tm0 = self.model_decl_node_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.decl_list_node_equalities.root(tm2);
    if self.model_decl.insert(ModelDecl(tm0, tm1, tm2)) {
        let weight0 = &mut self.model_decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ModelDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ModelDeclTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ModelDeclTable::WEIGHT);

    }
}

/// Returns `true` if `decl_node_type(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn decl_node_type(&self, mut arg0: DeclNode, mut arg1: TypeDeclNode) -> bool {
    arg0 = self.root_decl_node(arg0);
arg1 = self.root_type_decl_node(arg1);
    self.decl_node_type.contains(DeclNodeType(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `decl_node_type` predicate.

#[allow(dead_code)]
pub fn iter_decl_node_type(&self) -> impl '_ + Iterator<Item=(DeclNode, TypeDeclNode)> {
    self.decl_node_type.iter_all().map(|t| (t.0, t.1))
}
/// Makes `decl_node_type(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_decl_node_type(&mut self, mut tm0: DeclNode, mut tm1: TypeDeclNode) {
    tm0 = self.decl_node_equalities.root(tm0);
tm1 = self.type_decl_node_equalities.root(tm1);
    if self.decl_node_type.insert(DeclNodeType(tm0, tm1)) {
        let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeTypeTable::WEIGHT);

    }
}

/// Returns `true` if `decl_node_pred(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn decl_node_pred(&self, mut arg0: DeclNode, mut arg1: PredDeclNode) -> bool {
    arg0 = self.root_decl_node(arg0);
arg1 = self.root_pred_decl_node(arg1);
    self.decl_node_pred.contains(DeclNodePred(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `decl_node_pred` predicate.

#[allow(dead_code)]
pub fn iter_decl_node_pred(&self) -> impl '_ + Iterator<Item=(DeclNode, PredDeclNode)> {
    self.decl_node_pred.iter_all().map(|t| (t.0, t.1))
}
/// Makes `decl_node_pred(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_decl_node_pred(&mut self, mut tm0: DeclNode, mut tm1: PredDeclNode) {
    tm0 = self.decl_node_equalities.root(tm0);
tm1 = self.pred_decl_node_equalities.root(tm1);
    if self.decl_node_pred.insert(DeclNodePred(tm0, tm1)) {
        let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodePredTable::WEIGHT);

let weight1 = &mut self.pred_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodePredTable::WEIGHT);

    }
}

/// Returns `true` if `decl_node_func(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn decl_node_func(&self, mut arg0: DeclNode, mut arg1: FuncDeclNode) -> bool {
    arg0 = self.root_decl_node(arg0);
arg1 = self.root_func_decl_node(arg1);
    self.decl_node_func.contains(DeclNodeFunc(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `decl_node_func` predicate.

#[allow(dead_code)]
pub fn iter_decl_node_func(&self) -> impl '_ + Iterator<Item=(DeclNode, FuncDeclNode)> {
    self.decl_node_func.iter_all().map(|t| (t.0, t.1))
}
/// Makes `decl_node_func(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_decl_node_func(&mut self, mut tm0: DeclNode, mut tm1: FuncDeclNode) {
    tm0 = self.decl_node_equalities.root(tm0);
tm1 = self.func_decl_node_equalities.root(tm1);
    if self.decl_node_func.insert(DeclNodeFunc(tm0, tm1)) {
        let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeFuncTable::WEIGHT);

let weight1 = &mut self.func_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeFuncTable::WEIGHT);

    }
}

/// Returns `true` if `decl_node_rule(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn decl_node_rule(&self, mut arg0: DeclNode, mut arg1: RuleDeclNode) -> bool {
    arg0 = self.root_decl_node(arg0);
arg1 = self.root_rule_decl_node(arg1);
    self.decl_node_rule.contains(DeclNodeRule(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `decl_node_rule` predicate.

#[allow(dead_code)]
pub fn iter_decl_node_rule(&self) -> impl '_ + Iterator<Item=(DeclNode, RuleDeclNode)> {
    self.decl_node_rule.iter_all().map(|t| (t.0, t.1))
}
/// Makes `decl_node_rule(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_decl_node_rule(&mut self, mut tm0: DeclNode, mut tm1: RuleDeclNode) {
    tm0 = self.decl_node_equalities.root(tm0);
tm1 = self.rule_decl_node_equalities.root(tm1);
    if self.decl_node_rule.insert(DeclNodeRule(tm0, tm1)) {
        let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeRuleTable::WEIGHT);

let weight1 = &mut self.rule_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeRuleTable::WEIGHT);

    }
}

/// Returns `true` if `decl_node_enum(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn decl_node_enum(&self, mut arg0: DeclNode, mut arg1: EnumDeclNode) -> bool {
    arg0 = self.root_decl_node(arg0);
arg1 = self.root_enum_decl_node(arg1);
    self.decl_node_enum.contains(DeclNodeEnum(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `decl_node_enum` predicate.

#[allow(dead_code)]
pub fn iter_decl_node_enum(&self) -> impl '_ + Iterator<Item=(DeclNode, EnumDeclNode)> {
    self.decl_node_enum.iter_all().map(|t| (t.0, t.1))
}
/// Makes `decl_node_enum(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_decl_node_enum(&mut self, mut tm0: DeclNode, mut tm1: EnumDeclNode) {
    tm0 = self.decl_node_equalities.root(tm0);
tm1 = self.enum_decl_node_equalities.root(tm1);
    if self.decl_node_enum.insert(DeclNodeEnum(tm0, tm1)) {
        let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeEnumTable::WEIGHT);

    }
}

/// Returns `true` if `decl_node_model(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn decl_node_model(&self, mut arg0: DeclNode, mut arg1: ModelDeclNode) -> bool {
    arg0 = self.root_decl_node(arg0);
arg1 = self.root_model_decl_node(arg1);
    self.decl_node_model.contains(DeclNodeModel(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `decl_node_model` predicate.

#[allow(dead_code)]
pub fn iter_decl_node_model(&self) -> impl '_ + Iterator<Item=(DeclNode, ModelDeclNode)> {
    self.decl_node_model.iter_all().map(|t| (t.0, t.1))
}
/// Makes `decl_node_model(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_decl_node_model(&mut self, mut tm0: DeclNode, mut tm1: ModelDeclNode) {
    tm0 = self.decl_node_equalities.root(tm0);
tm1 = self.model_decl_node_equalities.root(tm1);
    if self.decl_node_model.insert(DeclNodeModel(tm0, tm1)) {
        let weight0 = &mut self.decl_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeModelTable::WEIGHT);

let weight1 = &mut self.model_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeModelTable::WEIGHT);

    }
}

/// Returns `true` if `nil_decl_list_node(arg0)` holds.
#[allow(dead_code)]
pub fn nil_decl_list_node(&self, mut arg0: DeclListNode) -> bool {
    arg0 = self.root_decl_list_node(arg0);
    self.nil_decl_list_node.contains(NilDeclListNode(arg0))
}
/// Returns an iterator over elements satisfying the `nil_decl_list_node` predicate.

#[allow(dead_code)]
pub fn iter_nil_decl_list_node(&self) -> impl '_ + Iterator<Item=DeclListNode> {
    self.nil_decl_list_node.iter_all().map(|t| t.0)
}
/// Makes `nil_decl_list_node(tm0)` hold.

#[allow(dead_code)]
pub fn insert_nil_decl_list_node(&mut self, mut tm0: DeclListNode) {
    tm0 = self.decl_list_node_equalities.root(tm0);
    if self.nil_decl_list_node.insert(NilDeclListNode(tm0)) {
        let weight0 = &mut self.decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NilDeclListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `cons_decl_list_node(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn cons_decl_list_node(&self, mut arg0: DeclListNode, mut arg1: DeclNode, mut arg2: DeclListNode) -> bool {
    arg0 = self.root_decl_list_node(arg0);
arg1 = self.root_decl_node(arg1);
arg2 = self.root_decl_list_node(arg2);
    self.cons_decl_list_node.contains(ConsDeclListNode(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `cons_decl_list_node` predicate.

#[allow(dead_code)]
pub fn iter_cons_decl_list_node(&self) -> impl '_ + Iterator<Item=(DeclListNode, DeclNode, DeclListNode)> {
    self.cons_decl_list_node.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `cons_decl_list_node(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_cons_decl_list_node(&mut self, mut tm0: DeclListNode, mut tm1: DeclNode, mut tm2: DeclListNode) {
    tm0 = self.decl_list_node_equalities.root(tm0);
tm1 = self.decl_node_equalities.root(tm1);
tm2 = self.decl_list_node_equalities.root(tm2);
    if self.cons_decl_list_node.insert(ConsDeclListNode(tm0, tm1, tm2)) {
        let weight0 = &mut self.decl_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConsDeclListNodeTable::WEIGHT);

let weight1 = &mut self.decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ConsDeclListNodeTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ConsDeclListNodeTable::WEIGHT);

    }
}

/// Returns `true` if `decls_module_node(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn decls_module_node(&self, mut arg0: ModuleNode, mut arg1: DeclListNode) -> bool {
    arg0 = self.root_module_node(arg0);
arg1 = self.root_decl_list_node(arg1);
    self.decls_module_node.contains(DeclsModuleNode(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `decls_module_node` predicate.

#[allow(dead_code)]
pub fn iter_decls_module_node(&self) -> impl '_ + Iterator<Item=(ModuleNode, DeclListNode)> {
    self.decls_module_node.iter_all().map(|t| (t.0, t.1))
}
/// Makes `decls_module_node(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_decls_module_node(&mut self, mut tm0: ModuleNode, mut tm1: DeclListNode) {
    tm0 = self.module_node_equalities.root(tm0);
tm1 = self.decl_list_node_equalities.root(tm1);
    if self.decls_module_node.insert(DeclsModuleNode(tm0, tm1)) {
        let weight0 = &mut self.module_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DeclsModuleNodeTable::WEIGHT);

let weight1 = &mut self.decl_list_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DeclsModuleNodeTable::WEIGHT);

    }
}

/// Returns `true` if `var_in_scope(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn var_in_scope(&self, mut arg0: VirtIdent, mut arg1: Scope) -> bool {
    arg0 = self.root_virt_ident(arg0);
arg1 = self.root_scope(arg1);
    self.var_in_scope.contains(VarInScope(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `var_in_scope` predicate.

#[allow(dead_code)]
pub fn iter_var_in_scope(&self) -> impl '_ + Iterator<Item=(VirtIdent, Scope)> {
    self.var_in_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes `var_in_scope(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_var_in_scope(&mut self, mut tm0: VirtIdent, mut tm1: Scope) {
    tm0 = self.virt_ident_equalities.root(tm0);
tm1 = self.scope_equalities.root(tm1);
    if self.var_in_scope.insert(VarInScope(tm0, tm1)) {
        let weight0 = &mut self.virt_ident_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(VarInScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(VarInScopeTable::WEIGHT);

    }
}

/// Returns `true` if `scope_extension(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn scope_extension(&self, mut arg0: Scope, mut arg1: Scope) -> bool {
    arg0 = self.root_scope(arg0);
arg1 = self.root_scope(arg1);
    self.scope_extension.contains(ScopeExtension(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `scope_extension` predicate.

#[allow(dead_code)]
pub fn iter_scope_extension(&self) -> impl '_ + Iterator<Item=(Scope, Scope)> {
    self.scope_extension.iter_all().map(|t| (t.0, t.1))
}
/// Makes `scope_extension(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_scope_extension(&mut self, mut tm0: Scope, mut tm1: Scope) {
    tm0 = self.scope_equalities.root(tm0);
tm1 = self.scope_equalities.root(tm1);
    if self.scope_extension.insert(ScopeExtension(tm0, tm1)) {
        let weight0 = &mut self.scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ScopeExtensionTable::WEIGHT);

let weight1 = &mut self.scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ScopeExtensionTable::WEIGHT);

    }
}

/// Returns `true` if `scope_single_child(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn scope_single_child(&self, mut arg0: RuleDescendantNode, mut arg1: RuleDescendantNode) -> bool {
    arg0 = self.root_rule_descendant_node(arg0);
arg1 = self.root_rule_descendant_node(arg1);
    self.scope_single_child.contains(ScopeSingleChild(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `scope_single_child` predicate.

#[allow(dead_code)]
pub fn iter_scope_single_child(&self) -> impl '_ + Iterator<Item=(RuleDescendantNode, RuleDescendantNode)> {
    self.scope_single_child.iter_all().map(|t| (t.0, t.1))
}
/// Makes `scope_single_child(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_scope_single_child(&mut self, mut tm0: RuleDescendantNode, mut tm1: RuleDescendantNode) {
    tm0 = self.rule_descendant_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
    if self.scope_single_child.insert(ScopeSingleChild(tm0, tm1)) {
        let weight0 = &mut self.rule_descendant_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ScopeSingleChildTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ScopeSingleChildTable::WEIGHT);

    }
}

/// Returns `true` if `scope_extension_siblings(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn scope_extension_siblings(&self, mut arg0: RuleDescendantNode, mut arg1: RuleDescendantNode, mut arg2: RuleDescendantNode) -> bool {
    arg0 = self.root_rule_descendant_node(arg0);
arg1 = self.root_rule_descendant_node(arg1);
arg2 = self.root_rule_descendant_node(arg2);
    self.scope_extension_siblings.contains(ScopeExtensionSiblings(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `scope_extension_siblings` predicate.

#[allow(dead_code)]
pub fn iter_scope_extension_siblings(&self) -> impl '_ + Iterator<Item=(RuleDescendantNode, RuleDescendantNode, RuleDescendantNode)> {
    self.scope_extension_siblings.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `scope_extension_siblings(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_scope_extension_siblings(&mut self, mut tm0: RuleDescendantNode, mut tm1: RuleDescendantNode, mut tm2: RuleDescendantNode) {
    tm0 = self.rule_descendant_node_equalities.root(tm0);
tm1 = self.rule_descendant_node_equalities.root(tm1);
tm2 = self.rule_descendant_node_equalities.root(tm2);
    if self.scope_extension_siblings.insert(ScopeExtensionSiblings(tm0, tm1, tm2)) {
        let weight0 = &mut self.rule_descendant_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

let weight2 = &mut self.rule_descendant_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

    }
}

/// Returns `true` if `is_normal_type(arg0)` holds.
#[allow(dead_code)]
pub fn is_normal_type(&self, mut arg0: Type) -> bool {
    arg0 = self.root_type(arg0);
    self.is_normal_type.contains(IsNormalType(arg0))
}
/// Returns an iterator over elements satisfying the `is_normal_type` predicate.

#[allow(dead_code)]
pub fn iter_is_normal_type(&self) -> impl '_ + Iterator<Item=Type> {
    self.is_normal_type.iter_all().map(|t| t.0)
}
/// Makes `is_normal_type(tm0)` hold.

#[allow(dead_code)]
pub fn insert_is_normal_type(&mut self, mut tm0: Type) {
    tm0 = self.type_equalities.root(tm0);
    if self.is_normal_type.insert(IsNormalType(tm0)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IsNormalTypeTable::WEIGHT);

    }
}

/// Returns `true` if `is_enum_type(arg0)` holds.
#[allow(dead_code)]
pub fn is_enum_type(&self, mut arg0: Type) -> bool {
    arg0 = self.root_type(arg0);
    self.is_enum_type.contains(IsEnumType(arg0))
}
/// Returns an iterator over elements satisfying the `is_enum_type` predicate.

#[allow(dead_code)]
pub fn iter_is_enum_type(&self) -> impl '_ + Iterator<Item=Type> {
    self.is_enum_type.iter_all().map(|t| t.0)
}
/// Makes `is_enum_type(tm0)` hold.

#[allow(dead_code)]
pub fn insert_is_enum_type(&mut self, mut tm0: Type) {
    tm0 = self.type_equalities.root(tm0);
    if self.is_enum_type.insert(IsEnumType(tm0)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IsEnumTypeTable::WEIGHT);

    }
}

/// Returns `true` if `is_model_type(arg0)` holds.
#[allow(dead_code)]
pub fn is_model_type(&self, mut arg0: Type) -> bool {
    arg0 = self.root_type(arg0);
    self.is_model_type.contains(IsModelType(arg0))
}
/// Returns an iterator over elements satisfying the `is_model_type` predicate.

#[allow(dead_code)]
pub fn iter_is_model_type(&self) -> impl '_ + Iterator<Item=Type> {
    self.is_model_type.iter_all().map(|t| t.0)
}
/// Makes `is_model_type(tm0)` hold.

#[allow(dead_code)]
pub fn insert_is_model_type(&mut self, mut tm0: Type) {
    tm0 = self.type_equalities.root(tm0);
    if self.is_model_type.insert(IsModelType(tm0)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IsModelTypeTable::WEIGHT);

    }
}

/// Returns `true` if `is_mor_type(arg0)` holds.
#[allow(dead_code)]
pub fn is_mor_type(&self, mut arg0: Type) -> bool {
    arg0 = self.root_type(arg0);
    self.is_mor_type.contains(IsMorType(arg0))
}
/// Returns an iterator over elements satisfying the `is_mor_type` predicate.

#[allow(dead_code)]
pub fn iter_is_mor_type(&self) -> impl '_ + Iterator<Item=Type> {
    self.is_mor_type.iter_all().map(|t| t.0)
}
/// Makes `is_mor_type(tm0)` hold.

#[allow(dead_code)]
pub fn insert_is_mor_type(&mut self, mut tm0: Type) {
    tm0 = self.type_equalities.root(tm0);
    if self.is_mor_type.insert(IsMorType(tm0)) {
        let weight0 = &mut self.type_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IsMorTypeTable::WEIGHT);

    }
}

/// Returns `true` if `illegal_member_type_expr_in_signature(arg0)` holds.
#[allow(dead_code)]
pub fn illegal_member_type_expr_in_signature(&self, mut arg0: TypeExprNode) -> bool {
    arg0 = self.root_type_expr_node(arg0);
    self.illegal_member_type_expr_in_signature.contains(IllegalMemberTypeExprInSignature(arg0))
}
/// Returns an iterator over elements satisfying the `illegal_member_type_expr_in_signature` predicate.

#[allow(dead_code)]
pub fn iter_illegal_member_type_expr_in_signature(&self) -> impl '_ + Iterator<Item=TypeExprNode> {
    self.illegal_member_type_expr_in_signature.iter_all().map(|t| t.0)
}
/// Makes `illegal_member_type_expr_in_signature(tm0)` hold.

#[allow(dead_code)]
pub fn insert_illegal_member_type_expr_in_signature(&mut self, mut tm0: TypeExprNode) {
    tm0 = self.type_expr_node_equalities.root(tm0);
    if self.illegal_member_type_expr_in_signature.insert(IllegalMemberTypeExprInSignature(tm0)) {
        let weight0 = &mut self.type_expr_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IllegalMemberTypeExprInSignatureTable::WEIGHT);

    }
}

/// Returns `true` if `is_total_func(arg0)` holds.
#[allow(dead_code)]
pub fn is_total_func(&self, mut arg0: Func) -> bool {
    arg0 = self.root_func(arg0);
    self.is_total_func.contains(IsTotalFunc(arg0))
}
/// Returns an iterator over elements satisfying the `is_total_func` predicate.

#[allow(dead_code)]
pub fn iter_is_total_func(&self) -> impl '_ + Iterator<Item=Func> {
    self.is_total_func.iter_all().map(|t| t.0)
}
/// Makes `is_total_func(tm0)` hold.

#[allow(dead_code)]
pub fn insert_is_total_func(&mut self, mut tm0: Func) {
    tm0 = self.func_equalities.root(tm0);
    if self.is_total_func.insert(IsTotalFunc(tm0)) {
        let weight0 = &mut self.func_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IsTotalFuncTable::WEIGHT);

    }
}

/// Returns `true` if `rel_app(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn rel_app(&self, mut arg0: Rel, mut arg1: ElList) -> bool {
    arg0 = self.root_rel(arg0);
arg1 = self.root_el_list(arg1);
    self.rel_app.contains(RelApp(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `rel_app` predicate.

#[allow(dead_code)]
pub fn iter_rel_app(&self) -> impl '_ + Iterator<Item=(Rel, ElList)> {
    self.rel_app.iter_all().map(|t| (t.0, t.1))
}
/// Makes `rel_app(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_rel_app(&mut self, mut tm0: Rel, mut tm1: ElList) {
    tm0 = self.rel_equalities.root(tm0);
tm1 = self.el_list_equalities.root(tm1);
    if self.rel_app.insert(RelApp(tm0, tm1)) {
        let weight0 = &mut self.rel_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RelAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RelAppTable::WEIGHT);

    }
}

/// Returns `true` if `el_type(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn el_type(&self, mut arg0: El, mut arg1: ElementType) -> bool {
    arg0 = self.root_el(arg0);
arg1 = self.root_element_type(arg1);
    self.el_type.contains(ElType(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `el_type` predicate.

#[allow(dead_code)]
pub fn iter_el_type(&self) -> impl '_ + Iterator<Item=(El, ElementType)> {
    self.el_type.iter_all().map(|t| (t.0, t.1))
}
/// Makes `el_type(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_el_type(&mut self, mut tm0: El, mut tm1: ElementType) {
    tm0 = self.el_equalities.root(tm0);
tm1 = self.element_type_equalities.root(tm1);
    if self.el_type.insert(ElType(tm0, tm1)) {
        let weight0 = &mut self.el_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ElTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ElTypeTable::WEIGHT);

    }
}

/// Returns `true` if `el_types(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn el_types(&self, mut arg0: ElList, mut arg1: ElementTypeList) -> bool {
    arg0 = self.root_el_list(arg0);
arg1 = self.root_element_type_list(arg1);
    self.el_types.contains(ElTypes(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `el_types` predicate.

#[allow(dead_code)]
pub fn iter_el_types(&self) -> impl '_ + Iterator<Item=(ElList, ElementTypeList)> {
    self.el_types.iter_all().map(|t| (t.0, t.1))
}
/// Makes `el_types(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_el_types(&mut self, mut tm0: ElList, mut tm1: ElementTypeList) {
    tm0 = self.el_list_equalities.root(tm0);
tm1 = self.element_type_list_equalities.root(tm1);
    if self.el_types.insert(ElTypes(tm0, tm1)) {
        let weight0 = &mut self.el_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ElTypesTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ElTypesTable::WEIGHT);

    }
}

/// Returns `true` if `constrained_el(arg0)` holds.
#[allow(dead_code)]
pub fn constrained_el(&self, mut arg0: El) -> bool {
    arg0 = self.root_el(arg0);
    self.constrained_el.contains(ConstrainedEl(arg0))
}
/// Returns an iterator over elements satisfying the `constrained_el` predicate.

#[allow(dead_code)]
pub fn iter_constrained_el(&self) -> impl '_ + Iterator<Item=El> {
    self.constrained_el.iter_all().map(|t| t.0)
}
/// Makes `constrained_el(tm0)` hold.

#[allow(dead_code)]
pub fn insert_constrained_el(&mut self, mut tm0: El) {
    tm0 = self.el_equalities.root(tm0);
    if self.constrained_el.insert(ConstrainedEl(tm0)) {
        let weight0 = &mut self.el_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConstrainedElTable::WEIGHT);

    }
}

/// Returns `true` if `constrained_els(arg0)` holds.
#[allow(dead_code)]
pub fn constrained_els(&self, mut arg0: ElList) -> bool {
    arg0 = self.root_el_list(arg0);
    self.constrained_els.contains(ConstrainedEls(arg0))
}
/// Returns an iterator over elements satisfying the `constrained_els` predicate.

#[allow(dead_code)]
pub fn iter_constrained_els(&self) -> impl '_ + Iterator<Item=ElList> {
    self.constrained_els.iter_all().map(|t| t.0)
}
/// Makes `constrained_els(tm0)` hold.

#[allow(dead_code)]
pub fn insert_constrained_els(&mut self, mut tm0: ElList) {
    tm0 = self.el_list_equalities.root(tm0);
    if self.constrained_els.insert(ConstrainedEls(tm0)) {
        let weight0 = &mut self.el_list_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ConstrainedElsTable::WEIGHT);

    }
}

/// Returns `true` if `in_ker(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn in_ker(&self, mut arg0: Morphism, mut arg1: El, mut arg2: El) -> bool {
    arg0 = self.root_morphism(arg0);
arg1 = self.root_el(arg1);
arg2 = self.root_el(arg2);
    self.in_ker.contains(InKer(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `in_ker` predicate.

#[allow(dead_code)]
pub fn iter_in_ker(&self) -> impl '_ + Iterator<Item=(Morphism, El, El)> {
    self.in_ker.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `in_ker(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_in_ker(&mut self, mut tm0: Morphism, mut tm1: El, mut tm2: El) {
    tm0 = self.morphism_equalities.root(tm0);
tm1 = self.el_equalities.root(tm1);
tm2 = self.el_equalities.root(tm2);
    if self.in_ker.insert(InKer(tm0, tm1, tm2)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(InKerTable::WEIGHT);

let weight1 = &mut self.el_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(InKerTable::WEIGHT);

let weight2 = &mut self.el_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(InKerTable::WEIGHT);

    }
}

/// Returns `true` if `el_in_img(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn el_in_img(&self, mut arg0: Morphism, mut arg1: El) -> bool {
    arg0 = self.root_morphism(arg0);
arg1 = self.root_el(arg1);
    self.el_in_img.contains(ElInImg(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `el_in_img` predicate.

#[allow(dead_code)]
pub fn iter_el_in_img(&self) -> impl '_ + Iterator<Item=(Morphism, El)> {
    self.el_in_img.iter_all().map(|t| (t.0, t.1))
}
/// Makes `el_in_img(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_el_in_img(&mut self, mut tm0: Morphism, mut tm1: El) {
    tm0 = self.morphism_equalities.root(tm0);
tm1 = self.el_equalities.root(tm1);
    if self.el_in_img.insert(ElInImg(tm0, tm1)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ElInImgTable::WEIGHT);

let weight1 = &mut self.el_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ElInImgTable::WEIGHT);

    }
}

/// Returns `true` if `rel_tuple_in_img(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn rel_tuple_in_img(&self, mut arg0: Morphism, mut arg1: Rel, mut arg2: ElList) -> bool {
    arg0 = self.root_morphism(arg0);
arg1 = self.root_rel(arg1);
arg2 = self.root_el_list(arg2);
    self.rel_tuple_in_img.contains(RelTupleInImg(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `rel_tuple_in_img` predicate.

#[allow(dead_code)]
pub fn iter_rel_tuple_in_img(&self) -> impl '_ + Iterator<Item=(Morphism, Rel, ElList)> {
    self.rel_tuple_in_img.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `rel_tuple_in_img(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_rel_tuple_in_img(&mut self, mut tm0: Morphism, mut tm1: Rel, mut tm2: ElList) {
    tm0 = self.morphism_equalities.root(tm0);
tm1 = self.rel_equalities.root(tm1);
tm2 = self.el_list_equalities.root(tm2);
    if self.rel_tuple_in_img.insert(RelTupleInImg(tm0, tm1, tm2)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(RelTupleInImgTable::WEIGHT);

let weight1 = &mut self.rel_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(RelTupleInImgTable::WEIGHT);

let weight2 = &mut self.el_list_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(RelTupleInImgTable::WEIGHT);

    }
}

/// Returns `true` if `symbol_scope_extension(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn symbol_scope_extension(&self, mut arg0: SymbolScope, mut arg1: SymbolScope) -> bool {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_symbol_scope(arg1);
    self.symbol_scope_extension.contains(SymbolScopeExtension(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `symbol_scope_extension` predicate.

#[allow(dead_code)]
pub fn iter_symbol_scope_extension(&self) -> impl '_ + Iterator<Item=(SymbolScope, SymbolScope)> {
    self.symbol_scope_extension.iter_all().map(|t| (t.0, t.1))
}
/// Makes `symbol_scope_extension(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_symbol_scope_extension(&mut self, mut tm0: SymbolScope, mut tm1: SymbolScope) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.symbol_scope_extension.insert(SymbolScopeExtension(tm0, tm1)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeExtensionTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeExtensionTable::WEIGHT);

    }
}

/// Returns `true` if `symbol_scope_ancestor(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn symbol_scope_ancestor(&self, mut arg0: SymbolScope, mut arg1: SymbolScope) -> bool {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_symbol_scope(arg1);
    self.symbol_scope_ancestor.contains(SymbolScopeAncestor(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `symbol_scope_ancestor` predicate.

#[allow(dead_code)]
pub fn iter_symbol_scope_ancestor(&self) -> impl '_ + Iterator<Item=(SymbolScope, SymbolScope)> {
    self.symbol_scope_ancestor.iter_all().map(|t| (t.0, t.1))
}
/// Makes `symbol_scope_ancestor(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_symbol_scope_ancestor(&mut self, mut tm0: SymbolScope, mut tm1: SymbolScope) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.symbol_scope_ancestor.insert(SymbolScopeAncestor(tm0, tm1)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeAncestorTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeAncestorTable::WEIGHT);

    }
}

/// Returns `true` if `element_member_symbol_scope(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn element_member_symbol_scope(&self, mut arg0: El, mut arg1: SymbolScope) -> bool {
    arg0 = self.root_el(arg0);
arg1 = self.root_symbol_scope(arg1);
    self.element_member_symbol_scope.contains(ElementMemberSymbolScope(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `element_member_symbol_scope` predicate.

#[allow(dead_code)]
pub fn iter_element_member_symbol_scope(&self) -> impl '_ + Iterator<Item=(El, SymbolScope)> {
    self.element_member_symbol_scope.iter_all().map(|t| (t.0, t.1))
}
/// Makes `element_member_symbol_scope(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_element_member_symbol_scope(&mut self, mut tm0: El, mut tm1: SymbolScope) {
    tm0 = self.el_equalities.root(tm0);
tm1 = self.symbol_scope_equalities.root(tm1);
    if self.element_member_symbol_scope.insert(ElementMemberSymbolScope(tm0, tm1)) {
        let weight0 = &mut self.el_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ElementMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ElementMemberSymbolScopeTable::WEIGHT);

    }
}

/// Returns `true` if `defined_symbol(arg0, arg1, arg2, arg3)` holds.
#[allow(dead_code)]
pub fn defined_symbol(&self, mut arg0: SymbolScope, mut arg1: Ident, mut arg2: SymbolKind, mut arg3: Loc) -> bool {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_symbol_kind(arg2);
arg3 = self.root_loc(arg3);
    self.defined_symbol.contains(DefinedSymbol(arg0, arg1, arg2, arg3))
}
/// Returns an iterator over tuples of elements satisfying the `defined_symbol` predicate.

#[allow(dead_code)]
pub fn iter_defined_symbol(&self) -> impl '_ + Iterator<Item=(SymbolScope, Ident, SymbolKind, Loc)> {
    self.defined_symbol.iter_all().map(|t| (t.0, t.1, t.2, t.3))
}
/// Makes `defined_symbol(tm0, tm1, tm2, tm3)` hold.

#[allow(dead_code)]
pub fn insert_defined_symbol(&mut self, mut tm0: SymbolScope, mut tm1: Ident, mut tm2: SymbolKind, mut tm3: Loc) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.symbol_kind_equalities.root(tm2);
tm3 = self.loc_equalities.root(tm3);
    if self.defined_symbol.insert(DefinedSymbol(tm0, tm1, tm2, tm3)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[tm3.0 as usize];
*weight3 = weight3.saturating_add(DefinedSymbolTable::WEIGHT);

    }
}

/// Returns `true` if `accessible_symbol(arg0, arg1, arg2, arg3)` holds.
#[allow(dead_code)]
pub fn accessible_symbol(&self, mut arg0: SymbolScope, mut arg1: Ident, mut arg2: SymbolKind, mut arg3: Loc) -> bool {
    arg0 = self.root_symbol_scope(arg0);
arg1 = self.root_ident(arg1);
arg2 = self.root_symbol_kind(arg2);
arg3 = self.root_loc(arg3);
    self.accessible_symbol.contains(AccessibleSymbol(arg0, arg1, arg2, arg3))
}
/// Returns an iterator over tuples of elements satisfying the `accessible_symbol` predicate.

#[allow(dead_code)]
pub fn iter_accessible_symbol(&self) -> impl '_ + Iterator<Item=(SymbolScope, Ident, SymbolKind, Loc)> {
    self.accessible_symbol.iter_all().map(|t| (t.0, t.1, t.2, t.3))
}
/// Makes `accessible_symbol(tm0, tm1, tm2, tm3)` hold.

#[allow(dead_code)]
pub fn insert_accessible_symbol(&mut self, mut tm0: SymbolScope, mut tm1: Ident, mut tm2: SymbolKind, mut tm3: Loc) {
    tm0 = self.symbol_scope_equalities.root(tm0);
tm1 = self.ident_equalities.root(tm1);
tm2 = self.symbol_kind_equalities.root(tm2);
tm3 = self.loc_equalities.root(tm3);
    if self.accessible_symbol.insert(AccessibleSymbol(tm0, tm1, tm2, tm3)) {
        let weight0 = &mut self.symbol_scope_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[tm3.0 as usize];
*weight3 = weight3.saturating_add(AccessibleSymbolTable::WEIGHT);

    }
}

/// Returns `true` if `should_be_symbol(arg0, arg1, arg2, arg3)` holds.
#[allow(dead_code)]
pub fn should_be_symbol(&self, mut arg0: Ident, mut arg1: SymbolKind, mut arg2: SymbolScope, mut arg3: Loc) -> bool {
    arg0 = self.root_ident(arg0);
arg1 = self.root_symbol_kind(arg1);
arg2 = self.root_symbol_scope(arg2);
arg3 = self.root_loc(arg3);
    self.should_be_symbol.contains(ShouldBeSymbol(arg0, arg1, arg2, arg3))
}
/// Returns an iterator over tuples of elements satisfying the `should_be_symbol` predicate.

#[allow(dead_code)]
pub fn iter_should_be_symbol(&self) -> impl '_ + Iterator<Item=(Ident, SymbolKind, SymbolScope, Loc)> {
    self.should_be_symbol.iter_all().map(|t| (t.0, t.1, t.2, t.3))
}
/// Makes `should_be_symbol(tm0, tm1, tm2, tm3)` hold.

#[allow(dead_code)]
pub fn insert_should_be_symbol(&mut self, mut tm0: Ident, mut tm1: SymbolKind, mut tm2: SymbolScope, mut tm3: Loc) {
    tm0 = self.ident_equalities.root(tm0);
tm1 = self.symbol_kind_equalities.root(tm1);
tm2 = self.symbol_scope_equalities.root(tm2);
tm3 = self.loc_equalities.root(tm3);
    if self.should_be_symbol.insert(ShouldBeSymbol(tm0, tm1, tm2, tm3)) {
        let weight0 = &mut self.ident_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[tm3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbolTable::WEIGHT);

    }
}

/// Returns `true` if `should_be_symbol_2(arg0, arg1, arg2, arg3, arg4)` holds.
#[allow(dead_code)]
pub fn should_be_symbol_2(&self, mut arg0: Ident, mut arg1: SymbolKind, mut arg2: SymbolKind, mut arg3: SymbolScope, mut arg4: Loc) -> bool {
    arg0 = self.root_ident(arg0);
arg1 = self.root_symbol_kind(arg1);
arg2 = self.root_symbol_kind(arg2);
arg3 = self.root_symbol_scope(arg3);
arg4 = self.root_loc(arg4);
    self.should_be_symbol_2.contains(ShouldBeSymbol2(arg0, arg1, arg2, arg3, arg4))
}
/// Returns an iterator over tuples of elements satisfying the `should_be_symbol_2` predicate.

#[allow(dead_code)]
pub fn iter_should_be_symbol_2(&self) -> impl '_ + Iterator<Item=(Ident, SymbolKind, SymbolKind, SymbolScope, Loc)> {
    self.should_be_symbol_2.iter_all().map(|t| (t.0, t.1, t.2, t.3, t.4))
}
/// Makes `should_be_symbol_2(tm0, tm1, tm2, tm3, tm4)` hold.

#[allow(dead_code)]
pub fn insert_should_be_symbol_2(&mut self, mut tm0: Ident, mut tm1: SymbolKind, mut tm2: SymbolKind, mut tm3: SymbolScope, mut tm4: Loc) {
    tm0 = self.ident_equalities.root(tm0);
tm1 = self.symbol_kind_equalities.root(tm1);
tm2 = self.symbol_kind_equalities.root(tm2);
tm3 = self.symbol_scope_equalities.root(tm3);
tm4 = self.loc_equalities.root(tm4);
    if self.should_be_symbol_2.insert(ShouldBeSymbol2(tm0, tm1, tm2, tm3, tm4)) {
        let weight0 = &mut self.ident_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[tm3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[tm4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol2Table::WEIGHT);

    }
}

/// Returns `true` if `should_be_symbol_3(arg0, arg1, arg2, arg3, arg4, arg5)` holds.
#[allow(dead_code)]
pub fn should_be_symbol_3(&self, mut arg0: Ident, mut arg1: SymbolKind, mut arg2: SymbolKind, mut arg3: SymbolKind, mut arg4: SymbolScope, mut arg5: Loc) -> bool {
    arg0 = self.root_ident(arg0);
arg1 = self.root_symbol_kind(arg1);
arg2 = self.root_symbol_kind(arg2);
arg3 = self.root_symbol_kind(arg3);
arg4 = self.root_symbol_scope(arg4);
arg5 = self.root_loc(arg5);
    self.should_be_symbol_3.contains(ShouldBeSymbol3(arg0, arg1, arg2, arg3, arg4, arg5))
}
/// Returns an iterator over tuples of elements satisfying the `should_be_symbol_3` predicate.

#[allow(dead_code)]
pub fn iter_should_be_symbol_3(&self) -> impl '_ + Iterator<Item=(Ident, SymbolKind, SymbolKind, SymbolKind, SymbolScope, Loc)> {
    self.should_be_symbol_3.iter_all().map(|t| (t.0, t.1, t.2, t.3, t.4, t.5))
}
/// Makes `should_be_symbol_3(tm0, tm1, tm2, tm3, tm4, tm5)` hold.

#[allow(dead_code)]
pub fn insert_should_be_symbol_3(&mut self, mut tm0: Ident, mut tm1: SymbolKind, mut tm2: SymbolKind, mut tm3: SymbolKind, mut tm4: SymbolScope, mut tm5: Loc) {
    tm0 = self.ident_equalities.root(tm0);
tm1 = self.symbol_kind_equalities.root(tm1);
tm2 = self.symbol_kind_equalities.root(tm2);
tm3 = self.symbol_kind_equalities.root(tm3);
tm4 = self.symbol_scope_equalities.root(tm4);
tm5 = self.loc_equalities.root(tm5);
    if self.should_be_symbol_3.insert(ShouldBeSymbol3(tm0, tm1, tm2, tm3, tm4, tm5)) {
        let weight0 = &mut self.ident_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[tm3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[tm4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[tm5.0 as usize];
*weight5 = weight5.saturating_add(ShouldBeSymbol3Table::WEIGHT);

    }
}

/// Returns `true` if `pred_arg_num_should_match(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn pred_arg_num_should_match(&self, mut arg0: Nat, mut arg1: Nat, mut arg2: Loc) -> bool {
    arg0 = self.root_nat(arg0);
arg1 = self.root_nat(arg1);
arg2 = self.root_loc(arg2);
    self.pred_arg_num_should_match.contains(PredArgNumShouldMatch(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `pred_arg_num_should_match` predicate.

#[allow(dead_code)]
pub fn iter_pred_arg_num_should_match(&self) -> impl '_ + Iterator<Item=(Nat, Nat, Loc)> {
    self.pred_arg_num_should_match.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `pred_arg_num_should_match(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_pred_arg_num_should_match(&mut self, mut tm0: Nat, mut tm1: Nat, mut tm2: Loc) {
    tm0 = self.nat_equalities.root(tm0);
tm1 = self.nat_equalities.root(tm1);
tm2 = self.loc_equalities.root(tm2);
    if self.pred_arg_num_should_match.insert(PredArgNumShouldMatch(tm0, tm1, tm2)) {
        let weight0 = &mut self.nat_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

    }
}

/// Returns `true` if `func_arg_num_should_match(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn func_arg_num_should_match(&self, mut arg0: Nat, mut arg1: Nat, mut arg2: Loc) -> bool {
    arg0 = self.root_nat(arg0);
arg1 = self.root_nat(arg1);
arg2 = self.root_loc(arg2);
    self.func_arg_num_should_match.contains(FuncArgNumShouldMatch(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `func_arg_num_should_match` predicate.

#[allow(dead_code)]
pub fn iter_func_arg_num_should_match(&self) -> impl '_ + Iterator<Item=(Nat, Nat, Loc)> {
    self.func_arg_num_should_match.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `func_arg_num_should_match(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_func_arg_num_should_match(&mut self, mut tm0: Nat, mut tm1: Nat, mut tm2: Loc) {
    tm0 = self.nat_equalities.root(tm0);
tm1 = self.nat_equalities.root(tm1);
tm2 = self.loc_equalities.root(tm2);
    if self.func_arg_num_should_match.insert(FuncArgNumShouldMatch(tm0, tm1, tm2)) {
        let weight0 = &mut self.nat_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

    }
}

/// Returns `true` if `cfg_edge(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn cfg_edge(&self, mut arg0: StmtNode, mut arg1: StmtNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_stmt_node(arg1);
    self.cfg_edge.contains(CfgEdge(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `cfg_edge` predicate.

#[allow(dead_code)]
pub fn iter_cfg_edge(&self) -> impl '_ + Iterator<Item=(StmtNode, StmtNode)> {
    self.cfg_edge.iter_all().map(|t| (t.0, t.1))
}
/// Makes `cfg_edge(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_cfg_edge(&mut self, mut tm0: StmtNode, mut tm1: StmtNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.stmt_node_equalities.root(tm1);
    if self.cfg_edge.insert(CfgEdge(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeTable::WEIGHT);

    }
}

/// Returns `true` if `cfg_edge_stmts_stmt(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn cfg_edge_stmts_stmt(&self, mut arg0: StmtListNode, mut arg1: StmtNode) -> bool {
    arg0 = self.root_stmt_list_node(arg0);
arg1 = self.root_stmt_node(arg1);
    self.cfg_edge_stmts_stmt.contains(CfgEdgeStmtsStmt(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `cfg_edge_stmts_stmt` predicate.

#[allow(dead_code)]
pub fn iter_cfg_edge_stmts_stmt(&self) -> impl '_ + Iterator<Item=(StmtListNode, StmtNode)> {
    self.cfg_edge_stmts_stmt.iter_all().map(|t| (t.0, t.1))
}
/// Makes `cfg_edge_stmts_stmt(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_cfg_edge_stmts_stmt(&mut self, mut tm0: StmtListNode, mut tm1: StmtNode) {
    tm0 = self.stmt_list_node_equalities.root(tm0);
tm1 = self.stmt_node_equalities.root(tm1);
    if self.cfg_edge_stmts_stmt.insert(CfgEdgeStmtsStmt(tm0, tm1)) {
        let weight0 = &mut self.stmt_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

    }
}

/// Returns `true` if `cfg_edge_stmt_stmts(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn cfg_edge_stmt_stmts(&self, mut arg0: StmtNode, mut arg1: StmtListNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_stmt_list_node(arg1);
    self.cfg_edge_stmt_stmts.contains(CfgEdgeStmtStmts(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `cfg_edge_stmt_stmts` predicate.

#[allow(dead_code)]
pub fn iter_cfg_edge_stmt_stmts(&self) -> impl '_ + Iterator<Item=(StmtNode, StmtListNode)> {
    self.cfg_edge_stmt_stmts.iter_all().map(|t| (t.0, t.1))
}
/// Makes `cfg_edge_stmt_stmts(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_cfg_edge_stmt_stmts(&mut self, mut tm0: StmtNode, mut tm1: StmtListNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.stmt_list_node_equalities.root(tm1);
    if self.cfg_edge_stmt_stmts.insert(CfgEdgeStmtStmts(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

    }
}

/// Returns `true` if `cfg_edge_fork(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn cfg_edge_fork(&self, mut arg0: StmtNode, mut arg1: StmtBlockListNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_stmt_block_list_node(arg1);
    self.cfg_edge_fork.contains(CfgEdgeFork(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `cfg_edge_fork` predicate.

#[allow(dead_code)]
pub fn iter_cfg_edge_fork(&self) -> impl '_ + Iterator<Item=(StmtNode, StmtBlockListNode)> {
    self.cfg_edge_fork.iter_all().map(|t| (t.0, t.1))
}
/// Makes `cfg_edge_fork(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_cfg_edge_fork(&mut self, mut tm0: StmtNode, mut tm1: StmtBlockListNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.stmt_block_list_node_equalities.root(tm1);
    if self.cfg_edge_fork.insert(CfgEdgeFork(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeForkTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeForkTable::WEIGHT);

    }
}

/// Returns `true` if `cfg_edge_join(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn cfg_edge_join(&self, mut arg0: StmtBlockListNode, mut arg1: StmtNode) -> bool {
    arg0 = self.root_stmt_block_list_node(arg0);
arg1 = self.root_stmt_node(arg1);
    self.cfg_edge_join.contains(CfgEdgeJoin(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `cfg_edge_join` predicate.

#[allow(dead_code)]
pub fn iter_cfg_edge_join(&self) -> impl '_ + Iterator<Item=(StmtBlockListNode, StmtNode)> {
    self.cfg_edge_join.iter_all().map(|t| (t.0, t.1))
}
/// Makes `cfg_edge_join(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_cfg_edge_join(&mut self, mut tm0: StmtBlockListNode, mut tm1: StmtNode) {
    tm0 = self.stmt_block_list_node_equalities.root(tm0);
tm1 = self.stmt_node_equalities.root(tm1);
    if self.cfg_edge_join.insert(CfgEdgeJoin(tm0, tm1)) {
        let weight0 = &mut self.stmt_block_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeJoinTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeJoinTable::WEIGHT);

    }
}

/// Returns `true` if `before_stmt_structure(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn before_stmt_structure(&self, mut arg0: StmtNode, mut arg1: Structure) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_structure(arg1);
    self.before_stmt_structure.contains(BeforeStmtStructure(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `before_stmt_structure` predicate.

#[allow(dead_code)]
pub fn iter_before_stmt_structure(&self) -> impl '_ + Iterator<Item=(StmtNode, Structure)> {
    self.before_stmt_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes `before_stmt_structure(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_before_stmt_structure(&mut self, mut tm0: StmtNode, mut tm1: Structure) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.before_stmt_structure.insert(BeforeStmtStructure(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(BeforeStmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(BeforeStmtStructureTable::WEIGHT);

    }
}

/// Returns `true` if `stmt_morphism(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn stmt_morphism(&self, mut arg0: StmtNode, mut arg1: Morphism) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_morphism(arg1);
    self.stmt_morphism.contains(StmtMorphism(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `stmt_morphism` predicate.

#[allow(dead_code)]
pub fn iter_stmt_morphism(&self) -> impl '_ + Iterator<Item=(StmtNode, Morphism)> {
    self.stmt_morphism.iter_all().map(|t| (t.0, t.1))
}
/// Makes `stmt_morphism(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_stmt_morphism(&mut self, mut tm0: StmtNode, mut tm1: Morphism) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.morphism_equalities.root(tm1);
    if self.stmt_morphism.insert(StmtMorphism(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(StmtMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(StmtMorphismTable::WEIGHT);

    }
}

/// Returns `true` if `if_morphism(arg0)` holds.
#[allow(dead_code)]
pub fn if_morphism(&self, mut arg0: Morphism) -> bool {
    arg0 = self.root_morphism(arg0);
    self.if_morphism.contains(IfMorphism(arg0))
}
/// Returns an iterator over elements satisfying the `if_morphism` predicate.

#[allow(dead_code)]
pub fn iter_if_morphism(&self) -> impl '_ + Iterator<Item=Morphism> {
    self.if_morphism.iter_all().map(|t| t.0)
}
/// Makes `if_morphism(tm0)` hold.

#[allow(dead_code)]
pub fn insert_if_morphism(&mut self, mut tm0: Morphism) {
    tm0 = self.morphism_equalities.root(tm0);
    if self.if_morphism.insert(IfMorphism(tm0)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IfMorphismTable::WEIGHT);

    }
}

/// Returns `true` if `surj_then_morphism(arg0)` holds.
#[allow(dead_code)]
pub fn surj_then_morphism(&self, mut arg0: Morphism) -> bool {
    arg0 = self.root_morphism(arg0);
    self.surj_then_morphism.contains(SurjThenMorphism(arg0))
}
/// Returns an iterator over elements satisfying the `surj_then_morphism` predicate.

#[allow(dead_code)]
pub fn iter_surj_then_morphism(&self) -> impl '_ + Iterator<Item=Morphism> {
    self.surj_then_morphism.iter_all().map(|t| t.0)
}
/// Makes `surj_then_morphism(tm0)` hold.

#[allow(dead_code)]
pub fn insert_surj_then_morphism(&mut self, mut tm0: Morphism) {
    tm0 = self.morphism_equalities.root(tm0);
    if self.surj_then_morphism.insert(SurjThenMorphism(tm0)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(SurjThenMorphismTable::WEIGHT);

    }
}

/// Returns `true` if `non_surj_then_morphism(arg0)` holds.
#[allow(dead_code)]
pub fn non_surj_then_morphism(&self, mut arg0: Morphism) -> bool {
    arg0 = self.root_morphism(arg0);
    self.non_surj_then_morphism.contains(NonSurjThenMorphism(arg0))
}
/// Returns an iterator over elements satisfying the `non_surj_then_morphism` predicate.

#[allow(dead_code)]
pub fn iter_non_surj_then_morphism(&self) -> impl '_ + Iterator<Item=Morphism> {
    self.non_surj_then_morphism.iter_all().map(|t| t.0)
}
/// Makes `non_surj_then_morphism(tm0)` hold.

#[allow(dead_code)]
pub fn insert_non_surj_then_morphism(&mut self, mut tm0: Morphism) {
    tm0 = self.morphism_equalities.root(tm0);
    if self.non_surj_then_morphism.insert(NonSurjThenMorphism(tm0)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NonSurjThenMorphismTable::WEIGHT);

    }
}

/// Returns `true` if `noop_morphism(arg0)` holds.
#[allow(dead_code)]
pub fn noop_morphism(&self, mut arg0: Morphism) -> bool {
    arg0 = self.root_morphism(arg0);
    self.noop_morphism.contains(NoopMorphism(arg0))
}
/// Returns an iterator over elements satisfying the `noop_morphism` predicate.

#[allow(dead_code)]
pub fn iter_noop_morphism(&self) -> impl '_ + Iterator<Item=Morphism> {
    self.noop_morphism.iter_all().map(|t| t.0)
}
/// Makes `noop_morphism(tm0)` hold.

#[allow(dead_code)]
pub fn insert_noop_morphism(&mut self, mut tm0: Morphism) {
    tm0 = self.morphism_equalities.root(tm0);
    if self.noop_morphism.insert(NoopMorphism(tm0)) {
        let weight0 = &mut self.morphism_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(NoopMorphismTable::WEIGHT);

    }
}

/// Returns `true` if `stmt_structure(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn stmt_structure(&self, mut arg0: StmtNode, mut arg1: Structure) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_structure(arg1);
    self.stmt_structure.contains(StmtStructure(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `stmt_structure` predicate.

#[allow(dead_code)]
pub fn iter_stmt_structure(&self) -> impl '_ + Iterator<Item=(StmtNode, Structure)> {
    self.stmt_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes `stmt_structure(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_stmt_structure(&mut self, mut tm0: StmtNode, mut tm1: Structure) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.stmt_structure.insert(StmtStructure(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(StmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(StmtStructureTable::WEIGHT);

    }
}

/// Returns `true` if `if_atom_structure(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn if_atom_structure(&self, mut arg0: IfAtomNode, mut arg1: Structure) -> bool {
    arg0 = self.root_if_atom_node(arg0);
arg1 = self.root_structure(arg1);
    self.if_atom_structure.contains(IfAtomStructure(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `if_atom_structure` predicate.

#[allow(dead_code)]
pub fn iter_if_atom_structure(&self) -> impl '_ + Iterator<Item=(IfAtomNode, Structure)> {
    self.if_atom_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes `if_atom_structure(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_if_atom_structure(&mut self, mut tm0: IfAtomNode, mut tm1: Structure) {
    tm0 = self.if_atom_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.if_atom_structure.insert(IfAtomStructure(tm0, tm1)) {
        let weight0 = &mut self.if_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomStructureTable::WEIGHT);

    }
}

/// Returns `true` if `then_atom_structure(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn then_atom_structure(&self, mut arg0: ThenAtomNode, mut arg1: Structure) -> bool {
    arg0 = self.root_then_atom_node(arg0);
arg1 = self.root_structure(arg1);
    self.then_atom_structure.contains(ThenAtomStructure(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `then_atom_structure` predicate.

#[allow(dead_code)]
pub fn iter_then_atom_structure(&self) -> impl '_ + Iterator<Item=(ThenAtomNode, Structure)> {
    self.then_atom_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes `then_atom_structure(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_then_atom_structure(&mut self, mut tm0: ThenAtomNode, mut tm1: Structure) {
    tm0 = self.then_atom_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.then_atom_structure.insert(ThenAtomStructure(tm0, tm1)) {
        let weight0 = &mut self.then_atom_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomStructureTable::WEIGHT);

    }
}

/// Returns `true` if `term_structure(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn term_structure(&self, mut arg0: TermNode, mut arg1: Structure) -> bool {
    arg0 = self.root_term_node(arg0);
arg1 = self.root_structure(arg1);
    self.term_structure.contains(TermStructure(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `term_structure` predicate.

#[allow(dead_code)]
pub fn iter_term_structure(&self) -> impl '_ + Iterator<Item=(TermNode, Structure)> {
    self.term_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes `term_structure(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_term_structure(&mut self, mut tm0: TermNode, mut tm1: Structure) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.term_structure.insert(TermStructure(tm0, tm1)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TermStructureTable::WEIGHT);

    }
}

/// Returns `true` if `terms_structure(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn terms_structure(&self, mut arg0: TermListNode, mut arg1: Structure) -> bool {
    arg0 = self.root_term_list_node(arg0);
arg1 = self.root_structure(arg1);
    self.terms_structure.contains(TermsStructure(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `terms_structure` predicate.

#[allow(dead_code)]
pub fn iter_terms_structure(&self) -> impl '_ + Iterator<Item=(TermListNode, Structure)> {
    self.terms_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes `terms_structure(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_terms_structure(&mut self, mut tm0: TermListNode, mut tm1: Structure) {
    tm0 = self.term_list_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.terms_structure.insert(TermsStructure(tm0, tm1)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TermsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TermsStructureTable::WEIGHT);

    }
}

/// Returns `true` if `opt_term_structure(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn opt_term_structure(&self, mut arg0: OptTermNode, mut arg1: Structure) -> bool {
    arg0 = self.root_opt_term_node(arg0);
arg1 = self.root_structure(arg1);
    self.opt_term_structure.contains(OptTermStructure(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `opt_term_structure` predicate.

#[allow(dead_code)]
pub fn iter_opt_term_structure(&self) -> impl '_ + Iterator<Item=(OptTermNode, Structure)> {
    self.opt_term_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes `opt_term_structure(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_opt_term_structure(&mut self, mut tm0: OptTermNode, mut tm1: Structure) {
    tm0 = self.opt_term_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.opt_term_structure.insert(OptTermStructure(tm0, tm1)) {
        let weight0 = &mut self.opt_term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(OptTermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(OptTermStructureTable::WEIGHT);

    }
}

/// Returns `true` if `type_expr_structure(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn type_expr_structure(&self, mut arg0: TypeExprNode, mut arg1: Structure) -> bool {
    arg0 = self.root_type_expr_node(arg0);
arg1 = self.root_structure(arg1);
    self.type_expr_structure.contains(TypeExprStructure(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `type_expr_structure` predicate.

#[allow(dead_code)]
pub fn iter_type_expr_structure(&self) -> impl '_ + Iterator<Item=(TypeExprNode, Structure)> {
    self.type_expr_structure.iter_all().map(|t| (t.0, t.1))
}
/// Makes `type_expr_structure(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_type_expr_structure(&mut self, mut tm0: TypeExprNode, mut tm1: Structure) {
    tm0 = self.type_expr_node_equalities.root(tm0);
tm1 = self.structure_equalities.root(tm1);
    if self.type_expr_structure.insert(TypeExprStructure(tm0, tm1)) {
        let weight0 = &mut self.type_expr_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TypeExprStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(TypeExprStructureTable::WEIGHT);

    }
}

/// Returns `true` if `term_should_be_epic_ok(arg0)` holds.
#[allow(dead_code)]
pub fn term_should_be_epic_ok(&self, mut arg0: TermNode) -> bool {
    arg0 = self.root_term_node(arg0);
    self.term_should_be_epic_ok.contains(TermShouldBeEpicOk(arg0))
}
/// Returns an iterator over elements satisfying the `term_should_be_epic_ok` predicate.

#[allow(dead_code)]
pub fn iter_term_should_be_epic_ok(&self) -> impl '_ + Iterator<Item=TermNode> {
    self.term_should_be_epic_ok.iter_all().map(|t| t.0)
}
/// Makes `term_should_be_epic_ok(tm0)` hold.

#[allow(dead_code)]
pub fn insert_term_should_be_epic_ok(&mut self, mut tm0: TermNode) {
    tm0 = self.term_node_equalities.root(tm0);
    if self.term_should_be_epic_ok.insert(TermShouldBeEpicOk(tm0)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TermShouldBeEpicOkTable::WEIGHT);

    }
}

/// Returns `true` if `terms_should_be_epic_ok(arg0)` holds.
#[allow(dead_code)]
pub fn terms_should_be_epic_ok(&self, mut arg0: TermListNode) -> bool {
    arg0 = self.root_term_list_node(arg0);
    self.terms_should_be_epic_ok.contains(TermsShouldBeEpicOk(arg0))
}
/// Returns an iterator over elements satisfying the `terms_should_be_epic_ok` predicate.

#[allow(dead_code)]
pub fn iter_terms_should_be_epic_ok(&self) -> impl '_ + Iterator<Item=TermListNode> {
    self.terms_should_be_epic_ok.iter_all().map(|t| t.0)
}
/// Makes `terms_should_be_epic_ok(tm0)` hold.

#[allow(dead_code)]
pub fn insert_terms_should_be_epic_ok(&mut self, mut tm0: TermListNode) {
    tm0 = self.term_list_node_equalities.root(tm0);
    if self.terms_should_be_epic_ok.insert(TermsShouldBeEpicOk(tm0)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(TermsShouldBeEpicOkTable::WEIGHT);

    }
}

/// Returns `true` if `el_should_be_surjective_ok(arg0)` holds.
#[allow(dead_code)]
pub fn el_should_be_surjective_ok(&self, mut arg0: El) -> bool {
    arg0 = self.root_el(arg0);
    self.el_should_be_surjective_ok.contains(ElShouldBeSurjectiveOk(arg0))
}
/// Returns an iterator over elements satisfying the `el_should_be_surjective_ok` predicate.

#[allow(dead_code)]
pub fn iter_el_should_be_surjective_ok(&self) -> impl '_ + Iterator<Item=El> {
    self.el_should_be_surjective_ok.iter_all().map(|t| t.0)
}
/// Makes `el_should_be_surjective_ok(tm0)` hold.

#[allow(dead_code)]
pub fn insert_el_should_be_surjective_ok(&mut self, mut tm0: El) {
    tm0 = self.el_equalities.root(tm0);
    if self.el_should_be_surjective_ok.insert(ElShouldBeSurjectiveOk(tm0)) {
        let weight0 = &mut self.el_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ElShouldBeSurjectiveOkTable::WEIGHT);

    }
}

/// Returns `true` if `el_is_surjective_ok(arg0)` holds.
#[allow(dead_code)]
pub fn el_is_surjective_ok(&self, mut arg0: El) -> bool {
    arg0 = self.root_el(arg0);
    self.el_is_surjective_ok.contains(ElIsSurjectiveOk(arg0))
}
/// Returns an iterator over elements satisfying the `el_is_surjective_ok` predicate.

#[allow(dead_code)]
pub fn iter_el_is_surjective_ok(&self) -> impl '_ + Iterator<Item=El> {
    self.el_is_surjective_ok.iter_all().map(|t| t.0)
}
/// Makes `el_is_surjective_ok(tm0)` hold.

#[allow(dead_code)]
pub fn insert_el_is_surjective_ok(&mut self, mut tm0: El) {
    tm0 = self.el_equalities.root(tm0);
    if self.el_is_surjective_ok.insert(ElIsSurjectiveOk(tm0)) {
        let weight0 = &mut self.el_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ElIsSurjectiveOkTable::WEIGHT);

    }
}

/// Returns `true` if `should_be_obtained_by_ctor(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn should_be_obtained_by_ctor(&self, mut arg0: TermNode, mut arg1: EnumDeclNode) -> bool {
    arg0 = self.root_term_node(arg0);
arg1 = self.root_enum_decl_node(arg1);
    self.should_be_obtained_by_ctor.contains(ShouldBeObtainedByCtor(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `should_be_obtained_by_ctor` predicate.

#[allow(dead_code)]
pub fn iter_should_be_obtained_by_ctor(&self) -> impl '_ + Iterator<Item=(TermNode, EnumDeclNode)> {
    self.should_be_obtained_by_ctor.iter_all().map(|t| (t.0, t.1))
}
/// Makes `should_be_obtained_by_ctor(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_should_be_obtained_by_ctor(&mut self, mut tm0: TermNode, mut tm1: EnumDeclNode) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.enum_decl_node_equalities.root(tm1);
    if self.should_be_obtained_by_ctor.insert(ShouldBeObtainedByCtor(tm0, tm1)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

    }
}

/// Returns `true` if `is_given_by_ctor(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn is_given_by_ctor(&self, mut arg0: TermNode, mut arg1: EnumDeclNode) -> bool {
    arg0 = self.root_term_node(arg0);
arg1 = self.root_enum_decl_node(arg1);
    self.is_given_by_ctor.contains(IsGivenByCtor(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `is_given_by_ctor` predicate.

#[allow(dead_code)]
pub fn iter_is_given_by_ctor(&self) -> impl '_ + Iterator<Item=(TermNode, EnumDeclNode)> {
    self.is_given_by_ctor.iter_all().map(|t| (t.0, t.1))
}
/// Makes `is_given_by_ctor(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_is_given_by_ctor(&mut self, mut tm0: TermNode, mut tm1: EnumDeclNode) {
    tm0 = self.term_node_equalities.root(tm0);
tm1 = self.enum_decl_node_equalities.root(tm1);
    if self.is_given_by_ctor.insert(IsGivenByCtor(tm0, tm1)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IsGivenByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(IsGivenByCtorTable::WEIGHT);

    }
}

/// Returns `true` if `function_can_be_made_defined(arg0)` holds.
#[allow(dead_code)]
pub fn function_can_be_made_defined(&self, mut arg0: Func) -> bool {
    arg0 = self.root_func(arg0);
    self.function_can_be_made_defined.contains(FunctionCanBeMadeDefined(arg0))
}
/// Returns an iterator over elements satisfying the `function_can_be_made_defined` predicate.

#[allow(dead_code)]
pub fn iter_function_can_be_made_defined(&self) -> impl '_ + Iterator<Item=Func> {
    self.function_can_be_made_defined.iter_all().map(|t| t.0)
}
/// Makes `function_can_be_made_defined(tm0)` hold.

#[allow(dead_code)]
pub fn insert_function_can_be_made_defined(&mut self, mut tm0: Func) {
    tm0 = self.func_equalities.root(tm0);
    if self.function_can_be_made_defined.insert(FunctionCanBeMadeDefined(tm0)) {
        let weight0 = &mut self.func_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(FunctionCanBeMadeDefinedTable::WEIGHT);

    }
}

/// Returns `true` if `case_pattern_is_variable(arg0)` holds.
#[allow(dead_code)]
pub fn case_pattern_is_variable(&self, mut arg0: Loc) -> bool {
    arg0 = self.root_loc(arg0);
    self.case_pattern_is_variable.contains(CasePatternIsVariable(arg0))
}
/// Returns an iterator over elements satisfying the `case_pattern_is_variable` predicate.

#[allow(dead_code)]
pub fn iter_case_pattern_is_variable(&self) -> impl '_ + Iterator<Item=Loc> {
    self.case_pattern_is_variable.iter_all().map(|t| t.0)
}
/// Makes `case_pattern_is_variable(tm0)` hold.

#[allow(dead_code)]
pub fn insert_case_pattern_is_variable(&mut self, mut tm0: Loc) {
    tm0 = self.loc_equalities.root(tm0);
    if self.case_pattern_is_variable.insert(CasePatternIsVariable(tm0)) {
        let weight0 = &mut self.loc_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CasePatternIsVariableTable::WEIGHT);

    }
}

/// Returns `true` if `case_pattern_is_wildcard(arg0)` holds.
#[allow(dead_code)]
pub fn case_pattern_is_wildcard(&self, mut arg0: Loc) -> bool {
    arg0 = self.root_loc(arg0);
    self.case_pattern_is_wildcard.contains(CasePatternIsWildcard(arg0))
}
/// Returns an iterator over elements satisfying the `case_pattern_is_wildcard` predicate.

#[allow(dead_code)]
pub fn iter_case_pattern_is_wildcard(&self) -> impl '_ + Iterator<Item=Loc> {
    self.case_pattern_is_wildcard.iter_all().map(|t| t.0)
}
/// Makes `case_pattern_is_wildcard(tm0)` hold.

#[allow(dead_code)]
pub fn insert_case_pattern_is_wildcard(&mut self, mut tm0: Loc) {
    tm0 = self.loc_equalities.root(tm0);
    if self.case_pattern_is_wildcard.insert(CasePatternIsWildcard(tm0)) {
        let weight0 = &mut self.loc_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CasePatternIsWildcardTable::WEIGHT);

    }
}

/// Returns `true` if `is_pattern_ctor_arg(arg0)` holds.
#[allow(dead_code)]
pub fn is_pattern_ctor_arg(&self, mut arg0: TermNode) -> bool {
    arg0 = self.root_term_node(arg0);
    self.is_pattern_ctor_arg.contains(IsPatternCtorArg(arg0))
}
/// Returns an iterator over elements satisfying the `is_pattern_ctor_arg` predicate.

#[allow(dead_code)]
pub fn iter_is_pattern_ctor_arg(&self) -> impl '_ + Iterator<Item=TermNode> {
    self.is_pattern_ctor_arg.iter_all().map(|t| t.0)
}
/// Makes `is_pattern_ctor_arg(tm0)` hold.

#[allow(dead_code)]
pub fn insert_is_pattern_ctor_arg(&mut self, mut tm0: TermNode) {
    tm0 = self.term_node_equalities.root(tm0);
    if self.is_pattern_ctor_arg.insert(IsPatternCtorArg(tm0)) {
        let weight0 = &mut self.term_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(IsPatternCtorArgTable::WEIGHT);

    }
}

/// Returns `true` if `are_pattern_ctor_args(arg0)` holds.
#[allow(dead_code)]
pub fn are_pattern_ctor_args(&self, mut arg0: TermListNode) -> bool {
    arg0 = self.root_term_list_node(arg0);
    self.are_pattern_ctor_args.contains(ArePatternCtorArgs(arg0))
}
/// Returns an iterator over elements satisfying the `are_pattern_ctor_args` predicate.

#[allow(dead_code)]
pub fn iter_are_pattern_ctor_args(&self) -> impl '_ + Iterator<Item=TermListNode> {
    self.are_pattern_ctor_args.iter_all().map(|t| t.0)
}
/// Makes `are_pattern_ctor_args(tm0)` hold.

#[allow(dead_code)]
pub fn insert_are_pattern_ctor_args(&mut self, mut tm0: TermListNode) {
    tm0 = self.term_list_node_equalities.root(tm0);
    if self.are_pattern_ctor_args.insert(ArePatternCtorArgs(tm0)) {
        let weight0 = &mut self.term_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(ArePatternCtorArgsTable::WEIGHT);

    }
}

/// Returns `true` if `pattern_ctor_arg_is_app(arg0)` holds.
#[allow(dead_code)]
pub fn pattern_ctor_arg_is_app(&self, mut arg0: Loc) -> bool {
    arg0 = self.root_loc(arg0);
    self.pattern_ctor_arg_is_app.contains(PatternCtorArgIsApp(arg0))
}
/// Returns an iterator over elements satisfying the `pattern_ctor_arg_is_app` predicate.

#[allow(dead_code)]
pub fn iter_pattern_ctor_arg_is_app(&self) -> impl '_ + Iterator<Item=Loc> {
    self.pattern_ctor_arg_is_app.iter_all().map(|t| t.0)
}
/// Makes `pattern_ctor_arg_is_app(tm0)` hold.

#[allow(dead_code)]
pub fn insert_pattern_ctor_arg_is_app(&mut self, mut tm0: Loc) {
    tm0 = self.loc_equalities.root(tm0);
    if self.pattern_ctor_arg_is_app.insert(PatternCtorArgIsApp(tm0)) {
        let weight0 = &mut self.loc_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PatternCtorArgIsAppTable::WEIGHT);

    }
}

/// Returns `true` if `pattern_ctor_arg_var_is_not_fresh(arg0)` holds.
#[allow(dead_code)]
pub fn pattern_ctor_arg_var_is_not_fresh(&self, mut arg0: Loc) -> bool {
    arg0 = self.root_loc(arg0);
    self.pattern_ctor_arg_var_is_not_fresh.contains(PatternCtorArgVarIsNotFresh(arg0))
}
/// Returns an iterator over elements satisfying the `pattern_ctor_arg_var_is_not_fresh` predicate.

#[allow(dead_code)]
pub fn iter_pattern_ctor_arg_var_is_not_fresh(&self) -> impl '_ + Iterator<Item=Loc> {
    self.pattern_ctor_arg_var_is_not_fresh.iter_all().map(|t| t.0)
}
/// Makes `pattern_ctor_arg_var_is_not_fresh(tm0)` hold.

#[allow(dead_code)]
pub fn insert_pattern_ctor_arg_var_is_not_fresh(&mut self, mut tm0: Loc) {
    tm0 = self.loc_equalities.root(tm0);
    if self.pattern_ctor_arg_var_is_not_fresh.insert(PatternCtorArgVarIsNotFresh(tm0)) {
        let weight0 = &mut self.loc_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(PatternCtorArgVarIsNotFreshTable::WEIGHT);

    }
}

/// Returns `true` if `cases_contain_ctor(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn cases_contain_ctor(&self, mut arg0: MatchCaseListNode, mut arg1: CtorDeclNode) -> bool {
    arg0 = self.root_match_case_list_node(arg0);
arg1 = self.root_ctor_decl_node(arg1);
    self.cases_contain_ctor.contains(CasesContainCtor(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `cases_contain_ctor` predicate.

#[allow(dead_code)]
pub fn iter_cases_contain_ctor(&self) -> impl '_ + Iterator<Item=(MatchCaseListNode, CtorDeclNode)> {
    self.cases_contain_ctor.iter_all().map(|t| (t.0, t.1))
}
/// Makes `cases_contain_ctor(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_cases_contain_ctor(&mut self, mut tm0: MatchCaseListNode, mut tm1: CtorDeclNode) {
    tm0 = self.match_case_list_node_equalities.root(tm0);
tm1 = self.ctor_decl_node_equalities.root(tm1);
    if self.cases_contain_ctor.insert(CasesContainCtor(tm0, tm1)) {
        let weight0 = &mut self.match_case_list_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(CasesContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(CasesContainCtorTable::WEIGHT);

    }
}

/// Returns `true` if `match_stmt_contains_ctor_of_enum(arg0, arg1, arg2)` holds.
#[allow(dead_code)]
pub fn match_stmt_contains_ctor_of_enum(&self, mut arg0: StmtNode, mut arg1: CtorDeclNode, mut arg2: EnumDeclNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_ctor_decl_node(arg1);
arg2 = self.root_enum_decl_node(arg2);
    self.match_stmt_contains_ctor_of_enum.contains(MatchStmtContainsCtorOfEnum(arg0, arg1, arg2))
}
/// Returns an iterator over tuples of elements satisfying the `match_stmt_contains_ctor_of_enum` predicate.

#[allow(dead_code)]
pub fn iter_match_stmt_contains_ctor_of_enum(&self) -> impl '_ + Iterator<Item=(StmtNode, CtorDeclNode, EnumDeclNode)> {
    self.match_stmt_contains_ctor_of_enum.iter_all().map(|t| (t.0, t.1, t.2))
}
/// Makes `match_stmt_contains_ctor_of_enum(tm0, tm1, tm2)` hold.

#[allow(dead_code)]
pub fn insert_match_stmt_contains_ctor_of_enum(&mut self, mut tm0: StmtNode, mut tm1: CtorDeclNode, mut tm2: EnumDeclNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.ctor_decl_node_equalities.root(tm1);
tm2 = self.enum_decl_node_equalities.root(tm2);
    if self.match_stmt_contains_ctor_of_enum.insert(MatchStmtContainsCtorOfEnum(tm0, tm1, tm2)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight2 = &mut self.enum_decl_node_weights[tm2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

    }
}

/// Returns `true` if `match_stmt_should_contain_ctor(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn match_stmt_should_contain_ctor(&self, mut arg0: StmtNode, mut arg1: CtorDeclNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_ctor_decl_node(arg1);
    self.match_stmt_should_contain_ctor.contains(MatchStmtShouldContainCtor(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `match_stmt_should_contain_ctor` predicate.

#[allow(dead_code)]
pub fn iter_match_stmt_should_contain_ctor(&self) -> impl '_ + Iterator<Item=(StmtNode, CtorDeclNode)> {
    self.match_stmt_should_contain_ctor.iter_all().map(|t| (t.0, t.1))
}
/// Makes `match_stmt_should_contain_ctor(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_match_stmt_should_contain_ctor(&mut self, mut tm0: StmtNode, mut tm1: CtorDeclNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.ctor_decl_node_equalities.root(tm1);
    if self.match_stmt_should_contain_ctor.insert(MatchStmtShouldContainCtor(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

    }
}

/// Returns `true` if `match_stmt_contains_ctor(arg0, arg1)` holds.
#[allow(dead_code)]
pub fn match_stmt_contains_ctor(&self, mut arg0: StmtNode, mut arg1: CtorDeclNode) -> bool {
    arg0 = self.root_stmt_node(arg0);
arg1 = self.root_ctor_decl_node(arg1);
    self.match_stmt_contains_ctor.contains(MatchStmtContainsCtor(arg0, arg1))
}
/// Returns an iterator over tuples of elements satisfying the `match_stmt_contains_ctor` predicate.

#[allow(dead_code)]
pub fn iter_match_stmt_contains_ctor(&self) -> impl '_ + Iterator<Item=(StmtNode, CtorDeclNode)> {
    self.match_stmt_contains_ctor.iter_all().map(|t| (t.0, t.1))
}
/// Makes `match_stmt_contains_ctor(tm0, tm1)` hold.

#[allow(dead_code)]
pub fn insert_match_stmt_contains_ctor(&mut self, mut tm0: StmtNode, mut tm1: CtorDeclNode) {
    tm0 = self.stmt_node_equalities.root(tm0);
tm1 = self.ctor_decl_node_equalities.root(tm1);
    if self.match_stmt_contains_ctor.insert(MatchStmtContainsCtor(tm0, tm1)) {
        let weight0 = &mut self.stmt_node_weights[tm0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[tm1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

    }
}

fn canonicalize(&mut self) {
    
for el in self.ident_uprooted.iter().copied() {
    let ts = self.type_decl.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.type_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeDeclTable::WEIGHT);

        t.0 = self.root_type_decl_node(t.0);
t.1 = self.root_ident(t.1);
        if self.type_decl.insert(t) {
            let weight0 = &mut self.type_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeDeclTable::WEIGHT);

        }
    }
}
for el in self.type_decl_node_uprooted.iter().copied() {
    let ts = self.type_decl.drain_with_element_type_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeDeclTable::WEIGHT);

        t.0 = self.root_type_decl_node(t.0);
t.1 = self.root_ident(t.1);
        if self.type_decl.insert(t) {
            let weight0 = &mut self.type_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeDeclTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_node_uprooted.iter().copied() {
    let ts = self.arg_decl_node_name.drain_with_element_arg_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgDeclNodeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgDeclNodeNameTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_ident(t.1);
        if self.arg_decl_node_name.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeNameTable::WEIGHT);

        }
    }
}
for el in self.ident_uprooted.iter().copied() {
    let ts = self.arg_decl_node_name.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgDeclNodeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgDeclNodeNameTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_ident(t.1);
        if self.arg_decl_node_name.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeNameTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_node_uprooted.iter().copied() {
    let ts = self.arg_decl_node_type.drain_with_element_arg_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgDeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgDeclNodeTypeTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_type_expr_node(t.1);
        if self.arg_decl_node_type.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.arg_decl_node_type.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgDeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgDeclNodeTypeTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_type_expr_node(t.1);
        if self.arg_decl_node_type.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeTypeTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_list_node_uprooted.iter().copied() {
    let ts = self.nil_arg_decl_list_node.drain_with_element_arg_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilArgDeclListNodeTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
        if self.nil_arg_decl_list_node.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilArgDeclListNodeTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_list_node_uprooted.iter().copied() {
    let ts = self.cons_arg_decl_list_node.drain_with_element_arg_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

let weight1 = &mut self.arg_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
t.1 = self.root_arg_decl_node(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
        if self.cons_arg_decl_list_node.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

let weight1 = &mut self.arg_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

        }
    }
}
for el in self.arg_decl_node_uprooted.iter().copied() {
    let ts = self.cons_arg_decl_list_node.drain_with_element_arg_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

let weight1 = &mut self.arg_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsArgDeclListNodeTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
t.1 = self.root_arg_decl_node(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
        if self.cons_arg_decl_list_node.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

let weight1 = &mut self.arg_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsArgDeclListNodeTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_list_node_uprooted.iter().copied() {
    let ts = self.pred_decl.drain_with_element_arg_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredDeclTable::WEIGHT);

        t.0 = self.root_pred_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
        if self.pred_decl.insert(t) {
            let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredDeclTable::WEIGHT);

        }
    }
}
for el in self.ident_uprooted.iter().copied() {
    let ts = self.pred_decl.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredDeclTable::WEIGHT);

        t.0 = self.root_pred_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
        if self.pred_decl.insert(t) {
            let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredDeclTable::WEIGHT);

        }
    }
}
for el in self.pred_decl_node_uprooted.iter().copied() {
    let ts = self.pred_decl.drain_with_element_pred_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredDeclTable::WEIGHT);

        t.0 = self.root_pred_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
        if self.pred_decl.insert(t) {
            let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredDeclTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_list_node_uprooted.iter().copied() {
    let ts = self.func_decl.drain_with_element_arg_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(FuncDeclTable::WEIGHT);

        t.0 = self.root_func_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
t.3 = self.root_type_expr_node(t.3);
        if self.func_decl.insert(t) {
            let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);

        }
    }
}
for el in self.func_decl_node_uprooted.iter().copied() {
    let ts = self.func_decl.drain_with_element_func_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(FuncDeclTable::WEIGHT);

        t.0 = self.root_func_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
t.3 = self.root_type_expr_node(t.3);
        if self.func_decl.insert(t) {
            let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);

        }
    }
}
for el in self.ident_uprooted.iter().copied() {
    let ts = self.func_decl.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(FuncDeclTable::WEIGHT);

        t.0 = self.root_func_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
t.3 = self.root_type_expr_node(t.3);
        if self.func_decl.insert(t) {
            let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.func_decl.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(FuncDeclTable::WEIGHT);

        t.0 = self.root_func_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
t.3 = self.root_type_expr_node(t.3);
        if self.func_decl.insert(t) {
            let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncDeclTable::WEIGHT);

let weight3 = &mut self.type_expr_node_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(FuncDeclTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_list_node_uprooted.iter().copied() {
    let ts = self.ctor_decl.drain_with_element_arg_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(CtorDeclTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
        if self.ctor_decl.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(CtorDeclTable::WEIGHT);

        }
    }
}
for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.ctor_decl.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(CtorDeclTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
        if self.ctor_decl.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(CtorDeclTable::WEIGHT);

        }
    }
}
for el in self.ident_uprooted.iter().copied() {
    let ts = self.ctor_decl.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(CtorDeclTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_arg_decl_list_node(t.2);
        if self.ctor_decl.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorDeclTable::WEIGHT);

let weight2 = &mut self.arg_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(CtorDeclTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_list_node_uprooted.iter().copied() {
    let ts = self.nil_ctor_decl_list_node.drain_with_element_ctor_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilCtorDeclListNodeTable::WEIGHT);

        t.0 = self.root_ctor_decl_list_node(t.0);
        if self.nil_ctor_decl_list_node.insert(t) {
            let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilCtorDeclListNodeTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_list_node_uprooted.iter().copied() {
    let ts = self.cons_ctor_decl_list_node.drain_with_element_ctor_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

        t.0 = self.root_ctor_decl_list_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
t.2 = self.root_ctor_decl_list_node(t.2);
        if self.cons_ctor_decl_list_node.insert(t) {
            let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

        }
    }
}
for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.cons_ctor_decl_list_node.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsCtorDeclListNodeTable::WEIGHT);

        t.0 = self.root_ctor_decl_list_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
t.2 = self.root_ctor_decl_list_node(t.2);
        if self.cons_ctor_decl_list_node.insert(t) {
            let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsCtorDeclListNodeTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_list_node_uprooted.iter().copied() {
    let ts = self.enum_decl.drain_with_element_ctor_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EnumDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EnumDeclTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(EnumDeclTable::WEIGHT);

        t.0 = self.root_enum_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_ctor_decl_list_node(t.2);
        if self.enum_decl.insert(t) {
            let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EnumDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EnumDeclTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(EnumDeclTable::WEIGHT);

        }
    }
}
for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.enum_decl.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EnumDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EnumDeclTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(EnumDeclTable::WEIGHT);

        t.0 = self.root_enum_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_ctor_decl_list_node(t.2);
        if self.enum_decl.insert(t) {
            let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EnumDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EnumDeclTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(EnumDeclTable::WEIGHT);

        }
    }
}
for el in self.ident_uprooted.iter().copied() {
    let ts = self.enum_decl.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EnumDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EnumDeclTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(EnumDeclTable::WEIGHT);

        t.0 = self.root_enum_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_ctor_decl_list_node(t.2);
        if self.enum_decl.insert(t) {
            let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EnumDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EnumDeclTable::WEIGHT);

let weight2 = &mut self.ctor_decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(EnumDeclTable::WEIGHT);

        }
    }
}

for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.nil_term_list_node.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilTermListNodeTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
        if self.nil_term_list_node.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilTermListNodeTable::WEIGHT);

        }
    }
}

for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.cons_term_list_node.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsTermListNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsTermListNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsTermListNodeTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.cons_term_list_node.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsTermListNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsTermListNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsTermListNodeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.cons_term_list_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsTermListNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsTermListNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsTermListNodeTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.cons_term_list_node.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsTermListNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsTermListNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsTermListNodeTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.ambient_type_expr.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_ident(t.1);
        if self.ambient_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientTypeExprTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.ambient_type_expr.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_ident(t.1);
        if self.ambient_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientTypeExprTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.member_type_expr.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MemberTypeExprTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MemberTypeExprTable::WEIGHT);

let weight2 = &mut self.ident_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MemberTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_ident(t.2);
        if self.member_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MemberTypeExprTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MemberTypeExprTable::WEIGHT);

let weight2 = &mut self.ident_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MemberTypeExprTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.member_type_expr.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MemberTypeExprTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MemberTypeExprTable::WEIGHT);

let weight2 = &mut self.ident_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MemberTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_ident(t.2);
        if self.member_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MemberTypeExprTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MemberTypeExprTable::WEIGHT);

let weight2 = &mut self.ident_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MemberTypeExprTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.member_type_expr.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MemberTypeExprTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MemberTypeExprTable::WEIGHT);

let weight2 = &mut self.ident_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MemberTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_ident(t.2);
        if self.member_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MemberTypeExprTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MemberTypeExprTable::WEIGHT);

let weight2 = &mut self.ident_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MemberTypeExprTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.mor_type_expr.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MorTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MorTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_ident(t.1);
        if self.mor_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeExprTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.mor_type_expr.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MorTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MorTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_ident(t.1);
        if self.mor_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeExprTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeExprTable::WEIGHT);

        }
    }
}

for el in self.opt_term_node_uprooted.iter().copied() {
    let ts = self.none_term_node.drain_with_element_opt_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NoneTermNodeTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
        if self.none_term_node.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NoneTermNodeTable::WEIGHT);

        }
    }
}

for el in self.opt_term_node_uprooted.iter().copied() {
    let ts = self.some_term_node.drain_with_element_opt_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SomeTermNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SomeTermNodeTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
t.1 = self.root_term_node(t.1);
        if self.some_term_node.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SomeTermNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SomeTermNodeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.some_term_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SomeTermNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SomeTermNodeTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
t.1 = self.root_term_node(t.1);
        if self.some_term_node.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SomeTermNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SomeTermNodeTable::WEIGHT);

        }
    }
}

for el in self.term_node_uprooted.iter().copied() {
    let ts = self.var_term_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarTermNodeTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarTermNodeTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_virt_ident(t.1);
        if self.var_term_node.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarTermNodeTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarTermNodeTable::WEIGHT);

        }
    }
}
for el in self.virt_ident_uprooted.iter().copied() {
    let ts = self.var_term_node.drain_with_element_virt_ident(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarTermNodeTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarTermNodeTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_virt_ident(t.1);
        if self.var_term_node.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarTermNodeTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarTermNodeTable::WEIGHT);

        }
    }
}

for el in self.term_node_uprooted.iter().copied() {
    let ts = self.wildcard_term_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(WildcardTermNodeTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
        if self.wildcard_term_node.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(WildcardTermNodeTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.app_term_node.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AppTermNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AppTermNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AppTermNodeTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.app_term_node.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AppTermNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AppTermNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AppTermNodeTable::WEIGHT);

        }
    }
}
for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.app_term_node.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AppTermNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AppTermNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AppTermNodeTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.app_term_node.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AppTermNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AppTermNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AppTermNodeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.app_term_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AppTermNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AppTermNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AppTermNodeTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.app_term_node.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AppTermNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AppTermNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AppTermNodeTable::WEIGHT);

        }
    }
}

for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.match_case.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchCaseTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchCaseTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchCaseTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_stmt_list_node(t.2);
        if self.match_case.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchCaseTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchCaseTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchCaseTable::WEIGHT);

        }
    }
}
for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.match_case.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchCaseTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchCaseTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchCaseTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_stmt_list_node(t.2);
        if self.match_case.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchCaseTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchCaseTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchCaseTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.match_case.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchCaseTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchCaseTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchCaseTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_stmt_list_node(t.2);
        if self.match_case.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchCaseTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchCaseTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchCaseTable::WEIGHT);

        }
    }
}

for el in self.match_case_list_node_uprooted.iter().copied() {
    let ts = self.nil_match_case_list_node.drain_with_element_match_case_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilMatchCaseListNodeTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
        if self.nil_match_case_list_node.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilMatchCaseListNodeTable::WEIGHT);

        }
    }
}

for el in self.match_case_list_node_uprooted.iter().copied() {
    let ts = self.cons_match_case_list_node.drain_with_element_match_case_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

let weight1 = &mut self.match_case_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_match_case_node(t.1);
t.2 = self.root_match_case_list_node(t.2);
        if self.cons_match_case_list_node.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

let weight1 = &mut self.match_case_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

        }
    }
}
for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.cons_match_case_list_node.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

let weight1 = &mut self.match_case_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsMatchCaseListNodeTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_match_case_node(t.1);
t.2 = self.root_match_case_list_node(t.2);
        if self.cons_match_case_list_node.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

let weight1 = &mut self.match_case_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsMatchCaseListNodeTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.equal_if_atom_node.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_term_node(t.2);
        if self.equal_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EqualIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EqualIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(EqualIfAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.equal_if_atom_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(EqualIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_term_node(t.2);
        if self.equal_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EqualIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EqualIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(EqualIfAtomNodeTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.defined_if_atom_node.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_term_node(t.1);
        if self.defined_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.defined_if_atom_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_term_node(t.1);
        if self.defined_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedIfAtomNodeTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.pred_if_atom_node.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.pred_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredIfAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.pred_if_atom_node.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.pred_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredIfAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.pred_if_atom_node.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.pred_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredIfAtomNodeTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.var_if_atom_node.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.type_expr_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(VarIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_type_expr_node(t.2);
        if self.var_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.type_expr_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(VarIfAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.var_if_atom_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.type_expr_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(VarIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_type_expr_node(t.2);
        if self.var_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.type_expr_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(VarIfAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.var_if_atom_node.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.type_expr_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(VarIfAtomNodeTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_type_expr_node(t.2);
        if self.var_if_atom_node.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarIfAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarIfAtomNodeTable::WEIGHT);

let weight2 = &mut self.type_expr_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(VarIfAtomNodeTable::WEIGHT);

        }
    }
}

for el in self.term_node_uprooted.iter().copied() {
    let ts = self.equal_then_atom_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_term_node(t.2);
        if self.equal_then_atom_node.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EqualThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EqualThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(EqualThenAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.then_atom_node_uprooted.iter().copied() {
    let ts = self.equal_then_atom_node.drain_with_element_then_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(EqualThenAtomNodeTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_term_node(t.2);
        if self.equal_then_atom_node.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EqualThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EqualThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(EqualThenAtomNodeTable::WEIGHT);

        }
    }
}

for el in self.opt_term_node_uprooted.iter().copied() {
    let ts = self.defined_then_atom_node.drain_with_element_opt_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.opt_term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_opt_term_node(t.1);
t.2 = self.root_term_node(t.2);
        if self.defined_then_atom_node.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.opt_term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.defined_then_atom_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.opt_term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_opt_term_node(t.1);
t.2 = self.root_term_node(t.2);
        if self.defined_then_atom_node.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.opt_term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.then_atom_node_uprooted.iter().copied() {
    let ts = self.defined_then_atom_node.drain_with_element_then_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.opt_term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(DefinedThenAtomNodeTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_opt_term_node(t.1);
t.2 = self.root_term_node(t.2);
        if self.defined_then_atom_node.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.opt_term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(DefinedThenAtomNodeTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.pred_then_atom_node.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredThenAtomNodeTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.pred_then_atom_node.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredThenAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.pred_then_atom_node.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredThenAtomNodeTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.pred_then_atom_node.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredThenAtomNodeTable::WEIGHT);

        }
    }
}
for el in self.then_atom_node_uprooted.iter().copied() {
    let ts = self.pred_then_atom_node.drain_with_element_then_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredThenAtomNodeTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_term_list_node(t.2);
        if self.pred_then_atom_node.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredThenAtomNodeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredThenAtomNodeTable::WEIGHT);

let weight2 = &mut self.term_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredThenAtomNodeTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.if_stmt_node.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfStmtNodeTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_if_atom_node(t.1);
        if self.if_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfStmtNodeTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfStmtNodeTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.if_stmt_node.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfStmtNodeTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_if_atom_node(t.1);
        if self.if_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfStmtNodeTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfStmtNodeTable::WEIGHT);

        }
    }
}

for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.then_stmt_node.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenStmtNodeTable::WEIGHT);

let weight1 = &mut self.then_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_then_atom_node(t.1);
        if self.then_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenStmtNodeTable::WEIGHT);

let weight1 = &mut self.then_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenStmtNodeTable::WEIGHT);

        }
    }
}
for el in self.then_atom_node_uprooted.iter().copied() {
    let ts = self.then_stmt_node.drain_with_element_then_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenStmtNodeTable::WEIGHT);

let weight1 = &mut self.then_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_then_atom_node(t.1);
        if self.then_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenStmtNodeTable::WEIGHT);

let weight1 = &mut self.then_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenStmtNodeTable::WEIGHT);

        }
    }
}

for el in self.stmt_block_list_node_uprooted.iter().copied() {
    let ts = self.branch_stmt_node.drain_with_element_stmt_block_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BranchStmtNodeTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BranchStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_stmt_block_list_node(t.1);
        if self.branch_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BranchStmtNodeTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BranchStmtNodeTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.branch_stmt_node.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BranchStmtNodeTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BranchStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_stmt_block_list_node(t.1);
        if self.branch_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BranchStmtNodeTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BranchStmtNodeTable::WEIGHT);

        }
    }
}

for el in self.match_case_list_node_uprooted.iter().copied() {
    let ts = self.match_stmt_node.drain_with_element_match_case_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_match_case_list_node(t.2);
        if self.match_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtNodeTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.match_stmt_node.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_match_case_list_node(t.2);
        if self.match_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtNodeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.match_stmt_node.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtNodeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_term_node(t.1);
t.2 = self.root_match_case_list_node(t.2);
        if self.match_stmt_node.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtNodeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtNodeTable::WEIGHT);

let weight2 = &mut self.match_case_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtNodeTable::WEIGHT);

        }
    }
}

for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.nil_stmt_list_node.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilStmtListNodeTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
        if self.nil_stmt_list_node.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilStmtListNodeTable::WEIGHT);

        }
    }
}

for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.cons_stmt_list_node.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsStmtListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsStmtListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsStmtListNodeTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
t.1 = self.root_stmt_node(t.1);
t.2 = self.root_stmt_list_node(t.2);
        if self.cons_stmt_list_node.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsStmtListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsStmtListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsStmtListNodeTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.cons_stmt_list_node.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsStmtListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsStmtListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsStmtListNodeTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
t.1 = self.root_stmt_node(t.1);
t.2 = self.root_stmt_list_node(t.2);
        if self.cons_stmt_list_node.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsStmtListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsStmtListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsStmtListNodeTable::WEIGHT);

        }
    }
}

for el in self.stmt_block_list_node_uprooted.iter().copied() {
    let ts = self.nil_stmt_block_list_node.drain_with_element_stmt_block_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilStmtBlockListNodeTable::WEIGHT);

        t.0 = self.root_stmt_block_list_node(t.0);
        if self.nil_stmt_block_list_node.insert(t) {
            let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilStmtBlockListNodeTable::WEIGHT);

        }
    }
}

for el in self.stmt_block_list_node_uprooted.iter().copied() {
    let ts = self.cons_stmt_block_list_node.drain_with_element_stmt_block_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_block_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

        t.0 = self.root_stmt_block_list_node(t.0);
t.1 = self.root_stmt_list_node(t.1);
t.2 = self.root_stmt_block_list_node(t.2);
        if self.cons_stmt_block_list_node.insert(t) {
            let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_block_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

        }
    }
}
for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.cons_stmt_block_list_node.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_block_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsStmtBlockListNodeTable::WEIGHT);

        t.0 = self.root_stmt_block_list_node(t.0);
t.1 = self.root_stmt_list_node(t.1);
t.2 = self.root_stmt_block_list_node(t.2);
        if self.cons_stmt_block_list_node.insert(t) {
            let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

let weight2 = &mut self.stmt_block_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsStmtBlockListNodeTable::WEIGHT);

        }
    }
}

for el in self.rule_decl_node_uprooted.iter().copied() {
    let ts = self.rule_decl.drain_with_element_rule_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDeclTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDeclTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_stmt_list_node(t.1);
        if self.rule_decl.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDeclTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDeclTable::WEIGHT);

        }
    }
}
for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.rule_decl.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDeclTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDeclTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_stmt_list_node(t.1);
        if self.rule_decl.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDeclTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDeclTable::WEIGHT);

        }
    }
}

for el in self.decl_list_node_uprooted.iter().copied() {
    let ts = self.model_decl.drain_with_element_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModelDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModelDeclTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ModelDeclTable::WEIGHT);

        t.0 = self.root_model_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_decl_list_node(t.2);
        if self.model_decl.insert(t) {
            let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModelDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModelDeclTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ModelDeclTable::WEIGHT);

        }
    }
}
for el in self.ident_uprooted.iter().copied() {
    let ts = self.model_decl.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModelDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModelDeclTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ModelDeclTable::WEIGHT);

        t.0 = self.root_model_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_decl_list_node(t.2);
        if self.model_decl.insert(t) {
            let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModelDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModelDeclTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ModelDeclTable::WEIGHT);

        }
    }
}
for el in self.model_decl_node_uprooted.iter().copied() {
    let ts = self.model_decl.drain_with_element_model_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModelDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModelDeclTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ModelDeclTable::WEIGHT);

        t.0 = self.root_model_decl_node(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_decl_list_node(t.2);
        if self.model_decl.insert(t) {
            let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModelDeclTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModelDeclTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ModelDeclTable::WEIGHT);

        }
    }
}

for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_type.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeTypeTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_type_decl_node(t.1);
        if self.decl_node_type.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeTypeTable::WEIGHT);

        }
    }
}
for el in self.type_decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_type.drain_with_element_type_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeTypeTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_type_decl_node(t.1);
        if self.decl_node_type.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeTypeTable::WEIGHT);

let weight1 = &mut self.type_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeTypeTable::WEIGHT);

        }
    }
}

for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_pred.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodePredTable::WEIGHT);

let weight1 = &mut self.pred_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodePredTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_pred_decl_node(t.1);
        if self.decl_node_pred.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodePredTable::WEIGHT);

let weight1 = &mut self.pred_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodePredTable::WEIGHT);

        }
    }
}
for el in self.pred_decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_pred.drain_with_element_pred_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodePredTable::WEIGHT);

let weight1 = &mut self.pred_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodePredTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_pred_decl_node(t.1);
        if self.decl_node_pred.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodePredTable::WEIGHT);

let weight1 = &mut self.pred_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodePredTable::WEIGHT);

        }
    }
}

for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_func.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeFuncTable::WEIGHT);

let weight1 = &mut self.func_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeFuncTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_func_decl_node(t.1);
        if self.decl_node_func.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeFuncTable::WEIGHT);

let weight1 = &mut self.func_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeFuncTable::WEIGHT);

        }
    }
}
for el in self.func_decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_func.drain_with_element_func_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeFuncTable::WEIGHT);

let weight1 = &mut self.func_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeFuncTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_func_decl_node(t.1);
        if self.decl_node_func.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeFuncTable::WEIGHT);

let weight1 = &mut self.func_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeFuncTable::WEIGHT);

        }
    }
}

for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_rule.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeRuleTable::WEIGHT);

let weight1 = &mut self.rule_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeRuleTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_rule_decl_node(t.1);
        if self.decl_node_rule.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeRuleTable::WEIGHT);

let weight1 = &mut self.rule_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeRuleTable::WEIGHT);

        }
    }
}
for el in self.rule_decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_rule.drain_with_element_rule_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeRuleTable::WEIGHT);

let weight1 = &mut self.rule_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeRuleTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_rule_decl_node(t.1);
        if self.decl_node_rule.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeRuleTable::WEIGHT);

let weight1 = &mut self.rule_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeRuleTable::WEIGHT);

        }
    }
}

for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_enum.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeEnumTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.decl_node_enum.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeEnumTable::WEIGHT);

        }
    }
}
for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_enum.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeEnumTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.decl_node_enum.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeEnumTable::WEIGHT);

        }
    }
}

for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_model.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeModelTable::WEIGHT);

let weight1 = &mut self.model_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeModelTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_model_decl_node(t.1);
        if self.decl_node_model.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeModelTable::WEIGHT);

let weight1 = &mut self.model_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeModelTable::WEIGHT);

        }
    }
}
for el in self.model_decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_model.drain_with_element_model_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeModelTable::WEIGHT);

let weight1 = &mut self.model_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeModelTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_model_decl_node(t.1);
        if self.decl_node_model.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeModelTable::WEIGHT);

let weight1 = &mut self.model_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeModelTable::WEIGHT);

        }
    }
}

for el in self.decl_list_node_uprooted.iter().copied() {
    let ts = self.nil_decl_list_node.drain_with_element_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilDeclListNodeTable::WEIGHT);

        t.0 = self.root_decl_list_node(t.0);
        if self.nil_decl_list_node.insert(t) {
            let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilDeclListNodeTable::WEIGHT);

        }
    }
}

for el in self.decl_list_node_uprooted.iter().copied() {
    let ts = self.cons_decl_list_node.drain_with_element_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsDeclListNodeTable::WEIGHT);

let weight1 = &mut self.decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsDeclListNodeTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsDeclListNodeTable::WEIGHT);

        t.0 = self.root_decl_list_node(t.0);
t.1 = self.root_decl_node(t.1);
t.2 = self.root_decl_list_node(t.2);
        if self.cons_decl_list_node.insert(t) {
            let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsDeclListNodeTable::WEIGHT);

let weight1 = &mut self.decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsDeclListNodeTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsDeclListNodeTable::WEIGHT);

        }
    }
}
for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.cons_decl_list_node.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsDeclListNodeTable::WEIGHT);

let weight1 = &mut self.decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsDeclListNodeTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsDeclListNodeTable::WEIGHT);

        t.0 = self.root_decl_list_node(t.0);
t.1 = self.root_decl_node(t.1);
t.2 = self.root_decl_list_node(t.2);
        if self.cons_decl_list_node.insert(t) {
            let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsDeclListNodeTable::WEIGHT);

let weight1 = &mut self.decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsDeclListNodeTable::WEIGHT);

let weight2 = &mut self.decl_list_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsDeclListNodeTable::WEIGHT);

        }
    }
}

for el in self.decl_list_node_uprooted.iter().copied() {
    let ts = self.decls_module_node.drain_with_element_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclsModuleNodeTable::WEIGHT);

let weight1 = &mut self.decl_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclsModuleNodeTable::WEIGHT);

        t.0 = self.root_module_node(t.0);
t.1 = self.root_decl_list_node(t.1);
        if self.decls_module_node.insert(t) {
            let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclsModuleNodeTable::WEIGHT);

let weight1 = &mut self.decl_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclsModuleNodeTable::WEIGHT);

        }
    }
}
for el in self.module_node_uprooted.iter().copied() {
    let ts = self.decls_module_node.drain_with_element_module_node(el);
    for mut t in ts {
        let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclsModuleNodeTable::WEIGHT);

let weight1 = &mut self.decl_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclsModuleNodeTable::WEIGHT);

        t.0 = self.root_module_node(t.0);
t.1 = self.root_decl_list_node(t.1);
        if self.decls_module_node.insert(t) {
            let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclsModuleNodeTable::WEIGHT);

let weight1 = &mut self.decl_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclsModuleNodeTable::WEIGHT);

        }
    }
}

for el in self.scope_uprooted.iter().copied() {
    let ts = self.var_in_scope.drain_with_element_scope(el);
    for mut t in ts {
        let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarInScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarInScopeTable::WEIGHT);

        t.0 = self.root_virt_ident(t.0);
t.1 = self.root_scope(t.1);
        if self.var_in_scope.insert(t) {
            let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarInScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarInScopeTable::WEIGHT);

        }
    }
}
for el in self.virt_ident_uprooted.iter().copied() {
    let ts = self.var_in_scope.drain_with_element_virt_ident(el);
    for mut t in ts {
        let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarInScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarInScopeTable::WEIGHT);

        t.0 = self.root_virt_ident(t.0);
t.1 = self.root_scope(t.1);
        if self.var_in_scope.insert(t) {
            let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarInScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarInScopeTable::WEIGHT);

        }
    }
}

for el in self.scope_uprooted.iter().copied() {
    let ts = self.scope_extension.drain_with_element_scope(el);
    for mut t in ts {
        let weight0 = &mut self.scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ScopeExtensionTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ScopeExtensionTable::WEIGHT);

        t.0 = self.root_scope(t.0);
t.1 = self.root_scope(t.1);
        if self.scope_extension.insert(t) {
            let weight0 = &mut self.scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ScopeExtensionTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ScopeExtensionTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.scope_single_child.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ScopeSingleChildTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ScopeSingleChildTable::WEIGHT);

        t.0 = self.root_rule_descendant_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.scope_single_child.insert(t) {
            let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ScopeSingleChildTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ScopeSingleChildTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.scope_extension_siblings.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ScopeExtensionSiblingsTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ScopeExtensionSiblingsTable::WEIGHT);

let weight2 = &mut self.rule_descendant_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ScopeExtensionSiblingsTable::WEIGHT);

        t.0 = self.root_rule_descendant_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
t.2 = self.root_rule_descendant_node(t.2);
        if self.scope_extension_siblings.insert(t) {
            let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

let weight2 = &mut self.rule_descendant_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ScopeExtensionSiblingsTable::WEIGHT);

        }
    }
}

for el in self.type_uprooted.iter().copied() {
    let ts = self.is_normal_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IsNormalTypeTable::WEIGHT);

        t.0 = self.root_type(t.0);
        if self.is_normal_type.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IsNormalTypeTable::WEIGHT);

        }
    }
}

for el in self.type_uprooted.iter().copied() {
    let ts = self.is_enum_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IsEnumTypeTable::WEIGHT);

        t.0 = self.root_type(t.0);
        if self.is_enum_type.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IsEnumTypeTable::WEIGHT);

        }
    }
}

for el in self.type_uprooted.iter().copied() {
    let ts = self.is_model_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IsModelTypeTable::WEIGHT);

        t.0 = self.root_type(t.0);
        if self.is_model_type.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IsModelTypeTable::WEIGHT);

        }
    }
}

for el in self.type_uprooted.iter().copied() {
    let ts = self.is_mor_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IsMorTypeTable::WEIGHT);

        t.0 = self.root_type(t.0);
        if self.is_mor_type.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IsMorTypeTable::WEIGHT);

        }
    }
}

for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.illegal_member_type_expr_in_signature.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IllegalMemberTypeExprInSignatureTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
        if self.illegal_member_type_expr_in_signature.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IllegalMemberTypeExprInSignatureTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.is_total_func.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IsTotalFuncTable::WEIGHT);

        t.0 = self.root_func(t.0);
        if self.is_total_func.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IsTotalFuncTable::WEIGHT);

        }
    }
}

for el in self.el_list_uprooted.iter().copied() {
    let ts = self.rel_app.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelAppTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_el_list(t.1);
        if self.rel_app.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelAppTable::WEIGHT);

        }
    }
}
for el in self.rel_uprooted.iter().copied() {
    let ts = self.rel_app.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelAppTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_el_list(t.1);
        if self.rel_app.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelAppTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.el_type.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElTypeTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_element_type(t.1);
        if self.el_type.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElTypeTable::WEIGHT);

        }
    }
}
for el in self.element_type_uprooted.iter().copied() {
    let ts = self.el_type.drain_with_element_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElTypeTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_element_type(t.1);
        if self.el_type.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElTypeTable::WEIGHT);

        }
    }
}

for el in self.el_list_uprooted.iter().copied() {
    let ts = self.el_types.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElTypesTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElTypesTable::WEIGHT);

        t.0 = self.root_el_list(t.0);
t.1 = self.root_element_type_list(t.1);
        if self.el_types.insert(t) {
            let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElTypesTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElTypesTable::WEIGHT);

        }
    }
}
for el in self.element_type_list_uprooted.iter().copied() {
    let ts = self.el_types.drain_with_element_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElTypesTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElTypesTable::WEIGHT);

        t.0 = self.root_el_list(t.0);
t.1 = self.root_element_type_list(t.1);
        if self.el_types.insert(t) {
            let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElTypesTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElTypesTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.constrained_el.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConstrainedElTable::WEIGHT);

        t.0 = self.root_el(t.0);
        if self.constrained_el.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConstrainedElTable::WEIGHT);

        }
    }
}

for el in self.el_list_uprooted.iter().copied() {
    let ts = self.constrained_els.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConstrainedElsTable::WEIGHT);

        t.0 = self.root_el_list(t.0);
        if self.constrained_els.insert(t) {
            let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConstrainedElsTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.in_ker.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(InKerTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(InKerTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(InKerTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_el(t.1);
t.2 = self.root_el(t.2);
        if self.in_ker.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(InKerTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(InKerTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(InKerTable::WEIGHT);

        }
    }
}
for el in self.morphism_uprooted.iter().copied() {
    let ts = self.in_ker.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(InKerTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(InKerTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(InKerTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_el(t.1);
t.2 = self.root_el(t.2);
        if self.in_ker.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(InKerTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(InKerTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(InKerTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.el_in_img.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElInImgTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElInImgTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_el(t.1);
        if self.el_in_img.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElInImgTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElInImgTable::WEIGHT);

        }
    }
}
for el in self.morphism_uprooted.iter().copied() {
    let ts = self.el_in_img.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElInImgTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElInImgTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_el(t.1);
        if self.el_in_img.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElInImgTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElInImgTable::WEIGHT);

        }
    }
}

for el in self.el_list_uprooted.iter().copied() {
    let ts = self.rel_tuple_in_img.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelTupleInImgTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelTupleInImgTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(RelTupleInImgTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_rel(t.1);
t.2 = self.root_el_list(t.2);
        if self.rel_tuple_in_img.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelTupleInImgTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelTupleInImgTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(RelTupleInImgTable::WEIGHT);

        }
    }
}
for el in self.morphism_uprooted.iter().copied() {
    let ts = self.rel_tuple_in_img.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelTupleInImgTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelTupleInImgTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(RelTupleInImgTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_rel(t.1);
t.2 = self.root_el_list(t.2);
        if self.rel_tuple_in_img.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelTupleInImgTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelTupleInImgTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(RelTupleInImgTable::WEIGHT);

        }
    }
}
for el in self.rel_uprooted.iter().copied() {
    let ts = self.rel_tuple_in_img.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelTupleInImgTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelTupleInImgTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(RelTupleInImgTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_rel(t.1);
t.2 = self.root_el_list(t.2);
        if self.rel_tuple_in_img.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelTupleInImgTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelTupleInImgTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(RelTupleInImgTable::WEIGHT);

        }
    }
}

for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.symbol_scope_extension.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SymbolScopeExtensionTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SymbolScopeExtensionTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.symbol_scope_extension.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeExtensionTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeExtensionTable::WEIGHT);

        }
    }
}

for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.symbol_scope_ancestor.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SymbolScopeAncestorTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SymbolScopeAncestorTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.symbol_scope_ancestor.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeAncestorTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeAncestorTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.element_member_symbol_scope.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElementMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElementMemberSymbolScopeTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.element_member_symbol_scope.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElementMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElementMemberSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.element_member_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElementMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElementMemberSymbolScopeTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.element_member_symbol_scope.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElementMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElementMemberSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.defined_symbol.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(DefinedSymbolTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_loc(t.3);
        if self.defined_symbol.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(DefinedSymbolTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.defined_symbol.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(DefinedSymbolTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_loc(t.3);
        if self.defined_symbol.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(DefinedSymbolTable::WEIGHT);

        }
    }
}
for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.defined_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(DefinedSymbolTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_loc(t.3);
        if self.defined_symbol.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(DefinedSymbolTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.defined_symbol.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(DefinedSymbolTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_loc(t.3);
        if self.defined_symbol.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DefinedSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DefinedSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(DefinedSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(DefinedSymbolTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.accessible_symbol.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(AccessibleSymbolTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_loc(t.3);
        if self.accessible_symbol.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(AccessibleSymbolTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.accessible_symbol.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(AccessibleSymbolTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_loc(t.3);
        if self.accessible_symbol.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(AccessibleSymbolTable::WEIGHT);

        }
    }
}
for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.accessible_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(AccessibleSymbolTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_loc(t.3);
        if self.accessible_symbol.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(AccessibleSymbolTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.accessible_symbol.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(AccessibleSymbolTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_loc(t.3);
        if self.accessible_symbol.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AccessibleSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(AccessibleSymbolTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.should_be_symbol.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbolTable::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_scope(t.2);
t.3 = self.root_loc(t.3);
        if self.should_be_symbol.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbolTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.should_be_symbol.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbolTable::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_scope(t.2);
t.3 = self.root_loc(t.3);
        if self.should_be_symbol.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbolTable::WEIGHT);

        }
    }
}
for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.should_be_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbolTable::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_scope(t.2);
t.3 = self.root_loc(t.3);
        if self.should_be_symbol.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbolTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.should_be_symbol.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbolTable::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_scope(t.2);
t.3 = self.root_loc(t.3);
        if self.should_be_symbol.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight2 = &mut self.symbol_scope_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbolTable::WEIGHT);

let weight3 = &mut self.loc_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbolTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.should_be_symbol_2.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[t.4.0 as usize];
*weight4 = weight4.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_symbol_scope(t.3);
t.4 = self.root_loc(t.4);
        if self.should_be_symbol_2.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[t.4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol2Table::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.should_be_symbol_2.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[t.4.0 as usize];
*weight4 = weight4.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_symbol_scope(t.3);
t.4 = self.root_loc(t.4);
        if self.should_be_symbol_2.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[t.4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol2Table::WEIGHT);

        }
    }
}
for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.should_be_symbol_2.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[t.4.0 as usize];
*weight4 = weight4.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_symbol_scope(t.3);
t.4 = self.root_loc(t.4);
        if self.should_be_symbol_2.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[t.4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol2Table::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.should_be_symbol_2.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[t.4.0 as usize];
*weight4 = weight4.saturating_sub(ShouldBeSymbol2Table::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_symbol_scope(t.3);
t.4 = self.root_loc(t.4);
        if self.should_be_symbol_2.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight3 = &mut self.symbol_scope_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol2Table::WEIGHT);

let weight4 = &mut self.loc_weights[t.4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol2Table::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.should_be_symbol_3.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[t.4.0 as usize];
*weight4 = weight4.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[t.5.0 as usize];
*weight5 = weight5.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_symbol_kind(t.3);
t.4 = self.root_symbol_scope(t.4);
t.5 = self.root_loc(t.5);
        if self.should_be_symbol_3.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[t.4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[t.5.0 as usize];
*weight5 = weight5.saturating_add(ShouldBeSymbol3Table::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.should_be_symbol_3.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[t.4.0 as usize];
*weight4 = weight4.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[t.5.0 as usize];
*weight5 = weight5.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_symbol_kind(t.3);
t.4 = self.root_symbol_scope(t.4);
t.5 = self.root_loc(t.5);
        if self.should_be_symbol_3.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[t.4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[t.5.0 as usize];
*weight5 = weight5.saturating_add(ShouldBeSymbol3Table::WEIGHT);

        }
    }
}
for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.should_be_symbol_3.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[t.4.0 as usize];
*weight4 = weight4.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[t.5.0 as usize];
*weight5 = weight5.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_symbol_kind(t.3);
t.4 = self.root_symbol_scope(t.4);
t.5 = self.root_loc(t.5);
        if self.should_be_symbol_3.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[t.4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[t.5.0 as usize];
*weight5 = weight5.saturating_add(ShouldBeSymbol3Table::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.should_be_symbol_3.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[t.3.0 as usize];
*weight3 = weight3.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[t.4.0 as usize];
*weight4 = weight4.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[t.5.0 as usize];
*weight5 = weight5.saturating_sub(ShouldBeSymbol3Table::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_symbol_kind(t.1);
t.2 = self.root_symbol_kind(t.2);
t.3 = self.root_symbol_kind(t.3);
t.4 = self.root_symbol_scope(t.4);
t.5 = self.root_loc(t.5);
        if self.should_be_symbol_3.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight1 = &mut self.symbol_kind_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight2 = &mut self.symbol_kind_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight3 = &mut self.symbol_kind_weights[t.3.0 as usize];
*weight3 = weight3.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight4 = &mut self.symbol_scope_weights[t.4.0 as usize];
*weight4 = weight4.saturating_add(ShouldBeSymbol3Table::WEIGHT);

let weight5 = &mut self.loc_weights[t.5.0 as usize];
*weight5 = weight5.saturating_add(ShouldBeSymbol3Table::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.pred_arg_num_should_match.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

        t.0 = self.root_nat(t.0);
t.1 = self.root_nat(t.1);
t.2 = self.root_loc(t.2);
        if self.pred_arg_num_should_match.insert(t) {
            let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

        }
    }
}
for el in self.nat_uprooted.iter().copied() {
    let ts = self.pred_arg_num_should_match.drain_with_element_nat(el);
    for mut t in ts {
        let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(PredArgNumShouldMatchTable::WEIGHT);

        t.0 = self.root_nat(t.0);
t.1 = self.root_nat(t.1);
t.2 = self.root_loc(t.2);
        if self.pred_arg_num_should_match.insert(t) {
            let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(PredArgNumShouldMatchTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.func_arg_num_should_match.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

        t.0 = self.root_nat(t.0);
t.1 = self.root_nat(t.1);
t.2 = self.root_loc(t.2);
        if self.func_arg_num_should_match.insert(t) {
            let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

        }
    }
}
for el in self.nat_uprooted.iter().copied() {
    let ts = self.func_arg_num_should_match.drain_with_element_nat(el);
    for mut t in ts {
        let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncArgNumShouldMatchTable::WEIGHT);

        t.0 = self.root_nat(t.0);
t.1 = self.root_nat(t.1);
t.2 = self.root_loc(t.2);
        if self.func_arg_num_should_match.insert(t) {
            let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

let weight2 = &mut self.loc_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncArgNumShouldMatchTable::WEIGHT);

        }
    }
}

for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.cfg_edge.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_stmt_node(t.1);
        if self.cfg_edge.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeTable::WEIGHT);

        }
    }
}

for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.cfg_edge_stmts_stmt.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeStmtsStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeStmtsStmtTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
t.1 = self.root_stmt_node(t.1);
        if self.cfg_edge_stmts_stmt.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.cfg_edge_stmts_stmt.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeStmtsStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeStmtsStmtTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
t.1 = self.root_stmt_node(t.1);
        if self.cfg_edge_stmts_stmt.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeStmtsStmtTable::WEIGHT);

        }
    }
}

for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.cfg_edge_stmt_stmts.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeStmtStmtsTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeStmtStmtsTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_stmt_list_node(t.1);
        if self.cfg_edge_stmt_stmts.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.cfg_edge_stmt_stmts.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeStmtStmtsTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeStmtStmtsTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_stmt_list_node(t.1);
        if self.cfg_edge_stmt_stmts.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeStmtStmtsTable::WEIGHT);

        }
    }
}

for el in self.stmt_block_list_node_uprooted.iter().copied() {
    let ts = self.cfg_edge_fork.drain_with_element_stmt_block_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeForkTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeForkTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_stmt_block_list_node(t.1);
        if self.cfg_edge_fork.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeForkTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeForkTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.cfg_edge_fork.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeForkTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeForkTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_stmt_block_list_node(t.1);
        if self.cfg_edge_fork.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeForkTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeForkTable::WEIGHT);

        }
    }
}

for el in self.stmt_block_list_node_uprooted.iter().copied() {
    let ts = self.cfg_edge_join.drain_with_element_stmt_block_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeJoinTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeJoinTable::WEIGHT);

        t.0 = self.root_stmt_block_list_node(t.0);
t.1 = self.root_stmt_node(t.1);
        if self.cfg_edge_join.insert(t) {
            let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeJoinTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeJoinTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.cfg_edge_join.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CfgEdgeJoinTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CfgEdgeJoinTable::WEIGHT);

        t.0 = self.root_stmt_block_list_node(t.0);
t.1 = self.root_stmt_node(t.1);
        if self.cfg_edge_join.insert(t) {
            let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CfgEdgeJoinTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CfgEdgeJoinTable::WEIGHT);

        }
    }
}

for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.before_stmt_structure.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BeforeStmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BeforeStmtStructureTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
        if self.before_stmt_structure.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BeforeStmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BeforeStmtStructureTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.before_stmt_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BeforeStmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BeforeStmtStructureTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
        if self.before_stmt_structure.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BeforeStmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BeforeStmtStructureTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.stmt_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(StmtMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(StmtMorphismTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_morphism(t.1);
        if self.stmt_morphism.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(StmtMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(StmtMorphismTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.stmt_morphism.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(StmtMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(StmtMorphismTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_morphism(t.1);
        if self.stmt_morphism.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(StmtMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(StmtMorphismTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.if_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfMorphismTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
        if self.if_morphism.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfMorphismTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.surj_then_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SurjThenMorphismTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
        if self.surj_then_morphism.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SurjThenMorphismTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.non_surj_then_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NonSurjThenMorphismTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
        if self.non_surj_then_morphism.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NonSurjThenMorphismTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.noop_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NoopMorphismTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
        if self.noop_morphism.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NoopMorphismTable::WEIGHT);

        }
    }
}

for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.stmt_structure.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(StmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(StmtStructureTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
        if self.stmt_structure.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(StmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(StmtStructureTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.stmt_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(StmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(StmtStructureTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
        if self.stmt_structure.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(StmtStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(StmtStructureTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.if_atom_structure.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfAtomStructureTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_structure(t.1);
        if self.if_atom_structure.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomStructureTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.if_atom_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfAtomStructureTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_structure(t.1);
        if self.if_atom_structure.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomStructureTable::WEIGHT);

        }
    }
}

for el in self.structure_uprooted.iter().copied() {
    let ts = self.then_atom_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenAtomStructureTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_structure(t.1);
        if self.then_atom_structure.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomStructureTable::WEIGHT);

        }
    }
}
for el in self.then_atom_node_uprooted.iter().copied() {
    let ts = self.then_atom_structure.drain_with_element_then_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenAtomStructureTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_structure(t.1);
        if self.then_atom_structure.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomStructureTable::WEIGHT);

        }
    }
}

for el in self.structure_uprooted.iter().copied() {
    let ts = self.term_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermStructureTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_structure(t.1);
        if self.term_structure.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermStructureTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.term_structure.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermStructureTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_structure(t.1);
        if self.term_structure.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermStructureTable::WEIGHT);

        }
    }
}

for el in self.structure_uprooted.iter().copied() {
    let ts = self.terms_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermsStructureTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_structure(t.1);
        if self.terms_structure.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermsStructureTable::WEIGHT);

        }
    }
}
for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.terms_structure.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermsStructureTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_structure(t.1);
        if self.terms_structure.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermsStructureTable::WEIGHT);

        }
    }
}

for el in self.opt_term_node_uprooted.iter().copied() {
    let ts = self.opt_term_structure.drain_with_element_opt_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(OptTermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(OptTermStructureTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
t.1 = self.root_structure(t.1);
        if self.opt_term_structure.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(OptTermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(OptTermStructureTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.opt_term_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(OptTermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(OptTermStructureTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
t.1 = self.root_structure(t.1);
        if self.opt_term_structure.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(OptTermStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(OptTermStructureTable::WEIGHT);

        }
    }
}

for el in self.structure_uprooted.iter().copied() {
    let ts = self.type_expr_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeExprStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeExprStructureTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_structure(t.1);
        if self.type_expr_structure.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeExprStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeExprStructureTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.type_expr_structure.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeExprStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeExprStructureTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_structure(t.1);
        if self.type_expr_structure.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeExprStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeExprStructureTable::WEIGHT);

        }
    }
}

for el in self.term_node_uprooted.iter().copied() {
    let ts = self.term_should_be_epic_ok.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermShouldBeEpicOkTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
        if self.term_should_be_epic_ok.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermShouldBeEpicOkTable::WEIGHT);

        }
    }
}

for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.terms_should_be_epic_ok.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermsShouldBeEpicOkTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
        if self.terms_should_be_epic_ok.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermsShouldBeEpicOkTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.el_should_be_surjective_ok.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElShouldBeSurjectiveOkTable::WEIGHT);

        t.0 = self.root_el(t.0);
        if self.el_should_be_surjective_ok.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElShouldBeSurjectiveOkTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.el_is_surjective_ok.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElIsSurjectiveOkTable::WEIGHT);

        t.0 = self.root_el(t.0);
        if self.el_is_surjective_ok.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElIsSurjectiveOkTable::WEIGHT);

        }
    }
}

for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.should_be_obtained_by_ctor.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeObtainedByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeObtainedByCtorTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.should_be_obtained_by_ctor.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.should_be_obtained_by_ctor.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ShouldBeObtainedByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ShouldBeObtainedByCtorTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.should_be_obtained_by_ctor.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ShouldBeObtainedByCtorTable::WEIGHT);

        }
    }
}

for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.is_given_by_ctor.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IsGivenByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IsGivenByCtorTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.is_given_by_ctor.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IsGivenByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IsGivenByCtorTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.is_given_by_ctor.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IsGivenByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IsGivenByCtorTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.is_given_by_ctor.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IsGivenByCtorTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IsGivenByCtorTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.function_can_be_made_defined.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FunctionCanBeMadeDefinedTable::WEIGHT);

        t.0 = self.root_func(t.0);
        if self.function_can_be_made_defined.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FunctionCanBeMadeDefinedTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.case_pattern_is_variable.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.loc_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CasePatternIsVariableTable::WEIGHT);

        t.0 = self.root_loc(t.0);
        if self.case_pattern_is_variable.insert(t) {
            let weight0 = &mut self.loc_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CasePatternIsVariableTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.case_pattern_is_wildcard.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.loc_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CasePatternIsWildcardTable::WEIGHT);

        t.0 = self.root_loc(t.0);
        if self.case_pattern_is_wildcard.insert(t) {
            let weight0 = &mut self.loc_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CasePatternIsWildcardTable::WEIGHT);

        }
    }
}

for el in self.term_node_uprooted.iter().copied() {
    let ts = self.is_pattern_ctor_arg.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IsPatternCtorArgTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
        if self.is_pattern_ctor_arg.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IsPatternCtorArgTable::WEIGHT);

        }
    }
}

for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.are_pattern_ctor_args.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArePatternCtorArgsTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
        if self.are_pattern_ctor_args.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArePatternCtorArgsTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.pattern_ctor_arg_is_app.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.loc_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PatternCtorArgIsAppTable::WEIGHT);

        t.0 = self.root_loc(t.0);
        if self.pattern_ctor_arg_is_app.insert(t) {
            let weight0 = &mut self.loc_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PatternCtorArgIsAppTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.pattern_ctor_arg_var_is_not_fresh.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.loc_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PatternCtorArgVarIsNotFreshTable::WEIGHT);

        t.0 = self.root_loc(t.0);
        if self.pattern_ctor_arg_var_is_not_fresh.insert(t) {
            let weight0 = &mut self.loc_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PatternCtorArgVarIsNotFreshTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.cases_contain_ctor.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CasesContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CasesContainCtorTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
        if self.cases_contain_ctor.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CasesContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CasesContainCtorTable::WEIGHT);

        }
    }
}
for el in self.match_case_list_node_uprooted.iter().copied() {
    let ts = self.cases_contain_ctor.drain_with_element_match_case_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CasesContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CasesContainCtorTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
        if self.cases_contain_ctor.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CasesContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CasesContainCtorTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.match_stmt_contains_ctor_of_enum.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight2 = &mut self.enum_decl_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
t.2 = self.root_enum_decl_node(t.2);
        if self.match_stmt_contains_ctor_of_enum.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight2 = &mut self.enum_decl_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

        }
    }
}
for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.match_stmt_contains_ctor_of_enum.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight2 = &mut self.enum_decl_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
t.2 = self.root_enum_decl_node(t.2);
        if self.match_stmt_contains_ctor_of_enum.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight2 = &mut self.enum_decl_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.match_stmt_contains_ctor_of_enum.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight2 = &mut self.enum_decl_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtContainsCtorOfEnumTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
t.2 = self.root_enum_decl_node(t.2);
        if self.match_stmt_contains_ctor_of_enum.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

let weight2 = &mut self.enum_decl_node_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtContainsCtorOfEnumTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.match_stmt_should_contain_ctor.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtShouldContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtShouldContainCtorTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
        if self.match_stmt_should_contain_ctor.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.match_stmt_should_contain_ctor.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtShouldContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtShouldContainCtorTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
        if self.match_stmt_should_contain_ctor.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtShouldContainCtorTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.match_stmt_contains_ctor.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtContainsCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtContainsCtorTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
        if self.match_stmt_contains_ctor.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.match_stmt_contains_ctor.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtContainsCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtContainsCtorTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
        if self.match_stmt_contains_ctor.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtContainsCtorTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.real_virt_ident.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RealVirtIdentTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RealVirtIdentTable::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_virt_ident(t.1);
        if self.real_virt_ident.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RealVirtIdentTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RealVirtIdentTable::WEIGHT);

        }
    }
}
for el in self.virt_ident_uprooted.iter().copied() {
    let ts = self.real_virt_ident.drain_with_element_virt_ident(el);
    for mut t in ts {
        let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RealVirtIdentTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RealVirtIdentTable::WEIGHT);

        t.0 = self.root_ident(t.0);
t.1 = self.root_virt_ident(t.1);
        if self.real_virt_ident.insert(t) {
            let weight0 = &mut self.ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RealVirtIdentTable::WEIGHT);

let weight1 = &mut self.virt_ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RealVirtIdentTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.virt_real_ident.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VirtRealIdentTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VirtRealIdentTable::WEIGHT);

        t.0 = self.root_virt_ident(t.0);
t.1 = self.root_ident(t.1);
        if self.virt_real_ident.insert(t) {
            let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VirtRealIdentTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VirtRealIdentTable::WEIGHT);

        }
    }
}
for el in self.virt_ident_uprooted.iter().copied() {
    let ts = self.virt_real_ident.drain_with_element_virt_ident(el);
    for mut t in ts {
        let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VirtRealIdentTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VirtRealIdentTable::WEIGHT);

        t.0 = self.root_virt_ident(t.0);
t.1 = self.root_ident(t.1);
        if self.virt_real_ident.insert(t) {
            let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VirtRealIdentTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VirtRealIdentTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.var.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(VarTable::WEIGHT);

        t.0 = self.root_structure(t.0);
t.1 = self.root_el_name(t.1);
t.2 = self.root_el(t.2);
        if self.var.insert(t) {
            let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(VarTable::WEIGHT);

        }
    }
}
for el in self.el_name_uprooted.iter().copied() {
    let ts = self.var.drain_with_element_el_name(el);
    for mut t in ts {
        let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(VarTable::WEIGHT);

        t.0 = self.root_structure(t.0);
t.1 = self.root_el_name(t.1);
t.2 = self.root_el(t.2);
        if self.var.insert(t) {
            let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(VarTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.var.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VarTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(VarTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(VarTable::WEIGHT);

        t.0 = self.root_structure(t.0);
t.1 = self.root_el_name(t.1);
t.2 = self.root_el(t.2);
        if self.var.insert(t) {
            let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VarTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(VarTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(VarTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.rule_name.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleNameTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_ident(t.1);
        if self.rule_name.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleNameTable::WEIGHT);

        }
    }
}
for el in self.rule_decl_node_uprooted.iter().copied() {
    let ts = self.rule_name.drain_with_element_rule_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleNameTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_ident(t.1);
        if self.rule_name.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleNameTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.module_name.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModuleNameTable::WEIGHT);

        t.0 = self.root_module_node(t.0);
t.1 = self.root_ident(t.1);
        if self.module_name.insert(t) {
            let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModuleNameTable::WEIGHT);

        }
    }
}
for el in self.module_node_uprooted.iter().copied() {
    let ts = self.module_name.drain_with_element_module_node(el);
    for mut t in ts {
        let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModuleNameTable::WEIGHT);

        t.0 = self.root_module_node(t.0);
t.1 = self.root_ident(t.1);
        if self.module_name.insert(t) {
            let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModuleNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModuleNameTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.type_decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.type_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeDeclNodeLocTable::WEIGHT);

        t.0 = self.root_type_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.type_decl_node_loc.insert(t) {
            let weight0 = &mut self.type_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeDeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.type_decl_node_uprooted.iter().copied() {
    let ts = self.type_decl_node_loc.drain_with_element_type_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeDeclNodeLocTable::WEIGHT);

        t.0 = self.root_type_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.type_decl_node_loc.insert(t) {
            let weight0 = &mut self.type_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeDeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_node_uprooted.iter().copied() {
    let ts = self.arg_decl_node_loc.drain_with_element_arg_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgDeclNodeLocTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.arg_decl_node_loc.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.arg_decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgDeclNodeLocTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.arg_decl_node_loc.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_list_node_uprooted.iter().copied() {
    let ts = self.arg_decl_list_node_loc.drain_with_element_arg_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgDeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgDeclListNodeLocTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
t.1 = self.root_loc(t.1);
        if self.arg_decl_list_node_loc.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.arg_decl_list_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgDeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgDeclListNodeLocTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
t.1 = self.root_loc(t.1);
        if self.arg_decl_list_node_loc.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgDeclListNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.pred_decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredDeclNodeLocTable::WEIGHT);

        t.0 = self.root_pred_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.pred_decl_node_loc.insert(t) {
            let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredDeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.pred_decl_node_uprooted.iter().copied() {
    let ts = self.pred_decl_node_loc.drain_with_element_pred_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredDeclNodeLocTable::WEIGHT);

        t.0 = self.root_pred_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.pred_decl_node_loc.insert(t) {
            let weight0 = &mut self.pred_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredDeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.func_decl_node_uprooted.iter().copied() {
    let ts = self.func_decl_node_loc.drain_with_element_func_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncDeclNodeLocTable::WEIGHT);

        t.0 = self.root_func_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.func_decl_node_loc.insert(t) {
            let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncDeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.func_decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncDeclNodeLocTable::WEIGHT);

        t.0 = self.root_func_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.func_decl_node_loc.insert(t) {
            let weight0 = &mut self.func_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncDeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.ctor_decl_node_loc.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorDeclNodeLocTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.ctor_decl_node_loc.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorDeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.ctor_decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorDeclNodeLocTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.ctor_decl_node_loc.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorDeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.enum_decl_node_loc.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EnumDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EnumDeclNodeLocTable::WEIGHT);

        t.0 = self.root_enum_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.enum_decl_node_loc.insert(t) {
            let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EnumDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EnumDeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.enum_decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EnumDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EnumDeclNodeLocTable::WEIGHT);

        t.0 = self.root_enum_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.enum_decl_node_loc.insert(t) {
            let weight0 = &mut self.enum_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EnumDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EnumDeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.model_decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModelDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModelDeclNodeLocTable::WEIGHT);

        t.0 = self.root_model_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.model_decl_node_loc.insert(t) {
            let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModelDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModelDeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.model_decl_node_uprooted.iter().copied() {
    let ts = self.model_decl_node_loc.drain_with_element_model_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModelDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModelDeclNodeLocTable::WEIGHT);

        t.0 = self.root_model_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.model_decl_node_loc.insert(t) {
            let weight0 = &mut self.model_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModelDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModelDeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.term_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermNodeLocTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_loc(t.1);
        if self.term_node_loc.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermNodeLocTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.term_node_loc.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermNodeLocTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_loc(t.1);
        if self.term_node_loc.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.term_list_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermListNodeLocTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_loc(t.1);
        if self.term_list_node_loc.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermListNodeLocTable::WEIGHT);

        }
    }
}
for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.term_list_node_loc.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermListNodeLocTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_loc(t.1);
        if self.term_list_node_loc.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermListNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.match_case_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchCaseNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchCaseNodeLocTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_loc(t.1);
        if self.match_case_node_loc.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchCaseNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchCaseNodeLocTable::WEIGHT);

        }
    }
}
for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.match_case_node_loc.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchCaseNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchCaseNodeLocTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_loc(t.1);
        if self.match_case_node_loc.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchCaseNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchCaseNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.opt_term_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(OptTermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(OptTermNodeLocTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
t.1 = self.root_loc(t.1);
        if self.opt_term_node_loc.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(OptTermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(OptTermNodeLocTable::WEIGHT);

        }
    }
}
for el in self.opt_term_node_uprooted.iter().copied() {
    let ts = self.opt_term_node_loc.drain_with_element_opt_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(OptTermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(OptTermNodeLocTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
t.1 = self.root_loc(t.1);
        if self.opt_term_node_loc.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(OptTermNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(OptTermNodeLocTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.if_atom_node_loc.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfAtomNodeLocTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_loc(t.1);
        if self.if_atom_node_loc.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomNodeLocTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.if_atom_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfAtomNodeLocTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_loc(t.1);
        if self.if_atom_node_loc.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.then_atom_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenAtomNodeLocTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_loc(t.1);
        if self.then_atom_node_loc.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomNodeLocTable::WEIGHT);

        }
    }
}
for el in self.then_atom_node_uprooted.iter().copied() {
    let ts = self.then_atom_node_loc.drain_with_element_then_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenAtomNodeLocTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_loc(t.1);
        if self.then_atom_node_loc.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.stmt_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(StmtNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(StmtNodeLocTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_loc(t.1);
        if self.stmt_node_loc.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(StmtNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(StmtNodeLocTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.stmt_node_loc.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(StmtNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(StmtNodeLocTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_loc(t.1);
        if self.stmt_node_loc.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(StmtNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(StmtNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.stmt_list_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(StmtListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(StmtListNodeLocTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
t.1 = self.root_loc(t.1);
        if self.stmt_list_node_loc.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(StmtListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(StmtListNodeLocTable::WEIGHT);

        }
    }
}
for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.stmt_list_node_loc.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(StmtListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(StmtListNodeLocTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
t.1 = self.root_loc(t.1);
        if self.stmt_list_node_loc.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(StmtListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(StmtListNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.rule_decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDeclNodeLocTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.rule_decl_node_loc.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.rule_decl_node_uprooted.iter().copied() {
    let ts = self.rule_decl_node_loc.drain_with_element_rule_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDeclNodeLocTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.rule_decl_node_loc.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.decl_node_loc.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeLocTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.decl_node_loc.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeLocTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.decl_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclNodeLocTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_loc(t.1);
        if self.decl_node_loc.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclNodeLocTable::WEIGHT);

        }
    }
}

for el in self.decl_list_node_uprooted.iter().copied() {
    let ts = self.decl_list_node_loc.drain_with_element_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclListNodeLocTable::WEIGHT);

        t.0 = self.root_decl_list_node(t.0);
t.1 = self.root_loc(t.1);
        if self.decl_list_node_loc.insert(t) {
            let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclListNodeLocTable::WEIGHT);

        }
    }
}
for el in self.loc_uprooted.iter().copied() {
    let ts = self.decl_list_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclListNodeLocTable::WEIGHT);

        t.0 = self.root_decl_list_node(t.0);
t.1 = self.root_loc(t.1);
        if self.decl_list_node_loc.insert(t) {
            let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclListNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclListNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.module_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModuleNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModuleNodeLocTable::WEIGHT);

        t.0 = self.root_module_node(t.0);
t.1 = self.root_loc(t.1);
        if self.module_node_loc.insert(t) {
            let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModuleNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModuleNodeLocTable::WEIGHT);

        }
    }
}
for el in self.module_node_uprooted.iter().copied() {
    let ts = self.module_node_loc.drain_with_element_module_node(el);
    for mut t in ts {
        let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModuleNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModuleNodeLocTable::WEIGHT);

        t.0 = self.root_module_node(t.0);
t.1 = self.root_loc(t.1);
        if self.module_node_loc.insert(t) {
            let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModuleNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModuleNodeLocTable::WEIGHT);

        }
    }
}

for el in self.loc_uprooted.iter().copied() {
    let ts = self.type_expr_node_loc.drain_with_element_loc(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeExprNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeExprNodeLocTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_loc(t.1);
        if self.type_expr_node_loc.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeExprNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeExprNodeLocTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.type_expr_node_loc.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeExprNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeExprNodeLocTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_loc(t.1);
        if self.type_expr_node_loc.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeExprNodeLocTable::WEIGHT);

let weight1 = &mut self.loc_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeExprNodeLocTable::WEIGHT);

        }
    }
}

for el in self.rule_decl_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_rule.drain_with_element_rule_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantRuleTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantRuleTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_rule.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantRuleTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantRuleTable::WEIGHT);

        }
    }
}
for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_rule.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantRuleTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantRuleTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_rule.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantRuleTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantRuleTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_term.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantTermTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_term.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTermTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_term.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantTermTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_term.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTermTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_term_list.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantTermListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantTermListTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_term_list.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTermListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTermListTable::WEIGHT);

        }
    }
}
for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_term_list.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantTermListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantTermListTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_term_list.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTermListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTermListTable::WEIGHT);

        }
    }
}

for el in self.opt_term_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_opt_term.drain_with_element_opt_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantOptTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantOptTermTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_opt_term.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantOptTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantOptTermTable::WEIGHT);

        }
    }
}
for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_opt_term.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantOptTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantOptTermTable::WEIGHT);

        t.0 = self.root_opt_term_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_opt_term.insert(t) {
            let weight0 = &mut self.opt_term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantOptTermTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantOptTermTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_if_atom.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantIfAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantIfAtomTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_if_atom.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

        }
    }
}
for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_if_atom.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantIfAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantIfAtomTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_if_atom.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantIfAtomTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_then_atom.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantThenAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantThenAtomTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_then_atom.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

        }
    }
}
for el in self.then_atom_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_then_atom.drain_with_element_then_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantThenAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantThenAtomTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_then_atom.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantThenAtomTable::WEIGHT);

        }
    }
}

for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_match_case.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantMatchCaseTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantMatchCaseTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_match_case.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

        }
    }
}
for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_match_case.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantMatchCaseTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantMatchCaseTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_match_case.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantMatchCaseTable::WEIGHT);

        }
    }
}

for el in self.match_case_list_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_match_case_list.drain_with_element_match_case_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantMatchCaseListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantMatchCaseListTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_match_case_list.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

        }
    }
}
for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_match_case_list.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantMatchCaseListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantMatchCaseListTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_match_case_list.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantMatchCaseListTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_stmt.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantStmtTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantStmtTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_stmt.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_stmt.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantStmtTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantStmtTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_stmt.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_stmt_list.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantStmtListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantStmtListTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_stmt_list.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtListTable::WEIGHT);

        }
    }
}
for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_stmt_list.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantStmtListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantStmtListTable::WEIGHT);

        t.0 = self.root_stmt_list_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_stmt_list.insert(t) {
            let weight0 = &mut self.stmt_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtListTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_stmt_block_list.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantStmtBlockListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantStmtBlockListTable::WEIGHT);

        t.0 = self.root_stmt_block_list_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_stmt_block_list.insert(t) {
            let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

        }
    }
}
for el in self.stmt_block_list_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_stmt_block_list.drain_with_element_stmt_block_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantStmtBlockListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantStmtBlockListTable::WEIGHT);

        t.0 = self.root_stmt_block_list_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_stmt_block_list.insert(t) {
            let weight0 = &mut self.stmt_block_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantStmtBlockListTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_type_expr.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantTypeExprTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTypeExprTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTypeExprTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.rule_descendant_type_expr.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleDescendantTypeExprTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RuleDescendantTypeExprTable::WEIGHT);

        t.0 = self.root_type_expr_node(t.0);
t.1 = self.root_rule_descendant_node(t.1);
        if self.rule_descendant_type_expr.insert(t) {
            let weight0 = &mut self.type_expr_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleDescendantTypeExprTable::WEIGHT);

let weight1 = &mut self.rule_descendant_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RuleDescendantTypeExprTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.entry_scope.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EntryScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EntryScopeTable::WEIGHT);

        t.0 = self.root_rule_descendant_node(t.0);
t.1 = self.root_scope(t.1);
        if self.entry_scope.insert(t) {
            let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EntryScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EntryScopeTable::WEIGHT);

        }
    }
}
for el in self.scope_uprooted.iter().copied() {
    let ts = self.entry_scope.drain_with_element_scope(el);
    for mut t in ts {
        let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EntryScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(EntryScopeTable::WEIGHT);

        t.0 = self.root_rule_descendant_node(t.0);
t.1 = self.root_scope(t.1);
        if self.entry_scope.insert(t) {
            let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EntryScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(EntryScopeTable::WEIGHT);

        }
    }
}

for el in self.rule_descendant_node_uprooted.iter().copied() {
    let ts = self.exit_scope.drain_with_element_rule_descendant_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ExitScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ExitScopeTable::WEIGHT);

        t.0 = self.root_rule_descendant_node(t.0);
t.1 = self.root_scope(t.1);
        if self.exit_scope.insert(t) {
            let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ExitScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ExitScopeTable::WEIGHT);

        }
    }
}
for el in self.scope_uprooted.iter().copied() {
    let ts = self.exit_scope.drain_with_element_scope(el);
    for mut t in ts {
        let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ExitScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ExitScopeTable::WEIGHT);

        t.0 = self.root_rule_descendant_node(t.0);
t.1 = self.root_scope(t.1);
        if self.exit_scope.insert(t) {
            let weight0 = &mut self.rule_descendant_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ExitScopeTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ExitScopeTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.ctor_enum.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorEnumTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.ctor_enum.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorEnumTable::WEIGHT);

        }
    }
}
for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.ctor_enum.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorEnumTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.ctor_enum.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorEnumTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_list_node_uprooted.iter().copied() {
    let ts = self.ctors_enum.drain_with_element_ctor_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorsEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorsEnumTable::WEIGHT);

        t.0 = self.root_ctor_decl_list_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.ctors_enum.insert(t) {
            let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorsEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorsEnumTable::WEIGHT);

        }
    }
}
for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.ctors_enum.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorsEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorsEnumTable::WEIGHT);

        t.0 = self.root_ctor_decl_list_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.ctors_enum.insert(t) {
            let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorsEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorsEnumTable::WEIGHT);

        }
    }
}

for el in self.match_case_list_node_uprooted.iter().copied() {
    let ts = self.cases_discriminee.drain_with_element_match_case_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CasesDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CasesDiscrimineeTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_term_node(t.1);
        if self.cases_discriminee.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CasesDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CasesDiscrimineeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.cases_discriminee.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CasesDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CasesDiscrimineeTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_term_node(t.1);
        if self.cases_discriminee.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CasesDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CasesDiscrimineeTable::WEIGHT);

        }
    }
}

for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.case_discriminee.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CaseDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CaseDiscrimineeTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_term_node(t.1);
        if self.case_discriminee.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CaseDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CaseDiscrimineeTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.case_discriminee.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CaseDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CaseDiscrimineeTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_term_node(t.1);
        if self.case_discriminee.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CaseDiscrimineeTable::WEIGHT);

let weight1 = &mut self.term_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CaseDiscrimineeTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.desugared_case_equality_atom.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DesugaredCaseEqualityAtomTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DesugaredCaseEqualityAtomTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_if_atom_node(t.1);
        if self.desugared_case_equality_atom.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

        }
    }
}
for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.desugared_case_equality_atom.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DesugaredCaseEqualityAtomTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DesugaredCaseEqualityAtomTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_if_atom_node(t.1);
        if self.desugared_case_equality_atom.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

let weight1 = &mut self.if_atom_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseEqualityAtomTable::WEIGHT);

        }
    }
}

for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.desugared_case_equality_stmt.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DesugaredCaseEqualityStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DesugaredCaseEqualityStmtTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_stmt_node(t.1);
        if self.desugared_case_equality_stmt.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.desugared_case_equality_stmt.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DesugaredCaseEqualityStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DesugaredCaseEqualityStmtTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_stmt_node(t.1);
        if self.desugared_case_equality_stmt.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

let weight1 = &mut self.stmt_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseEqualityStmtTable::WEIGHT);

        }
    }
}

for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.desugared_case_block.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DesugaredCaseBlockTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DesugaredCaseBlockTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_stmt_list_node(t.1);
        if self.desugared_case_block.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseBlockTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseBlockTable::WEIGHT);

        }
    }
}
for el in self.stmt_list_node_uprooted.iter().copied() {
    let ts = self.desugared_case_block.drain_with_element_stmt_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DesugaredCaseBlockTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DesugaredCaseBlockTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_stmt_list_node(t.1);
        if self.desugared_case_block.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseBlockTable::WEIGHT);

let weight1 = &mut self.stmt_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseBlockTable::WEIGHT);

        }
    }
}

for el in self.match_case_list_node_uprooted.iter().copied() {
    let ts = self.desugared_case_block_list.drain_with_element_match_case_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DesugaredCaseBlockListTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DesugaredCaseBlockListTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_stmt_block_list_node(t.1);
        if self.desugared_case_block_list.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

        }
    }
}
for el in self.stmt_block_list_node_uprooted.iter().copied() {
    let ts = self.desugared_case_block_list.drain_with_element_stmt_block_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DesugaredCaseBlockListTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DesugaredCaseBlockListTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_stmt_block_list_node(t.1);
        if self.desugared_case_block_list.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

let weight1 = &mut self.stmt_block_list_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DesugaredCaseBlockListTable::WEIGHT);

        }
    }
}

for el in self.type_list_uprooted.iter().copied() {
    let ts = self.nil_type_list.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilTypeListTable::WEIGHT);

        t.0 = self.root_type_list(t.0);
        if self.nil_type_list.insert(t) {
            let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilTypeListTable::WEIGHT);

        }
    }
}

for el in self.type_uprooted.iter().copied() {
    let ts = self.cons_type_list.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsTypeListTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsTypeListTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_type_list(t.1);
t.2 = self.root_type_list(t.2);
        if self.cons_type_list.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsTypeListTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsTypeListTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.cons_type_list.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsTypeListTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsTypeListTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_type_list(t.1);
t.2 = self.root_type_list(t.2);
        if self.cons_type_list.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsTypeListTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsTypeListTable::WEIGHT);

        }
    }
}

for el in self.type_uprooted.iter().copied() {
    let ts = self.snoc_type_list.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SnocTypeListTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SnocTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SnocTypeListTable::WEIGHT);

        t.0 = self.root_type_list(t.0);
t.1 = self.root_type(t.1);
t.2 = self.root_type_list(t.2);
        if self.snoc_type_list.insert(t) {
            let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SnocTypeListTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SnocTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SnocTypeListTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.snoc_type_list.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SnocTypeListTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SnocTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SnocTypeListTable::WEIGHT);

        t.0 = self.root_type_list(t.0);
t.1 = self.root_type(t.1);
t.2 = self.root_type_list(t.2);
        if self.snoc_type_list.insert(t) {
            let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SnocTypeListTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SnocTypeListTable::WEIGHT);

let weight2 = &mut self.type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SnocTypeListTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.semantic_type.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticTypeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticTypeTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticTypeTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_type(t.2);
        if self.semantic_type.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticTypeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticTypeTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticTypeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.semantic_type.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticTypeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticTypeTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticTypeTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_type(t.2);
        if self.semantic_type.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticTypeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticTypeTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticTypeTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.semantic_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticTypeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticTypeTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticTypeTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_type(t.2);
        if self.semantic_type.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticTypeTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticTypeTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticTypeTable::WEIGHT);

        }
    }
}

for el in self.decl_node_uprooted.iter().copied() {
    let ts = self.decl_symbol_scope.drain_with_element_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclSymbolScopeTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.decl_symbol_scope.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.decl_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclSymbolScopeTable::WEIGHT);

        t.0 = self.root_decl_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.decl_symbol_scope.insert(t) {
            let weight0 = &mut self.decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.type_uprooted.iter().copied() {
    let ts = self.mor_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MorTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MorTypeTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_type(t.1);
        if self.mor_type.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.mor_type_dom_func.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MorTypeDomFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MorTypeDomFuncTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_func(t.1);
        if self.mor_type_dom_func.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeDomFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeDomFuncTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.mor_type_dom_func.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MorTypeDomFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MorTypeDomFuncTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_func(t.1);
        if self.mor_type_dom_func.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeDomFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeDomFuncTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.mor_type_cod_func.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MorTypeCodFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MorTypeCodFuncTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_func(t.1);
        if self.mor_type_cod_func.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeCodFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeCodFuncTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.mor_type_cod_func.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MorTypeCodFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MorTypeCodFuncTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_func(t.1);
        if self.mor_type_cod_func.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MorTypeCodFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MorTypeCodFuncTable::WEIGHT);

        }
    }
}

for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.type_definition_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeDefinitionSymbolScopeTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.type_definition_symbol_scope.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeDefinitionSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.type_definition_symbol_scope.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeDefinitionSymbolScopeTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.type_definition_symbol_scope.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeDefinitionSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.func_rel.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncRelTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_rel(t.1);
        if self.func_rel.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncRelTable::WEIGHT);

        }
    }
}
for el in self.rel_uprooted.iter().copied() {
    let ts = self.func_rel.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncRelTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_rel(t.1);
        if self.func_rel.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncRelTable::WEIGHT);

        }
    }
}

for el in self.rel_uprooted.iter().copied() {
    let ts = self.rel_definition_symbol_scope.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelDefinitionSymbolScopeTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.rel_definition_symbol_scope.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelDefinitionSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.rel_definition_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelDefinitionSymbolScopeTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.rel_definition_symbol_scope.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelDefinitionSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelDefinitionSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.domain.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DomainTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_type_list(t.1);
        if self.domain.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DomainTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.domain.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DomainTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_type_list(t.1);
        if self.domain.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DomainTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.codomain.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CodomainTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CodomainTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_type(t.1);
        if self.codomain.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CodomainTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CodomainTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.codomain.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CodomainTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CodomainTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_type(t.1);
        if self.codomain.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CodomainTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CodomainTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.type_name.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeNameTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_ident(t.1);
        if self.type_name.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeNameTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.type_name.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeNameTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_ident(t.1);
        if self.type_name.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeNameTable::WEIGHT);

        }
    }
}

for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.virtual_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(VirtualSymbolScopeTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
        if self.virtual_symbol_scope.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(VirtualSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.parent_model_func.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ParentModelFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ParentModelFuncTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_func(t.1);
        if self.parent_model_func.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ParentModelFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ParentModelFuncTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.parent_model_func.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ParentModelFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ParentModelFuncTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_func(t.1);
        if self.parent_model_func.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ParentModelFuncTable::WEIGHT);

let weight1 = &mut self.func_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ParentModelFuncTable::WEIGHT);

        }
    }
}

for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.symbol_scope_model.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SymbolScopeModelTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SymbolScopeModelTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_type(t.1);
        if self.symbol_scope_model.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeModelTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeModelTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.symbol_scope_model.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SymbolScopeModelTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SymbolScopeModelTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_type(t.1);
        if self.symbol_scope_model.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeModelTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeModelTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.flat_domain.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FlatDomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FlatDomainTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_type_list(t.1);
        if self.flat_domain.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FlatDomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FlatDomainTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.flat_domain.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FlatDomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FlatDomainTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_type_list(t.1);
        if self.flat_domain.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FlatDomainTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FlatDomainTable::WEIGHT);

        }
    }
}

for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.semantic_signature_type_expr.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_type_expr_node(t.1);
t.2 = self.root_type(t.2);
        if self.semantic_signature_type_expr.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.semantic_signature_type_expr.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_type_expr_node(t.1);
t.2 = self.root_type(t.2);
        if self.semantic_signature_type_expr.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

        }
    }
}
for el in self.type_expr_node_uprooted.iter().copied() {
    let ts = self.semantic_signature_type_expr.drain_with_element_type_expr_node(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticSignatureTypeExprTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_type_expr_node(t.1);
t.2 = self.root_type(t.2);
        if self.semantic_signature_type_expr.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

let weight1 = &mut self.type_expr_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

let weight2 = &mut self.type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticSignatureTypeExprTable::WEIGHT);

        }
    }
}

for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.type_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeSymbolTable::WEIGHT);

        t.0 = self.root_symbol_kind(t.0);
        if self.type_symbol.insert(t) {
            let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeSymbolTable::WEIGHT);

        }
    }
}

for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.enum_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(EnumSymbolTable::WEIGHT);

        t.0 = self.root_symbol_kind(t.0);
        if self.enum_symbol.insert(t) {
            let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(EnumSymbolTable::WEIGHT);

        }
    }
}

for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.model_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModelSymbolTable::WEIGHT);

        t.0 = self.root_symbol_kind(t.0);
        if self.model_symbol.insert(t) {
            let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModelSymbolTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_node_uprooted.iter().copied() {
    let ts = self.semantic_arg_type.drain_with_element_arg_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticArgTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticArgTypeTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_type(t.1);
        if self.semantic_arg_type.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticArgTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticArgTypeTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.semantic_arg_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticArgTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticArgTypeTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_type(t.1);
        if self.semantic_arg_type.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticArgTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticArgTypeTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_node_uprooted.iter().copied() {
    let ts = self.arg_symbol_scope.drain_with_element_arg_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgSymbolScopeTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.arg_symbol_scope.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.arg_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgSymbolScopeTable::WEIGHT);

        t.0 = self.root_arg_decl_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.arg_symbol_scope.insert(t) {
            let weight0 = &mut self.arg_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_list_node_uprooted.iter().copied() {
    let ts = self.semantic_arg_types.drain_with_element_arg_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticArgTypesTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticArgTypesTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
t.1 = self.root_type_list(t.1);
        if self.semantic_arg_types.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticArgTypesTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticArgTypesTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.semantic_arg_types.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticArgTypesTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticArgTypesTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
t.1 = self.root_type_list(t.1);
        if self.semantic_arg_types.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticArgTypesTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticArgTypesTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.semantic_pred.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticPredTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticPredTable::WEIGHT);

let weight2 = &mut self.pred_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticPredTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_pred(t.2);
        if self.semantic_pred.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticPredTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticPredTable::WEIGHT);

let weight2 = &mut self.pred_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticPredTable::WEIGHT);

        }
    }
}
for el in self.pred_uprooted.iter().copied() {
    let ts = self.semantic_pred.drain_with_element_pred(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticPredTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticPredTable::WEIGHT);

let weight2 = &mut self.pred_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticPredTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_pred(t.2);
        if self.semantic_pred.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticPredTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticPredTable::WEIGHT);

let weight2 = &mut self.pred_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticPredTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.semantic_pred.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticPredTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticPredTable::WEIGHT);

let weight2 = &mut self.pred_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticPredTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_pred(t.2);
        if self.semantic_pred.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticPredTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticPredTable::WEIGHT);

let weight2 = &mut self.pred_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticPredTable::WEIGHT);

        }
    }
}

for el in self.pred_uprooted.iter().copied() {
    let ts = self.pred_arity.drain_with_element_pred(el);
    for mut t in ts {
        let weight0 = &mut self.pred_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredArityTable::WEIGHT);

        t.0 = self.root_pred(t.0);
t.1 = self.root_type_list(t.1);
        if self.pred_arity.insert(t) {
            let weight0 = &mut self.pred_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredArityTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.pred_arity.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.pred_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredArityTable::WEIGHT);

        t.0 = self.root_pred(t.0);
t.1 = self.root_type_list(t.1);
        if self.pred_arity.insert(t) {
            let weight0 = &mut self.pred_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredArityTable::WEIGHT);

        }
    }
}

for el in self.func_uprooted.iter().copied() {
    let ts = self.semantic_func.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticFuncTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticFuncTable::WEIGHT);

let weight2 = &mut self.func_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticFuncTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_func(t.2);
        if self.semantic_func.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticFuncTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticFuncTable::WEIGHT);

let weight2 = &mut self.func_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticFuncTable::WEIGHT);

        }
    }
}
for el in self.ident_uprooted.iter().copied() {
    let ts = self.semantic_func.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticFuncTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticFuncTable::WEIGHT);

let weight2 = &mut self.func_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticFuncTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_func(t.2);
        if self.semantic_func.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticFuncTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticFuncTable::WEIGHT);

let weight2 = &mut self.func_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticFuncTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.semantic_func.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticFuncTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticFuncTable::WEIGHT);

let weight2 = &mut self.func_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticFuncTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
t.2 = self.root_func(t.2);
        if self.semantic_func.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticFuncTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticFuncTable::WEIGHT);

let weight2 = &mut self.func_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticFuncTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.ctor_symbol_scope.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorSymbolScopeTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.ctor_symbol_scope.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.ctor_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorSymbolScopeTable::WEIGHT);

        t.0 = self.root_ctor_decl_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.ctor_symbol_scope.insert(t) {
            let weight0 = &mut self.ctor_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.pred_uprooted.iter().copied() {
    let ts = self.pred_rel.drain_with_element_pred(el);
    for mut t in ts {
        let weight0 = &mut self.pred_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredRelTable::WEIGHT);

        t.0 = self.root_pred(t.0);
t.1 = self.root_rel(t.1);
        if self.pred_rel.insert(t) {
            let weight0 = &mut self.pred_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredRelTable::WEIGHT);

        }
    }
}
for el in self.rel_uprooted.iter().copied() {
    let ts = self.pred_rel.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.pred_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(PredRelTable::WEIGHT);

        t.0 = self.root_pred(t.0);
t.1 = self.root_rel(t.1);
        if self.pred_rel.insert(t) {
            let weight0 = &mut self.pred_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredRelTable::WEIGHT);

let weight1 = &mut self.rel_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(PredRelTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.rel_name.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelNameTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_ident(t.1);
        if self.rel_name.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelNameTable::WEIGHT);

        }
    }
}
for el in self.rel_uprooted.iter().copied() {
    let ts = self.rel_name.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelNameTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_ident(t.1);
        if self.rel_name.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelNameTable::WEIGHT);

        }
    }
}

for el in self.rel_uprooted.iter().copied() {
    let ts = self.arity.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArityTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_type_list(t.1);
        if self.arity.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArityTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.arity.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArityTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_type_list(t.1);
        if self.arity.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArityTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.dom.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DomTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DomTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_structure(t.1);
        if self.dom.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DomTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DomTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.dom.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DomTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DomTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_structure(t.1);
        if self.dom.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DomTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DomTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.cod.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CodTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CodTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_structure(t.1);
        if self.cod.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CodTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CodTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.cod.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CodTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CodTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_structure(t.1);
        if self.cod.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CodTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CodTable::WEIGHT);

        }
    }
}

for el in self.rel_uprooted.iter().copied() {
    let ts = self.flat_arity.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FlatArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FlatArityTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_type_list(t.1);
        if self.flat_arity.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FlatArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FlatArityTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.flat_arity.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FlatArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FlatArityTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_type_list(t.1);
        if self.flat_arity.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FlatArityTable::WEIGHT);

let weight1 = &mut self.type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FlatArityTable::WEIGHT);

        }
    }
}

for el in self.module_node_uprooted.iter().copied() {
    let ts = self.module_symbol_scope.drain_with_element_module_node(el);
    for mut t in ts {
        let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModuleSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModuleSymbolScopeTable::WEIGHT);

        t.0 = self.root_module_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.module_symbol_scope.insert(t) {
            let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModuleSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModuleSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.module_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModuleSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModuleSymbolScopeTable::WEIGHT);

        t.0 = self.root_module_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.module_symbol_scope.insert(t) {
            let weight0 = &mut self.module_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModuleSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModuleSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.el_list_uprooted.iter().copied() {
    let ts = self.nil_el_list.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(NilElListTable::WEIGHT);

        t.0 = self.root_structure(t.0);
t.1 = self.root_el_list(t.1);
        if self.nil_el_list.insert(t) {
            let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(NilElListTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.nil_el_list.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(NilElListTable::WEIGHT);

        t.0 = self.root_structure(t.0);
t.1 = self.root_el_list(t.1);
        if self.nil_el_list.insert(t) {
            let weight0 = &mut self.structure_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(NilElListTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.cons_el_list.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsElListTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el_list(t.2);
        if self.cons_el_list.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsElListTable::WEIGHT);

        }
    }
}
for el in self.el_list_uprooted.iter().copied() {
    let ts = self.cons_el_list.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsElListTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el_list(t.2);
        if self.cons_el_list.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsElListTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsElListTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.snoc_el_list.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SnocElListTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SnocElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SnocElListTable::WEIGHT);

        t.0 = self.root_el_list(t.0);
t.1 = self.root_el(t.1);
t.2 = self.root_el_list(t.2);
        if self.snoc_el_list.insert(t) {
            let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SnocElListTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SnocElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SnocElListTable::WEIGHT);

        }
    }
}
for el in self.el_list_uprooted.iter().copied() {
    let ts = self.snoc_el_list.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SnocElListTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SnocElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SnocElListTable::WEIGHT);

        t.0 = self.root_el_list(t.0);
t.1 = self.root_el(t.1);
t.2 = self.root_el_list(t.2);
        if self.snoc_el_list.insert(t) {
            let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SnocElListTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SnocElListTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SnocElListTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.el_structure.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElStructureTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_structure(t.1);
        if self.el_structure.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElStructureTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.el_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElStructureTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_structure(t.1);
        if self.el_structure.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElStructureTable::WEIGHT);

        }
    }
}

for el in self.el_list_uprooted.iter().copied() {
    let ts = self.els_structure.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElsStructureTable::WEIGHT);

        t.0 = self.root_el_list(t.0);
t.1 = self.root_structure(t.1);
        if self.els_structure.insert(t) {
            let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElsStructureTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.els_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ElsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ElsStructureTable::WEIGHT);

        t.0 = self.root_el_list(t.0);
t.1 = self.root_structure(t.1);
        if self.els_structure.insert(t) {
            let weight0 = &mut self.el_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ElsStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ElsStructureTable::WEIGHT);

        }
    }
}

for el in self.element_type_uprooted.iter().copied() {
    let ts = self.ambient_type.drain_with_element_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientTypeTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_element_type(t.1);
        if self.ambient_type.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientTypeTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.ambient_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientTypeTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_element_type(t.1);
        if self.ambient_type.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientTypeTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientTypeTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.instantiated_type.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(InstantiatedTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(InstantiatedTypeTable::WEIGHT);

let weight2 = &mut self.element_type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(InstantiatedTypeTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_type(t.1);
t.2 = self.root_element_type(t.2);
        if self.instantiated_type.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(InstantiatedTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(InstantiatedTypeTable::WEIGHT);

let weight2 = &mut self.element_type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(InstantiatedTypeTable::WEIGHT);

        }
    }
}
for el in self.element_type_uprooted.iter().copied() {
    let ts = self.instantiated_type.drain_with_element_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(InstantiatedTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(InstantiatedTypeTable::WEIGHT);

let weight2 = &mut self.element_type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(InstantiatedTypeTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_type(t.1);
t.2 = self.root_element_type(t.2);
        if self.instantiated_type.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(InstantiatedTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(InstantiatedTypeTable::WEIGHT);

let weight2 = &mut self.element_type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(InstantiatedTypeTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.instantiated_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(InstantiatedTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(InstantiatedTypeTable::WEIGHT);

let weight2 = &mut self.element_type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(InstantiatedTypeTable::WEIGHT);

        t.0 = self.root_el(t.0);
t.1 = self.root_type(t.1);
t.2 = self.root_element_type(t.2);
        if self.instantiated_type.insert(t) {
            let weight0 = &mut self.el_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(InstantiatedTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(InstantiatedTypeTable::WEIGHT);

let weight2 = &mut self.element_type_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(InstantiatedTypeTable::WEIGHT);

        }
    }
}

for el in self.element_type_uprooted.iter().copied() {
    let ts = self.underlying_type.drain_with_element_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.element_type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(UnderlyingTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(UnderlyingTypeTable::WEIGHT);

        t.0 = self.root_element_type(t.0);
t.1 = self.root_type(t.1);
        if self.underlying_type.insert(t) {
            let weight0 = &mut self.element_type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(UnderlyingTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(UnderlyingTypeTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.underlying_type.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.element_type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(UnderlyingTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(UnderlyingTypeTable::WEIGHT);

        t.0 = self.root_element_type(t.0);
t.1 = self.root_type(t.1);
        if self.underlying_type.insert(t) {
            let weight0 = &mut self.element_type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(UnderlyingTypeTable::WEIGHT);

let weight1 = &mut self.type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(UnderlyingTypeTable::WEIGHT);

        }
    }
}

for el in self.element_type_list_uprooted.iter().copied() {
    let ts = self.nil_element_type_list.drain_with_element_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.element_type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(NilElementTypeListTable::WEIGHT);

        t.0 = self.root_element_type_list(t.0);
        if self.nil_element_type_list.insert(t) {
            let weight0 = &mut self.element_type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(NilElementTypeListTable::WEIGHT);

        }
    }
}

for el in self.element_type_uprooted.iter().copied() {
    let ts = self.cons_element_type_list.drain_with_element_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.element_type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsElementTypeListTable::WEIGHT);

        t.0 = self.root_element_type(t.0);
t.1 = self.root_element_type_list(t.1);
t.2 = self.root_element_type_list(t.2);
        if self.cons_element_type_list.insert(t) {
            let weight0 = &mut self.element_type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsElementTypeListTable::WEIGHT);

        }
    }
}
for el in self.element_type_list_uprooted.iter().copied() {
    let ts = self.cons_element_type_list.drain_with_element_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.element_type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ConsElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ConsElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ConsElementTypeListTable::WEIGHT);

        t.0 = self.root_element_type(t.0);
t.1 = self.root_element_type_list(t.1);
t.2 = self.root_element_type_list(t.2);
        if self.cons_element_type_list.insert(t) {
            let weight0 = &mut self.element_type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ConsElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ConsElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ConsElementTypeListTable::WEIGHT);

        }
    }
}

for el in self.element_type_uprooted.iter().copied() {
    let ts = self.snoc_element_type_list.drain_with_element_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.element_type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SnocElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SnocElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SnocElementTypeListTable::WEIGHT);

        t.0 = self.root_element_type_list(t.0);
t.1 = self.root_element_type(t.1);
t.2 = self.root_element_type_list(t.2);
        if self.snoc_element_type_list.insert(t) {
            let weight0 = &mut self.element_type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SnocElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SnocElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SnocElementTypeListTable::WEIGHT);

        }
    }
}
for el in self.element_type_list_uprooted.iter().copied() {
    let ts = self.snoc_element_type_list.drain_with_element_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.element_type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SnocElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SnocElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SnocElementTypeListTable::WEIGHT);

        t.0 = self.root_element_type_list(t.0);
t.1 = self.root_element_type(t.1);
t.2 = self.root_element_type_list(t.2);
        if self.snoc_element_type_list.insert(t) {
            let weight0 = &mut self.element_type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SnocElementTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SnocElementTypeListTable::WEIGHT);

let weight2 = &mut self.element_type_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SnocElementTypeListTable::WEIGHT);

        }
    }
}

for el in self.element_type_list_uprooted.iter().copied() {
    let ts = self.ambient_el_type_list.drain_with_element_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientElTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientElTypeListTable::WEIGHT);

        t.0 = self.root_type_list(t.0);
t.1 = self.root_element_type_list(t.1);
        if self.ambient_el_type_list.insert(t) {
            let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientElTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientElTypeListTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.ambient_el_type_list.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientElTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientElTypeListTable::WEIGHT);

        t.0 = self.root_type_list(t.0);
t.1 = self.root_element_type_list(t.1);
        if self.ambient_el_type_list.insert(t) {
            let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientElTypeListTable::WEIGHT);

let weight1 = &mut self.element_type_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientElTypeListTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.func_app.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncAppTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncAppTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el(t.2);
        if self.func_app.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncAppTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncAppTable::WEIGHT);

        }
    }
}
for el in self.el_list_uprooted.iter().copied() {
    let ts = self.func_app.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncAppTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncAppTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el(t.2);
        if self.func_app.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncAppTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncAppTable::WEIGHT);

        }
    }
}
for el in self.func_uprooted.iter().copied() {
    let ts = self.func_app.drain_with_element_func(el);
    for mut t in ts {
        let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(FuncAppTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(FuncAppTable::WEIGHT);

        t.0 = self.root_func(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el(t.2);
        if self.func_app.insert(t) {
            let weight0 = &mut self.func_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncAppTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(FuncAppTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(FuncAppTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.map_el.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MapElTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MapElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MapElTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_el(t.1);
t.2 = self.root_el(t.2);
        if self.map_el.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MapElTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MapElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MapElTable::WEIGHT);

        }
    }
}
for el in self.morphism_uprooted.iter().copied() {
    let ts = self.map_el.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MapElTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MapElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MapElTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_el(t.1);
t.2 = self.root_el(t.2);
        if self.map_el.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MapElTable::WEIGHT);

let weight1 = &mut self.el_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MapElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MapElTable::WEIGHT);

        }
    }
}

for el in self.el_list_uprooted.iter().copied() {
    let ts = self.map_els.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MapElsTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MapElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MapElsTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el_list(t.2);
        if self.map_els.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MapElsTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MapElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MapElsTable::WEIGHT);

        }
    }
}
for el in self.morphism_uprooted.iter().copied() {
    let ts = self.map_els.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MapElsTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MapElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MapElsTable::WEIGHT);

        t.0 = self.root_morphism(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el_list(t.2);
        if self.map_els.insert(t) {
            let weight0 = &mut self.morphism_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MapElsTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MapElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MapElsTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.ambient_model_el.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientModelElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AmbientModelElTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el(t.2);
        if self.ambient_model_el.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AmbientModelElTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.ambient_model_el.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientModelElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AmbientModelElTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el(t.2);
        if self.ambient_model_el.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AmbientModelElTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.ambient_model_el.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientModelElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(AmbientModelElTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el(t.2);
        if self.ambient_model_el.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(AmbientModelElTable::WEIGHT);

        }
    }
}

for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.pred_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(PredSymbolTable::WEIGHT);

        t.0 = self.root_symbol_kind(t.0);
        if self.pred_symbol.insert(t) {
            let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(PredSymbolTable::WEIGHT);

        }
    }
}

for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.func_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(FuncSymbolTable::WEIGHT);

        t.0 = self.root_symbol_kind(t.0);
        if self.func_symbol.insert(t) {
            let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(FuncSymbolTable::WEIGHT);

        }
    }
}

for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.rule_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RuleSymbolTable::WEIGHT);

        t.0 = self.root_symbol_kind(t.0);
        if self.rule_symbol.insert(t) {
            let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RuleSymbolTable::WEIGHT);

        }
    }
}

for el in self.symbol_kind_uprooted.iter().copied() {
    let ts = self.ctor_symbol.drain_with_element_symbol_kind(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorSymbolTable::WEIGHT);

        t.0 = self.root_symbol_kind(t.0);
        if self.ctor_symbol.insert(t) {
            let weight0 = &mut self.symbol_kind_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorSymbolTable::WEIGHT);

        }
    }
}

for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.symbol_scope_parent.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SymbolScopeParentTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SymbolScopeParentTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.symbol_scope_parent.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeParentTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeParentTable::WEIGHT);

        }
    }
}

for el in self.decl_list_node_uprooted.iter().copied() {
    let ts = self.decls_symbol_scope.drain_with_element_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclsSymbolScopeTable::WEIGHT);

        t.0 = self.root_decl_list_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.decls_symbol_scope.insert(t) {
            let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclsSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.decls_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(DeclsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(DeclsSymbolScopeTable::WEIGHT);

        t.0 = self.root_decl_list_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.decls_symbol_scope.insert(t) {
            let weight0 = &mut self.decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(DeclsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(DeclsSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.arg_decl_list_node_uprooted.iter().copied() {
    let ts = self.args_symbol_scope.drain_with_element_arg_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgsSymbolScopeTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.args_symbol_scope.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgsSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.args_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ArgsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ArgsSymbolScopeTable::WEIGHT);

        t.0 = self.root_arg_decl_list_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.args_symbol_scope.insert(t) {
            let weight0 = &mut self.arg_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ArgsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ArgsSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_list_node_uprooted.iter().copied() {
    let ts = self.ctors_symbol_scope.drain_with_element_ctor_decl_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorsSymbolScopeTable::WEIGHT);

        t.0 = self.root_ctor_decl_list_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.ctors_symbol_scope.insert(t) {
            let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorsSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.ctors_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CtorsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CtorsSymbolScopeTable::WEIGHT);

        t.0 = self.root_ctor_decl_list_node(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.ctors_symbol_scope.insert(t) {
            let weight0 = &mut self.ctor_decl_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CtorsSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CtorsSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.model_member_symbol_scope.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModelMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModelMemberSymbolScopeTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.model_member_symbol_scope.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModelMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModelMemberSymbolScopeTable::WEIGHT);

        }
    }
}
for el in self.type_uprooted.iter().copied() {
    let ts = self.model_member_symbol_scope.drain_with_element_type(el);
    for mut t in ts {
        let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ModelMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ModelMemberSymbolScopeTable::WEIGHT);

        t.0 = self.root_type(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.model_member_symbol_scope.insert(t) {
            let weight0 = &mut self.type_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ModelMemberSymbolScopeTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ModelMemberSymbolScopeTable::WEIGHT);

        }
    }
}

for el in self.ident_uprooted.iter().copied() {
    let ts = self.symbol_scope_name.drain_with_element_ident(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SymbolScopeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SymbolScopeNameTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
        if self.symbol_scope_name.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeNameTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.symbol_scope_name.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SymbolScopeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SymbolScopeNameTable::WEIGHT);

        t.0 = self.root_symbol_scope(t.0);
t.1 = self.root_ident(t.1);
        if self.symbol_scope_name.insert(t) {
            let weight0 = &mut self.symbol_scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SymbolScopeNameTable::WEIGHT);

let weight1 = &mut self.ident_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SymbolScopeNameTable::WEIGHT);

        }
    }
}

for el in self.scope_uprooted.iter().copied() {
    let ts = self.scope_symbols.drain_with_element_scope(el);
    for mut t in ts {
        let weight0 = &mut self.scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ScopeSymbolsTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ScopeSymbolsTable::WEIGHT);

        t.0 = self.root_scope(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.scope_symbols.insert(t) {
            let weight0 = &mut self.scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ScopeSymbolsTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ScopeSymbolsTable::WEIGHT);

        }
    }
}
for el in self.symbol_scope_uprooted.iter().copied() {
    let ts = self.scope_symbols.drain_with_element_symbol_scope(el);
    for mut t in ts {
        let weight0 = &mut self.scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ScopeSymbolsTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ScopeSymbolsTable::WEIGHT);

        t.0 = self.root_scope(t.0);
t.1 = self.root_symbol_scope(t.1);
        if self.scope_symbols.insert(t) {
            let weight0 = &mut self.scope_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ScopeSymbolsTable::WEIGHT);

let weight1 = &mut self.symbol_scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ScopeSymbolsTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.semantic_el.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticElTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el(t.2);
        if self.semantic_el.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticElTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.semantic_el.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticElTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el(t.2);
        if self.semantic_el.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticElTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.semantic_el.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticElTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el(t.2);
        if self.semantic_el.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticElTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticElTable::WEIGHT);

        }
    }
}

for el in self.nat_uprooted.iter().copied() {
    let ts = self.zero.drain_with_element_nat(el);
    for mut t in ts {
        let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ZeroTable::WEIGHT);

        t.0 = self.root_nat(t.0);
        if self.zero.insert(t) {
            let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ZeroTable::WEIGHT);

        }
    }
}

for el in self.nat_uprooted.iter().copied() {
    let ts = self.succ.drain_with_element_nat(el);
    for mut t in ts {
        let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SuccTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SuccTable::WEIGHT);

        t.0 = self.root_nat(t.0);
t.1 = self.root_nat(t.1);
        if self.succ.insert(t) {
            let weight0 = &mut self.nat_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SuccTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SuccTable::WEIGHT);

        }
    }
}

for el in self.nat_uprooted.iter().copied() {
    let ts = self.type_list_len.drain_with_element_nat(el);
    for mut t in ts {
        let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeListLenTable::WEIGHT);

        t.0 = self.root_type_list(t.0);
t.1 = self.root_nat(t.1);
        if self.type_list_len.insert(t) {
            let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeListLenTable::WEIGHT);

        }
    }
}
for el in self.type_list_uprooted.iter().copied() {
    let ts = self.type_list_len.drain_with_element_type_list(el);
    for mut t in ts {
        let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TypeListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TypeListLenTable::WEIGHT);

        t.0 = self.root_type_list(t.0);
t.1 = self.root_nat(t.1);
        if self.type_list_len.insert(t) {
            let weight0 = &mut self.type_list_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TypeListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TypeListLenTable::WEIGHT);

        }
    }
}

for el in self.nat_uprooted.iter().copied() {
    let ts = self.term_list_len.drain_with_element_nat(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermListLenTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_nat(t.1);
        if self.term_list_len.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermListLenTable::WEIGHT);

        }
    }
}
for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.term_list_len.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(TermListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(TermListLenTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_nat(t.1);
        if self.term_list_len.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(TermListLenTable::WEIGHT);

let weight1 = &mut self.nat_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(TermListLenTable::WEIGHT);

        }
    }
}

for el in self.rule_decl_node_uprooted.iter().copied() {
    let ts = self.before_rule_structure.drain_with_element_rule_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BeforeRuleStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BeforeRuleStructureTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_structure(t.1);
        if self.before_rule_structure.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BeforeRuleStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BeforeRuleStructureTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.before_rule_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BeforeRuleStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BeforeRuleStructureTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_structure(t.1);
        if self.before_rule_structure.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BeforeRuleStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BeforeRuleStructureTable::WEIGHT);

        }
    }
}

for el in self.rule_decl_node_uprooted.iter().copied() {
    let ts = self.ambient_model_el_structure.drain_with_element_rule_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientModelElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientModelElStructureTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_structure(t.1);
        if self.ambient_model_el_structure.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElStructureTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.ambient_model_el_structure.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientModelElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientModelElStructureTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_structure(t.1);
        if self.ambient_model_el_structure.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElStructureTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElStructureTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.ambient_model_el_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientModelElMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientModelElMorphismTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_morphism(t.1);
        if self.ambient_model_el_morphism.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElMorphismTable::WEIGHT);

        }
    }
}
for el in self.rule_decl_node_uprooted.iter().copied() {
    let ts = self.ambient_model_el_morphism.drain_with_element_rule_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(AmbientModelElMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(AmbientModelElMorphismTable::WEIGHT);

        t.0 = self.root_rule_decl_node(t.0);
t.1 = self.root_morphism(t.1);
        if self.ambient_model_el_morphism.insert(t) {
            let weight0 = &mut self.rule_decl_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(AmbientModelElMorphismTable::WEIGHT);

let weight1 = &mut self.morphism_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(AmbientModelElMorphismTable::WEIGHT);

        }
    }
}

for el in self.if_atom_node_uprooted.iter().copied() {
    let ts = self.if_atom_morphism.drain_with_element_if_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(IfAtomMorphismTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.if_atom_morphism.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(IfAtomMorphismTable::WEIGHT);

        }
    }
}
for el in self.morphism_uprooted.iter().copied() {
    let ts = self.if_atom_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(IfAtomMorphismTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.if_atom_morphism.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(IfAtomMorphismTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.if_atom_morphism.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(IfAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(IfAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(IfAtomMorphismTable::WEIGHT);

        t.0 = self.root_if_atom_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.if_atom_morphism.insert(t) {
            let weight0 = &mut self.if_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(IfAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(IfAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(IfAtomMorphismTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.then_atom_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ThenAtomMorphismTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.then_atom_morphism.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ThenAtomMorphismTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.then_atom_morphism.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ThenAtomMorphismTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.then_atom_morphism.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ThenAtomMorphismTable::WEIGHT);

        }
    }
}
for el in self.then_atom_node_uprooted.iter().copied() {
    let ts = self.then_atom_morphism.drain_with_element_then_atom_node(el);
    for mut t in ts {
        let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(ThenAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(ThenAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(ThenAtomMorphismTable::WEIGHT);

        t.0 = self.root_then_atom_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.then_atom_morphism.insert(t) {
            let weight0 = &mut self.then_atom_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(ThenAtomMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(ThenAtomMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(ThenAtomMorphismTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.branch_stmt_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BranchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BranchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(BranchStmtMorphismTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.branch_stmt_morphism.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BranchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BranchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(BranchStmtMorphismTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.branch_stmt_morphism.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BranchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BranchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(BranchStmtMorphismTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.branch_stmt_morphism.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BranchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BranchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(BranchStmtMorphismTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.branch_stmt_morphism.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(BranchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(BranchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(BranchStmtMorphismTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.branch_stmt_morphism.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(BranchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(BranchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(BranchStmtMorphismTable::WEIGHT);

        }
    }
}

for el in self.morphism_uprooted.iter().copied() {
    let ts = self.match_stmt_morphism.drain_with_element_morphism(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtMorphismTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.match_stmt_morphism.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtMorphismTable::WEIGHT);

        }
    }
}
for el in self.stmt_node_uprooted.iter().copied() {
    let ts = self.match_stmt_morphism.drain_with_element_stmt_node(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtMorphismTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.match_stmt_morphism.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtMorphismTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.match_stmt_morphism.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(MatchStmtMorphismTable::WEIGHT);

        t.0 = self.root_stmt_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_morphism(t.2);
        if self.match_stmt_morphism.insert(t) {
            let weight0 = &mut self.stmt_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchStmtMorphismTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchStmtMorphismTable::WEIGHT);

let weight2 = &mut self.morphism_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(MatchStmtMorphismTable::WEIGHT);

        }
    }
}

for el in self.el_name_uprooted.iter().copied() {
    let ts = self.semantic_name.drain_with_element_el_name(el);
    for mut t in ts {
        let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticNameTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticNameTable::WEIGHT);

let weight2 = &mut self.el_name_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticNameTable::WEIGHT);

        t.0 = self.root_virt_ident(t.0);
t.1 = self.root_scope(t.1);
t.2 = self.root_el_name(t.2);
        if self.semantic_name.insert(t) {
            let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticNameTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticNameTable::WEIGHT);

let weight2 = &mut self.el_name_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticNameTable::WEIGHT);

        }
    }
}
for el in self.scope_uprooted.iter().copied() {
    let ts = self.semantic_name.drain_with_element_scope(el);
    for mut t in ts {
        let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticNameTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticNameTable::WEIGHT);

let weight2 = &mut self.el_name_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticNameTable::WEIGHT);

        t.0 = self.root_virt_ident(t.0);
t.1 = self.root_scope(t.1);
t.2 = self.root_el_name(t.2);
        if self.semantic_name.insert(t) {
            let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticNameTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticNameTable::WEIGHT);

let weight2 = &mut self.el_name_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticNameTable::WEIGHT);

        }
    }
}
for el in self.virt_ident_uprooted.iter().copied() {
    let ts = self.semantic_name.drain_with_element_virt_ident(el);
    for mut t in ts {
        let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticNameTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticNameTable::WEIGHT);

let weight2 = &mut self.el_name_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticNameTable::WEIGHT);

        t.0 = self.root_virt_ident(t.0);
t.1 = self.root_scope(t.1);
t.2 = self.root_el_name(t.2);
        if self.semantic_name.insert(t) {
            let weight0 = &mut self.virt_ident_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticNameTable::WEIGHT);

let weight1 = &mut self.scope_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticNameTable::WEIGHT);

let weight2 = &mut self.el_name_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticNameTable::WEIGHT);

        }
    }
}

for el in self.el_list_uprooted.iter().copied() {
    let ts = self.semantic_els.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticElsTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticElsTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el_list(t.2);
        if self.semantic_els.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticElsTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticElsTable::WEIGHT);

        }
    }
}
for el in self.structure_uprooted.iter().copied() {
    let ts = self.semantic_els.drain_with_element_structure(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticElsTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticElsTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el_list(t.2);
        if self.semantic_els.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticElsTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticElsTable::WEIGHT);

        }
    }
}
for el in self.term_list_node_uprooted.iter().copied() {
    let ts = self.semantic_els.drain_with_element_term_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(SemanticElsTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(SemanticElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(SemanticElsTable::WEIGHT);

        t.0 = self.root_term_list_node(t.0);
t.1 = self.root_structure(t.1);
t.2 = self.root_el_list(t.2);
        if self.semantic_els.insert(t) {
            let weight0 = &mut self.term_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(SemanticElsTable::WEIGHT);

let weight1 = &mut self.structure_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(SemanticElsTable::WEIGHT);

let weight2 = &mut self.el_list_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(SemanticElsTable::WEIGHT);

        }
    }
}

for el in self.el_name_uprooted.iter().copied() {
    let ts = self.wildcard_name.drain_with_element_el_name(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(WildcardNameTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(WildcardNameTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_el_name(t.1);
        if self.wildcard_name.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(WildcardNameTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(WildcardNameTable::WEIGHT);

        }
    }
}
for el in self.term_node_uprooted.iter().copied() {
    let ts = self.wildcard_name.drain_with_element_term_node(el);
    for mut t in ts {
        let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(WildcardNameTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(WildcardNameTable::WEIGHT);

        t.0 = self.root_term_node(t.0);
t.1 = self.root_el_name(t.1);
        if self.wildcard_name.insert(t) {
            let weight0 = &mut self.term_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(WildcardNameTable::WEIGHT);

let weight1 = &mut self.el_name_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(WildcardNameTable::WEIGHT);

        }
    }
}

for el in self.el_uprooted.iter().copied() {
    let ts = self.rel_app_parent_model_el.drain_with_element_el(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelAppParentModelElTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelAppParentModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(RelAppParentModelElTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el(t.2);
        if self.rel_app_parent_model_el.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelAppParentModelElTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelAppParentModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(RelAppParentModelElTable::WEIGHT);

        }
    }
}
for el in self.el_list_uprooted.iter().copied() {
    let ts = self.rel_app_parent_model_el.drain_with_element_el_list(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelAppParentModelElTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelAppParentModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(RelAppParentModelElTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el(t.2);
        if self.rel_app_parent_model_el.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelAppParentModelElTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelAppParentModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(RelAppParentModelElTable::WEIGHT);

        }
    }
}
for el in self.rel_uprooted.iter().copied() {
    let ts = self.rel_app_parent_model_el.drain_with_element_rel(el);
    for mut t in ts {
        let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(RelAppParentModelElTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(RelAppParentModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_sub(RelAppParentModelElTable::WEIGHT);

        t.0 = self.root_rel(t.0);
t.1 = self.root_el_list(t.1);
t.2 = self.root_el(t.2);
        if self.rel_app_parent_model_el.insert(t) {
            let weight0 = &mut self.rel_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(RelAppParentModelElTable::WEIGHT);

let weight1 = &mut self.el_list_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(RelAppParentModelElTable::WEIGHT);

let weight2 = &mut self.el_weights[t.2.0 as usize];
*weight2 = weight2.saturating_add(RelAppParentModelElTable::WEIGHT);

        }
    }
}

for el in self.ctor_decl_node_uprooted.iter().copied() {
    let ts = self.match_case_pattern_ctor.drain_with_element_ctor_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchCasePatternCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchCasePatternCtorTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
        if self.match_case_pattern_ctor.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchCasePatternCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchCasePatternCtorTable::WEIGHT);

        }
    }
}
for el in self.match_case_node_uprooted.iter().copied() {
    let ts = self.match_case_pattern_ctor.drain_with_element_match_case_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(MatchCasePatternCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(MatchCasePatternCtorTable::WEIGHT);

        t.0 = self.root_match_case_node(t.0);
t.1 = self.root_ctor_decl_node(t.1);
        if self.match_case_pattern_ctor.insert(t) {
            let weight0 = &mut self.match_case_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(MatchCasePatternCtorTable::WEIGHT);

let weight1 = &mut self.ctor_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(MatchCasePatternCtorTable::WEIGHT);

        }
    }
}

for el in self.enum_decl_node_uprooted.iter().copied() {
    let ts = self.cases_determined_enum.drain_with_element_enum_decl_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CasesDeterminedEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CasesDeterminedEnumTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.cases_determined_enum.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CasesDeterminedEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CasesDeterminedEnumTable::WEIGHT);

        }
    }
}
for el in self.match_case_list_node_uprooted.iter().copied() {
    let ts = self.cases_determined_enum.drain_with_element_match_case_list_node(el);
    for mut t in ts {
        let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_sub(CasesDeterminedEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_sub(CasesDeterminedEnumTable::WEIGHT);

        t.0 = self.root_match_case_list_node(t.0);
t.1 = self.root_enum_decl_node(t.1);
        if self.cases_determined_enum.insert(t) {
            let weight0 = &mut self.match_case_list_node_weights[t.0.0 as usize];
*weight0 = weight0.saturating_add(CasesDeterminedEnumTable::WEIGHT);

let weight1 = &mut self.enum_decl_node_weights[t.1.0 as usize];
*weight1 = weight1.saturating_add(CasesDeterminedEnumTable::WEIGHT);

        }
    }
}


    self.ident_uprooted.clear();
self.virt_ident_uprooted.clear();
self.type_decl_node_uprooted.clear();
self.arg_decl_node_uprooted.clear();
self.arg_decl_list_node_uprooted.clear();
self.pred_decl_node_uprooted.clear();
self.func_decl_node_uprooted.clear();
self.ctor_decl_node_uprooted.clear();
self.ctor_decl_list_node_uprooted.clear();
self.enum_decl_node_uprooted.clear();
self.term_node_uprooted.clear();
self.term_list_node_uprooted.clear();
self.type_expr_node_uprooted.clear();
self.opt_term_node_uprooted.clear();
self.match_case_node_uprooted.clear();
self.match_case_list_node_uprooted.clear();
self.if_atom_node_uprooted.clear();
self.then_atom_node_uprooted.clear();
self.stmt_node_uprooted.clear();
self.stmt_list_node_uprooted.clear();
self.stmt_block_list_node_uprooted.clear();
self.rule_decl_node_uprooted.clear();
self.model_decl_node_uprooted.clear();
self.decl_node_uprooted.clear();
self.decl_list_node_uprooted.clear();
self.module_node_uprooted.clear();
self.loc_uprooted.clear();
self.rule_descendant_node_uprooted.clear();
self.scope_uprooted.clear();
self.type_uprooted.clear();
self.pred_uprooted.clear();
self.func_uprooted.clear();
self.structure_uprooted.clear();
self.el_uprooted.clear();
self.el_name_uprooted.clear();
self.morphism_uprooted.clear();
self.symbol_scope_uprooted.clear();
self.nat_uprooted.clear();
self.type_list_uprooted.clear();
self.rel_uprooted.clear();
self.el_list_uprooted.clear();
self.element_type_uprooted.clear();
self.element_type_list_uprooted.clear();
self.symbol_kind_uprooted.clear();
}
fn is_dirty(&self) -> bool {
    self.empty_join_is_dirty  || self.absurd.is_dirty() || self.type_decl.is_dirty() || self.arg_decl_node_name.is_dirty() || self.arg_decl_node_type.is_dirty() || self.nil_arg_decl_list_node.is_dirty() || self.cons_arg_decl_list_node.is_dirty() || self.pred_decl.is_dirty() || self.func_decl.is_dirty() || self.ctor_decl.is_dirty() || self.nil_ctor_decl_list_node.is_dirty() || self.cons_ctor_decl_list_node.is_dirty() || self.enum_decl.is_dirty() || self.nil_term_list_node.is_dirty() || self.cons_term_list_node.is_dirty() || self.ambient_type_expr.is_dirty() || self.member_type_expr.is_dirty() || self.mor_type_expr.is_dirty() || self.none_term_node.is_dirty() || self.some_term_node.is_dirty() || self.var_term_node.is_dirty() || self.wildcard_term_node.is_dirty() || self.app_term_node.is_dirty() || self.match_case.is_dirty() || self.nil_match_case_list_node.is_dirty() || self.cons_match_case_list_node.is_dirty() || self.equal_if_atom_node.is_dirty() || self.defined_if_atom_node.is_dirty() || self.pred_if_atom_node.is_dirty() || self.var_if_atom_node.is_dirty() || self.equal_then_atom_node.is_dirty() || self.defined_then_atom_node.is_dirty() || self.pred_then_atom_node.is_dirty() || self.if_stmt_node.is_dirty() || self.then_stmt_node.is_dirty() || self.branch_stmt_node.is_dirty() || self.match_stmt_node.is_dirty() || self.nil_stmt_list_node.is_dirty() || self.cons_stmt_list_node.is_dirty() || self.nil_stmt_block_list_node.is_dirty() || self.cons_stmt_block_list_node.is_dirty() || self.rule_decl.is_dirty() || self.model_decl.is_dirty() || self.decl_node_type.is_dirty() || self.decl_node_pred.is_dirty() || self.decl_node_func.is_dirty() || self.decl_node_rule.is_dirty() || self.decl_node_enum.is_dirty() || self.decl_node_model.is_dirty() || self.nil_decl_list_node.is_dirty() || self.cons_decl_list_node.is_dirty() || self.decls_module_node.is_dirty() || self.var_in_scope.is_dirty() || self.scope_extension.is_dirty() || self.scope_single_child.is_dirty() || self.scope_extension_siblings.is_dirty() || self.is_normal_type.is_dirty() || self.is_enum_type.is_dirty() || self.is_model_type.is_dirty() || self.is_mor_type.is_dirty() || self.illegal_member_type_expr_in_signature.is_dirty() || self.is_total_func.is_dirty() || self.rel_app.is_dirty() || self.el_type.is_dirty() || self.el_types.is_dirty() || self.constrained_el.is_dirty() || self.constrained_els.is_dirty() || self.in_ker.is_dirty() || self.el_in_img.is_dirty() || self.rel_tuple_in_img.is_dirty() || self.symbol_scope_extension.is_dirty() || self.symbol_scope_ancestor.is_dirty() || self.element_member_symbol_scope.is_dirty() || self.defined_symbol.is_dirty() || self.accessible_symbol.is_dirty() || self.should_be_symbol.is_dirty() || self.should_be_symbol_2.is_dirty() || self.should_be_symbol_3.is_dirty() || self.pred_arg_num_should_match.is_dirty() || self.func_arg_num_should_match.is_dirty() || self.cfg_edge.is_dirty() || self.cfg_edge_stmts_stmt.is_dirty() || self.cfg_edge_stmt_stmts.is_dirty() || self.cfg_edge_fork.is_dirty() || self.cfg_edge_join.is_dirty() || self.before_stmt_structure.is_dirty() || self.stmt_morphism.is_dirty() || self.if_morphism.is_dirty() || self.surj_then_morphism.is_dirty() || self.non_surj_then_morphism.is_dirty() || self.noop_morphism.is_dirty() || self.stmt_structure.is_dirty() || self.if_atom_structure.is_dirty() || self.then_atom_structure.is_dirty() || self.term_structure.is_dirty() || self.terms_structure.is_dirty() || self.opt_term_structure.is_dirty() || self.type_expr_structure.is_dirty() || self.term_should_be_epic_ok.is_dirty() || self.terms_should_be_epic_ok.is_dirty() || self.el_should_be_surjective_ok.is_dirty() || self.el_is_surjective_ok.is_dirty() || self.should_be_obtained_by_ctor.is_dirty() || self.is_given_by_ctor.is_dirty() || self.function_can_be_made_defined.is_dirty() || self.case_pattern_is_variable.is_dirty() || self.case_pattern_is_wildcard.is_dirty() || self.is_pattern_ctor_arg.is_dirty() || self.are_pattern_ctor_args.is_dirty() || self.pattern_ctor_arg_is_app.is_dirty() || self.pattern_ctor_arg_var_is_not_fresh.is_dirty() || self.cases_contain_ctor.is_dirty() || self.match_stmt_contains_ctor_of_enum.is_dirty() || self.match_stmt_should_contain_ctor.is_dirty() || self.match_stmt_contains_ctor.is_dirty() || self.real_virt_ident.is_dirty() || self.virt_real_ident.is_dirty() || self.var.is_dirty() || self.rule_name.is_dirty() || self.module_name.is_dirty() || self.type_decl_node_loc.is_dirty() || self.arg_decl_node_loc.is_dirty() || self.arg_decl_list_node_loc.is_dirty() || self.pred_decl_node_loc.is_dirty() || self.func_decl_node_loc.is_dirty() || self.ctor_decl_node_loc.is_dirty() || self.enum_decl_node_loc.is_dirty() || self.model_decl_node_loc.is_dirty() || self.term_node_loc.is_dirty() || self.term_list_node_loc.is_dirty() || self.match_case_node_loc.is_dirty() || self.opt_term_node_loc.is_dirty() || self.if_atom_node_loc.is_dirty() || self.then_atom_node_loc.is_dirty() || self.stmt_node_loc.is_dirty() || self.stmt_list_node_loc.is_dirty() || self.rule_decl_node_loc.is_dirty() || self.decl_node_loc.is_dirty() || self.decl_list_node_loc.is_dirty() || self.module_node_loc.is_dirty() || self.type_expr_node_loc.is_dirty() || self.rule_descendant_rule.is_dirty() || self.rule_descendant_term.is_dirty() || self.rule_descendant_term_list.is_dirty() || self.rule_descendant_opt_term.is_dirty() || self.rule_descendant_if_atom.is_dirty() || self.rule_descendant_then_atom.is_dirty() || self.rule_descendant_match_case.is_dirty() || self.rule_descendant_match_case_list.is_dirty() || self.rule_descendant_stmt.is_dirty() || self.rule_descendant_stmt_list.is_dirty() || self.rule_descendant_stmt_block_list.is_dirty() || self.rule_descendant_type_expr.is_dirty() || self.entry_scope.is_dirty() || self.exit_scope.is_dirty() || self.ctor_enum.is_dirty() || self.ctors_enum.is_dirty() || self.cases_discriminee.is_dirty() || self.case_discriminee.is_dirty() || self.desugared_case_equality_atom.is_dirty() || self.desugared_case_equality_stmt.is_dirty() || self.desugared_case_block.is_dirty() || self.desugared_case_block_list.is_dirty() || self.nil_type_list.is_dirty() || self.cons_type_list.is_dirty() || self.snoc_type_list.is_dirty() || self.semantic_type.is_dirty() || self.decl_symbol_scope.is_dirty() || self.mor_type.is_dirty() || self.mor_type_dom_func.is_dirty() || self.mor_type_cod_func.is_dirty() || self.type_definition_symbol_scope.is_dirty() || self.func_rel.is_dirty() || self.rel_definition_symbol_scope.is_dirty() || self.domain.is_dirty() || self.codomain.is_dirty() || self.type_name.is_dirty() || self.virtual_symbol_scope.is_dirty() || self.parent_model_func.is_dirty() || self.symbol_scope_model.is_dirty() || self.flat_domain.is_dirty() || self.semantic_signature_type_expr.is_dirty() || self.type_symbol.is_dirty() || self.enum_symbol.is_dirty() || self.model_symbol.is_dirty() || self.semantic_arg_type.is_dirty() || self.arg_symbol_scope.is_dirty() || self.semantic_arg_types.is_dirty() || self.semantic_pred.is_dirty() || self.pred_arity.is_dirty() || self.semantic_func.is_dirty() || self.ctor_symbol_scope.is_dirty() || self.pred_rel.is_dirty() || self.rel_name.is_dirty() || self.arity.is_dirty() || self.dom.is_dirty() || self.cod.is_dirty() || self.flat_arity.is_dirty() || self.module_symbol_scope.is_dirty() || self.nil_el_list.is_dirty() || self.cons_el_list.is_dirty() || self.snoc_el_list.is_dirty() || self.el_structure.is_dirty() || self.els_structure.is_dirty() || self.ambient_type.is_dirty() || self.instantiated_type.is_dirty() || self.underlying_type.is_dirty() || self.nil_element_type_list.is_dirty() || self.cons_element_type_list.is_dirty() || self.snoc_element_type_list.is_dirty() || self.ambient_el_type_list.is_dirty() || self.func_app.is_dirty() || self.map_el.is_dirty() || self.map_els.is_dirty() || self.ambient_model_el.is_dirty() || self.pred_symbol.is_dirty() || self.func_symbol.is_dirty() || self.rule_symbol.is_dirty() || self.ctor_symbol.is_dirty() || self.symbol_scope_parent.is_dirty() || self.decls_symbol_scope.is_dirty() || self.args_symbol_scope.is_dirty() || self.ctors_symbol_scope.is_dirty() || self.model_member_symbol_scope.is_dirty() || self.symbol_scope_name.is_dirty() || self.scope_symbols.is_dirty() || self.semantic_el.is_dirty() || self.zero.is_dirty() || self.succ.is_dirty() || self.type_list_len.is_dirty() || self.term_list_len.is_dirty() || self.before_rule_structure.is_dirty() || self.ambient_model_el_structure.is_dirty() || self.ambient_model_el_morphism.is_dirty() || self.if_atom_morphism.is_dirty() || self.then_atom_morphism.is_dirty() || self.branch_stmt_morphism.is_dirty() || self.match_stmt_morphism.is_dirty() || self.semantic_name.is_dirty() || self.semantic_els.is_dirty() || self.wildcard_name.is_dirty() || self.rel_app_parent_model_el.is_dirty() || self.match_case_pattern_ctor.is_dirty() || self.cases_determined_enum.is_dirty()  || !self.ident_new.is_empty() || !self.virt_ident_new.is_empty() || !self.type_decl_node_new.is_empty() || !self.arg_decl_node_new.is_empty() || !self.type_expr_node_new.is_empty() || !self.arg_decl_list_node_new.is_empty() || !self.pred_decl_node_new.is_empty() || !self.func_decl_node_new.is_empty() || !self.ctor_decl_node_new.is_empty() || !self.ctor_decl_list_node_new.is_empty() || !self.enum_decl_node_new.is_empty() || !self.term_node_new.is_empty() || !self.term_list_node_new.is_empty() || !self.opt_term_node_new.is_empty() || !self.match_case_node_new.is_empty() || !self.stmt_list_node_new.is_empty() || !self.match_case_list_node_new.is_empty() || !self.if_atom_node_new.is_empty() || !self.then_atom_node_new.is_empty() || !self.stmt_node_new.is_empty() || !self.stmt_block_list_node_new.is_empty() || !self.rule_decl_node_new.is_empty() || !self.model_decl_node_new.is_empty() || !self.decl_list_node_new.is_empty() || !self.decl_node_new.is_empty() || !self.module_node_new.is_empty() || !self.loc_new.is_empty() || !self.rule_descendant_node_new.is_empty() || !self.scope_new.is_empty() || !self.type_new.is_empty() || !self.type_list_new.is_empty() || !self.symbol_scope_new.is_empty() || !self.func_new.is_empty() || !self.pred_new.is_empty() || !self.rel_new.is_empty() || !self.structure_new.is_empty() || !self.el_new.is_empty() || !self.el_list_new.is_empty() || !self.el_name_new.is_empty() || !self.element_type_new.is_empty() || !self.element_type_list_new.is_empty() || !self.morphism_new.is_empty() || !self.symbol_kind_new.is_empty() || !self.nat_new.is_empty()  || !self.ident_uprooted.is_empty() || !self.virt_ident_uprooted.is_empty() || !self.type_decl_node_uprooted.is_empty() || !self.arg_decl_node_uprooted.is_empty() || !self.type_expr_node_uprooted.is_empty() || !self.arg_decl_list_node_uprooted.is_empty() || !self.pred_decl_node_uprooted.is_empty() || !self.func_decl_node_uprooted.is_empty() || !self.ctor_decl_node_uprooted.is_empty() || !self.ctor_decl_list_node_uprooted.is_empty() || !self.enum_decl_node_uprooted.is_empty() || !self.term_node_uprooted.is_empty() || !self.term_list_node_uprooted.is_empty() || !self.opt_term_node_uprooted.is_empty() || !self.match_case_node_uprooted.is_empty() || !self.stmt_list_node_uprooted.is_empty() || !self.match_case_list_node_uprooted.is_empty() || !self.if_atom_node_uprooted.is_empty() || !self.then_atom_node_uprooted.is_empty() || !self.stmt_node_uprooted.is_empty() || !self.stmt_block_list_node_uprooted.is_empty() || !self.rule_decl_node_uprooted.is_empty() || !self.model_decl_node_uprooted.is_empty() || !self.decl_list_node_uprooted.is_empty() || !self.decl_node_uprooted.is_empty() || !self.module_node_uprooted.is_empty() || !self.loc_uprooted.is_empty() || !self.rule_descendant_node_uprooted.is_empty() || !self.scope_uprooted.is_empty() || !self.type_uprooted.is_empty() || !self.type_list_uprooted.is_empty() || !self.symbol_scope_uprooted.is_empty() || !self.func_uprooted.is_empty() || !self.pred_uprooted.is_empty() || !self.rel_uprooted.is_empty() || !self.structure_uprooted.is_empty() || !self.el_uprooted.is_empty() || !self.el_list_uprooted.is_empty() || !self.el_name_uprooted.is_empty() || !self.element_type_uprooted.is_empty() || !self.element_type_list_uprooted.is_empty() || !self.morphism_uprooted.is_empty() || !self.symbol_kind_uprooted.is_empty() || !self.nat_uprooted.is_empty()
}

#[allow(unused_variables)]
fn implicit_functionality_0_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RealVirtIdent(tm0, tm1, ) in self.real_virt_ident.iter_new() {

#[allow(unused_variables)]
for RealVirtIdent(_, tm2, ) in self.real_virt_ident.iter_all_0(tm0, ) {

delta.new_virt_ident_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_1_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VirtRealIdent(tm0, tm1, ) in self.virt_real_ident.iter_new() {

#[allow(unused_variables)]
for VirtRealIdent(_, tm2, ) in self.virt_real_ident.iter_all_0(tm0, ) {

delta.new_ident_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_2_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleName(tm0, tm1, ) in self.rule_name.iter_new() {

#[allow(unused_variables)]
for RuleName(_, tm2, ) in self.rule_name.iter_all_0(tm0, ) {

delta.new_ident_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_3_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleName(tm0, tm1, ) in self.module_name.iter_new() {

#[allow(unused_variables)]
for ModuleName(_, tm2, ) in self.module_name.iter_all_0(tm0, ) {

delta.new_ident_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_4_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDeclNodeLoc(tm0, tm1, ) in self.type_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for TypeDeclNodeLoc(_, tm2, ) in self.type_decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_5_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgDeclNodeLoc(tm0, tm1, ) in self.arg_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for ArgDeclNodeLoc(_, tm2, ) in self.arg_decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_6_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgDeclListNodeLoc(tm0, tm1, ) in self.arg_decl_list_node_loc.iter_new() {

#[allow(unused_variables)]
for ArgDeclListNodeLoc(_, tm2, ) in self.arg_decl_list_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_7_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredDeclNodeLoc(tm0, tm1, ) in self.pred_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for PredDeclNodeLoc(_, tm2, ) in self.pred_decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_8_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDeclNodeLoc(tm0, tm1, ) in self.func_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for FuncDeclNodeLoc(_, tm2, ) in self.func_decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_9_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDeclNodeLoc(tm0, tm1, ) in self.ctor_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for CtorDeclNodeLoc(_, tm2, ) in self.ctor_decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_10_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDeclNodeLoc(tm0, tm1, ) in self.enum_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for EnumDeclNodeLoc(_, tm2, ) in self.enum_decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_11_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDeclNodeLoc(tm0, tm1, ) in self.model_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for ModelDeclNodeLoc(_, tm2, ) in self.model_decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_12_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm0, tm1, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for TermNodeLoc(_, tm2, ) in self.term_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_13_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListNodeLoc(tm0, tm1, ) in self.term_list_node_loc.iter_new() {

#[allow(unused_variables)]
for TermListNodeLoc(_, tm2, ) in self.term_list_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_14_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCaseNodeLoc(tm0, tm1, ) in self.match_case_node_loc.iter_new() {

#[allow(unused_variables)]
for MatchCaseNodeLoc(_, tm2, ) in self.match_case_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_15_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for OptTermNodeLoc(tm0, tm1, ) in self.opt_term_node_loc.iter_new() {

#[allow(unused_variables)]
for OptTermNodeLoc(_, tm2, ) in self.opt_term_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_16_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(tm0, tm1, ) in self.if_atom_node_loc.iter_new() {

#[allow(unused_variables)]
for IfAtomNodeLoc(_, tm2, ) in self.if_atom_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_17_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomNodeLoc(tm0, tm1, ) in self.then_atom_node_loc.iter_new() {

#[allow(unused_variables)]
for ThenAtomNodeLoc(_, tm2, ) in self.then_atom_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_18_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtNodeLoc(tm0, tm1, ) in self.stmt_node_loc.iter_new() {

#[allow(unused_variables)]
for StmtNodeLoc(_, tm2, ) in self.stmt_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_19_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtListNodeLoc(tm0, tm1, ) in self.stmt_list_node_loc.iter_new() {

#[allow(unused_variables)]
for StmtListNodeLoc(_, tm2, ) in self.stmt_list_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_20_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDeclNodeLoc(tm0, tm1, ) in self.rule_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for RuleDeclNodeLoc(_, tm2, ) in self.rule_decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_21_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeLoc(tm0, tm1, ) in self.decl_node_loc.iter_new() {

#[allow(unused_variables)]
for DeclNodeLoc(_, tm2, ) in self.decl_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_22_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclListNodeLoc(tm0, tm1, ) in self.decl_list_node_loc.iter_new() {

#[allow(unused_variables)]
for DeclListNodeLoc(_, tm2, ) in self.decl_list_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_23_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleNodeLoc(tm0, tm1, ) in self.module_node_loc.iter_new() {

#[allow(unused_variables)]
for ModuleNodeLoc(_, tm2, ) in self.module_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_24_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeExprNodeLoc(tm0, tm1, ) in self.type_expr_node_loc.iter_new() {

#[allow(unused_variables)]
for TypeExprNodeLoc(_, tm2, ) in self.type_expr_node_loc.iter_all_0(tm0, ) {

delta.new_loc_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_25_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantRule(tm0, tm1, ) in self.rule_descendant_rule.iter_new() {

#[allow(unused_variables)]
for RuleDescendantRule(_, tm2, ) in self.rule_descendant_rule.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_26_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm1, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm2, ) in self.rule_descendant_term.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_27_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(tm0, tm1, ) in self.rule_descendant_term_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTermList(_, tm2, ) in self.rule_descendant_term_list.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_28_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantOptTerm(tm0, tm1, ) in self.rule_descendant_opt_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantOptTerm(_, tm2, ) in self.rule_descendant_opt_term.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_29_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm1, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm2, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_30_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm1, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm2, ) in self.rule_descendant_then_atom.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_31_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCase(tm0, tm1, ) in self.rule_descendant_match_case.iter_new() {

#[allow(unused_variables)]
for RuleDescendantMatchCase(_, tm2, ) in self.rule_descendant_match_case.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_32_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCaseList(tm0, tm1, ) in self.rule_descendant_match_case_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantMatchCaseList(_, tm2, ) in self.rule_descendant_match_case_list.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_33_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(tm0, tm1, ) in self.rule_descendant_stmt.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmt(_, tm2, ) in self.rule_descendant_stmt.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_34_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(tm0, tm1, ) in self.rule_descendant_stmt_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm2, ) in self.rule_descendant_stmt_list.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_35_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm0, tm1, ) in self.rule_descendant_stmt_block_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm2, ) in self.rule_descendant_stmt_block_list.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_36_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTypeExpr(tm0, tm1, ) in self.rule_descendant_type_expr.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTypeExpr(_, tm2, ) in self.rule_descendant_type_expr.iter_all_0(tm0, ) {

delta.new_rule_descendant_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_37_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm0, tm1, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm2, ) in self.entry_scope.iter_all_0(tm0, ) {

delta.new_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_38_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm0, tm1, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for ExitScope(_, tm2, ) in self.exit_scope.iter_all_0(tm0, ) {

delta.new_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_39_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(tm0, tm1, ) in self.ctor_enum.iter_new() {

#[allow(unused_variables)]
for CtorEnum(_, tm2, ) in self.ctor_enum.iter_all_0(tm0, ) {

delta.new_enum_decl_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_40_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorsEnum(tm0, tm1, ) in self.ctors_enum.iter_new() {

#[allow(unused_variables)]
for CtorsEnum(_, tm2, ) in self.ctors_enum.iter_all_0(tm0, ) {

delta.new_enum_decl_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_41_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CasesDiscriminee(tm0, tm1, ) in self.cases_discriminee.iter_new() {

#[allow(unused_variables)]
for CasesDiscriminee(_, tm2, ) in self.cases_discriminee.iter_all_0(tm0, ) {

delta.new_term_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_42_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CaseDiscriminee(tm0, tm1, ) in self.case_discriminee.iter_new() {

#[allow(unused_variables)]
for CaseDiscriminee(_, tm2, ) in self.case_discriminee.iter_all_0(tm0, ) {

delta.new_term_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_43_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityAtom(tm0, tm1, ) in self.desugared_case_equality_atom.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseEqualityAtom(_, tm2, ) in self.desugared_case_equality_atom.iter_all_0(tm0, ) {

delta.new_if_atom_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_44_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(tm0, tm1, ) in self.desugared_case_equality_stmt.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(_, tm2, ) in self.desugared_case_equality_stmt.iter_all_0(tm0, ) {

delta.new_stmt_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_45_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlock(tm0, tm1, ) in self.desugared_case_block.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseBlock(_, tm2, ) in self.desugared_case_block.iter_all_0(tm0, ) {

delta.new_stmt_list_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_46_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(tm0, tm1, ) in self.desugared_case_block_list.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseBlockList(_, tm2, ) in self.desugared_case_block_list.iter_all_0(tm0, ) {

delta.new_stmt_block_list_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_47_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm0, tm1, tm2, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for SemanticType(_, _, tm3, ) in self.semantic_type.iter_all_0_1(tm0, tm1, ) {

delta.new_type_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_48_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorType(tm0, tm1, ) in self.mor_type.iter_new() {

#[allow(unused_variables)]
for MorType(_, tm2, ) in self.mor_type.iter_all_0(tm0, ) {

delta.new_type_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_49_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeDomFunc(tm0, tm1, ) in self.mor_type_dom_func.iter_new() {

#[allow(unused_variables)]
for MorTypeDomFunc(_, tm2, ) in self.mor_type_dom_func.iter_all_0(tm0, ) {

delta.new_func_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_50_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeCodFunc(tm0, tm1, ) in self.mor_type_cod_func.iter_new() {

#[allow(unused_variables)]
for MorTypeCodFunc(_, tm2, ) in self.mor_type_cod_func.iter_all_0(tm0, ) {

delta.new_func_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_51_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeName(tm0, tm1, ) in self.type_name.iter_new() {

#[allow(unused_variables)]
for TypeName(_, tm2, ) in self.type_name.iter_all_0(tm0, ) {

delta.new_ident_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_52_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VirtualSymbolScope(tm0, ) in self.virtual_symbol_scope.iter_new() {

#[allow(unused_variables)]
for VirtualSymbolScope(tm1, ) in self.virtual_symbol_scope.iter_all() {

delta.new_symbol_scope_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_53_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ParentModelFunc(tm0, tm1, ) in self.parent_model_func.iter_new() {

#[allow(unused_variables)]
for ParentModelFunc(_, tm2, ) in self.parent_model_func.iter_all_0(tm0, ) {

delta.new_func_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_54_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm0, tm1, tm2, ) in self.semantic_signature_type_expr.iter_new() {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(_, _, tm3, ) in self.semantic_signature_type_expr.iter_all_0_1(tm0, tm1, ) {

delta.new_type_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_55_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgType(tm0, tm1, ) in self.semantic_arg_type.iter_new() {

#[allow(unused_variables)]
for SemanticArgType(_, tm2, ) in self.semantic_arg_type.iter_all_0(tm0, ) {

delta.new_type_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_56_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(tm0, tm1, ) in self.semantic_arg_types.iter_new() {

#[allow(unused_variables)]
for SemanticArgTypes(_, tm2, ) in self.semantic_arg_types.iter_all_0(tm0, ) {

delta.new_type_list_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_57_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm0, tm1, tm2, ) in self.semantic_pred.iter_new() {

#[allow(unused_variables)]
for SemanticPred(_, _, tm3, ) in self.semantic_pred.iter_all_0_1(tm0, tm1, ) {

delta.new_pred_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_58_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredArity(tm0, tm1, ) in self.pred_arity.iter_new() {

#[allow(unused_variables)]
for PredArity(_, tm2, ) in self.pred_arity.iter_all_0(tm0, ) {

delta.new_type_list_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_59_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm0, tm1, tm2, ) in self.semantic_func.iter_new() {

#[allow(unused_variables)]
for SemanticFunc(_, _, tm3, ) in self.semantic_func.iter_all_0_1(tm0, tm1, ) {

delta.new_func_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_60_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(tm0, tm1, ) in self.domain.iter_new() {

#[allow(unused_variables)]
for Domain(_, tm2, ) in self.domain.iter_all_0(tm0, ) {

delta.new_type_list_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_61_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Codomain(tm0, tm1, ) in self.codomain.iter_new() {

#[allow(unused_variables)]
for Codomain(_, tm2, ) in self.codomain.iter_all_0(tm0, ) {

delta.new_type_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_62_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelName(tm0, tm1, ) in self.rel_name.iter_new() {

#[allow(unused_variables)]
for RelName(_, tm2, ) in self.rel_name.iter_all_0(tm0, ) {

delta.new_ident_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_63_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(tm0, tm1, ) in self.arity.iter_new() {

#[allow(unused_variables)]
for Arity(_, tm2, ) in self.arity.iter_all_0(tm0, ) {

delta.new_type_list_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_64_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FlatArity(tm0, tm1, ) in self.flat_arity.iter_new() {

#[allow(unused_variables)]
for FlatArity(_, tm2, ) in self.flat_arity.iter_all_0(tm0, ) {

delta.new_type_list_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_65_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FlatDomain(tm0, tm1, ) in self.flat_domain.iter_new() {

#[allow(unused_variables)]
for FlatDomain(_, tm2, ) in self.flat_domain.iter_all_0(tm0, ) {

delta.new_type_list_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_66_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Var(tm0, tm1, tm2, ) in self.var.iter_new() {

#[allow(unused_variables)]
for Var(_, _, tm3, ) in self.var.iter_all_0_1(tm0, tm1, ) {

delta.new_el_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_67_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(tm0, tm1, ) in self.el_structure.iter_new() {

#[allow(unused_variables)]
for ElStructure(_, tm2, ) in self.el_structure.iter_all_0(tm0, ) {

delta.new_structure_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_68_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElsStructure(tm0, tm1, ) in self.els_structure.iter_new() {

#[allow(unused_variables)]
for ElsStructure(_, tm2, ) in self.els_structure.iter_all_0(tm0, ) {

delta.new_structure_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_69_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for UnderlyingType(tm0, tm1, ) in self.underlying_type.iter_new() {

#[allow(unused_variables)]
for UnderlyingType(_, tm2, ) in self.underlying_type.iter_all_0(tm0, ) {

delta.new_type_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_70_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientElTypeList(tm0, tm1, ) in self.ambient_el_type_list.iter_new() {

#[allow(unused_variables)]
for AmbientElTypeList(_, tm2, ) in self.ambient_el_type_list.iter_all_0(tm0, ) {

delta.new_element_type_list_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_71_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncApp(tm0, tm1, tm2, ) in self.func_app.iter_new() {

#[allow(unused_variables)]
for FuncApp(_, _, tm3, ) in self.func_app.iter_all_0_1(tm0, tm1, ) {

delta.new_el_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_72_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Dom(tm0, tm1, ) in self.dom.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm2, ) in self.dom.iter_all_0(tm0, ) {

delta.new_structure_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_73_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm0, tm1, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for Cod(_, tm2, ) in self.cod.iter_all_0(tm0, ) {

delta.new_structure_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_74_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm0, tm1, tm2, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for MapEl(_, _, tm3, ) in self.map_el.iter_all_0_1(tm0, tm1, ) {

delta.new_el_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_75_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(tm0, tm1, tm2, ) in self.map_els.iter_new() {

#[allow(unused_variables)]
for MapEls(_, _, tm3, ) in self.map_els.iter_all_0_1(tm0, tm1, ) {

delta.new_el_list_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_76_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeParent(tm0, tm1, ) in self.symbol_scope_parent.iter_new() {

#[allow(unused_variables)]
for SymbolScopeParent(_, tm2, ) in self.symbol_scope_parent.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_77_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleSymbolScope(tm0, tm1, ) in self.module_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ModuleSymbolScope(_, tm2, ) in self.module_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_78_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm1, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm2, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_79_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(tm0, tm1, ) in self.decls_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclsSymbolScope(_, tm2, ) in self.decls_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_80_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgSymbolScope(tm0, tm1, ) in self.arg_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ArgSymbolScope(_, tm2, ) in self.arg_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_81_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgsSymbolScope(tm0, tm1, ) in self.args_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ArgsSymbolScope(_, tm2, ) in self.args_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_82_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(tm0, tm1, ) in self.ctor_symbol_scope.iter_new() {

#[allow(unused_variables)]
for CtorSymbolScope(_, tm2, ) in self.ctor_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_83_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorsSymbolScope(tm0, tm1, ) in self.ctors_symbol_scope.iter_new() {

#[allow(unused_variables)]
for CtorsSymbolScope(_, tm2, ) in self.ctors_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_84_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelMemberSymbolScope(tm0, tm1, ) in self.model_member_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ModelMemberSymbolScope(_, tm2, ) in self.model_member_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_85_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(tm0, tm1, ) in self.symbol_scope_model.iter_new() {

#[allow(unused_variables)]
for SymbolScopeModel(_, tm2, ) in self.symbol_scope_model.iter_all_0(tm0, ) {

delta.new_type_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_86_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeName(tm0, tm1, ) in self.symbol_scope_name.iter_new() {

#[allow(unused_variables)]
for SymbolScopeName(_, tm2, ) in self.symbol_scope_name.iter_all_0(tm0, ) {

delta.new_ident_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_87_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm0, tm1, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm2, ) in self.scope_symbols.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_88_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDefinitionSymbolScope(tm0, tm1, ) in self.type_definition_symbol_scope.iter_new() {

#[allow(unused_variables)]
for TypeDefinitionSymbolScope(_, tm2, ) in self.type_definition_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_89_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm0, tm1, ) in self.rel_definition_symbol_scope.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm2, ) in self.rel_definition_symbol_scope.iter_all_0(tm0, ) {

delta.new_symbol_scope_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_90_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Zero(tm0, ) in self.zero.iter_new() {

#[allow(unused_variables)]
for Zero(tm1, ) in self.zero.iter_all() {

delta.new_nat_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_91_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Succ(tm0, tm1, ) in self.succ.iter_new() {

#[allow(unused_variables)]
for Succ(_, tm2, ) in self.succ.iter_all_0(tm0, ) {

delta.new_nat_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_92_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm0, tm1, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for TypeListLen(_, tm2, ) in self.type_list_len.iter_all_0(tm0, ) {

delta.new_nat_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_93_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(tm0, tm1, ) in self.term_list_len.iter_new() {

#[allow(unused_variables)]
for TermListLen(_, tm2, ) in self.term_list_len.iter_all_0(tm0, ) {

delta.new_nat_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_94_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeRuleStructure(tm0, tm1, ) in self.before_rule_structure.iter_new() {

#[allow(unused_variables)]
for BeforeRuleStructure(_, tm2, ) in self.before_rule_structure.iter_all_0(tm0, ) {

delta.new_structure_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_95_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElStructure(tm0, tm1, ) in self.ambient_model_el_structure.iter_new() {

#[allow(unused_variables)]
for AmbientModelElStructure(_, tm2, ) in self.ambient_model_el_structure.iter_all_0(tm0, ) {

delta.new_structure_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_96_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElMorphism(tm0, tm1, ) in self.ambient_model_el_morphism.iter_new() {

#[allow(unused_variables)]
for AmbientModelElMorphism(_, tm2, ) in self.ambient_model_el_morphism.iter_all_0(tm0, ) {

delta.new_morphism_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_97_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomMorphism(tm0, tm1, tm2, ) in self.if_atom_morphism.iter_new() {

#[allow(unused_variables)]
for IfAtomMorphism(_, _, tm3, ) in self.if_atom_morphism.iter_all_0_1(tm0, tm1, ) {

delta.new_morphism_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_98_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomMorphism(tm0, tm1, tm2, ) in self.then_atom_morphism.iter_new() {

#[allow(unused_variables)]
for ThenAtomMorphism(_, _, tm3, ) in self.then_atom_morphism.iter_all_0_1(tm0, tm1, ) {

delta.new_morphism_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_99_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BranchStmtMorphism(tm0, tm1, tm2, ) in self.branch_stmt_morphism.iter_new() {

#[allow(unused_variables)]
for BranchStmtMorphism(_, _, tm3, ) in self.branch_stmt_morphism.iter_all_0_1(tm0, tm1, ) {

delta.new_morphism_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_100_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtMorphism(tm0, tm1, tm2, ) in self.match_stmt_morphism.iter_new() {

#[allow(unused_variables)]
for MatchStmtMorphism(_, _, tm3, ) in self.match_stmt_morphism.iter_all_0_1(tm0, tm1, ) {

delta.new_morphism_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_101_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticName(tm0, tm1, tm2, ) in self.semantic_name.iter_new() {

#[allow(unused_variables)]
for SemanticName(_, _, tm3, ) in self.semantic_name.iter_all_0_1(tm0, tm1, ) {

delta.new_el_name_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_102_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm0, tm1, tm2, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for SemanticEl(_, _, tm3, ) in self.semantic_el.iter_all_0_1(tm0, tm1, ) {

delta.new_el_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_103_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(tm0, tm1, tm2, ) in self.semantic_els.iter_new() {

#[allow(unused_variables)]
for SemanticEls(_, _, tm3, ) in self.semantic_els.iter_all_0_1(tm0, tm1, ) {

delta.new_el_list_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_104_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm0, tm1, tm2, ) in self.ambient_model_el.iter_new() {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm3, ) in self.ambient_model_el.iter_all_0_1(tm0, tm1, ) {

delta.new_el_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_105_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for WildcardName(tm0, tm1, ) in self.wildcard_name.iter_new() {

#[allow(unused_variables)]
for WildcardName(_, tm2, ) in self.wildcard_name.iter_all_0(tm0, ) {

delta.new_el_name_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_106_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelAppParentModelEl(tm0, tm1, tm2, ) in self.rel_app_parent_model_el.iter_new() {

#[allow(unused_variables)]
for RelAppParentModelEl(_, _, tm3, ) in self.rel_app_parent_model_el.iter_all_0_1(tm0, tm1, ) {

delta.new_el_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_107_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCasePatternCtor(tm0, tm1, ) in self.match_case_pattern_ctor.iter_new() {

#[allow(unused_variables)]
for MatchCasePatternCtor(_, tm2, ) in self.match_case_pattern_ctor.iter_all_0(tm0, ) {

delta.new_ctor_decl_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_108_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CasesDeterminedEnum(tm0, tm1, ) in self.cases_determined_enum.iter_new() {

#[allow(unused_variables)]
for CasesDeterminedEnum(_, tm2, ) in self.cases_determined_enum.iter_all_0(tm0, ) {

delta.new_enum_decl_node_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_109_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTypeList(tm0, ) in self.nil_type_list.iter_new() {

#[allow(unused_variables)]
for NilTypeList(tm1, ) in self.nil_type_list.iter_all() {

delta.new_type_list_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_110_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm0, tm1, tm2, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for ConsTypeList(_, _, tm3, ) in self.cons_type_list.iter_all_0_1(tm0, tm1, ) {

delta.new_type_list_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_111_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocTypeList(tm0, tm1, tm2, ) in self.snoc_type_list.iter_new() {

#[allow(unused_variables)]
for SnocTypeList(_, _, tm3, ) in self.snoc_type_list.iter_all_0_1(tm0, tm1, ) {

delta.new_type_list_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_112_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(tm0, tm1, ) in self.pred_rel.iter_new() {

#[allow(unused_variables)]
for PredRel(_, tm2, ) in self.pred_rel.iter_all_0(tm0, ) {

delta.new_rel_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_113_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm0, tm1, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for FuncRel(_, tm2, ) in self.func_rel.iter_all_0(tm0, ) {

delta.new_rel_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_114_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm0, tm1, ) in self.nil_el_list.iter_new() {

#[allow(unused_variables)]
for NilElList(_, tm2, ) in self.nil_el_list.iter_all_0(tm0, ) {

delta.new_el_list_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_115_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm0, tm1, tm2, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for ConsElList(_, _, tm3, ) in self.cons_el_list.iter_all_0_1(tm0, tm1, ) {

delta.new_el_list_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_116_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm0, tm1, tm2, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for SnocElList(_, _, tm3, ) in self.snoc_el_list.iter_all_0_1(tm0, tm1, ) {

delta.new_el_list_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_117_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm0, tm1, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for AmbientType(_, tm2, ) in self.ambient_type.iter_all_0(tm0, ) {

delta.new_element_type_equalities.push((tm1, tm2));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_118_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm0, tm1, tm2, ) in self.instantiated_type.iter_new() {

#[allow(unused_variables)]
for InstantiatedType(_, _, tm3, ) in self.instantiated_type.iter_all_0_1(tm0, tm1, ) {

delta.new_element_type_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_119_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElementTypeList(tm0, ) in self.nil_element_type_list.iter_new() {

#[allow(unused_variables)]
for NilElementTypeList(tm1, ) in self.nil_element_type_list.iter_all() {

delta.new_element_type_list_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_120_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElementTypeList(tm0, tm1, tm2, ) in self.cons_element_type_list.iter_new() {

#[allow(unused_variables)]
for ConsElementTypeList(_, _, tm3, ) in self.cons_element_type_list.iter_all_0_1(tm0, tm1, ) {

delta.new_element_type_list_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_121_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElementTypeList(tm0, tm1, tm2, ) in self.snoc_element_type_list.iter_new() {

#[allow(unused_variables)]
for SnocElementTypeList(_, _, tm3, ) in self.snoc_element_type_list.iter_all_0_1(tm0, tm1, ) {

delta.new_element_type_list_equalities.push((tm2, tm3));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_122_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm0, ) in self.type_symbol.iter_new() {

#[allow(unused_variables)]
for TypeSymbol(tm1, ) in self.type_symbol.iter_all() {

delta.new_symbol_kind_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_123_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredSymbol(tm0, ) in self.pred_symbol.iter_new() {

#[allow(unused_variables)]
for PredSymbol(tm1, ) in self.pred_symbol.iter_all() {

delta.new_symbol_kind_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_124_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncSymbol(tm0, ) in self.func_symbol.iter_new() {

#[allow(unused_variables)]
for FuncSymbol(tm1, ) in self.func_symbol.iter_all() {

delta.new_symbol_kind_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_125_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleSymbol(tm0, ) in self.rule_symbol.iter_new() {

#[allow(unused_variables)]
for RuleSymbol(tm1, ) in self.rule_symbol.iter_all() {

delta.new_symbol_kind_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_126_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm0, ) in self.enum_symbol.iter_new() {

#[allow(unused_variables)]
for EnumSymbol(tm1, ) in self.enum_symbol.iter_all() {

delta.new_symbol_kind_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_127_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbol(tm0, ) in self.ctor_symbol.iter_new() {

#[allow(unused_variables)]
for CtorSymbol(tm1, ) in self.ctor_symbol.iter_all() {

delta.new_symbol_kind_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn implicit_functionality_128_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm0, ) in self.model_symbol.iter_new() {

#[allow(unused_variables)]
for ModelSymbol(tm1, ) in self.model_symbol.iter_all() {

delta.new_symbol_kind_equalities.push((tm0, tm1));



}

}

}
}


#[allow(unused_variables)]
fn real_virt_ident_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.real_virt_ident_total_1(delta, );
self.real_virt_ident_total_2(delta, );
self.real_virt_ident_total_5(delta, );




}
}

#[allow(unused_variables)]
fn real_virt_ident_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn real_virt_ident_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.ident_new.iter().copied() {

self.real_virt_ident_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn real_virt_ident_total_3(&self, delta: &mut ModelDelta, tm0: Ident) {
for _ in [()] {
self.real_virt_ident_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn real_virt_ident_total_4(&self, delta: &mut ModelDelta, tm0: Ident) {
for _ in [()] {
let tm1 = match self.real_virt_ident.iter_all_0(tm0).next() {
    Some(RealVirtIdent(_,  res)) => res,
    None => { 
        delta.new_real_virt_ident_def.push(RealVirtIdentArgs(tm0));
        break;
    },
};

self.real_virt_ident_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn real_virt_ident_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RealVirtIdent(tm0, tm1, ) in self.real_virt_ident.iter_new() {

self.real_virt_ident_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn real_virt_ident_total_6(&self, delta: &mut ModelDelta, tm0: Ident, tm1: VirtIdent) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn virt_real_ident_retraction_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.virt_real_ident_retraction_1(delta, );
self.virt_real_ident_retraction_2(delta, );



}
}

#[allow(unused_variables)]
fn virt_real_ident_retraction_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn virt_real_ident_retraction_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RealVirtIdent(tm1, tm0, ) in self.real_virt_ident.iter_new() {

self.virt_real_ident_retraction_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn virt_real_ident_retraction_3(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Ident) {
for _ in [()] {
let exists_already = self.virt_real_ident.iter_all_0_1(tm0, tm1).next().is_some();
if !exists_already {
delta.new_virt_real_ident.push(VirtRealIdent(tm0, tm1));
}



}
}


#[allow(unused_variables)]
fn rule_descendant_rule_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_rule_total_1(delta, );
self.rule_descendant_rule_total_2(delta, );
self.rule_descendant_rule_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_rule_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_rule_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.rule_decl_node_new.iter().copied() {

self.rule_descendant_rule_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_rule_total_3(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
for _ in [()] {
self.rule_descendant_rule_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_rule_total_4(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_rule.iter_all_0(tm0).next() {
    Some(RuleDescendantRule(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_rule_def.push(RuleDescendantRuleArgs(tm0));
        break;
    },
};

self.rule_descendant_rule_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_rule_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantRule(tm0, tm1, ) in self.rule_descendant_rule.iter_new() {

self.rule_descendant_rule_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_rule_total_6(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_term_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_term_total_1(delta, );
self.rule_descendant_term_total_2(delta, );
self.rule_descendant_term_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_term_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_term_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.term_node_new.iter().copied() {

self.rule_descendant_term_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_term_total_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
self.rule_descendant_term_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_term_total_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_term.iter_all_0(tm0).next() {
    Some(RuleDescendantTerm(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_term_def.push(RuleDescendantTermArgs(tm0));
        break;
    },
};

self.rule_descendant_term_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_term_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm1, ) in self.rule_descendant_term.iter_new() {

self.rule_descendant_term_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_term_total_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_term_list_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_term_list_total_1(delta, );
self.rule_descendant_term_list_total_2(delta, );
self.rule_descendant_term_list_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_term_list_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_term_list_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.term_list_node_new.iter().copied() {

self.rule_descendant_term_list_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_term_list_total_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
self.rule_descendant_term_list_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_term_list_total_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_term_list.iter_all_0(tm0).next() {
    Some(RuleDescendantTermList(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_term_list_def.push(RuleDescendantTermListArgs(tm0));
        break;
    },
};

self.rule_descendant_term_list_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_term_list_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(tm0, tm1, ) in self.rule_descendant_term_list.iter_new() {

self.rule_descendant_term_list_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_term_list_total_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_opt_term_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_opt_term_total_1(delta, );
self.rule_descendant_opt_term_total_2(delta, );
self.rule_descendant_opt_term_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_opt_term_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_opt_term_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.opt_term_node_new.iter().copied() {

self.rule_descendant_opt_term_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_opt_term_total_3(&self, delta: &mut ModelDelta, tm0: OptTermNode) {
for _ in [()] {
self.rule_descendant_opt_term_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_opt_term_total_4(&self, delta: &mut ModelDelta, tm0: OptTermNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_opt_term.iter_all_0(tm0).next() {
    Some(RuleDescendantOptTerm(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_opt_term_def.push(RuleDescendantOptTermArgs(tm0));
        break;
    },
};

self.rule_descendant_opt_term_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_opt_term_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantOptTerm(tm0, tm1, ) in self.rule_descendant_opt_term.iter_new() {

self.rule_descendant_opt_term_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_opt_term_total_6(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_if_atom_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_if_atom_total_1(delta, );
self.rule_descendant_if_atom_total_2(delta, );
self.rule_descendant_if_atom_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_if_atom_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_if_atom_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.if_atom_node_new.iter().copied() {

self.rule_descendant_if_atom_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_if_atom_total_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode) {
for _ in [()] {
self.rule_descendant_if_atom_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_if_atom_total_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_if_atom.iter_all_0(tm0).next() {
    Some(RuleDescendantIfAtom(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_if_atom_def.push(RuleDescendantIfAtomArgs(tm0));
        break;
    },
};

self.rule_descendant_if_atom_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_if_atom_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm1, ) in self.rule_descendant_if_atom.iter_new() {

self.rule_descendant_if_atom_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_if_atom_total_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_then_atom_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_then_atom_total_1(delta, );
self.rule_descendant_then_atom_total_2(delta, );
self.rule_descendant_then_atom_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_then_atom_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_then_atom_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.then_atom_node_new.iter().copied() {

self.rule_descendant_then_atom_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_then_atom_total_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode) {
for _ in [()] {
self.rule_descendant_then_atom_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_then_atom_total_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_then_atom.iter_all_0(tm0).next() {
    Some(RuleDescendantThenAtom(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_then_atom_def.push(RuleDescendantThenAtomArgs(tm0));
        break;
    },
};

self.rule_descendant_then_atom_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_then_atom_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm1, ) in self.rule_descendant_then_atom.iter_new() {

self.rule_descendant_then_atom_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_then_atom_total_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_match_case_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_match_case_total_1(delta, );
self.rule_descendant_match_case_total_2(delta, );
self.rule_descendant_match_case_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.match_case_node_new.iter().copied() {

self.rule_descendant_match_case_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_total_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode) {
for _ in [()] {
self.rule_descendant_match_case_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_total_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_match_case.iter_all_0(tm0).next() {
    Some(RuleDescendantMatchCase(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_match_case_def.push(RuleDescendantMatchCaseArgs(tm0));
        break;
    },
};

self.rule_descendant_match_case_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCase(tm0, tm1, ) in self.rule_descendant_match_case.iter_new() {

self.rule_descendant_match_case_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_total_6(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_match_case_list_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_match_case_list_total_1(delta, );
self.rule_descendant_match_case_list_total_2(delta, );
self.rule_descendant_match_case_list_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_list_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_list_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.match_case_list_node_new.iter().copied() {

self.rule_descendant_match_case_list_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_list_total_3(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode) {
for _ in [()] {
self.rule_descendant_match_case_list_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_list_total_4(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_match_case_list.iter_all_0(tm0).next() {
    Some(RuleDescendantMatchCaseList(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_match_case_list_def.push(RuleDescendantMatchCaseListArgs(tm0));
        break;
    },
};

self.rule_descendant_match_case_list_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_list_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCaseList(tm0, tm1, ) in self.rule_descendant_match_case_list.iter_new() {

self.rule_descendant_match_case_list_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_match_case_list_total_6(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_stmt_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_stmt_total_1(delta, );
self.rule_descendant_stmt_total_2(delta, );
self.rule_descendant_stmt_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.stmt_node_new.iter().copied() {

self.rule_descendant_stmt_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_total_3(&self, delta: &mut ModelDelta, tm0: StmtNode) {
for _ in [()] {
self.rule_descendant_stmt_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_total_4(&self, delta: &mut ModelDelta, tm0: StmtNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_stmt.iter_all_0(tm0).next() {
    Some(RuleDescendantStmt(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_stmt_def.push(RuleDescendantStmtArgs(tm0));
        break;
    },
};

self.rule_descendant_stmt_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(tm0, tm1, ) in self.rule_descendant_stmt.iter_new() {

self.rule_descendant_stmt_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_total_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_stmt_list_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_stmt_list_total_1(delta, );
self.rule_descendant_stmt_list_total_2(delta, );
self.rule_descendant_stmt_list_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_list_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_list_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.stmt_list_node_new.iter().copied() {

self.rule_descendant_stmt_list_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_list_total_3(&self, delta: &mut ModelDelta, tm0: StmtListNode) {
for _ in [()] {
self.rule_descendant_stmt_list_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_list_total_4(&self, delta: &mut ModelDelta, tm0: StmtListNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_stmt_list.iter_all_0(tm0).next() {
    Some(RuleDescendantStmtList(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_stmt_list_def.push(RuleDescendantStmtListArgs(tm0));
        break;
    },
};

self.rule_descendant_stmt_list_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_list_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(tm0, tm1, ) in self.rule_descendant_stmt_list.iter_new() {

self.rule_descendant_stmt_list_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_list_total_6(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_stmt_block_list_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_stmt_block_list_total_1(delta, );
self.rule_descendant_stmt_block_list_total_2(delta, );
self.rule_descendant_stmt_block_list_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_block_list_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_block_list_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.stmt_block_list_node_new.iter().copied() {

self.rule_descendant_stmt_block_list_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_block_list_total_3(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode) {
for _ in [()] {
self.rule_descendant_stmt_block_list_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_block_list_total_4(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_stmt_block_list.iter_all_0(tm0).next() {
    Some(RuleDescendantStmtBlockList(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_stmt_block_list_def.push(RuleDescendantStmtBlockListArgs(tm0));
        break;
    },
};

self.rule_descendant_stmt_block_list_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_block_list_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm0, tm1, ) in self.rule_descendant_stmt_block_list.iter_new() {

self.rule_descendant_stmt_block_list_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_stmt_block_list_total_6(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rule_descendant_type_expr_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_descendant_type_expr_total_1(delta, );
self.rule_descendant_type_expr_total_2(delta, );
self.rule_descendant_type_expr_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rule_descendant_type_expr_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_descendant_type_expr_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.type_expr_node_new.iter().copied() {

self.rule_descendant_type_expr_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_type_expr_total_3(&self, delta: &mut ModelDelta, tm0: TypeExprNode) {
for _ in [()] {
self.rule_descendant_type_expr_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rule_descendant_type_expr_total_4(&self, delta: &mut ModelDelta, tm0: TypeExprNode) {
for _ in [()] {
let tm1 = match self.rule_descendant_type_expr.iter_all_0(tm0).next() {
    Some(RuleDescendantTypeExpr(_,  res)) => res,
    None => { 
        delta.new_rule_descendant_type_expr_def.push(RuleDescendantTypeExprArgs(tm0));
        break;
    },
};

self.rule_descendant_type_expr_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rule_descendant_type_expr_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTypeExpr(tm0, tm1, ) in self.rule_descendant_type_expr.iter_new() {

self.rule_descendant_type_expr_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_descendant_type_expr_total_6(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: RuleDescendantNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn scope_extension_vars_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scope_extension_vars_1(delta, );
self.scope_extension_vars_2(delta, );
self.scope_extension_vars_5(delta, );




}
}

#[allow(unused_variables)]
fn scope_extension_vars_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scope_extension_vars_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarInScope(tm0, tm1, ) in self.var_in_scope.iter_new() {

self.scope_extension_vars_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scope_extension_vars_3(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope) {
for _ in [()] {
self.scope_extension_vars_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scope_extension_vars_4(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeExtension(_, tm2, ) in self.scope_extension.iter_all_0(tm1, ) {

self.scope_extension_vars_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scope_extension_vars_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeExtension(tm1, tm2, ) in self.scope_extension.iter_new() {

#[allow(unused_variables)]
for VarInScope(tm0, _, ) in self.var_in_scope.iter_old_1(tm1, ) {

self.scope_extension_vars_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scope_extension_vars_6(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope, tm2: Scope) {
for _ in [()] {
let exists_already = self.var_in_scope.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_var_in_scope.push(VarInScope(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn entry_exit_scope_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.entry_exit_scope_total_1(delta, );
self.entry_exit_scope_total_2(delta, );
self.entry_exit_scope_total_5(delta, );
self.entry_exit_scope_total_8(delta, );





}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.rule_descendant_node_new.iter().copied() {

self.entry_exit_scope_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_3(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode) {
for _ in [()] {
self.entry_exit_scope_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_4(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode) {
for _ in [()] {
let tm1 = match self.entry_scope.iter_all_0(tm0).next() {
    Some(EntryScope(_,  res)) => res,
    None => { 
        delta.new_entry_scope_def.push(EntryScopeArgs(tm0));
        break;
    },
};

self.entry_exit_scope_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm0, tm1, ) in self.entry_scope.iter_new() {

self.entry_exit_scope_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_6(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: Scope) {
for _ in [()] {
self.entry_exit_scope_total_7(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_7(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: Scope) {
for _ in [()] {
let tm2 = match self.exit_scope.iter_all_0(tm0).next() {
    Some(ExitScope(_,  res)) => res,
    None => { 
        delta.new_exit_scope_def.push(ExitScopeArgs(tm0));
        break;
    },
};

self.entry_exit_scope_total_9(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm0, tm2, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm1, ) in self.entry_scope.iter_old_0(tm0, ) {

self.entry_exit_scope_total_9(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn entry_exit_scope_total_9(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: Scope, tm2: Scope) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.exit_scope_extends_entry_scope_1(delta, );
self.exit_scope_extends_entry_scope_2(delta, );
self.exit_scope_extends_entry_scope_5(delta, );
self.exit_scope_extends_entry_scope_8(delta, );





}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.rule_descendant_node_new.iter().copied() {

self.exit_scope_extends_entry_scope_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_3(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode) {
for _ in [()] {
self.exit_scope_extends_entry_scope_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_4(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(_, tm1, ) in self.entry_scope.iter_all_0(tm0, ) {

self.exit_scope_extends_entry_scope_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm0, tm1, ) in self.entry_scope.iter_new() {

self.exit_scope_extends_entry_scope_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_6(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: Scope) {
for _ in [()] {
self.exit_scope_extends_entry_scope_7(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_7(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: Scope) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(_, tm2, ) in self.exit_scope.iter_all_0(tm0, ) {

self.exit_scope_extends_entry_scope_9(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm0, tm2, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm1, ) in self.entry_scope.iter_old_0(tm0, ) {

self.exit_scope_extends_entry_scope_9(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn exit_scope_extends_entry_scope_9(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: Scope, tm2: Scope) {
for _ in [()] {
let exists_already = self.scope_extension.iter_all_0_1(tm1, tm2).next().is_some();
if !exists_already {
delta.new_scope_extension.push(ScopeExtension(tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn scope_single_child_scopes_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scope_single_child_scopes_1(delta, );
self.scope_single_child_scopes_2(delta, );
self.scope_single_child_scopes_5(delta, );
self.scope_single_child_scopes_8(delta, );





}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSingleChild(tm0, tm1, ) in self.scope_single_child.iter_new() {

self.scope_single_child_scopes_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_3(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode) {
for _ in [()] {
self.scope_single_child_scopes_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_4(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(_, tm2, ) in self.entry_scope.iter_all_0(tm1, ) {

self.scope_single_child_scopes_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm1, tm2, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSingleChild(tm0, _, ) in self.scope_single_child.iter_old_1(tm1, ) {

self.scope_single_child_scopes_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_6(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: Scope) {
for _ in [()] {
self.scope_single_child_scopes_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_7(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: Scope) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(_, tm3, ) in self.exit_scope.iter_all_0(tm1, ) {

self.scope_single_child_scopes_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm1, tm3, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm2, ) in self.entry_scope.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for ScopeSingleChild(tm0, _, ) in self.scope_single_child.iter_old_1(tm1, ) {

self.scope_single_child_scopes_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scope_single_child_scopes_9(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: Scope, tm3: Scope) {
for _ in [()] {
let exists_already = self.entry_scope.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_entry_scope.push(EntryScope(tm0, tm2));
}

let exists_already = self.exit_scope.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_exit_scope.push(ExitScope(tm0, tm3));
}




}
}


#[allow(unused_variables)]
fn scope_extension_siblings_parent_first_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scope_extension_siblings_parent_first_1(delta, );
self.scope_extension_siblings_parent_first_2(delta, );
self.scope_extension_siblings_parent_first_5(delta, );




}
}

#[allow(unused_variables)]
fn scope_extension_siblings_parent_first_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_parent_first_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeExtensionSiblings(tm0, tm1, tm2, ) in self.scope_extension_siblings.iter_new() {

self.scope_extension_siblings_parent_first_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_parent_first_3(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scope_extension_siblings_parent_first_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scope_extension_siblings_parent_first_4(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(_, tm3, ) in self.entry_scope.iter_all_0(tm2, ) {

self.scope_extension_siblings_parent_first_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_parent_first_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm2, tm3, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeExtensionSiblings(tm0, tm1, _, ) in self.scope_extension_siblings.iter_old_2(tm2, ) {

self.scope_extension_siblings_parent_first_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_parent_first_6(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode, tm3: Scope) {
for _ in [()] {
let exists_already = self.entry_scope.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_entry_scope.push(EntryScope(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn scope_extension_siblings_first_second_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scope_extension_siblings_first_second_1(delta, );
self.scope_extension_siblings_first_second_2(delta, );
self.scope_extension_siblings_first_second_5(delta, );




}
}

#[allow(unused_variables)]
fn scope_extension_siblings_first_second_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_first_second_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeExtensionSiblings(tm0, tm1, tm2, ) in self.scope_extension_siblings.iter_new() {

self.scope_extension_siblings_first_second_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_first_second_3(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scope_extension_siblings_first_second_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scope_extension_siblings_first_second_4(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(_, tm3, ) in self.exit_scope.iter_all_0(tm0, ) {

self.scope_extension_siblings_first_second_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_first_second_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm0, tm3, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for ScopeExtensionSiblings(_, tm1, tm2, ) in self.scope_extension_siblings.iter_old_0(tm0, ) {

self.scope_extension_siblings_first_second_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_first_second_6(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode, tm3: Scope) {
for _ in [()] {
let exists_already = self.entry_scope.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_entry_scope.push(EntryScope(tm1, tm3));
}



}
}


#[allow(unused_variables)]
fn scope_extension_siblings_second_parent_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scope_extension_siblings_second_parent_1(delta, );
self.scope_extension_siblings_second_parent_2(delta, );
self.scope_extension_siblings_second_parent_5(delta, );




}
}

#[allow(unused_variables)]
fn scope_extension_siblings_second_parent_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_second_parent_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeExtensionSiblings(tm0, tm1, tm2, ) in self.scope_extension_siblings.iter_new() {

self.scope_extension_siblings_second_parent_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_second_parent_3(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scope_extension_siblings_second_parent_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scope_extension_siblings_second_parent_4(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(_, tm3, ) in self.exit_scope.iter_all_0(tm1, ) {

self.scope_extension_siblings_second_parent_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_second_parent_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm1, tm3, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for ScopeExtensionSiblings(tm0, _, tm2, ) in self.scope_extension_siblings.iter_old_1(tm1, ) {

self.scope_extension_siblings_second_parent_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scope_extension_siblings_second_parent_6(&self, delta: &mut ModelDelta, tm0: RuleDescendantNode, tm1: RuleDescendantNode, tm2: RuleDescendantNode, tm3: Scope) {
for _ in [()] {
let exists_already = self.exit_scope.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_exit_scope.push(ExitScope(tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_rule_stmts_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_rule_stmts_1(delta, );
self.scopes_rule_stmts_2(delta, );
self.scopes_rule_stmts_5(delta, );
self.scopes_rule_stmts_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDecl(tm0, tm1, ) in self.rule_decl.iter_new() {

self.scopes_rule_stmts_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_3(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode) {
for _ in [()] {
self.scopes_rule_stmts_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_4(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantRule(_, tm2, ) in self.rule_descendant_rule.iter_all_0(tm0, ) {

self.scopes_rule_stmts_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantRule(tm0, tm2, ) in self.rule_descendant_rule.iter_new() {

#[allow(unused_variables)]
for RuleDecl(_, tm1, ) in self.rule_decl.iter_old_0(tm0, ) {

self.scopes_rule_stmts_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_6(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_rule_stmts_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_7(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm3, ) in self.rule_descendant_stmt_list.iter_all_0(tm1, ) {

self.scopes_rule_stmts_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(tm1, tm3, ) in self.rule_descendant_stmt_list.iter_new() {

#[allow(unused_variables)]
for RuleDecl(tm0, _, ) in self.rule_decl.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantRule(_, tm2, ) in self.rule_descendant_rule.iter_old_0(tm0, ) {

self.scopes_rule_stmts_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_rule_stmts_9(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm3, tm2).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn scopes_stmt_list_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_stmt_list_cons_1(delta, );
self.scopes_stmt_list_cons_2(delta, );
self.scopes_stmt_list_cons_5(delta, );
self.scopes_stmt_list_cons_8(delta, );
self.scopes_stmt_list_cons_11(delta, );






}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm0, tm1, tm2, ) in self.cons_stmt_list_node.iter_new() {

self.scopes_stmt_list_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_3(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode) {
for _ in [()] {
self.scopes_stmt_list_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_4(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm3, ) in self.rule_descendant_stmt_list.iter_all_0(tm0, ) {

self.scopes_stmt_list_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(tm0, tm3, ) in self.rule_descendant_stmt_list.iter_new() {

#[allow(unused_variables)]
for ConsStmtListNode(_, tm1, tm2, ) in self.cons_stmt_list_node.iter_old_0(tm0, ) {

self.scopes_stmt_list_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_6(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_list_cons_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_7(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(_, tm4, ) in self.rule_descendant_stmt.iter_all_0(tm1, ) {

self.scopes_stmt_list_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(tm1, tm4, ) in self.rule_descendant_stmt.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmtList(tm0, tm3, ) in self.rule_descendant_stmt_list.iter_old() {

#[allow(unused_variables)]
for ConsStmtListNode(_, _, tm2, ) in self.cons_stmt_list_node.iter_old_0_1(tm0, tm1, ) {

self.scopes_stmt_list_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_9(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_list_cons_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_10(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm5, ) in self.rule_descendant_stmt_list.iter_all_0(tm2, ) {

self.scopes_stmt_list_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(tm2, tm5, ) in self.rule_descendant_stmt_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmtList(tm0, tm3, ) in self.rule_descendant_stmt_list.iter_old() {

#[allow(unused_variables)]
for ConsStmtListNode(_, tm1, _, ) in self.cons_stmt_list_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantStmt(_, tm4, ) in self.rule_descendant_stmt.iter_old_0(tm1, ) {

self.scopes_stmt_list_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_list_cons_12(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_extension_siblings.iter_all_0_1_2(tm4, tm5, tm3).next().is_some();
if !exists_already {
delta.new_scope_extension_siblings.push(ScopeExtensionSiblings(tm4, tm5, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_stmt_block_list_cons_1(delta, );
self.scopes_stmt_block_list_cons_2(delta, );
self.scopes_stmt_block_list_cons_5(delta, );
self.scopes_stmt_block_list_cons_8(delta, );
self.scopes_stmt_block_list_cons_11(delta, );
self.scopes_stmt_block_list_cons_14(delta, );







}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtBlockListNode(tm0, tm1, tm2, ) in self.cons_stmt_block_list_node.iter_new() {

self.scopes_stmt_block_list_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_3(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode) {
for _ in [()] {
self.scopes_stmt_block_list_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_4(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm3, ) in self.rule_descendant_stmt_block_list.iter_all_0(tm0, ) {

self.scopes_stmt_block_list_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm0, tm3, ) in self.rule_descendant_stmt_block_list.iter_new() {

#[allow(unused_variables)]
for ConsStmtBlockListNode(_, tm1, tm2, ) in self.cons_stmt_block_list_node.iter_old_0(tm0, ) {

self.scopes_stmt_block_list_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_6(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_block_list_cons_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_7(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm4, ) in self.rule_descendant_stmt_list.iter_all_0(tm1, ) {

self.scopes_stmt_block_list_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(tm1, tm4, ) in self.rule_descendant_stmt_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm0, tm3, ) in self.rule_descendant_stmt_block_list.iter_old() {

#[allow(unused_variables)]
for ConsStmtBlockListNode(_, _, tm2, ) in self.cons_stmt_block_list_node.iter_old_0_1(tm0, tm1, ) {

self.scopes_stmt_block_list_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_9(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_block_list_cons_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_10(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm5, ) in self.rule_descendant_stmt_block_list.iter_all_0(tm2, ) {

self.scopes_stmt_block_list_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm2, tm5, ) in self.rule_descendant_stmt_block_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm0, tm3, ) in self.rule_descendant_stmt_block_list.iter_old() {

#[allow(unused_variables)]
for ConsStmtBlockListNode(_, tm1, _, ) in self.cons_stmt_block_list_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm4, ) in self.rule_descendant_stmt_list.iter_old_0(tm1, ) {

self.scopes_stmt_block_list_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_12(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_block_list_cons_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_13(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(_, tm6, ) in self.entry_scope.iter_all_0(tm3, ) {

self.scopes_stmt_block_list_cons_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm3, tm6, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm0, _, ) in self.rule_descendant_stmt_block_list.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for ConsStmtBlockListNode(_, tm1, tm2, ) in self.cons_stmt_block_list_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm4, ) in self.rule_descendant_stmt_list.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm5, ) in self.rule_descendant_stmt_block_list.iter_old_0(tm2, ) {

self.scopes_stmt_block_list_cons_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_block_list_cons_15(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtListNode, tm2: StmtBlockListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode, tm6: Scope) {
for _ in [()] {
let exists_already = self.entry_scope.iter_all_0_1(tm4, tm6).next().is_some();
if !exists_already {
delta.new_entry_scope.push(EntryScope(tm4, tm6));
}

let exists_already = self.entry_scope.iter_all_0_1(tm5, tm6).next().is_some();
if !exists_already {
delta.new_entry_scope.push(EntryScope(tm5, tm6));
}




}
}


#[allow(unused_variables)]
fn scopes_stmt_if_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_stmt_if_1(delta, );
self.scopes_stmt_if_2(delta, );
self.scopes_stmt_if_5(delta, );
self.scopes_stmt_if_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_stmt_if_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_stmt_if_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfStmtNode(tm0, tm1, ) in self.if_stmt_node.iter_new() {

self.scopes_stmt_if_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_if_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
for _ in [()] {
self.scopes_stmt_if_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_stmt_if_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(_, tm2, ) in self.rule_descendant_stmt.iter_all_0(tm0, ) {

self.scopes_stmt_if_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_if_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(tm0, tm2, ) in self.rule_descendant_stmt.iter_new() {

#[allow(unused_variables)]
for IfStmtNode(_, tm1, ) in self.if_stmt_node.iter_old_0(tm0, ) {

self.scopes_stmt_if_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_if_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_if_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_stmt_if_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm3, ) in self.rule_descendant_if_atom.iter_all_0(tm1, ) {

self.scopes_stmt_if_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_if_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm1, tm3, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for IfStmtNode(tm0, _, ) in self.if_stmt_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmt(_, tm2, ) in self.rule_descendant_stmt.iter_old_0(tm0, ) {

self.scopes_stmt_if_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_if_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm3, tm2).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn scopes_stmt_then_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_stmt_then_1(delta, );
self.scopes_stmt_then_2(delta, );
self.scopes_stmt_then_5(delta, );
self.scopes_stmt_then_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_stmt_then_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_stmt_then_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenStmtNode(tm0, tm1, ) in self.then_stmt_node.iter_new() {

self.scopes_stmt_then_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_then_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
self.scopes_stmt_then_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_stmt_then_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(_, tm2, ) in self.rule_descendant_stmt.iter_all_0(tm0, ) {

self.scopes_stmt_then_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_then_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(tm0, tm2, ) in self.rule_descendant_stmt.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(_, tm1, ) in self.then_stmt_node.iter_old_0(tm0, ) {

self.scopes_stmt_then_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_then_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_then_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_stmt_then_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm3, ) in self.rule_descendant_then_atom.iter_all_0(tm1, ) {

self.scopes_stmt_then_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_then_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm1, tm3, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(tm0, _, ) in self.then_stmt_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmt(_, tm2, ) in self.rule_descendant_stmt.iter_old_0(tm0, ) {

self.scopes_stmt_then_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_then_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm3, tm2).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn scopes_stmt_branch_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_stmt_branch_1(delta, );
self.scopes_stmt_branch_2(delta, );
self.scopes_stmt_branch_5(delta, );
self.scopes_stmt_branch_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BranchStmtNode(tm0, tm1, ) in self.branch_stmt_node.iter_new() {

self.scopes_stmt_branch_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
self.scopes_stmt_branch_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(_, tm2, ) in self.rule_descendant_stmt.iter_all_0(tm0, ) {

self.scopes_stmt_branch_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(tm0, tm2, ) in self.rule_descendant_stmt.iter_new() {

#[allow(unused_variables)]
for BranchStmtNode(_, tm1, ) in self.branch_stmt_node.iter_old_0(tm0, ) {

self.scopes_stmt_branch_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_branch_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm3, ) in self.rule_descendant_stmt_block_list.iter_all_0(tm1, ) {

self.scopes_stmt_branch_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm1, tm3, ) in self.rule_descendant_stmt_block_list.iter_new() {

#[allow(unused_variables)]
for BranchStmtNode(tm0, _, ) in self.branch_stmt_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmt(_, tm2, ) in self.rule_descendant_stmt.iter_old_0(tm0, ) {

self.scopes_stmt_branch_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_branch_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm3, tm2).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn scopes_stmt_match_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_stmt_match_1(delta, );
self.scopes_stmt_match_2(delta, );
self.scopes_stmt_match_5(delta, );
self.scopes_stmt_match_8(delta, );
self.scopes_stmt_match_11(delta, );






}
}

#[allow(unused_variables)]
fn scopes_stmt_match_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_stmt_match_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.scopes_stmt_match_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_match_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.scopes_stmt_match_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_stmt_match_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(_, tm3, ) in self.rule_descendant_stmt.iter_all_0(tm0, ) {

self.scopes_stmt_match_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_match_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmt(tm0, tm3, ) in self.rule_descendant_stmt.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(_, tm1, tm2, ) in self.match_stmt_node.iter_old_0(tm0, ) {

self.scopes_stmt_match_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_match_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_match_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_stmt_match_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

self.scopes_stmt_match_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_match_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm4, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmt(tm0, tm3, ) in self.rule_descendant_stmt.iter_old() {

#[allow(unused_variables)]
for MatchStmtNode(_, _, tm2, ) in self.match_stmt_node.iter_old_0_1(tm0, tm1, ) {

self.scopes_stmt_match_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_match_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
self.scopes_stmt_match_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_stmt_match_10(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCaseList(_, tm5, ) in self.rule_descendant_match_case_list.iter_all_0(tm2, ) {

self.scopes_stmt_match_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_stmt_match_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCaseList(tm2, tm5, ) in self.rule_descendant_match_case_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantStmt(tm0, tm3, ) in self.rule_descendant_stmt.iter_old() {

#[allow(unused_variables)]
for MatchStmtNode(_, tm1, _, ) in self.match_stmt_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_old_0(tm1, ) {

self.scopes_stmt_match_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_stmt_match_12(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_extension_siblings.iter_all_0_1_2(tm4, tm5, tm3).next().is_some();
if !exists_already {
delta.new_scope_extension_siblings.push(ScopeExtensionSiblings(tm4, tm5, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_if_atom_equal_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_if_atom_equal_1(delta, );
self.scopes_if_atom_equal_2(delta, );
self.scopes_if_atom_equal_5(delta, );
self.scopes_if_atom_equal_8(delta, );
self.scopes_if_atom_equal_11(delta, );






}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EqualIfAtomNode(tm0, tm1, tm2, ) in self.equal_if_atom_node.iter_new() {

self.scopes_if_atom_equal_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
self.scopes_if_atom_equal_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm3, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

self.scopes_if_atom_equal_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm3, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for EqualIfAtomNode(_, tm1, tm2, ) in self.equal_if_atom_node.iter_old_0(tm0, ) {

self.scopes_if_atom_equal_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_if_atom_equal_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

self.scopes_if_atom_equal_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm4, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm3, ) in self.rule_descendant_if_atom.iter_old() {

#[allow(unused_variables)]
for EqualIfAtomNode(_, _, tm2, ) in self.equal_if_atom_node.iter_old_0_1(tm0, tm1, ) {

self.scopes_if_atom_equal_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_9(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
self.scopes_if_atom_equal_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_10(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm5, ) in self.rule_descendant_term.iter_all_0(tm2, ) {

self.scopes_if_atom_equal_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm2, tm5, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm3, ) in self.rule_descendant_if_atom.iter_old() {

#[allow(unused_variables)]
for EqualIfAtomNode(_, tm1, _, ) in self.equal_if_atom_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_old_0(tm1, ) {

self.scopes_if_atom_equal_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_equal_12(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_extension_siblings.iter_all_0_1_2(tm4, tm5, tm3).next().is_some();
if !exists_already {
delta.new_scope_extension_siblings.push(ScopeExtensionSiblings(tm4, tm5, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_if_atom_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_if_atom_defined_1(delta, );
self.scopes_if_atom_defined_2(delta, );
self.scopes_if_atom_defined_5(delta, );
self.scopes_if_atom_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedIfAtomNode(tm0, tm1, ) in self.defined_if_atom_node.iter_new() {

self.scopes_if_atom_defined_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode) {
for _ in [()] {
self.scopes_if_atom_defined_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm2, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

self.scopes_if_atom_defined_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm2, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for DefinedIfAtomNode(_, tm1, ) in self.defined_if_atom_node.iter_old_0(tm0, ) {

self.scopes_if_atom_defined_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_if_atom_defined_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm3, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

self.scopes_if_atom_defined_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm3, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for DefinedIfAtomNode(tm0, _, ) in self.defined_if_atom_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm2, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

self.scopes_if_atom_defined_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_defined_9(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm3, tm2).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn scopes_if_atom_pred_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_if_atom_pred_1(delta, );
self.scopes_if_atom_pred_2(delta, );
self.scopes_if_atom_pred_5(delta, );
self.scopes_if_atom_pred_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredIfAtomNode(tm0, tm1, tm2, ) in self.pred_if_atom_node.iter_new() {

self.scopes_if_atom_pred_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.scopes_if_atom_pred_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm3, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

self.scopes_if_atom_pred_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm3, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.scopes_if_atom_pred_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_if_atom_pred_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(_, tm4, ) in self.rule_descendant_term_list.iter_all_0(tm2, ) {

self.scopes_if_atom_pred_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(tm2, tm4, ) in self.rule_descendant_term_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm3, ) in self.rule_descendant_if_atom.iter_old() {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, _, ) in self.pred_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.scopes_if_atom_pred_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_pred_9(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm4, tm3).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_if_atom_var_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_if_atom_var_1(delta, );
self.scopes_if_atom_var_2(delta, );
self.scopes_if_atom_var_5(delta, );
self.scopes_if_atom_var_8(delta, );
self.scopes_if_atom_var_11(delta, );






}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, tm2, ) in self.var_if_atom_node.iter_new() {

self.scopes_if_atom_var_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
self.scopes_if_atom_var_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm3, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

self.scopes_if_atom_var_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm3, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

self.scopes_if_atom_var_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_if_atom_var_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

self.scopes_if_atom_var_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm4, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm3, ) in self.rule_descendant_if_atom.iter_old() {

#[allow(unused_variables)]
for VarIfAtomNode(_, _, tm2, ) in self.var_if_atom_node.iter_old_0_1(tm0, tm1, ) {

self.scopes_if_atom_var_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_9(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
self.scopes_if_atom_var_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_10(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTypeExpr(_, tm5, ) in self.rule_descendant_type_expr.iter_all_0(tm2, ) {

self.scopes_if_atom_var_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTypeExpr(tm2, tm5, ) in self.rule_descendant_type_expr.iter_new() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm3, ) in self.rule_descendant_if_atom.iter_old() {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, _, ) in self.var_if_atom_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_old_0(tm1, ) {

self.scopes_if_atom_var_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_if_atom_var_12(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_extension_siblings.iter_all_0_1_2(tm5, tm4, tm3).next().is_some();
if !exists_already {
delta.new_scope_extension_siblings.push(ScopeExtensionSiblings(tm5, tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_then_atom_equal_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_then_atom_equal_1(delta, );
self.scopes_then_atom_equal_2(delta, );
self.scopes_then_atom_equal_5(delta, );
self.scopes_then_atom_equal_8(delta, );
self.scopes_then_atom_equal_11(delta, );






}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EqualThenAtomNode(tm0, tm1, tm2, ) in self.equal_then_atom_node.iter_new() {

self.scopes_then_atom_equal_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
self.scopes_then_atom_equal_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm3, ) in self.rule_descendant_then_atom.iter_all_0(tm0, ) {

self.scopes_then_atom_equal_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm3, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for EqualThenAtomNode(_, tm1, tm2, ) in self.equal_then_atom_node.iter_old_0(tm0, ) {

self.scopes_then_atom_equal_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_then_atom_equal_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_7(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

self.scopes_then_atom_equal_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm4, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm3, ) in self.rule_descendant_then_atom.iter_old() {

#[allow(unused_variables)]
for EqualThenAtomNode(_, _, tm2, ) in self.equal_then_atom_node.iter_old_0_1(tm0, tm1, ) {

self.scopes_then_atom_equal_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_9(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
self.scopes_then_atom_equal_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_10(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm5, ) in self.rule_descendant_term.iter_all_0(tm2, ) {

self.scopes_then_atom_equal_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm2, tm5, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm3, ) in self.rule_descendant_then_atom.iter_old() {

#[allow(unused_variables)]
for EqualThenAtomNode(_, tm1, _, ) in self.equal_then_atom_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_old_0(tm1, ) {

self.scopes_then_atom_equal_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_equal_12(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_extension_siblings.iter_all_0_1_2(tm4, tm5, tm3).next().is_some();
if !exists_already {
delta.new_scope_extension_siblings.push(ScopeExtensionSiblings(tm4, tm5, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_then_atom_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_then_atom_defined_1(delta, );
self.scopes_then_atom_defined_2(delta, );
self.scopes_then_atom_defined_5(delta, );
self.scopes_then_atom_defined_8(delta, );
self.scopes_then_atom_defined_11(delta, );






}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, tm1, tm2, ) in self.defined_then_atom_node.iter_new() {

self.scopes_then_atom_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
self.scopes_then_atom_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm3, ) in self.rule_descendant_then_atom.iter_all_0(tm0, ) {

self.scopes_then_atom_defined_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm3, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, tm2, ) in self.defined_then_atom_node.iter_old_0(tm0, ) {

self.scopes_then_atom_defined_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_then_atom_defined_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_7(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantOptTerm(_, tm4, ) in self.rule_descendant_opt_term.iter_all_0(tm1, ) {

self.scopes_then_atom_defined_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantOptTerm(tm1, tm4, ) in self.rule_descendant_opt_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm3, ) in self.rule_descendant_then_atom.iter_old() {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, _, tm2, ) in self.defined_then_atom_node.iter_old_0_1(tm0, tm1, ) {

self.scopes_then_atom_defined_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_9(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
self.scopes_then_atom_defined_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_10(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm5, ) in self.rule_descendant_term.iter_all_0(tm2, ) {

self.scopes_then_atom_defined_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm2, tm5, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm3, ) in self.rule_descendant_then_atom.iter_old() {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, _, ) in self.defined_then_atom_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantOptTerm(_, tm4, ) in self.rule_descendant_opt_term.iter_old_0(tm1, ) {

self.scopes_then_atom_defined_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_defined_12(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_extension_siblings.iter_all_0_1_2(tm4, tm5, tm3).next().is_some();
if !exists_already {
delta.new_scope_extension_siblings.push(ScopeExtensionSiblings(tm4, tm5, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_then_atom_pred_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_then_atom_pred_1(delta, );
self.scopes_then_atom_pred_2(delta, );
self.scopes_then_atom_pred_5(delta, );
self.scopes_then_atom_pred_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredThenAtomNode(tm0, tm1, tm2, ) in self.pred_then_atom_node.iter_new() {

self.scopes_then_atom_pred_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.scopes_then_atom_pred_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm3, ) in self.rule_descendant_then_atom.iter_all_0(tm0, ) {

self.scopes_then_atom_pred_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm3, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.scopes_then_atom_pred_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_then_atom_pred_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_7(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(_, tm4, ) in self.rule_descendant_term_list.iter_all_0(tm2, ) {

self.scopes_then_atom_pred_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(tm2, tm4, ) in self.rule_descendant_term_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm3, ) in self.rule_descendant_then_atom.iter_old() {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, _, ) in self.pred_then_atom_node.iter_old_0_2(tm0, tm2, ) {

self.scopes_then_atom_pred_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_then_atom_pred_9(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_extension_siblings.iter_all_0_1_2(tm3, tm4, tm3).next().is_some();
if !exists_already {
delta.new_scope_extension_siblings.push(ScopeExtensionSiblings(tm3, tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_term_list_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_term_list_cons_1(delta, );
self.scopes_term_list_cons_2(delta, );
self.scopes_term_list_cons_5(delta, );
self.scopes_term_list_cons_8(delta, );
self.scopes_term_list_cons_11(delta, );






}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTermListNode(tm0, tm1, tm2, ) in self.cons_term_list_node.iter_new() {

self.scopes_term_list_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_3(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
self.scopes_term_list_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_4(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(_, tm3, ) in self.rule_descendant_term_list.iter_all_0(tm0, ) {

self.scopes_term_list_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(tm0, tm3, ) in self.rule_descendant_term_list.iter_new() {

#[allow(unused_variables)]
for ConsTermListNode(_, tm1, tm2, ) in self.cons_term_list_node.iter_old_0(tm0, ) {

self.scopes_term_list_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_term_list_cons_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_7(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

self.scopes_term_list_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm4, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTermList(tm0, tm3, ) in self.rule_descendant_term_list.iter_old() {

#[allow(unused_variables)]
for ConsTermListNode(_, _, tm2, ) in self.cons_term_list_node.iter_old_0_1(tm0, tm1, ) {

self.scopes_term_list_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_9(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
self.scopes_term_list_cons_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_10(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(_, tm5, ) in self.rule_descendant_term_list.iter_all_0(tm2, ) {

self.scopes_term_list_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(tm2, tm5, ) in self.rule_descendant_term_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTermList(tm0, tm3, ) in self.rule_descendant_term_list.iter_old() {

#[allow(unused_variables)]
for ConsTermListNode(_, tm1, _, ) in self.cons_term_list_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_old_0(tm1, ) {

self.scopes_term_list_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_term_list_cons_12(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode, tm5: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_extension_siblings.iter_all_0_1_2(tm4, tm5, tm3).next().is_some();
if !exists_already {
delta.new_scope_extension_siblings.push(ScopeExtensionSiblings(tm4, tm5, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_opt_term_some_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_opt_term_some_1(delta, );
self.scopes_opt_term_some_2(delta, );
self.scopes_opt_term_some_5(delta, );
self.scopes_opt_term_some_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SomeTermNode(tm0, tm1, ) in self.some_term_node.iter_new() {

self.scopes_opt_term_some_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_3(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode) {
for _ in [()] {
self.scopes_opt_term_some_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_4(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantOptTerm(_, tm2, ) in self.rule_descendant_opt_term.iter_all_0(tm0, ) {

self.scopes_opt_term_some_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantOptTerm(tm0, tm2, ) in self.rule_descendant_opt_term.iter_new() {

#[allow(unused_variables)]
for SomeTermNode(_, tm1, ) in self.some_term_node.iter_old_0(tm0, ) {

self.scopes_opt_term_some_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_6(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_opt_term_some_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_7(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm3, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

self.scopes_opt_term_some_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm3, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for SomeTermNode(tm0, _, ) in self.some_term_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantOptTerm(_, tm2, ) in self.rule_descendant_opt_term.iter_old_0(tm0, ) {

self.scopes_opt_term_some_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_opt_term_some_9(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm3, tm2).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn scopes_term_app_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_term_app_1(delta, );
self.scopes_term_app_2(delta, );
self.scopes_term_app_5(delta, );
self.scopes_term_app_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_term_app_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_term_app_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm0, tm1, tm2, ) in self.app_term_node.iter_new() {

self.scopes_term_app_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_term_app_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.scopes_term_app_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_term_app_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm3, ) in self.rule_descendant_term.iter_all_0(tm0, ) {

self.scopes_term_app_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_term_app_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm3, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.scopes_term_app_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_term_app_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_term_app_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_term_app_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(_, tm4, ) in self.rule_descendant_term_list.iter_all_0(tm2, ) {

self.scopes_term_app_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_term_app_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTermList(tm2, tm4, ) in self.rule_descendant_term_list.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm3, ) in self.rule_descendant_term.iter_old() {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

self.scopes_term_app_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_term_app_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm4, tm3).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_term_var_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_term_var_1(delta, );
self.scopes_term_var_2(delta, );
self.scopes_term_var_5(delta, );
self.scopes_term_var_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_term_var_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_term_var_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarTermNode(tm0, tm1, ) in self.var_term_node.iter_new() {

self.scopes_term_var_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_term_var_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
for _ in [()] {
self.scopes_term_var_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_term_var_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm2, ) in self.rule_descendant_term.iter_all_0(tm0, ) {

self.scopes_term_var_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_term_var_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm2, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_old_0(tm0, ) {

self.scopes_term_var_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_term_var_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_term_var_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_term_var_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(_, tm3, ) in self.exit_scope.iter_all_0(tm2, ) {

self.scopes_term_var_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_term_var_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm2, tm3, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_old_0(tm0, ) {

self.scopes_term_var_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_term_var_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: RuleDescendantNode, tm3: Scope) {
for _ in [()] {
let exists_already = self.var_in_scope.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_var_in_scope.push(VarInScope(tm1, tm3));
}



}
}


#[allow(unused_variables)]
fn scopes_member_type_expr_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_member_type_expr_1(delta, );
self.scopes_member_type_expr_2(delta, );
self.scopes_member_type_expr_5(delta, );
self.scopes_member_type_expr_8(delta, );





}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MemberTypeExpr(tm0, tm1, tm2, ) in self.member_type_expr.iter_new() {

self.scopes_member_type_expr_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_3(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: TermNode, tm2: Ident) {
for _ in [()] {
self.scopes_member_type_expr_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_4(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: TermNode, tm2: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTypeExpr(_, tm3, ) in self.rule_descendant_type_expr.iter_all_0(tm0, ) {

self.scopes_member_type_expr_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTypeExpr(tm0, tm3, ) in self.rule_descendant_type_expr.iter_new() {

#[allow(unused_variables)]
for MemberTypeExpr(_, tm1, tm2, ) in self.member_type_expr.iter_old_0(tm0, ) {

self.scopes_member_type_expr_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_6(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: TermNode, tm2: Ident, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_member_type_expr_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_7(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: TermNode, tm2: Ident, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm4, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

self.scopes_member_type_expr_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm4, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTypeExpr(tm0, tm3, ) in self.rule_descendant_type_expr.iter_old() {

#[allow(unused_variables)]
for MemberTypeExpr(_, _, tm2, ) in self.member_type_expr.iter_old_0_1(tm0, tm1, ) {

self.scopes_member_type_expr_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_member_type_expr_9(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: TermNode, tm2: Ident, tm3: RuleDescendantNode, tm4: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_single_child.iter_all_0_1(tm4, tm3).next().is_some();
if !exists_already {
delta.new_scope_single_child.push(ScopeSingleChild(tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn enum_ctors_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.enum_ctors_1(delta, );
self.enum_ctors_2(delta, );



}
}

#[allow(unused_variables)]
fn enum_ctors_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn enum_ctors_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm0, tm1, tm2, ) in self.enum_decl.iter_new() {

self.enum_ctors_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn enum_ctors_3(&self, delta: &mut ModelDelta, tm0: EnumDeclNode, tm1: Ident, tm2: CtorDeclListNode) {
for _ in [()] {
let exists_already = self.ctors_enum.iter_all_0_1(tm2, tm0).next().is_some();
if !exists_already {
delta.new_ctors_enum.push(CtorsEnum(tm2, tm0));
}



}
}


#[allow(unused_variables)]
fn enum_ctors_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.enum_ctors_cons_1(delta, );
self.enum_ctors_cons_2(delta, );
self.enum_ctors_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn enum_ctors_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn enum_ctors_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorsEnum(tm1, tm0, ) in self.ctors_enum.iter_new() {

self.enum_ctors_cons_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn enum_ctors_cons_3(&self, delta: &mut ModelDelta, tm0: EnumDeclNode, tm1: CtorDeclListNode) {
for _ in [()] {
self.enum_ctors_cons_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn enum_ctors_cons_4(&self, delta: &mut ModelDelta, tm0: EnumDeclNode, tm1: CtorDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsCtorDeclListNode(_, tm2, tm3, ) in self.cons_ctor_decl_list_node.iter_all_0(tm1, ) {

self.enum_ctors_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn enum_ctors_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsCtorDeclListNode(tm1, tm2, tm3, ) in self.cons_ctor_decl_list_node.iter_new() {

#[allow(unused_variables)]
for CtorsEnum(_, tm0, ) in self.ctors_enum.iter_old_0(tm1, ) {

self.enum_ctors_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn enum_ctors_cons_6(&self, delta: &mut ModelDelta, tm0: EnumDeclNode, tm1: CtorDeclListNode, tm2: CtorDeclNode, tm3: CtorDeclListNode) {
for _ in [()] {
let exists_already = self.ctor_enum.iter_all_0_1(tm2, tm0).next().is_some();
if !exists_already {
delta.new_ctor_enum.push(CtorEnum(tm2, tm0));
}

let exists_already = self.ctors_enum.iter_all_0_1(tm3, tm0).next().is_some();
if !exists_already {
delta.new_ctors_enum.push(CtorsEnum(tm3, tm0));
}




}
}


#[allow(unused_variables)]
fn match_stmt_cases_discriminee_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_stmt_cases_discriminee_1(delta, );
self.match_stmt_cases_discriminee_2(delta, );



}
}

#[allow(unused_variables)]
fn match_stmt_cases_discriminee_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_stmt_cases_discriminee_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.match_stmt_cases_discriminee_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_stmt_cases_discriminee_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
let exists_already = self.cases_discriminee.iter_all_0_1(tm2, tm1).next().is_some();
if !exists_already {
delta.new_cases_discriminee.push(CasesDiscriminee(tm2, tm1));
}



}
}


#[allow(unused_variables)]
fn cases_match_stmt_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cases_match_stmt_cons_1(delta, );
self.cases_match_stmt_cons_2(delta, );
self.cases_match_stmt_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn cases_match_stmt_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cases_match_stmt_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CasesDiscriminee(tm1, tm0, ) in self.cases_discriminee.iter_new() {

self.cases_match_stmt_cons_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cases_match_stmt_cons_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseListNode) {
for _ in [()] {
self.cases_match_stmt_cons_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cases_match_stmt_cons_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsMatchCaseListNode(_, tm2, tm3, ) in self.cons_match_case_list_node.iter_all_0(tm1, ) {

self.cases_match_stmt_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cases_match_stmt_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsMatchCaseListNode(tm1, tm2, tm3, ) in self.cons_match_case_list_node.iter_new() {

#[allow(unused_variables)]
for CasesDiscriminee(_, tm0, ) in self.cases_discriminee.iter_old_0(tm1, ) {

self.cases_match_stmt_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cases_match_stmt_cons_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseListNode, tm2: MatchCaseNode, tm3: MatchCaseListNode) {
for _ in [()] {
let exists_already = self.case_discriminee.iter_all_0_1(tm2, tm0).next().is_some();
if !exists_already {
delta.new_case_discriminee.push(CaseDiscriminee(tm2, tm0));
}

let exists_already = self.cases_discriminee.iter_all_0_1(tm3, tm0).next().is_some();
if !exists_already {
delta.new_cases_discriminee.push(CasesDiscriminee(tm3, tm0));
}




}
}


#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.desugared_case_equality_stmt_loc_1(delta, );
self.desugared_case_equality_stmt_loc_2(delta, );
self.desugared_case_equality_stmt_loc_5(delta, );
self.desugared_case_equality_stmt_loc_8(delta, );





}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm0, tm1, tm2, ) in self.match_case.iter_new() {

self.desugared_case_equality_stmt_loc_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.desugared_case_equality_stmt_loc_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(_, tm3, ) in self.term_node_loc.iter_all_0(tm1, ) {

self.desugared_case_equality_stmt_loc_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm1, tm3, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for MatchCase(tm0, _, tm2, ) in self.match_case.iter_old_1(tm1, ) {

self.desugared_case_equality_stmt_loc_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_6(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: Loc) {
for _ in [()] {
self.desugared_case_equality_stmt_loc_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_7(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: Loc) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(_, tm4, ) in self.desugared_case_equality_stmt.iter_all_0(tm0, ) {

self.desugared_case_equality_stmt_loc_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(tm0, tm4, ) in self.desugared_case_equality_stmt.iter_new() {

#[allow(unused_variables)]
for TermNodeLoc(tm1, tm3, ) in self.term_node_loc.iter_old() {

#[allow(unused_variables)]
for MatchCase(_, _, tm2, ) in self.match_case.iter_old_0_1(tm0, tm1, ) {

self.desugared_case_equality_stmt_loc_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_stmt_loc_9(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: Loc, tm4: StmtNode) {
for _ in [()] {
let exists_already = self.stmt_node_loc.iter_all_0_1(tm4, tm3).next().is_some();
if !exists_already {
delta.new_stmt_node_loc.push(StmtNodeLoc(tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn desugared_case_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.desugared_case_defined_1(delta, );
self.desugared_case_defined_2(delta, );
self.desugared_case_defined_5(delta, );
self.desugared_case_defined_8(delta, );
self.desugared_case_defined_11(delta, );






}
}

#[allow(unused_variables)]
fn desugared_case_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn desugared_case_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm0, tm1, tm2, ) in self.match_case.iter_new() {

self.desugared_case_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn desugared_case_defined_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.desugared_case_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn desugared_case_defined_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
let tm3 = match self.desugared_case_equality_atom.iter_all_0(tm0).next() {
    Some(DesugaredCaseEqualityAtom(_,  res)) => res,
    None => { 
        delta.new_desugared_case_equality_atom_def.push(DesugaredCaseEqualityAtomArgs(tm0));
        break;
    },
};

self.desugared_case_defined_6(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn desugared_case_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityAtom(tm0, tm3, ) in self.desugared_case_equality_atom.iter_new() {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

self.desugared_case_defined_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn desugared_case_defined_6(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: IfAtomNode) {
for _ in [()] {
self.desugared_case_defined_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn desugared_case_defined_7(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: IfAtomNode) {
for _ in [()] {
let tm4 = match self.desugared_case_equality_stmt.iter_all_0(tm0).next() {
    Some(DesugaredCaseEqualityStmt(_,  res)) => res,
    None => { 
        delta.new_desugared_case_equality_stmt_def.push(DesugaredCaseEqualityStmtArgs(tm0));
        break;
    },
};

self.desugared_case_defined_9(delta, tm0, tm1, tm2, tm3, tm4);



}
}

#[allow(unused_variables)]
fn desugared_case_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(tm0, tm4, ) in self.desugared_case_equality_stmt.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseEqualityAtom(_, tm3, ) in self.desugared_case_equality_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

self.desugared_case_defined_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn desugared_case_defined_9(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: IfAtomNode, tm4: StmtNode) {
for _ in [()] {
self.desugared_case_defined_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn desugared_case_defined_10(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: IfAtomNode, tm4: StmtNode) {
for _ in [()] {
let tm5 = match self.desugared_case_block.iter_all_0(tm0).next() {
    Some(DesugaredCaseBlock(_,  res)) => res,
    None => { 
        delta.new_desugared_case_block_def.push(DesugaredCaseBlockArgs(tm0));
        break;
    },
};

self.desugared_case_defined_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn desugared_case_defined_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlock(tm0, tm5, ) in self.desugared_case_block.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(_, tm4, ) in self.desugared_case_equality_stmt.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for DesugaredCaseEqualityAtom(_, tm3, ) in self.desugared_case_equality_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

self.desugared_case_defined_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn desugared_case_defined_12(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: IfAtomNode, tm4: StmtNode, tm5: StmtListNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn desugared_case_block_list_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.desugared_case_block_list_defined_1(delta, );
self.desugared_case_block_list_defined_2(delta, );
self.desugared_case_block_list_defined_5(delta, );




}
}

#[allow(unused_variables)]
fn desugared_case_block_list_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn desugared_case_block_list_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.match_case_list_node_new.iter().copied() {

self.desugared_case_block_list_defined_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn desugared_case_block_list_defined_3(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode) {
for _ in [()] {
self.desugared_case_block_list_defined_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn desugared_case_block_list_defined_4(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode) {
for _ in [()] {
let tm1 = match self.desugared_case_block_list.iter_all_0(tm0).next() {
    Some(DesugaredCaseBlockList(_,  res)) => res,
    None => { 
        delta.new_desugared_case_block_list_def.push(DesugaredCaseBlockListArgs(tm0));
        break;
    },
};

self.desugared_case_block_list_defined_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn desugared_case_block_list_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(tm0, tm1, ) in self.desugared_case_block_list.iter_new() {

self.desugared_case_block_list_defined_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn desugared_case_block_list_defined_6(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: StmtBlockListNode) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.desugared_case_equality_atom_stmt_1(delta, );
self.desugared_case_equality_atom_stmt_2(delta, );
self.desugared_case_equality_atom_stmt_5(delta, );
self.desugared_case_equality_atom_stmt_8(delta, );
self.desugared_case_equality_atom_stmt_11(delta, );






}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CaseDiscriminee(tm1, tm0, ) in self.case_discriminee.iter_new() {

self.desugared_case_equality_atom_stmt_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseNode) {
for _ in [()] {
self.desugared_case_equality_atom_stmt_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseNode) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(_, tm2, tm3, ) in self.match_case.iter_all_0(tm1, ) {

self.desugared_case_equality_atom_stmt_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm1, tm2, tm3, ) in self.match_case.iter_new() {

#[allow(unused_variables)]
for CaseDiscriminee(_, tm0, ) in self.case_discriminee.iter_old_0(tm1, ) {

self.desugared_case_equality_atom_stmt_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseNode, tm2: TermNode, tm3: StmtListNode) {
for _ in [()] {
self.desugared_case_equality_atom_stmt_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseNode, tm2: TermNode, tm3: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityAtom(_, tm4, ) in self.desugared_case_equality_atom.iter_all_0(tm1, ) {

self.desugared_case_equality_atom_stmt_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityAtom(tm1, tm4, ) in self.desugared_case_equality_atom.iter_new() {

#[allow(unused_variables)]
for CaseDiscriminee(_, tm0, ) in self.case_discriminee.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for MatchCase(_, tm2, tm3, ) in self.match_case.iter_old_0(tm1, ) {

self.desugared_case_equality_atom_stmt_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseNode, tm2: TermNode, tm3: StmtListNode, tm4: IfAtomNode) {
for _ in [()] {
self.desugared_case_equality_atom_stmt_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_10(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseNode, tm2: TermNode, tm3: StmtListNode, tm4: IfAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(_, tm5, ) in self.desugared_case_equality_stmt.iter_all_0(tm1, ) {

self.desugared_case_equality_atom_stmt_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(tm1, tm5, ) in self.desugared_case_equality_stmt.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseEqualityAtom(_, tm4, ) in self.desugared_case_equality_atom.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for CaseDiscriminee(_, tm0, ) in self.case_discriminee.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for MatchCase(_, tm2, tm3, ) in self.match_case.iter_old_0(tm1, ) {

self.desugared_case_equality_atom_stmt_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn desugared_case_equality_atom_stmt_12(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: MatchCaseNode, tm2: TermNode, tm3: StmtListNode, tm4: IfAtomNode, tm5: StmtNode) {
for _ in [()] {
let exists_already = self.equal_if_atom_node.iter_all_0_1_2(tm4, tm0, tm2).next().is_some();
if !exists_already {
delta.new_equal_if_atom_node.push(EqualIfAtomNode(tm4, tm0, tm2));
}

let exists_already = self.if_stmt_node.iter_all_0_1(tm5, tm4).next().is_some();
if !exists_already {
delta.new_if_stmt_node.push(IfStmtNode(tm5, tm4));
}




}
}


#[allow(unused_variables)]
fn desugared_case_block_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.desugared_case_block_structure_1(delta, );
self.desugared_case_block_structure_2(delta, );
self.desugared_case_block_structure_5(delta, );
self.desugared_case_block_structure_8(delta, );





}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm0, tm1, tm2, ) in self.match_case.iter_new() {

self.desugared_case_block_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.desugared_case_block_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(_, tm3, ) in self.desugared_case_equality_stmt.iter_all_0(tm0, ) {

self.desugared_case_block_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(tm0, tm3, ) in self.desugared_case_equality_stmt.iter_new() {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

self.desugared_case_block_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_6(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: StmtNode) {
for _ in [()] {
self.desugared_case_block_structure_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_7(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: StmtNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlock(_, tm4, ) in self.desugared_case_block.iter_all_0(tm0, ) {

self.desugared_case_block_structure_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlock(tm0, tm4, ) in self.desugared_case_block.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseEqualityStmt(_, tm3, ) in self.desugared_case_equality_stmt.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

self.desugared_case_block_structure_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn desugared_case_block_structure_9(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: StmtNode, tm4: StmtListNode) {
for _ in [()] {
let exists_already = self.cons_stmt_list_node.iter_all_0_1_2(tm4, tm3, tm2).next().is_some();
if !exists_already {
delta.new_cons_stmt_list_node.push(ConsStmtListNode(tm4, tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn desugared_case_blocks_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.desugared_case_blocks_1(delta, );
self.desugared_case_blocks_2(delta, );
self.desugared_case_blocks_5(delta, );
self.desugared_case_blocks_8(delta, );
self.desugared_case_blocks_11(delta, );






}
}

#[allow(unused_variables)]
fn desugared_case_blocks_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn desugared_case_blocks_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, tm1, tm2, ) in self.cons_match_case_list_node.iter_new() {

self.desugared_case_blocks_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn desugared_case_blocks_3(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.desugared_case_blocks_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn desugared_case_blocks_4(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(_, tm3, ) in self.desugared_case_block_list.iter_all_0(tm0, ) {

self.desugared_case_blocks_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn desugared_case_blocks_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(tm0, tm3, ) in self.desugared_case_block_list.iter_new() {

#[allow(unused_variables)]
for ConsMatchCaseListNode(_, tm1, tm2, ) in self.cons_match_case_list_node.iter_old_0(tm0, ) {

self.desugared_case_blocks_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn desugared_case_blocks_6(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: StmtBlockListNode) {
for _ in [()] {
self.desugared_case_blocks_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn desugared_case_blocks_7(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: StmtBlockListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlock(_, tm4, ) in self.desugared_case_block.iter_all_0(tm1, ) {

self.desugared_case_blocks_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn desugared_case_blocks_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlock(tm1, tm4, ) in self.desugared_case_block.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseBlockList(tm0, tm3, ) in self.desugared_case_block_list.iter_old() {

#[allow(unused_variables)]
for ConsMatchCaseListNode(_, _, tm2, ) in self.cons_match_case_list_node.iter_old_0_1(tm0, tm1, ) {

self.desugared_case_blocks_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn desugared_case_blocks_9(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: StmtBlockListNode, tm4: StmtListNode) {
for _ in [()] {
self.desugared_case_blocks_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn desugared_case_blocks_10(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: StmtBlockListNode, tm4: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(_, tm5, ) in self.desugared_case_block_list.iter_all_0(tm2, ) {

self.desugared_case_blocks_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn desugared_case_blocks_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(tm2, tm5, ) in self.desugared_case_block_list.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseBlockList(tm0, tm3, ) in self.desugared_case_block_list.iter_old() {

#[allow(unused_variables)]
for ConsMatchCaseListNode(_, tm1, _, ) in self.cons_match_case_list_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for DesugaredCaseBlock(_, tm4, ) in self.desugared_case_block.iter_old_0(tm1, ) {

self.desugared_case_blocks_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn desugared_case_blocks_12(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: StmtBlockListNode, tm4: StmtListNode, tm5: StmtBlockListNode) {
for _ in [()] {
let exists_already = self.cons_stmt_block_list_node.iter_all_0_1_2(tm3, tm4, tm5).next().is_some();
if !exists_already {
delta.new_cons_stmt_block_list_node.push(ConsStmtBlockListNode(tm3, tm4, tm5));
}



}
}


#[allow(unused_variables)]
fn scopes_desugared_case_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_desugared_case_1(delta, );
self.scopes_desugared_case_2(delta, );
self.scopes_desugared_case_5(delta, );
self.scopes_desugared_case_8(delta, );
self.scopes_desugared_case_11(delta, );
self.scopes_desugared_case_14(delta, );







}
}

#[allow(unused_variables)]
fn scopes_desugared_case_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlock(tm1, tm0, ) in self.desugared_case_block.iter_new() {

self.scopes_desugared_case_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_3(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode) {
for _ in [()] {
self.scopes_desugared_case_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_desugared_case_4(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm2, ) in self.rule_descendant_stmt_list.iter_all_0(tm0, ) {

self.scopes_desugared_case_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtList(tm0, tm2, ) in self.rule_descendant_stmt_list.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseBlock(tm1, _, ) in self.desugared_case_block.iter_old_1(tm0, ) {

self.scopes_desugared_case_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_6(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_desugared_case_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_desugared_case_7(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCase(_, tm3, ) in self.rule_descendant_match_case.iter_all_0(tm1, ) {

self.scopes_desugared_case_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCase(tm1, tm3, ) in self.rule_descendant_match_case.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseBlock(_, tm0, ) in self.desugared_case_block.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm2, ) in self.rule_descendant_stmt_list.iter_old_0(tm0, ) {

self.scopes_desugared_case_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_9(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_desugared_case_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_desugared_case_10(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm3, ) {

self.scopes_desugared_case_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm3, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for RuleDescendantMatchCase(tm1, _, ) in self.rule_descendant_match_case.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for DesugaredCaseBlock(_, tm0, ) in self.desugared_case_block.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm2, ) in self.rule_descendant_stmt_list.iter_old_0(tm0, ) {

self.scopes_desugared_case_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_12(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode, tm4: Scope) {
for _ in [()] {
self.scopes_desugared_case_13(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_desugared_case_13(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode, tm4: Scope) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(_, tm5, ) in self.exit_scope.iter_all_0(tm3, ) {

self.scopes_desugared_case_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm3, tm5, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for RuleDescendantMatchCase(tm1, _, ) in self.rule_descendant_match_case.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for DesugaredCaseBlock(_, tm0, ) in self.desugared_case_block.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmtList(_, tm2, ) in self.rule_descendant_stmt_list.iter_old_0(tm0, ) {

self.scopes_desugared_case_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_15(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: MatchCaseNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode, tm4: Scope, tm5: Scope) {
for _ in [()] {
let exists_already = self.entry_scope.iter_all_0_1(tm2, tm4).next().is_some();
if !exists_already {
delta.new_entry_scope.push(EntryScope(tm2, tm4));
}

let exists_already = self.exit_scope.iter_all_0_1(tm2, tm5).next().is_some();
if !exists_already {
delta.new_exit_scope.push(ExitScope(tm2, tm5));
}




}
}


#[allow(unused_variables)]
fn scopes_desugared_case_list_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scopes_desugared_case_list_1(delta, );
self.scopes_desugared_case_list_2(delta, );
self.scopes_desugared_case_list_5(delta, );
self.scopes_desugared_case_list_8(delta, );
self.scopes_desugared_case_list_11(delta, );
self.scopes_desugared_case_list_14(delta, );







}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(tm1, tm0, ) in self.desugared_case_block_list.iter_new() {

self.scopes_desugared_case_list_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_3(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode) {
for _ in [()] {
self.scopes_desugared_case_list_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_4(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm2, ) in self.rule_descendant_stmt_block_list.iter_all_0(tm0, ) {

self.scopes_desugared_case_list_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantStmtBlockList(tm0, tm2, ) in self.rule_descendant_stmt_block_list.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseBlockList(tm1, _, ) in self.desugared_case_block_list.iter_old_1(tm0, ) {

self.scopes_desugared_case_list_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_6(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode, tm2: RuleDescendantNode) {
for _ in [()] {
self.scopes_desugared_case_list_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_7(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode, tm2: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCaseList(_, tm3, ) in self.rule_descendant_match_case_list.iter_all_0(tm1, ) {

self.scopes_desugared_case_list_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCaseList(tm1, tm3, ) in self.rule_descendant_match_case_list.iter_new() {

#[allow(unused_variables)]
for DesugaredCaseBlockList(_, tm0, ) in self.desugared_case_block_list.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm2, ) in self.rule_descendant_stmt_block_list.iter_old_0(tm0, ) {

self.scopes_desugared_case_list_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_9(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
self.scopes_desugared_case_list_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_10(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm3, ) {

self.scopes_desugared_case_list_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm3, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for RuleDescendantMatchCaseList(tm1, _, ) in self.rule_descendant_match_case_list.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for DesugaredCaseBlockList(_, tm0, ) in self.desugared_case_block_list.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm2, ) in self.rule_descendant_stmt_block_list.iter_old_0(tm0, ) {

self.scopes_desugared_case_list_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_12(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode, tm4: Scope) {
for _ in [()] {
self.scopes_desugared_case_list_13(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_13(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode, tm4: Scope) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(_, tm5, ) in self.exit_scope.iter_all_0(tm3, ) {

self.scopes_desugared_case_list_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm3, tm5, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for RuleDescendantMatchCaseList(tm1, _, ) in self.rule_descendant_match_case_list.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for DesugaredCaseBlockList(_, tm0, ) in self.desugared_case_block_list.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantStmtBlockList(_, tm2, ) in self.rule_descendant_stmt_block_list.iter_old_0(tm0, ) {

self.scopes_desugared_case_list_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn scopes_desugared_case_list_15(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: MatchCaseListNode, tm2: RuleDescendantNode, tm3: RuleDescendantNode, tm4: Scope, tm5: Scope) {
for _ in [()] {
let exists_already = self.entry_scope.iter_all_0_1(tm2, tm4).next().is_some();
if !exists_already {
delta.new_entry_scope.push(EntryScope(tm2, tm4));
}

let exists_already = self.exit_scope.iter_all_0_1(tm2, tm5).next().is_some();
if !exists_already {
delta.new_exit_scope.push(ExitScope(tm2, tm5));
}




}
}


#[allow(unused_variables)]
fn type_list_nil_not_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_list_nil_not_cons_1(delta, );
self.type_list_nil_not_cons_2(delta, );
self.type_list_nil_not_cons_3(delta, );




}
}

#[allow(unused_variables)]
fn type_list_nil_not_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_list_nil_not_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTypeList(tm0, ) in self.nil_type_list.iter_new() {

#[allow(unused_variables)]
for ConsTypeList(tm1, tm2, _, ) in self.cons_type_list.iter_old_2(tm0, ) {

self.type_list_nil_not_cons_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn type_list_nil_not_cons_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm1, tm2, tm0, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for NilTypeList(_, ) in self.nil_type_list.iter_all_0(tm0, ) {

self.type_list_nil_not_cons_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn type_list_nil_not_cons_4(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList) {
for _ in [()] {
let exists_already = self.absurd.iter_all().next().is_some();
if !exists_already {
delta.new_absurd.push(Absurd());
}



}
}


#[allow(unused_variables)]
fn type_list_cons_injective_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_list_cons_injective_1(delta, );
self.type_list_cons_injective_2(delta, );
self.type_list_cons_injective_3(delta, );




}
}

#[allow(unused_variables)]
fn type_list_cons_injective_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_list_cons_injective_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm1, tm3, tm0, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for ConsTypeList(tm2, tm4, _, ) in self.cons_type_list.iter_old_2(tm0, ) {

self.type_list_cons_injective_4(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn type_list_cons_injective_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm2, tm4, tm0, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for ConsTypeList(tm1, tm3, _, ) in self.cons_type_list.iter_all_2(tm0, ) {

self.type_list_cons_injective_4(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn type_list_cons_injective_4(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: Type, tm3: TypeList, tm4: TypeList) {
for _ in [()] {
delta.new_type_equalities.push((tm1, tm2));

delta.new_type_equalities.push((tm2, tm1));

delta.new_type_list_equalities.push((tm3, tm4));

delta.new_type_list_equalities.push((tm4, tm3));






}
}


#[allow(unused_variables)]
fn semantic_decl_type_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_decl_type_1(delta, );
self.semantic_decl_type_2(delta, );
self.semantic_decl_type_5(delta, );
self.semantic_decl_type_8(delta, );
self.semantic_decl_type_11(delta, );






}
}

#[allow(unused_variables)]
fn semantic_decl_type_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_decl_type_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeType(tm0, tm1, ) in self.decl_node_type.iter_new() {

self.semantic_decl_type_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_type_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode) {
for _ in [()] {
self.semantic_decl_type_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_decl_type_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDecl(_, tm2, ) in self.type_decl.iter_all_0(tm1, ) {

self.semantic_decl_type_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_type_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDecl(tm1, tm2, ) in self.type_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeType(tm0, _, ) in self.decl_node_type.iter_old_1(tm1, ) {

self.semantic_decl_type_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_type_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident) {
for _ in [()] {
self.semantic_decl_type_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn semantic_decl_type_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm3, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.semantic_decl_type_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_type_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm3, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeType(_, tm1, ) in self.decl_node_type.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for TypeDecl(_, tm2, ) in self.type_decl.iter_old_0(tm1, ) {

self.semantic_decl_type_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_type_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope) {
for _ in [()] {
self.semantic_decl_type_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn semantic_decl_type_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope) {
for _ in [()] {
let tm4 = match self.semantic_type.iter_all_0_1(tm3, tm2).next() {
    Some(SemanticType(_, _,  res)) => res,
    None => { 
        delta.new_semantic_type_def.push(SemanticTypeArgs(tm3, tm2));
        break;
    },
};

self.semantic_decl_type_12(delta, tm0, tm1, tm2, tm3, tm4);



}
}

#[allow(unused_variables)]
fn semantic_decl_type_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm3, tm2, tm4, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for TypeDecl(tm1, _, ) in self.type_decl.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for DeclNodeType(_, _, ) in self.decl_node_type.iter_old_0_1(tm0, tm1, ) {

self.semantic_decl_type_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_type_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope, tm4: Type) {
for _ in [()] {
let exists_already = self.is_normal_type.iter_all_0(tm4).next().is_some();
if !exists_already {
delta.new_is_normal_type.push(IsNormalType(tm4));
}



}
}


#[allow(unused_variables)]
fn semantic_decl_enum_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_decl_enum_1(delta, );
self.semantic_decl_enum_2(delta, );
self.semantic_decl_enum_5(delta, );
self.semantic_decl_enum_8(delta, );
self.semantic_decl_enum_11(delta, );






}
}

#[allow(unused_variables)]
fn semantic_decl_enum_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_decl_enum_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeEnum(tm0, tm1, ) in self.decl_node_enum.iter_new() {

self.semantic_decl_enum_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_enum_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode) {
for _ in [()] {
self.semantic_decl_enum_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_decl_enum_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(_, tm2, tm3, ) in self.enum_decl.iter_all_0(tm1, ) {

self.semantic_decl_enum_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_enum_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm1, tm2, tm3, ) in self.enum_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeEnum(tm0, _, ) in self.decl_node_enum.iter_old_1(tm1, ) {

self.semantic_decl_enum_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_enum_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode) {
for _ in [()] {
self.semantic_decl_enum_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn semantic_decl_enum_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.semantic_decl_enum_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_enum_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeEnum(_, tm1, ) in self.decl_node_enum.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EnumDecl(_, tm2, tm3, ) in self.enum_decl.iter_old_0(tm1, ) {

self.semantic_decl_enum_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_enum_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope) {
for _ in [()] {
self.semantic_decl_enum_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn semantic_decl_enum_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope) {
for _ in [()] {
let tm5 = match self.semantic_type.iter_all_0_1(tm4, tm2).next() {
    Some(SemanticType(_, _,  res)) => res,
    None => { 
        delta.new_semantic_type_def.push(SemanticTypeArgs(tm4, tm2));
        break;
    },
};

self.semantic_decl_enum_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn semantic_decl_enum_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm4, tm2, tm5, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for DeclNodeEnum(_, tm1, ) in self.decl_node_enum.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EnumDecl(_, _, tm3, ) in self.enum_decl.iter_old_0_1(tm1, tm2, ) {

self.semantic_decl_enum_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_enum_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope, tm5: Type) {
for _ in [()] {
let exists_already = self.is_enum_type.iter_all_0(tm5).next().is_some();
if !exists_already {
delta.new_is_enum_type.push(IsEnumType(tm5));
}



}
}


#[allow(unused_variables)]
fn semantic_decl_model_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_decl_model_1(delta, );
self.semantic_decl_model_2(delta, );
self.semantic_decl_model_5(delta, );
self.semantic_decl_model_8(delta, );
self.semantic_decl_model_11(delta, );






}
}

#[allow(unused_variables)]
fn semantic_decl_model_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_decl_model_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeModel(tm0, tm1, ) in self.decl_node_model.iter_new() {

self.semantic_decl_model_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_model_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode) {
for _ in [()] {
self.semantic_decl_model_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_decl_model_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDecl(_, tm2, tm3, ) in self.model_decl.iter_all_0(tm1, ) {

self.semantic_decl_model_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_model_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDecl(tm1, tm2, tm3, ) in self.model_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeModel(tm0, _, ) in self.decl_node_model.iter_old_1(tm1, ) {

self.semantic_decl_model_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_model_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode) {
for _ in [()] {
self.semantic_decl_model_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn semantic_decl_model_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.semantic_decl_model_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_model_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeModel(_, tm1, ) in self.decl_node_model.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelDecl(_, tm2, tm3, ) in self.model_decl.iter_old_0(tm1, ) {

self.semantic_decl_model_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_model_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope) {
for _ in [()] {
self.semantic_decl_model_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn semantic_decl_model_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope) {
for _ in [()] {
let tm5 = match self.semantic_type.iter_all_0_1(tm4, tm2).next() {
    Some(SemanticType(_, _,  res)) => res,
    None => { 
        delta.new_semantic_type_def.push(SemanticTypeArgs(tm4, tm2));
        break;
    },
};

self.semantic_decl_model_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn semantic_decl_model_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm4, tm2, tm5, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for DeclNodeModel(_, tm1, ) in self.decl_node_model.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelDecl(_, _, tm3, ) in self.model_decl.iter_old_0_1(tm1, tm2, ) {

self.semantic_decl_model_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_model_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope, tm5: Type) {
for _ in [()] {
let exists_already = self.is_model_type.iter_all_0(tm5).next().is_some();
if !exists_already {
delta.new_is_model_type.push(IsModelType(tm5));
}



}
}


#[allow(unused_variables)]
fn mor_type_defined_for_model_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.mor_type_defined_for_model_1(delta, );
self.mor_type_defined_for_model_2(delta, );
self.mor_type_defined_for_model_5(delta, );
self.mor_type_defined_for_model_8(delta, );
self.mor_type_defined_for_model_11(delta, );






}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IsModelType(tm0, ) in self.is_model_type.iter_new() {

self.mor_type_defined_for_model_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_3(&self, delta: &mut ModelDelta, tm0: Type) {
for _ in [()] {
self.mor_type_defined_for_model_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_4(&self, delta: &mut ModelDelta, tm0: Type) {
for _ in [()] {
let tm1 = match self.mor_type.iter_all_0(tm0).next() {
    Some(MorType(_,  res)) => res,
    None => { 
        delta.new_mor_type_def.push(MorTypeArgs(tm0));
        break;
    },
};

self.mor_type_defined_for_model_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorType(tm0, tm1, ) in self.mor_type.iter_new() {

#[allow(unused_variables)]
for IsModelType(_, ) in self.is_model_type.iter_old_0(tm0, ) {

self.mor_type_defined_for_model_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_6(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
self.mor_type_defined_for_model_7(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_7(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
let tm2 = match self.mor_type_dom_func.iter_all_0(tm1).next() {
    Some(MorTypeDomFunc(_,  res)) => res,
    None => { 
        delta.new_mor_type_dom_func_def.push(MorTypeDomFuncArgs(tm1));
        break;
    },
};

self.mor_type_defined_for_model_9(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeDomFunc(tm1, tm2, ) in self.mor_type_dom_func.iter_new() {

#[allow(unused_variables)]
for MorType(tm0, _, ) in self.mor_type.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for IsModelType(_, ) in self.is_model_type.iter_old_0(tm0, ) {

self.mor_type_defined_for_model_9(delta, tm0, tm1, tm2);


}

}

}

}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_9(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func) {
for _ in [()] {
self.mor_type_defined_for_model_10(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_10(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func) {
for _ in [()] {
let tm3 = match self.mor_type_cod_func.iter_all_0(tm1).next() {
    Some(MorTypeCodFunc(_,  res)) => res,
    None => { 
        delta.new_mor_type_cod_func_def.push(MorTypeCodFuncArgs(tm1));
        break;
    },
};

self.mor_type_defined_for_model_12(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeCodFunc(tm1, tm3, ) in self.mor_type_cod_func.iter_new() {

#[allow(unused_variables)]
for MorTypeDomFunc(_, tm2, ) in self.mor_type_dom_func.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for IsModelType(tm0, ) in self.is_model_type.iter_old() {

#[allow(unused_variables)]
for MorType(_, _, ) in self.mor_type.iter_old_0_1(tm0, tm1, ) {

self.mor_type_defined_for_model_12(delta, tm0, tm1, tm2, tm3);


}

}

}

}

}
}

#[allow(unused_variables)]
fn mor_type_defined_for_model_12(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func, tm3: Func) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn mor_type_is_mor_type_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.mor_type_is_mor_type_1(delta, );
self.mor_type_is_mor_type_2(delta, );



}
}

#[allow(unused_variables)]
fn mor_type_is_mor_type_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn mor_type_is_mor_type_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorType(tm1, tm0, ) in self.mor_type.iter_new() {

self.mor_type_is_mor_type_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn mor_type_is_mor_type_3(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
let exists_already = self.is_mor_type.iter_all_0(tm0).next().is_some();
if !exists_already {
delta.new_is_mor_type.push(IsMorType(tm0));
}



}
}


#[allow(unused_variables)]
fn mor_type_symbol_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.mor_type_symbol_scope_1(delta, );
self.mor_type_symbol_scope_2(delta, );
self.mor_type_symbol_scope_5(delta, );




}
}

#[allow(unused_variables)]
fn mor_type_symbol_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn mor_type_symbol_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorType(tm1, tm0, ) in self.mor_type.iter_new() {

self.mor_type_symbol_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn mor_type_symbol_scope_3(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
self.mor_type_symbol_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn mor_type_symbol_scope_4(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDefinitionSymbolScope(_, tm2, ) in self.type_definition_symbol_scope.iter_all_0(tm1, ) {

self.mor_type_symbol_scope_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn mor_type_symbol_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDefinitionSymbolScope(tm1, tm2, ) in self.type_definition_symbol_scope.iter_new() {

#[allow(unused_variables)]
for MorType(_, tm0, ) in self.mor_type.iter_old_0(tm1, ) {

self.mor_type_symbol_scope_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn mor_type_symbol_scope_6(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: SymbolScope) {
for _ in [()] {
let exists_already = self.type_definition_symbol_scope.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_type_definition_symbol_scope.push(TypeDefinitionSymbolScope(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.mor_type_dom_func_symbol_scope_1(delta, );
self.mor_type_dom_func_symbol_scope_2(delta, );
self.mor_type_dom_func_symbol_scope_5(delta, );
self.mor_type_dom_func_symbol_scope_8(delta, );





}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeDomFunc(tm1, tm0, ) in self.mor_type_dom_func.iter_new() {

self.mor_type_dom_func_symbol_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_3(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type) {
for _ in [()] {
self.mor_type_dom_func_symbol_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_4(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(_, tm2, ) in self.func_rel.iter_all_0(tm0, ) {

self.mor_type_dom_func_symbol_scope_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm0, tm2, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for MorTypeDomFunc(tm1, _, ) in self.mor_type_dom_func.iter_old_1(tm0, ) {

self.mor_type_dom_func_symbol_scope_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_6(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: Rel) {
for _ in [()] {
self.mor_type_dom_func_symbol_scope_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_7(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: Rel) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDefinitionSymbolScope(_, tm3, ) in self.type_definition_symbol_scope.iter_all_0(tm1, ) {

self.mor_type_dom_func_symbol_scope_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDefinitionSymbolScope(tm1, tm3, ) in self.type_definition_symbol_scope.iter_new() {

#[allow(unused_variables)]
for MorTypeDomFunc(_, tm0, ) in self.mor_type_dom_func.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for FuncRel(_, tm2, ) in self.func_rel.iter_old_0(tm0, ) {

self.mor_type_dom_func_symbol_scope_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn mor_type_dom_func_symbol_scope_9(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: Rel, tm3: SymbolScope) {
for _ in [()] {
let exists_already = self.rel_definition_symbol_scope.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_rel_definition_symbol_scope.push(RelDefinitionSymbolScope(tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.mor_type_cod_func_symbol_scope_1(delta, );
self.mor_type_cod_func_symbol_scope_2(delta, );
self.mor_type_cod_func_symbol_scope_5(delta, );
self.mor_type_cod_func_symbol_scope_8(delta, );





}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeCodFunc(tm1, tm0, ) in self.mor_type_cod_func.iter_new() {

self.mor_type_cod_func_symbol_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_3(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type) {
for _ in [()] {
self.mor_type_cod_func_symbol_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_4(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(_, tm2, ) in self.func_rel.iter_all_0(tm0, ) {

self.mor_type_cod_func_symbol_scope_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm0, tm2, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for MorTypeCodFunc(tm1, _, ) in self.mor_type_cod_func.iter_old_1(tm0, ) {

self.mor_type_cod_func_symbol_scope_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_6(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: Rel) {
for _ in [()] {
self.mor_type_cod_func_symbol_scope_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_7(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: Rel) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDefinitionSymbolScope(_, tm3, ) in self.type_definition_symbol_scope.iter_all_0(tm1, ) {

self.mor_type_cod_func_symbol_scope_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDefinitionSymbolScope(tm1, tm3, ) in self.type_definition_symbol_scope.iter_new() {

#[allow(unused_variables)]
for MorTypeCodFunc(_, tm0, ) in self.mor_type_cod_func.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for FuncRel(_, tm2, ) in self.func_rel.iter_old_0(tm0, ) {

self.mor_type_cod_func_symbol_scope_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn mor_type_cod_func_symbol_scope_9(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: Rel, tm3: SymbolScope) {
for _ in [()] {
let exists_already = self.rel_definition_symbol_scope.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_rel_definition_symbol_scope.push(RelDefinitionSymbolScope(tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.mor_type_dom_cod_func_domains_1(delta, );
self.mor_type_dom_cod_func_domains_2(delta, );
self.mor_type_dom_cod_func_domains_5(delta, );
self.mor_type_dom_cod_func_domains_8(delta, );
self.mor_type_dom_cod_func_domains_11(delta, );
self.mor_type_dom_cod_func_domains_14(delta, );







}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorType(tm1, tm0, ) in self.mor_type.iter_new() {

self.mor_type_dom_cod_func_domains_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_3(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
self.mor_type_dom_cod_func_domains_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_4(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeDomFunc(_, tm2, ) in self.mor_type_dom_func.iter_all_0(tm0, ) {

self.mor_type_dom_cod_func_domains_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeDomFunc(tm0, tm2, ) in self.mor_type_dom_func.iter_new() {

#[allow(unused_variables)]
for MorType(tm1, _, ) in self.mor_type.iter_old_1(tm0, ) {

self.mor_type_dom_cod_func_domains_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_6(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func) {
for _ in [()] {
self.mor_type_dom_cod_func_domains_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_7(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeCodFunc(_, tm3, ) in self.mor_type_cod_func.iter_all_0(tm0, ) {

self.mor_type_dom_cod_func_domains_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeCodFunc(tm0, tm3, ) in self.mor_type_cod_func.iter_new() {

#[allow(unused_variables)]
for MorTypeDomFunc(_, tm2, ) in self.mor_type_dom_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for MorType(tm1, _, ) in self.mor_type.iter_old_1(tm0, ) {

self.mor_type_dom_cod_func_domains_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_9(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func, tm3: Func) {
for _ in [()] {
self.mor_type_dom_cod_func_domains_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_10(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func, tm3: Func) {
for _ in [()] {
let tm4 = match self.nil_type_list.iter_all().next() {
    Some(NilTypeList( res)) => res,
    None => { 
        delta.new_nil_type_list_def.push(NilTypeListArgs());
        break;
    },
};

self.mor_type_dom_cod_func_domains_12(delta, tm0, tm1, tm2, tm3, tm4);



}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTypeList(tm4, ) in self.nil_type_list.iter_new() {

#[allow(unused_variables)]
for MorTypeCodFunc(tm0, tm3, ) in self.mor_type_cod_func.iter_old() {

#[allow(unused_variables)]
for MorType(tm1, _, ) in self.mor_type.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for MorTypeDomFunc(_, tm2, ) in self.mor_type_dom_func.iter_old_0(tm0, ) {

self.mor_type_dom_cod_func_domains_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_12(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func, tm3: Func, tm4: TypeList) {
for _ in [()] {
self.mor_type_dom_cod_func_domains_13(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_13(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func, tm3: Func, tm4: TypeList) {
for _ in [()] {
let tm5 = match self.cons_type_list.iter_all_0_1(tm0, tm4).next() {
    Some(ConsTypeList(_, _,  res)) => res,
    None => { 
        delta.new_cons_type_list_def.push(ConsTypeListArgs(tm0, tm4));
        break;
    },
};

self.mor_type_dom_cod_func_domains_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm0, tm4, tm5, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for NilTypeList(_, ) in self.nil_type_list.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for MorType(tm1, _, ) in self.mor_type.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for MorTypeDomFunc(_, tm2, ) in self.mor_type_dom_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for MorTypeCodFunc(_, tm3, ) in self.mor_type_cod_func.iter_old_0(tm0, ) {

self.mor_type_dom_cod_func_domains_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_domains_15(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func, tm3: Func, tm4: TypeList, tm5: TypeList) {
for _ in [()] {
let exists_already = self.domain.iter_all_0_1(tm2, tm5).next().is_some();
if !exists_already {
delta.new_domain.push(Domain(tm2, tm5));
}

let exists_already = self.domain.iter_all_0_1(tm3, tm5).next().is_some();
if !exists_already {
delta.new_domain.push(Domain(tm3, tm5));
}




}
}


#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.mor_type_dom_cod_func_codomains_1(delta, );
self.mor_type_dom_cod_func_codomains_2(delta, );
self.mor_type_dom_cod_func_codomains_5(delta, );
self.mor_type_dom_cod_func_codomains_8(delta, );





}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorType(tm1, tm0, ) in self.mor_type.iter_new() {

self.mor_type_dom_cod_func_codomains_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_3(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
self.mor_type_dom_cod_func_codomains_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_4(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeDomFunc(_, tm2, ) in self.mor_type_dom_func.iter_all_0(tm0, ) {

self.mor_type_dom_cod_func_codomains_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeDomFunc(tm0, tm2, ) in self.mor_type_dom_func.iter_new() {

#[allow(unused_variables)]
for MorType(tm1, _, ) in self.mor_type.iter_old_1(tm0, ) {

self.mor_type_dom_cod_func_codomains_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_6(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func) {
for _ in [()] {
self.mor_type_dom_cod_func_codomains_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_7(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeCodFunc(_, tm3, ) in self.mor_type_cod_func.iter_all_0(tm0, ) {

self.mor_type_dom_cod_func_codomains_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeCodFunc(tm0, tm3, ) in self.mor_type_cod_func.iter_new() {

#[allow(unused_variables)]
for MorTypeDomFunc(_, tm2, ) in self.mor_type_dom_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for MorType(tm1, _, ) in self.mor_type.iter_old_1(tm0, ) {

self.mor_type_dom_cod_func_codomains_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn mor_type_dom_cod_func_codomains_9(&self, delta: &mut ModelDelta, tm0: Type, tm1: Type, tm2: Func, tm3: Func) {
for _ in [()] {
let exists_already = self.codomain.iter_all_0_1(tm2, tm1).next().is_some();
if !exists_already {
delta.new_codomain.push(Codomain(tm2, tm1));
}

let exists_already = self.codomain.iter_all_0_1(tm3, tm1).next().is_some();
if !exists_already {
delta.new_codomain.push(Codomain(tm3, tm1));
}




}
}


#[allow(unused_variables)]
fn type_name_semantic_type_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_name_semantic_type_1(delta, );
self.type_name_semantic_type_2(delta, );



}
}

#[allow(unused_variables)]
fn type_name_semantic_type_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_name_semantic_type_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm1, tm2, tm0, ) in self.semantic_type.iter_new() {

self.type_name_semantic_type_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn type_name_semantic_type_3(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: Ident) {
for _ in [()] {
let exists_already = self.type_name.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_type_name.push(TypeName(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn virtual_symbol_scope_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.virtual_symbol_scope_total_1(delta, );
self.virtual_symbol_scope_total_3(delta, );



}
}

#[allow(unused_variables)]
fn virtual_symbol_scope_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.virtual_symbol_scope_total_2(delta, );


}
}

#[allow(unused_variables)]
fn virtual_symbol_scope_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
let tm0 = match self.virtual_symbol_scope.iter_all().next() {
    Some(VirtualSymbolScope( res)) => res,
    None => { 
        delta.new_virtual_symbol_scope_def.push(VirtualSymbolScopeArgs());
        break;
    },
};

self.virtual_symbol_scope_total_4(delta, tm0);



}
}

#[allow(unused_variables)]
fn virtual_symbol_scope_total_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VirtualSymbolScope(tm0, ) in self.virtual_symbol_scope.iter_new() {

self.virtual_symbol_scope_total_4(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn virtual_symbol_scope_total_4(&self, delta: &mut ModelDelta, tm0: SymbolScope) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.parent_model_func_defined_and_codomain_1(delta, );
self.parent_model_func_defined_and_codomain_2(delta, );
self.parent_model_func_defined_and_codomain_5(delta, );
self.parent_model_func_defined_and_codomain_8(delta, );





}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDefinitionSymbolScope(tm1, tm0, ) in self.type_definition_symbol_scope.iter_new() {

self.parent_model_func_defined_and_codomain_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Type) {
for _ in [()] {
self.parent_model_func_defined_and_codomain_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Type) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(_, tm2, ) in self.symbol_scope_model.iter_all_0(tm0, ) {

self.parent_model_func_defined_and_codomain_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(tm0, tm2, ) in self.symbol_scope_model.iter_new() {

#[allow(unused_variables)]
for TypeDefinitionSymbolScope(tm1, _, ) in self.type_definition_symbol_scope.iter_old_1(tm0, ) {

self.parent_model_func_defined_and_codomain_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Type, tm2: Type) {
for _ in [()] {
self.parent_model_func_defined_and_codomain_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_7(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Type, tm2: Type) {
for _ in [()] {
let tm3 = match self.parent_model_func.iter_all_0(tm1).next() {
    Some(ParentModelFunc(_,  res)) => res,
    None => { 
        delta.new_parent_model_func_def.push(ParentModelFuncArgs(tm1));
        break;
    },
};

self.parent_model_func_defined_and_codomain_9(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ParentModelFunc(tm1, tm3, ) in self.parent_model_func.iter_new() {

#[allow(unused_variables)]
for TypeDefinitionSymbolScope(_, tm0, ) in self.type_definition_symbol_scope.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for SymbolScopeModel(_, tm2, ) in self.symbol_scope_model.iter_old_0(tm0, ) {

self.parent_model_func_defined_and_codomain_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn parent_model_func_defined_and_codomain_9(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Type, tm2: Type, tm3: Func) {
for _ in [()] {
let exists_already = self.codomain.iter_all_0_1(tm3, tm2).next().is_some();
if !exists_already {
delta.new_codomain.push(Codomain(tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn parent_model_func_def_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.parent_model_func_def_scope_1(delta, );
self.parent_model_func_def_scope_2(delta, );
self.parent_model_func_def_scope_5(delta, );
self.parent_model_func_def_scope_8(delta, );





}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VirtualSymbolScope(tm0, ) in self.virtual_symbol_scope.iter_new() {

self.parent_model_func_def_scope_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_3(&self, delta: &mut ModelDelta, tm0: SymbolScope) {
for _ in [()] {
self.parent_model_func_def_scope_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_4(&self, delta: &mut ModelDelta, tm0: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for ParentModelFunc(tm2, tm1, ) in self.parent_model_func.iter_all() {

self.parent_model_func_def_scope_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ParentModelFunc(tm2, tm1, ) in self.parent_model_func.iter_new() {

#[allow(unused_variables)]
for VirtualSymbolScope(tm0, ) in self.virtual_symbol_scope.iter_old() {

self.parent_model_func_def_scope_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Func, tm2: Type) {
for _ in [()] {
self.parent_model_func_def_scope_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_7(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Func, tm2: Type) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(_, tm3, ) in self.func_rel.iter_all_0(tm1, ) {

self.parent_model_func_def_scope_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm1, tm3, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for ParentModelFunc(tm2, _, ) in self.parent_model_func.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for VirtualSymbolScope(tm0, ) in self.virtual_symbol_scope.iter_old() {

self.parent_model_func_def_scope_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn parent_model_func_def_scope_9(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Func, tm2: Type, tm3: Rel) {
for _ in [()] {
let exists_already = self.rel_definition_symbol_scope.iter_all_0_1(tm3, tm0).next().is_some();
if !exists_already {
delta.new_rel_definition_symbol_scope.push(RelDefinitionSymbolScope(tm3, tm0));
}



}
}


#[allow(unused_variables)]
fn parent_model_func_domain_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.parent_model_func_domain_1(delta, );
self.parent_model_func_domain_2(delta, );
self.parent_model_func_domain_5(delta, );
self.parent_model_func_domain_8(delta, );





}
}

#[allow(unused_variables)]
fn parent_model_func_domain_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn parent_model_func_domain_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ParentModelFunc(tm1, tm0, ) in self.parent_model_func.iter_new() {

self.parent_model_func_domain_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn parent_model_func_domain_3(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type) {
for _ in [()] {
self.parent_model_func_domain_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn parent_model_func_domain_4(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type) {
for _ in [()] {
let tm2 = match self.nil_type_list.iter_all().next() {
    Some(NilTypeList( res)) => res,
    None => { 
        delta.new_nil_type_list_def.push(NilTypeListArgs());
        break;
    },
};

self.parent_model_func_domain_6(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn parent_model_func_domain_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTypeList(tm2, ) in self.nil_type_list.iter_new() {

#[allow(unused_variables)]
for ParentModelFunc(tm1, tm0, ) in self.parent_model_func.iter_old() {

self.parent_model_func_domain_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn parent_model_func_domain_6(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: TypeList) {
for _ in [()] {
self.parent_model_func_domain_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn parent_model_func_domain_7(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: TypeList) {
for _ in [()] {
let tm3 = match self.cons_type_list.iter_all_0_1(tm1, tm2).next() {
    Some(ConsTypeList(_, _,  res)) => res,
    None => { 
        delta.new_cons_type_list_def.push(ConsTypeListArgs(tm1, tm2));
        break;
    },
};

self.parent_model_func_domain_9(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn parent_model_func_domain_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm1, tm2, tm3, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for NilTypeList(_, ) in self.nil_type_list.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ParentModelFunc(_, tm0, ) in self.parent_model_func.iter_old_0(tm1, ) {

self.parent_model_func_domain_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn parent_model_func_domain_9(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type, tm2: TypeList, tm3: TypeList) {
for _ in [()] {
let exists_already = self.domain.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_domain.push(Domain(tm0, tm3));
}

let exists_already = self.flat_domain.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_flat_domain.push(FlatDomain(tm0, tm3));
}




}
}


#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_signature_type_expr_ambient_1(delta, );
self.semantic_signature_type_expr_ambient_2(delta, );
self.semantic_signature_type_expr_ambient_5(delta, );
self.semantic_signature_type_expr_ambient_8(delta, );
self.semantic_signature_type_expr_ambient_11(delta, );
self.semantic_signature_type_expr_ambient_14(delta, );
self.semantic_signature_type_expr_ambient_17(delta, );
self.semantic_signature_type_expr_ambient_20(delta, );
self.semantic_signature_type_expr_ambient_23(delta, );
self.semantic_signature_type_expr_ambient_26(delta, );
self.semantic_signature_type_expr_ambient_29(delta, );












}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, tm2, tm0, ) in self.semantic_signature_type_expr.iter_new() {

self.semantic_signature_type_expr_ambient_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_3(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode) {
for _ in [()] {
self.semantic_signature_type_expr_ambient_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_4(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for TypeExprNodeLoc(_, tm3, ) in self.type_expr_node_loc.iter_all_0(tm2, ) {

self.semantic_signature_type_expr_ambient_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeExprNodeLoc(tm2, tm3, ) in self.type_expr_node_loc.iter_new() {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, _, tm0, ) in self.semantic_signature_type_expr.iter_old_1(tm2, ) {

self.semantic_signature_type_expr_ambient_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_6(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc) {
for _ in [()] {
self.semantic_signature_type_expr_ambient_7(delta, tm0, tm1, tm2, tm3);
self.semantic_signature_type_expr_ambient_10(delta, tm0, tm1, tm2, tm3);
self.semantic_signature_type_expr_ambient_13(delta, tm0, tm1, tm2, tm3);




}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_7(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientTypeExpr(_, tm4, ) in self.ambient_type_expr.iter_all_0(tm2, ) {

self.semantic_signature_type_expr_ambient_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm4, ) in self.ambient_type_expr.iter_new() {

#[allow(unused_variables)]
for TypeExprNodeLoc(_, tm3, ) in self.type_expr_node_loc.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, _, tm0, ) in self.semantic_signature_type_expr.iter_old_1(tm2, ) {

self.semantic_signature_type_expr_ambient_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_9(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm4: Ident) {
for _ in [()] {
self.semantic_signature_type_expr_ambient_16(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_10(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc) {
for _ in [()] {
#[allow(unused_variables)]
for MemberTypeExpr(_, tm5, tm6, ) in self.member_type_expr.iter_all_0(tm2, ) {

self.semantic_signature_type_expr_ambient_12(delta, tm0, tm1, tm2, tm3, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MemberTypeExpr(tm2, tm5, tm6, ) in self.member_type_expr.iter_new() {

#[allow(unused_variables)]
for TypeExprNodeLoc(_, tm3, ) in self.type_expr_node_loc.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, _, tm0, ) in self.semantic_signature_type_expr.iter_old_1(tm2, ) {

self.semantic_signature_type_expr_ambient_12(delta, tm0, tm1, tm2, tm3, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_12(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm5: TermNode, tm6: Ident) {
for _ in [()] {
let exists_already = self.illegal_member_type_expr_in_signature.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_illegal_member_type_expr_in_signature.push(IllegalMemberTypeExprInSignature(tm2));
}



}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_13(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeExpr(_, tm7, ) in self.mor_type_expr.iter_all_0(tm2, ) {

self.semantic_signature_type_expr_ambient_15(delta, tm0, tm1, tm2, tm3, tm7);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MorTypeExpr(tm2, tm7, ) in self.mor_type_expr.iter_new() {

#[allow(unused_variables)]
for TypeExprNodeLoc(_, tm3, ) in self.type_expr_node_loc.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, _, tm0, ) in self.semantic_signature_type_expr.iter_old_1(tm2, ) {

self.semantic_signature_type_expr_ambient_15(delta, tm0, tm1, tm2, tm3, tm7);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_15(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm7: Ident) {
for _ in [()] {
self.semantic_signature_type_expr_ambient_19(delta, tm0, tm1, tm2, tm3, tm7);


}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_16(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm4: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm8, ) in self.type_symbol.iter_all() {

self.semantic_signature_type_expr_ambient_18(delta, tm0, tm1, tm2, tm3, tm4, tm8);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm8, ) in self.type_symbol.iter_new() {

#[allow(unused_variables)]
for TypeExprNodeLoc(tm2, tm3, ) in self.type_expr_node_loc.iter_old() {

#[allow(unused_variables)]
for AmbientTypeExpr(_, tm4, ) in self.ambient_type_expr.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, _, tm0, ) in self.semantic_signature_type_expr.iter_old_1(tm2, ) {

self.semantic_signature_type_expr_ambient_18(delta, tm0, tm1, tm2, tm3, tm4, tm8);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_18(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm4: Ident, tm8: SymbolKind) {
for _ in [()] {
self.semantic_signature_type_expr_ambient_22(delta, tm0, tm1, tm2, tm3, tm4, tm8);


}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_19(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm7: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm9, ) in self.model_symbol.iter_all() {

self.semantic_signature_type_expr_ambient_21(delta, tm0, tm1, tm2, tm3, tm7, tm9);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_20(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm9, ) in self.model_symbol.iter_new() {

#[allow(unused_variables)]
for TypeExprNodeLoc(tm2, tm3, ) in self.type_expr_node_loc.iter_old() {

#[allow(unused_variables)]
for MorTypeExpr(_, tm7, ) in self.mor_type_expr.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, _, tm0, ) in self.semantic_signature_type_expr.iter_old_1(tm2, ) {

self.semantic_signature_type_expr_ambient_21(delta, tm0, tm1, tm2, tm3, tm7, tm9);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_21(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm7: Ident, tm9: SymbolKind) {
for _ in [()] {
let exists_already = self.should_be_symbol.iter_all_0_1_2_3(tm7, tm9, tm1, tm3).next().is_some();
if !exists_already {
delta.new_should_be_symbol.push(ShouldBeSymbol(tm7, tm9, tm1, tm3));
}

self.semantic_signature_type_expr_ambient_28(delta, tm0, tm1, tm2, tm3, tm7, tm9);



}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_22(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm4: Ident, tm8: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm10, ) in self.enum_symbol.iter_all() {

self.semantic_signature_type_expr_ambient_24(delta, tm0, tm1, tm2, tm3, tm4, tm8, tm10);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_23(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm10, ) in self.enum_symbol.iter_new() {

#[allow(unused_variables)]
for TypeSymbol(tm8, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm4, ) in self.ambient_type_expr.iter_old() {

#[allow(unused_variables)]
for TypeExprNodeLoc(_, tm3, ) in self.type_expr_node_loc.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, _, tm0, ) in self.semantic_signature_type_expr.iter_old_1(tm2, ) {

self.semantic_signature_type_expr_ambient_24(delta, tm0, tm1, tm2, tm3, tm4, tm8, tm10);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_24(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm4: Ident, tm8: SymbolKind, tm10: SymbolKind) {
for _ in [()] {
self.semantic_signature_type_expr_ambient_25(delta, tm0, tm1, tm2, tm3, tm4, tm8, tm10);


}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_25(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm4: Ident, tm8: SymbolKind, tm10: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm11, ) in self.model_symbol.iter_all() {

self.semantic_signature_type_expr_ambient_27(delta, tm0, tm1, tm2, tm3, tm4, tm8, tm10, tm11);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_26(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm11, ) in self.model_symbol.iter_new() {

#[allow(unused_variables)]
for EnumSymbol(tm10, ) in self.enum_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm8, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm4, ) in self.ambient_type_expr.iter_old() {

#[allow(unused_variables)]
for TypeExprNodeLoc(_, tm3, ) in self.type_expr_node_loc.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm1, _, tm0, ) in self.semantic_signature_type_expr.iter_old_1(tm2, ) {

self.semantic_signature_type_expr_ambient_27(delta, tm0, tm1, tm2, tm3, tm4, tm8, tm10, tm11);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_27(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm4: Ident, tm8: SymbolKind, tm10: SymbolKind, tm11: SymbolKind) {
for _ in [()] {
let exists_already = self.should_be_symbol_3.iter_all_0_1_2_3_4_5(tm4, tm8, tm10, tm11, tm1, tm3).next().is_some();
if !exists_already {
delta.new_should_be_symbol_3.push(ShouldBeSymbol3(tm4, tm8, tm10, tm11, tm1, tm3));
}

let exists_already = self.semantic_type.iter_all_0_1_2(tm1, tm4, tm0).next().is_some();
if !exists_already {
delta.new_semantic_type.push(SemanticType(tm1, tm4, tm0));
}




}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_28(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm7: Ident, tm9: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, _, tm12, ) in self.semantic_type.iter_all_0_1(tm1, tm7, ) {

self.semantic_signature_type_expr_ambient_30(delta, tm0, tm1, tm2, tm3, tm7, tm9, tm12);


}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_29(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm1, tm7, tm12, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for ModelSymbol(tm9, ) in self.model_symbol.iter_old() {

#[allow(unused_variables)]
for MorTypeExpr(tm2, _, ) in self.mor_type_expr.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for ShouldBeSymbol(_, _, _, tm3, ) in self.should_be_symbol.iter_old_0_1_2(tm7, tm9, tm1, ) {

#[allow(unused_variables)]
for TypeExprNodeLoc(_, _, ) in self.type_expr_node_loc.iter_old_0_1(tm2, tm3, ) {

#[allow(unused_variables)]
for SemanticSignatureTypeExpr(_, _, tm0, ) in self.semantic_signature_type_expr.iter_old_0_1(tm1, tm2, ) {

self.semantic_signature_type_expr_ambient_30(delta, tm0, tm1, tm2, tm3, tm7, tm9, tm12);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_signature_type_expr_ambient_30(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: TypeExprNode, tm3: Loc, tm7: Ident, tm9: SymbolKind, tm12: Type) {
for _ in [()] {
let exists_already = self.mor_type.iter_all_0_1(tm12, tm0).next().is_some();
if !exists_already {
delta.new_mor_type.push(MorType(tm12, tm0));
}



}
}


#[allow(unused_variables)]
fn semantic_arg_type_def_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_arg_type_def_1(delta, );
self.semantic_arg_type_def_2(delta, );
self.semantic_arg_type_def_5(delta, );
self.semantic_arg_type_def_8(delta, );





}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgDeclNodeType(tm0, tm1, ) in self.arg_decl_node_type.iter_new() {

self.semantic_arg_type_def_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_3(&self, delta: &mut ModelDelta, tm0: ArgDeclNode, tm1: TypeExprNode) {
for _ in [()] {
self.semantic_arg_type_def_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_4(&self, delta: &mut ModelDelta, tm0: ArgDeclNode, tm1: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for ArgSymbolScope(_, tm2, ) in self.arg_symbol_scope.iter_all_0(tm0, ) {

self.semantic_arg_type_def_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgSymbolScope(tm0, tm2, ) in self.arg_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ArgDeclNodeType(_, tm1, ) in self.arg_decl_node_type.iter_old_0(tm0, ) {

self.semantic_arg_type_def_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_6(&self, delta: &mut ModelDelta, tm0: ArgDeclNode, tm1: TypeExprNode, tm2: SymbolScope) {
for _ in [()] {
self.semantic_arg_type_def_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_7(&self, delta: &mut ModelDelta, tm0: ArgDeclNode, tm1: TypeExprNode, tm2: SymbolScope) {
for _ in [()] {
let tm3 = match self.semantic_signature_type_expr.iter_all_0_1(tm2, tm1).next() {
    Some(SemanticSignatureTypeExpr(_, _,  res)) => res,
    None => { 
        delta.new_semantic_signature_type_expr_def.push(SemanticSignatureTypeExprArgs(tm2, tm1));
        break;
    },
};

self.semantic_arg_type_def_9(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm2, tm1, tm3, ) in self.semantic_signature_type_expr.iter_new() {

#[allow(unused_variables)]
for ArgSymbolScope(tm0, _, ) in self.arg_symbol_scope.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for ArgDeclNodeType(_, _, ) in self.arg_decl_node_type.iter_old_0_1(tm0, tm1, ) {

self.semantic_arg_type_def_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_arg_type_def_9(&self, delta: &mut ModelDelta, tm0: ArgDeclNode, tm1: TypeExprNode, tm2: SymbolScope, tm3: Type) {
for _ in [()] {
let exists_already = self.semantic_arg_type.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_semantic_arg_type.push(SemanticArgType(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn semantic_arg_types_nil_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_arg_types_nil_1(delta, );
self.semantic_arg_types_nil_2(delta, );
self.semantic_arg_types_nil_5(delta, );




}
}

#[allow(unused_variables)]
fn semantic_arg_types_nil_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_arg_types_nil_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilArgDeclListNode(tm0, ) in self.nil_arg_decl_list_node.iter_new() {

self.semantic_arg_types_nil_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn semantic_arg_types_nil_3(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode) {
for _ in [()] {
self.semantic_arg_types_nil_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn semantic_arg_types_nil_4(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode) {
for _ in [()] {
let tm1 = match self.nil_type_list.iter_all().next() {
    Some(NilTypeList( res)) => res,
    None => { 
        delta.new_nil_type_list_def.push(NilTypeListArgs());
        break;
    },
};

self.semantic_arg_types_nil_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn semantic_arg_types_nil_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTypeList(tm1, ) in self.nil_type_list.iter_new() {

#[allow(unused_variables)]
for NilArgDeclListNode(tm0, ) in self.nil_arg_decl_list_node.iter_old() {

self.semantic_arg_types_nil_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn semantic_arg_types_nil_6(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: TypeList) {
for _ in [()] {
let exists_already = self.semantic_arg_types.iter_all_0_1(tm0, tm1).next().is_some();
if !exists_already {
delta.new_semantic_arg_types.push(SemanticArgTypes(tm0, tm1));
}



}
}


#[allow(unused_variables)]
fn semantic_arg_types_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_arg_types_cons_1(delta, );
self.semantic_arg_types_cons_2(delta, );
self.semantic_arg_types_cons_5(delta, );
self.semantic_arg_types_cons_8(delta, );
self.semantic_arg_types_cons_11(delta, );






}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsArgDeclListNode(tm0, tm1, tm2, ) in self.cons_arg_decl_list_node.iter_new() {

self.semantic_arg_types_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_3(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode) {
for _ in [()] {
self.semantic_arg_types_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_4(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgType(_, tm3, ) in self.semantic_arg_type.iter_all_0(tm1, ) {

self.semantic_arg_types_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgType(tm1, tm3, ) in self.semantic_arg_type.iter_new() {

#[allow(unused_variables)]
for ConsArgDeclListNode(tm0, _, tm2, ) in self.cons_arg_decl_list_node.iter_old_1(tm1, ) {

self.semantic_arg_types_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_6(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode, tm3: Type) {
for _ in [()] {
self.semantic_arg_types_cons_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_7(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode, tm3: Type) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(_, tm4, ) in self.semantic_arg_types.iter_all_0(tm2, ) {

self.semantic_arg_types_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(tm2, tm4, ) in self.semantic_arg_types.iter_new() {

#[allow(unused_variables)]
for SemanticArgType(tm1, tm3, ) in self.semantic_arg_type.iter_old() {

#[allow(unused_variables)]
for ConsArgDeclListNode(tm0, _, _, ) in self.cons_arg_decl_list_node.iter_old_1_2(tm1, tm2, ) {

self.semantic_arg_types_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_9(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode, tm3: Type, tm4: TypeList) {
for _ in [()] {
self.semantic_arg_types_cons_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_10(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode, tm3: Type, tm4: TypeList) {
for _ in [()] {
let tm5 = match self.cons_type_list.iter_all_0_1(tm3, tm4).next() {
    Some(ConsTypeList(_, _,  res)) => res,
    None => { 
        delta.new_cons_type_list_def.push(ConsTypeListArgs(tm3, tm4));
        break;
    },
};

self.semantic_arg_types_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm3, tm4, tm5, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for SemanticArgTypes(tm2, _, ) in self.semantic_arg_types.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for SemanticArgType(tm1, _, ) in self.semantic_arg_type.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for ConsArgDeclListNode(tm0, _, _, ) in self.cons_arg_decl_list_node.iter_old_1_2(tm1, tm2, ) {

self.semantic_arg_types_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_arg_types_cons_12(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode, tm3: Type, tm4: TypeList, tm5: TypeList) {
for _ in [()] {
let exists_already = self.semantic_arg_types.iter_all_0_1(tm0, tm5).next().is_some();
if !exists_already {
delta.new_semantic_arg_types.push(SemanticArgTypes(tm0, tm5));
}



}
}


#[allow(unused_variables)]
fn semantic_decl_pred_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_decl_pred_1(delta, );
self.semantic_decl_pred_2(delta, );
self.semantic_decl_pred_5(delta, );
self.semantic_decl_pred_8(delta, );
self.semantic_decl_pred_11(delta, );
self.semantic_decl_pred_14(delta, );







}
}

#[allow(unused_variables)]
fn semantic_decl_pred_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodePred(tm0, tm1, ) in self.decl_node_pred.iter_new() {

self.semantic_decl_pred_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode) {
for _ in [()] {
self.semantic_decl_pred_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_decl_pred_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for PredDecl(_, tm2, tm3, ) in self.pred_decl.iter_all_0(tm1, ) {

self.semantic_decl_pred_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredDecl(tm1, tm2, tm3, ) in self.pred_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodePred(tm0, _, ) in self.decl_node_pred.iter_old_1(tm1, ) {

self.semantic_decl_pred_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode) {
for _ in [()] {
self.semantic_decl_pred_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn semantic_decl_pred_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.semantic_decl_pred_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodePred(_, tm1, ) in self.decl_node_pred.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for PredDecl(_, tm2, tm3, ) in self.pred_decl.iter_old_0(tm1, ) {

self.semantic_decl_pred_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope) {
for _ in [()] {
self.semantic_decl_pred_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn semantic_decl_pred_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope) {
for _ in [()] {
let tm5 = match self.semantic_pred.iter_all_0_1(tm4, tm2).next() {
    Some(SemanticPred(_, _,  res)) => res,
    None => { 
        delta.new_semantic_pred_def.push(SemanticPredArgs(tm4, tm2));
        break;
    },
};

self.semantic_decl_pred_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn semantic_decl_pred_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm4, tm2, tm5, ) in self.semantic_pred.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for DeclNodePred(_, tm1, ) in self.decl_node_pred.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for PredDecl(_, _, tm3, ) in self.pred_decl.iter_old_0_1(tm1, tm2, ) {

self.semantic_decl_pred_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope, tm5: Pred) {
for _ in [()] {
self.semantic_decl_pred_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn semantic_decl_pred_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope, tm5: Pred) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(_, tm6, ) in self.semantic_arg_types.iter_all_0(tm3, ) {

self.semantic_decl_pred_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(tm3, tm6, ) in self.semantic_arg_types.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodePred(_, tm1, ) in self.decl_node_pred.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for PredDecl(_, tm2, _, ) in self.pred_decl.iter_old_0_2(tm1, tm3, ) {

#[allow(unused_variables)]
for SemanticPred(_, _, tm5, ) in self.semantic_pred.iter_old_0_1(tm4, tm2, ) {

self.semantic_decl_pred_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_pred_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope, tm5: Pred, tm6: TypeList) {
for _ in [()] {
let exists_already = self.pred_arity.iter_all_0_1(tm5, tm6).next().is_some();
if !exists_already {
delta.new_pred_arity.push(PredArity(tm5, tm6));
}



}
}


#[allow(unused_variables)]
fn semantic_decl_func_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_decl_func_1(delta, );
self.semantic_decl_func_2(delta, );
self.semantic_decl_func_5(delta, );
self.semantic_decl_func_8(delta, );
self.semantic_decl_func_11(delta, );
self.semantic_decl_func_14(delta, );
self.semantic_decl_func_17(delta, );








}
}

#[allow(unused_variables)]
fn semantic_decl_func_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_decl_func_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeFunc(tm0, tm1, ) in self.decl_node_func.iter_new() {

self.semantic_decl_func_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode) {
for _ in [()] {
self.semantic_decl_func_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_decl_func_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, tm4, ) in self.func_decl.iter_all_0(tm1, ) {

self.semantic_decl_func_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDecl(tm1, tm2, tm3, tm4, ) in self.func_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeFunc(tm0, _, ) in self.decl_node_func.iter_old_1(tm1, ) {

self.semantic_decl_func_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode) {
for _ in [()] {
self.semantic_decl_func_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn semantic_decl_func_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm5, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.semantic_decl_func_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm5, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeFunc(_, tm1, ) in self.decl_node_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, tm4, ) in self.func_decl.iter_old_0(tm1, ) {

self.semantic_decl_func_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope) {
for _ in [()] {
self.semantic_decl_func_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn semantic_decl_func_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope) {
for _ in [()] {
let tm6 = match self.semantic_func.iter_all_0_1(tm5, tm2).next() {
    Some(SemanticFunc(_, _,  res)) => res,
    None => { 
        delta.new_semantic_func_def.push(SemanticFuncArgs(tm5, tm2));
        break;
    },
};

self.semantic_decl_func_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);



}
}

#[allow(unused_variables)]
fn semantic_decl_func_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm5, tm2, tm6, ) in self.semantic_func.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for DeclNodeFunc(_, tm1, ) in self.decl_node_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for FuncDecl(_, _, tm3, tm4, ) in self.func_decl.iter_old_0_1(tm1, tm2, ) {

self.semantic_decl_func_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope, tm6: Func) {
for _ in [()] {
self.semantic_decl_func_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);
self.semantic_decl_func_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);



}
}

#[allow(unused_variables)]
fn semantic_decl_func_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope, tm6: Func) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(_, tm7, ) in self.semantic_arg_types.iter_all_0(tm3, ) {

self.semantic_decl_func_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(tm3, tm7, ) in self.semantic_arg_types.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm5, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodeFunc(_, tm1, ) in self.decl_node_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for FuncDecl(_, tm2, _, tm4, ) in self.func_decl.iter_old_0_2(tm1, tm3, ) {

#[allow(unused_variables)]
for SemanticFunc(_, _, tm6, ) in self.semantic_func.iter_old_0_1(tm5, tm2, ) {

self.semantic_decl_func_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope, tm6: Func, tm7: TypeList) {
for _ in [()] {
let exists_already = self.domain.iter_all_0_1(tm6, tm7).next().is_some();
if !exists_already {
delta.new_domain.push(Domain(tm6, tm7));
}



}
}

#[allow(unused_variables)]
fn semantic_decl_func_16(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope, tm6: Func) {
for _ in [()] {
let tm8 = match self.semantic_signature_type_expr.iter_all_0_1(tm5, tm4).next() {
    Some(SemanticSignatureTypeExpr(_, _,  res)) => res,
    None => { 
        delta.new_semantic_signature_type_expr_def.push(SemanticSignatureTypeExprArgs(tm5, tm4));
        break;
    },
};

self.semantic_decl_func_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm8);



}
}

#[allow(unused_variables)]
fn semantic_decl_func_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticSignatureTypeExpr(tm5, tm4, tm8, ) in self.semantic_signature_type_expr.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for DeclNodeFunc(_, tm1, ) in self.decl_node_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, _, ) in self.func_decl.iter_old_0_3(tm1, tm4, ) {

#[allow(unused_variables)]
for SemanticFunc(_, _, tm6, ) in self.semantic_func.iter_old_0_1(tm5, tm2, ) {

self.semantic_decl_func_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm8);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_func_18(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope, tm6: Func, tm8: Type) {
for _ in [()] {
let exists_already = self.codomain.iter_all_0_1(tm6, tm8).next().is_some();
if !exists_already {
delta.new_codomain.push(Codomain(tm6, tm8));
}



}
}


#[allow(unused_variables)]
fn semantic_decl_ctor_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_decl_ctor_1(delta, );
self.semantic_decl_ctor_2(delta, );
self.semantic_decl_ctor_5(delta, );
self.semantic_decl_ctor_8(delta, );
self.semantic_decl_ctor_11(delta, );
self.semantic_decl_ctor_14(delta, );
self.semantic_decl_ctor_17(delta, );
self.semantic_decl_ctor_20(delta, );









}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDecl(tm0, tm1, tm2, ) in self.ctor_decl.iter_new() {

self.semantic_decl_ctor_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_3(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode) {
for _ in [()] {
self.semantic_decl_ctor_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_4(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(_, tm3, ) in self.ctor_enum.iter_all_0(tm0, ) {

self.semantic_decl_ctor_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(tm0, tm3, ) in self.ctor_enum.iter_new() {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

self.semantic_decl_ctor_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_6(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode) {
for _ in [()] {
self.semantic_decl_ctor_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_7(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(_, tm4, ) in self.ctor_symbol_scope.iter_all_0(tm0, ) {

self.semantic_decl_ctor_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(tm0, tm4, ) in self.ctor_symbol_scope.iter_new() {

#[allow(unused_variables)]
for CtorEnum(_, tm3, ) in self.ctor_enum.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

self.semantic_decl_ctor_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_9(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope) {
for _ in [()] {
self.semantic_decl_ctor_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_10(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope) {
for _ in [()] {
let tm5 = match self.semantic_func.iter_all_0_1(tm4, tm1).next() {
    Some(SemanticFunc(_, _,  res)) => res,
    None => { 
        delta.new_semantic_func_def.push(SemanticFuncArgs(tm4, tm1));
        break;
    },
};

self.semantic_decl_ctor_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm4, tm1, tm5, ) in self.semantic_func.iter_new() {

#[allow(unused_variables)]
for CtorSymbolScope(tm0, _, ) in self.ctor_symbol_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for CtorDecl(_, _, tm2, ) in self.ctor_decl.iter_old_0_1(tm0, tm1, ) {

#[allow(unused_variables)]
for CtorEnum(_, tm3, ) in self.ctor_enum.iter_old_0(tm0, ) {

self.semantic_decl_ctor_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_12(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Func) {
for _ in [()] {
self.semantic_decl_ctor_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);
self.semantic_decl_ctor_16(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_13(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Func) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(_, tm6, ) in self.semantic_arg_types.iter_all_0(tm2, ) {

self.semantic_decl_ctor_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticArgTypes(tm2, tm6, ) in self.semantic_arg_types.iter_new() {

#[allow(unused_variables)]
for CtorSymbolScope(tm0, tm4, ) in self.ctor_symbol_scope.iter_old() {

#[allow(unused_variables)]
for CtorDecl(_, tm1, _, ) in self.ctor_decl.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for CtorEnum(_, tm3, ) in self.ctor_enum.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for SemanticFunc(_, _, tm5, ) in self.semantic_func.iter_old_0_1(tm4, tm1, ) {

self.semantic_decl_ctor_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_15(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Func, tm6: TypeList) {
for _ in [()] {
let exists_already = self.domain.iter_all_0_1(tm5, tm6).next().is_some();
if !exists_already {
delta.new_domain.push(Domain(tm5, tm6));
}



}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_16(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Func) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(_, tm7, tm8, ) in self.enum_decl.iter_all_0(tm3, ) {

self.semantic_decl_ctor_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm3, tm7, tm8, ) in self.enum_decl.iter_new() {

#[allow(unused_variables)]
for CtorEnum(tm0, _, ) in self.ctor_enum.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for CtorSymbolScope(_, tm4, ) in self.ctor_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for SemanticFunc(_, _, tm5, ) in self.semantic_func.iter_old_0_1(tm4, tm1, ) {

self.semantic_decl_ctor_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_18(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Func, tm7: Ident, tm8: CtorDeclListNode) {
for _ in [()] {
self.semantic_decl_ctor_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8);


}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_19(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Func, tm7: Ident, tm8: CtorDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, _, tm9, ) in self.semantic_type.iter_all_0_1(tm4, tm7, ) {

self.semantic_decl_ctor_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9);


}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_20(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm4, tm7, tm9, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for CtorSymbolScope(tm0, _, ) in self.ctor_symbol_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for CtorEnum(_, tm3, ) in self.ctor_enum.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EnumDecl(_, _, tm8, ) in self.enum_decl.iter_old_0_1(tm3, tm7, ) {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for SemanticFunc(_, _, tm5, ) in self.semantic_func.iter_old_0_1(tm4, tm1, ) {

self.semantic_decl_ctor_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_decl_ctor_21(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Func, tm7: Ident, tm8: CtorDeclListNode, tm9: Type) {
for _ in [()] {
let exists_already = self.codomain.iter_all_0_1(tm5, tm9).next().is_some();
if !exists_already {
delta.new_codomain.push(Codomain(tm5, tm9));
}



}
}


#[allow(unused_variables)]
fn semantic_func_name_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_func_name_1(delta, );
self.semantic_func_name_2(delta, );
self.semantic_func_name_3(delta, );




}
}

#[allow(unused_variables)]
fn semantic_func_name_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_func_name_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm2, tm3, tm1, ) in self.semantic_func.iter_new() {

#[allow(unused_variables)]
for FuncRel(_, tm0, ) in self.func_rel.iter_old_0(tm1, ) {

self.semantic_func_name_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_func_name_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm1, tm0, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for SemanticFunc(tm2, tm3, _, ) in self.semantic_func.iter_all_2(tm1, ) {

self.semantic_func_name_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_func_name_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: Func, tm2: SymbolScope, tm3: Ident) {
for _ in [()] {
let exists_already = self.rel_name.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_rel_name.push(RelName(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn semantic_pred_name_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_pred_name_1(delta, );
self.semantic_pred_name_2(delta, );
self.semantic_pred_name_3(delta, );




}
}

#[allow(unused_variables)]
fn semantic_pred_name_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_pred_name_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm2, tm3, tm1, ) in self.semantic_pred.iter_new() {

#[allow(unused_variables)]
for PredRel(_, tm0, ) in self.pred_rel.iter_old_0(tm1, ) {

self.semantic_pred_name_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_pred_name_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(tm1, tm0, ) in self.pred_rel.iter_new() {

#[allow(unused_variables)]
for SemanticPred(tm2, tm3, _, ) in self.semantic_pred.iter_all_2(tm1, ) {

self.semantic_pred_name_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_pred_name_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: Pred, tm2: SymbolScope, tm3: Ident) {
for _ in [()] {
let exists_already = self.rel_name.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_rel_name.push(RelName(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn rel_constructors_pred_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rel_constructors_pred_total_1(delta, );
self.rel_constructors_pred_total_2(delta, );
self.rel_constructors_pred_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rel_constructors_pred_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rel_constructors_pred_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.pred_new.iter().copied() {

self.rel_constructors_pred_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rel_constructors_pred_total_3(&self, delta: &mut ModelDelta, tm0: Pred) {
for _ in [()] {
self.rel_constructors_pred_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rel_constructors_pred_total_4(&self, delta: &mut ModelDelta, tm0: Pred) {
for _ in [()] {
let tm1 = match self.pred_rel.iter_all_0(tm0).next() {
    Some(PredRel(_,  res)) => res,
    None => { 
        delta.new_pred_rel_def.push(PredRelArgs(tm0));
        break;
    },
};

self.rel_constructors_pred_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rel_constructors_pred_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(tm0, tm1, ) in self.pred_rel.iter_new() {

self.rel_constructors_pred_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rel_constructors_pred_total_6(&self, delta: &mut ModelDelta, tm0: Pred, tm1: Rel) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn rel_constructors_func_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rel_constructors_func_total_1(delta, );
self.rel_constructors_func_total_2(delta, );
self.rel_constructors_func_total_5(delta, );




}
}

#[allow(unused_variables)]
fn rel_constructors_func_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rel_constructors_func_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.func_new.iter().copied() {

self.rel_constructors_func_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn rel_constructors_func_total_3(&self, delta: &mut ModelDelta, tm0: Func) {
for _ in [()] {
self.rel_constructors_func_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn rel_constructors_func_total_4(&self, delta: &mut ModelDelta, tm0: Func) {
for _ in [()] {
let tm1 = match self.func_rel.iter_all_0(tm0).next() {
    Some(FuncRel(_,  res)) => res,
    None => { 
        delta.new_func_rel_def.push(FuncRelArgs(tm0));
        break;
    },
};

self.rel_constructors_func_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn rel_constructors_func_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm0, tm1, ) in self.func_rel.iter_new() {

self.rel_constructors_func_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rel_constructors_func_total_6(&self, delta: &mut ModelDelta, tm0: Func, tm1: Rel) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn semantic_pred_scope_extension_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_pred_scope_extension_1(delta, );
self.semantic_pred_scope_extension_2(delta, );
self.semantic_pred_scope_extension_5(delta, );




}
}

#[allow(unused_variables)]
fn semantic_pred_scope_extension_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_pred_scope_extension_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeExtension(tm0, tm1, ) in self.symbol_scope_extension.iter_new() {

self.semantic_pred_scope_extension_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_pred_scope_extension_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
self.semantic_pred_scope_extension_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_pred_scope_extension_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(_, tm3, tm2, ) in self.semantic_pred.iter_all_0(tm0, ) {

self.semantic_pred_scope_extension_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_pred_scope_extension_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm0, tm3, tm2, ) in self.semantic_pred.iter_new() {

#[allow(unused_variables)]
for SymbolScopeExtension(_, tm1, ) in self.symbol_scope_extension.iter_old_0(tm0, ) {

self.semantic_pred_scope_extension_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_pred_scope_extension_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope, tm2: Pred, tm3: Ident) {
for _ in [()] {
let exists_already = self.semantic_pred.iter_all_0_1_2(tm1, tm3, tm2).next().is_some();
if !exists_already {
delta.new_semantic_pred.push(SemanticPred(tm1, tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn semantic_func_scope_extension_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_func_scope_extension_1(delta, );
self.semantic_func_scope_extension_2(delta, );
self.semantic_func_scope_extension_5(delta, );




}
}

#[allow(unused_variables)]
fn semantic_func_scope_extension_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_func_scope_extension_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeExtension(tm0, tm1, ) in self.symbol_scope_extension.iter_new() {

self.semantic_func_scope_extension_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_func_scope_extension_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
self.semantic_func_scope_extension_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_func_scope_extension_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(_, tm3, tm2, ) in self.semantic_func.iter_all_0(tm0, ) {

self.semantic_func_scope_extension_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_func_scope_extension_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm0, tm3, tm2, ) in self.semantic_func.iter_new() {

#[allow(unused_variables)]
for SymbolScopeExtension(_, tm1, ) in self.symbol_scope_extension.iter_old_0(tm0, ) {

self.semantic_func_scope_extension_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_func_scope_extension_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope, tm2: Func, tm3: Ident) {
for _ in [()] {
let exists_already = self.semantic_func.iter_all_0_1_2(tm1, tm3, tm2).next().is_some();
if !exists_already {
delta.new_semantic_func.push(SemanticFunc(tm1, tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn semantic_type_scope_extension_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_type_scope_extension_1(delta, );
self.semantic_type_scope_extension_2(delta, );
self.semantic_type_scope_extension_5(delta, );




}
}

#[allow(unused_variables)]
fn semantic_type_scope_extension_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_type_scope_extension_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeExtension(tm0, tm1, ) in self.symbol_scope_extension.iter_new() {

self.semantic_type_scope_extension_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_type_scope_extension_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
self.semantic_type_scope_extension_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_type_scope_extension_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, tm3, tm2, ) in self.semantic_type.iter_all_0(tm0, ) {

self.semantic_type_scope_extension_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_type_scope_extension_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm0, tm3, tm2, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for SymbolScopeExtension(_, tm1, ) in self.symbol_scope_extension.iter_old_0(tm0, ) {

self.semantic_type_scope_extension_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_type_scope_extension_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope, tm2: Type, tm3: Ident) {
for _ in [()] {
let exists_already = self.semantic_type.iter_all_0_1_2(tm1, tm3, tm2).next().is_some();
if !exists_already {
delta.new_semantic_type.push(SemanticType(tm1, tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn arity_laws_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.arity_laws_1(delta, );
self.arity_laws_2(delta, );
self.arity_laws_7(delta, );
self.arity_laws_10(delta, );
self.arity_laws_13(delta, );
self.arity_laws_16(delta, );
self.arity_laws_19(delta, );
self.arity_laws_22(delta, );









}
}

#[allow(unused_variables)]
fn arity_laws_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn arity_laws_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.rel_new.iter().copied() {

self.arity_laws_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn arity_laws_3(&self, delta: &mut ModelDelta, tm0: Rel) {
for _ in [()] {
self.arity_laws_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn arity_laws_4(&self, delta: &mut ModelDelta, tm0: Rel) {
for _ in [()] {
self.arity_laws_5(delta, tm0);


}
}

#[allow(unused_variables)]
fn arity_laws_5(&self, delta: &mut ModelDelta, tm0: Rel) {
for _ in [()] {
self.arity_laws_6(delta, tm0);
self.arity_laws_9(delta, tm0);



}
}

#[allow(unused_variables)]
fn arity_laws_6(&self, delta: &mut ModelDelta, tm0: Rel) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(tm1, _, ) in self.pred_rel.iter_all_1(tm0, ) {

self.arity_laws_8(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn arity_laws_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(tm1, tm0, ) in self.pred_rel.iter_new() {

self.arity_laws_8(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn arity_laws_8(&self, delta: &mut ModelDelta, tm0: Rel, tm1: Pred) {
for _ in [()] {
self.arity_laws_12(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn arity_laws_9(&self, delta: &mut ModelDelta, tm0: Rel) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_all_1(tm0, ) {

self.arity_laws_11(delta, tm0, tm2);


}

}
}

#[allow(unused_variables)]
fn arity_laws_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm2, tm0, ) in self.func_rel.iter_new() {

self.arity_laws_11(delta, tm0, tm2);


}

}
}

#[allow(unused_variables)]
fn arity_laws_11(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func) {
for _ in [()] {
self.arity_laws_15(delta, tm0, tm2);


}
}

#[allow(unused_variables)]
fn arity_laws_12(&self, delta: &mut ModelDelta, tm0: Rel, tm1: Pred) {
for _ in [()] {
#[allow(unused_variables)]
for PredArity(_, tm3, ) in self.pred_arity.iter_all_0(tm1, ) {

self.arity_laws_14(delta, tm0, tm1, tm3);


}

}
}

#[allow(unused_variables)]
fn arity_laws_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredArity(tm1, tm3, ) in self.pred_arity.iter_new() {

#[allow(unused_variables)]
for PredRel(_, tm0, ) in self.pred_rel.iter_old_0(tm1, ) {

self.arity_laws_14(delta, tm0, tm1, tm3);


}

}

}
}

#[allow(unused_variables)]
fn arity_laws_14(&self, delta: &mut ModelDelta, tm0: Rel, tm1: Pred, tm3: TypeList) {
for _ in [()] {
let exists_already = self.arity.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_arity.push(Arity(tm0, tm3));
}



}
}

#[allow(unused_variables)]
fn arity_laws_15(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(_, tm4, ) in self.domain.iter_all_0(tm2, ) {

self.arity_laws_17(delta, tm0, tm2, tm4);


}

}
}

#[allow(unused_variables)]
fn arity_laws_16(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(tm2, tm4, ) in self.domain.iter_new() {

#[allow(unused_variables)]
for FuncRel(_, tm0, ) in self.func_rel.iter_old_0(tm2, ) {

self.arity_laws_17(delta, tm0, tm2, tm4);


}

}

}
}

#[allow(unused_variables)]
fn arity_laws_17(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func, tm4: TypeList) {
for _ in [()] {
self.arity_laws_18(delta, tm0, tm2, tm4);


}
}

#[allow(unused_variables)]
fn arity_laws_18(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func, tm4: TypeList) {
for _ in [()] {
#[allow(unused_variables)]
for Codomain(_, tm5, ) in self.codomain.iter_all_0(tm2, ) {

self.arity_laws_20(delta, tm0, tm2, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn arity_laws_19(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Codomain(tm2, tm5, ) in self.codomain.iter_new() {

#[allow(unused_variables)]
for FuncRel(_, tm0, ) in self.func_rel.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for Domain(_, tm4, ) in self.domain.iter_old_0(tm2, ) {

self.arity_laws_20(delta, tm0, tm2, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn arity_laws_20(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func, tm4: TypeList, tm5: Type) {
for _ in [()] {
self.arity_laws_21(delta, tm0, tm2, tm4, tm5);


}
}

#[allow(unused_variables)]
fn arity_laws_21(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func, tm4: TypeList, tm5: Type) {
for _ in [()] {
let tm6 = match self.snoc_type_list.iter_all_0_1(tm4, tm5).next() {
    Some(SnocTypeList(_, _,  res)) => res,
    None => { 
        delta.new_snoc_type_list_def.push(SnocTypeListArgs(tm4, tm5));
        break;
    },
};

self.arity_laws_23(delta, tm0, tm2, tm4, tm5, tm6);



}
}

#[allow(unused_variables)]
fn arity_laws_22(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocTypeList(tm4, tm5, tm6, ) in self.snoc_type_list.iter_new() {

#[allow(unused_variables)]
for Codomain(tm2, _, ) in self.codomain.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for Domain(_, _, ) in self.domain.iter_old_0_1(tm2, tm4, ) {

#[allow(unused_variables)]
for FuncRel(_, tm0, ) in self.func_rel.iter_old_0(tm2, ) {

self.arity_laws_23(delta, tm0, tm2, tm4, tm5, tm6);


}

}

}

}

}
}

#[allow(unused_variables)]
fn arity_laws_23(&self, delta: &mut ModelDelta, tm0: Rel, tm2: Func, tm4: TypeList, tm5: Type, tm6: TypeList) {
for _ in [()] {
let exists_already = self.arity.iter_all_0_1(tm0, tm6).next().is_some();
if !exists_already {
delta.new_arity.push(Arity(tm0, tm6));
}



}
}


#[allow(unused_variables)]
fn top_level_flat_arity_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.top_level_flat_arity_law_1(delta, );
self.top_level_flat_arity_law_2(delta, );
self.top_level_flat_arity_law_5(delta, );
self.top_level_flat_arity_law_8(delta, );
self.top_level_flat_arity_law_11(delta, );
self.top_level_flat_arity_law_14(delta, );







}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, tm0, ) in self.rel_definition_symbol_scope.iter_new() {

self.top_level_flat_arity_law_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel) {
for _ in [()] {
self.top_level_flat_arity_law_4(delta, tm0, tm1);
self.top_level_flat_arity_law_7(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleSymbolScope(tm2, _, ) in self.module_symbol_scope.iter_all_1(tm0, ) {

self.top_level_flat_arity_law_6(delta, tm1, tm0, tm2);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleSymbolScope(tm2, tm0, ) in self.module_symbol_scope.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm0, ) {

self.top_level_flat_arity_law_6(delta, tm1, tm0, tm2);


}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_6(&self, delta: &mut ModelDelta, tm1: Rel, tm0: SymbolScope, tm2: ModuleNode) {
for _ in [()] {
self.top_level_flat_arity_law_10(delta, tm1, tm0, tm2);


}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_7(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel) {
for _ in [()] {
#[allow(unused_variables)]
for VirtualSymbolScope(_, ) in self.virtual_symbol_scope.iter_all_0(tm0, ) {

self.top_level_flat_arity_law_9(delta, tm1, tm0);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VirtualSymbolScope(tm0, ) in self.virtual_symbol_scope.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm0, ) {

self.top_level_flat_arity_law_9(delta, tm1, tm0);


}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_9(&self, delta: &mut ModelDelta, tm1: Rel, tm0: SymbolScope) {
for _ in [()] {
self.top_level_flat_arity_law_13(delta, tm1, tm0);


}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_10(&self, delta: &mut ModelDelta, tm1: Rel, tm0: SymbolScope, tm2: ModuleNode) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(_, tm3, ) in self.arity.iter_all_0(tm1, ) {

self.top_level_flat_arity_law_12(delta, tm1, tm0, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(tm1, tm3, ) in self.arity.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm0, ) in self.rel_definition_symbol_scope.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for ModuleSymbolScope(tm2, _, ) in self.module_symbol_scope.iter_old_1(tm0, ) {

self.top_level_flat_arity_law_12(delta, tm1, tm0, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_12(&self, delta: &mut ModelDelta, tm1: Rel, tm0: SymbolScope, tm2: ModuleNode, tm3: TypeList) {
for _ in [()] {
let exists_already = self.flat_arity.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_flat_arity.push(FlatArity(tm1, tm3));
}



}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_13(&self, delta: &mut ModelDelta, tm1: Rel, tm0: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(_, tm4, ) in self.arity.iter_all_0(tm1, ) {

self.top_level_flat_arity_law_15(delta, tm1, tm0, tm4);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(tm1, tm4, ) in self.arity.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm0, ) in self.rel_definition_symbol_scope.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for VirtualSymbolScope(_, ) in self.virtual_symbol_scope.iter_old_0(tm0, ) {

self.top_level_flat_arity_law_15(delta, tm1, tm0, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_arity_law_15(&self, delta: &mut ModelDelta, tm1: Rel, tm0: SymbolScope, tm4: TypeList) {
for _ in [()] {
let exists_already = self.flat_arity.iter_all_0_1(tm1, tm4).next().is_some();
if !exists_already {
delta.new_flat_arity.push(FlatArity(tm1, tm4));
}



}
}


#[allow(unused_variables)]
fn top_level_flat_domain_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.top_level_flat_domain_law_1(delta, );
self.top_level_flat_domain_law_2(delta, );
self.top_level_flat_domain_law_3(delta, );
self.top_level_flat_domain_law_6(delta, );
self.top_level_flat_domain_law_9(delta, );
self.top_level_flat_domain_law_12(delta, );
self.top_level_flat_domain_law_15(delta, );








}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, tm0, ) in self.rel_definition_symbol_scope.iter_new() {

#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_old_1(tm1, ) {

self.top_level_flat_domain_law_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm2, tm1, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm0, ) in self.rel_definition_symbol_scope.iter_all_0(tm1, ) {

self.top_level_flat_domain_law_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func) {
for _ in [()] {
self.top_level_flat_domain_law_5(delta, tm0, tm1, tm2);
self.top_level_flat_domain_law_8(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_5(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleSymbolScope(tm3, _, ) in self.module_symbol_scope.iter_all_1(tm0, ) {

self.top_level_flat_domain_law_7(delta, tm1, tm2, tm0, tm3);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleSymbolScope(tm3, tm0, ) in self.module_symbol_scope.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_old_1(tm1, ) {

self.top_level_flat_domain_law_7(delta, tm1, tm2, tm0, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_7(&self, delta: &mut ModelDelta, tm1: Rel, tm2: Func, tm0: SymbolScope, tm3: ModuleNode) {
for _ in [()] {
self.top_level_flat_domain_law_11(delta, tm1, tm2, tm0, tm3);


}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_8(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func) {
for _ in [()] {
#[allow(unused_variables)]
for VirtualSymbolScope(_, ) in self.virtual_symbol_scope.iter_all_0(tm0, ) {

self.top_level_flat_domain_law_10(delta, tm1, tm2, tm0);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VirtualSymbolScope(tm0, ) in self.virtual_symbol_scope.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_old_1(tm1, ) {

self.top_level_flat_domain_law_10(delta, tm1, tm2, tm0);


}

}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_10(&self, delta: &mut ModelDelta, tm1: Rel, tm2: Func, tm0: SymbolScope) {
for _ in [()] {
self.top_level_flat_domain_law_14(delta, tm1, tm2, tm0);


}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_11(&self, delta: &mut ModelDelta, tm1: Rel, tm2: Func, tm0: SymbolScope, tm3: ModuleNode) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(_, tm4, ) in self.domain.iter_all_0(tm2, ) {

self.top_level_flat_domain_law_13(delta, tm1, tm2, tm0, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(tm2, tm4, ) in self.domain.iter_new() {

#[allow(unused_variables)]
for FuncRel(_, tm1, ) in self.func_rel.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm0, ) in self.rel_definition_symbol_scope.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for ModuleSymbolScope(tm3, _, ) in self.module_symbol_scope.iter_old_1(tm0, ) {

self.top_level_flat_domain_law_13(delta, tm1, tm2, tm0, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_13(&self, delta: &mut ModelDelta, tm1: Rel, tm2: Func, tm0: SymbolScope, tm3: ModuleNode, tm4: TypeList) {
for _ in [()] {
let exists_already = self.flat_domain.iter_all_0_1(tm2, tm4).next().is_some();
if !exists_already {
delta.new_flat_domain.push(FlatDomain(tm2, tm4));
}



}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_14(&self, delta: &mut ModelDelta, tm1: Rel, tm2: Func, tm0: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(_, tm5, ) in self.domain.iter_all_0(tm2, ) {

self.top_level_flat_domain_law_16(delta, tm1, tm2, tm0, tm5);


}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(tm2, tm5, ) in self.domain.iter_new() {

#[allow(unused_variables)]
for FuncRel(_, tm1, ) in self.func_rel.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for VirtualSymbolScope(tm0, ) in self.virtual_symbol_scope.iter_old() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, _, ) in self.rel_definition_symbol_scope.iter_old_0_1(tm1, tm0, ) {

self.top_level_flat_domain_law_16(delta, tm1, tm2, tm0, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn top_level_flat_domain_law_16(&self, delta: &mut ModelDelta, tm1: Rel, tm2: Func, tm0: SymbolScope, tm5: TypeList) {
for _ in [()] {
let exists_already = self.flat_domain.iter_all_0_1(tm2, tm5).next().is_some();
if !exists_already {
delta.new_flat_domain.push(FlatDomain(tm2, tm5));
}



}
}


#[allow(unused_variables)]
fn member_flat_arity_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.member_flat_arity_law_1(delta, );
self.member_flat_arity_law_2(delta, );
self.member_flat_arity_law_5(delta, );
self.member_flat_arity_law_8(delta, );
self.member_flat_arity_law_11(delta, );






}
}

#[allow(unused_variables)]
fn member_flat_arity_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn member_flat_arity_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, tm0, ) in self.rel_definition_symbol_scope.iter_new() {

self.member_flat_arity_law_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn member_flat_arity_law_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel) {
for _ in [()] {
self.member_flat_arity_law_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn member_flat_arity_law_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(_, tm2, ) in self.symbol_scope_model.iter_all_0(tm0, ) {

self.member_flat_arity_law_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn member_flat_arity_law_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(tm0, tm2, ) in self.symbol_scope_model.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm0, ) {

self.member_flat_arity_law_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn member_flat_arity_law_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Type) {
for _ in [()] {
self.member_flat_arity_law_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn member_flat_arity_law_7(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Type) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(_, tm3, ) in self.arity.iter_all_0(tm1, ) {

self.member_flat_arity_law_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn member_flat_arity_law_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(tm1, tm3, ) in self.arity.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm0, ) in self.rel_definition_symbol_scope.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for SymbolScopeModel(_, tm2, ) in self.symbol_scope_model.iter_old_0(tm0, ) {

self.member_flat_arity_law_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn member_flat_arity_law_9(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Type, tm3: TypeList) {
for _ in [()] {
self.member_flat_arity_law_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn member_flat_arity_law_10(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Type, tm3: TypeList) {
for _ in [()] {
let tm4 = match self.cons_type_list.iter_all_0_1(tm2, tm3).next() {
    Some(ConsTypeList(_, _,  res)) => res,
    None => { 
        delta.new_cons_type_list_def.push(ConsTypeListArgs(tm2, tm3));
        break;
    },
};

self.member_flat_arity_law_12(delta, tm0, tm1, tm2, tm3, tm4);



}
}

#[allow(unused_variables)]
fn member_flat_arity_law_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm2, tm3, tm4, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for SymbolScopeModel(tm0, _, ) in self.symbol_scope_model.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for Arity(_, _, ) in self.arity.iter_old_0_1(tm1, tm3, ) {

self.member_flat_arity_law_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn member_flat_arity_law_12(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Type, tm3: TypeList, tm4: TypeList) {
for _ in [()] {
let exists_already = self.flat_arity.iter_all_0_1(tm1, tm4).next().is_some();
if !exists_already {
delta.new_flat_arity.push(FlatArity(tm1, tm4));
}



}
}


#[allow(unused_variables)]
fn member_flat_domain_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.member_flat_domain_law_1(delta, );
self.member_flat_domain_law_2(delta, );
self.member_flat_domain_law_3(delta, );
self.member_flat_domain_law_6(delta, );
self.member_flat_domain_law_9(delta, );
self.member_flat_domain_law_12(delta, );







}
}

#[allow(unused_variables)]
fn member_flat_domain_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn member_flat_domain_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, tm0, ) in self.rel_definition_symbol_scope.iter_new() {

#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_old_1(tm1, ) {

self.member_flat_domain_law_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn member_flat_domain_law_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm2, tm1, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm0, ) in self.rel_definition_symbol_scope.iter_all_0(tm1, ) {

self.member_flat_domain_law_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn member_flat_domain_law_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func) {
for _ in [()] {
self.member_flat_domain_law_5(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn member_flat_domain_law_5(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(_, tm3, ) in self.symbol_scope_model.iter_all_0(tm0, ) {

self.member_flat_domain_law_7(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn member_flat_domain_law_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(tm0, tm3, ) in self.symbol_scope_model.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_old_1(tm1, ) {

self.member_flat_domain_law_7(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn member_flat_domain_law_7(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func, tm3: Type) {
for _ in [()] {
self.member_flat_domain_law_8(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn member_flat_domain_law_8(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func, tm3: Type) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(_, tm4, ) in self.domain.iter_all_0(tm2, ) {

self.member_flat_domain_law_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn member_flat_domain_law_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(tm2, tm4, ) in self.domain.iter_new() {

#[allow(unused_variables)]
for FuncRel(_, tm1, ) in self.func_rel.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm0, ) in self.rel_definition_symbol_scope.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for SymbolScopeModel(_, tm3, ) in self.symbol_scope_model.iter_old_0(tm0, ) {

self.member_flat_domain_law_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn member_flat_domain_law_10(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func, tm3: Type, tm4: TypeList) {
for _ in [()] {
self.member_flat_domain_law_11(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn member_flat_domain_law_11(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func, tm3: Type, tm4: TypeList) {
for _ in [()] {
let tm5 = match self.cons_type_list.iter_all_0_1(tm3, tm4).next() {
    Some(ConsTypeList(_, _,  res)) => res,
    None => { 
        delta.new_cons_type_list_def.push(ConsTypeListArgs(tm3, tm4));
        break;
    },
};

self.member_flat_domain_law_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn member_flat_domain_law_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm3, tm4, tm5, ) in self.cons_type_list.iter_new() {

#[allow(unused_variables)]
for SymbolScopeModel(tm0, _, ) in self.symbol_scope_model.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm1, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for Domain(_, _, ) in self.domain.iter_old_0_1(tm2, tm4, ) {

self.member_flat_domain_law_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn member_flat_domain_law_13(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Rel, tm2: Func, tm3: Type, tm4: TypeList, tm5: TypeList) {
for _ in [()] {
let exists_already = self.flat_domain.iter_all_0_1(tm2, tm5).next().is_some();
if !exists_already {
delta.new_flat_domain.push(FlatDomain(tm2, tm5));
}



}
}


#[allow(unused_variables)]
fn parent_func_is_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.parent_func_is_total_1(delta, );
self.parent_func_is_total_2(delta, );



}
}

#[allow(unused_variables)]
fn parent_func_is_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn parent_func_is_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ParentModelFunc(tm1, tm0, ) in self.parent_model_func.iter_new() {

self.parent_func_is_total_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn parent_func_is_total_3(&self, delta: &mut ModelDelta, tm0: Func, tm1: Type) {
for _ in [()] {
let exists_already = self.is_total_func.iter_all_0(tm0).next().is_some();
if !exists_already {
delta.new_is_total_func.push(IsTotalFunc(tm0));
}



}
}


#[allow(unused_variables)]
fn el_list_cons_injective_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.el_list_cons_injective_1(delta, );
self.el_list_cons_injective_2(delta, );
self.el_list_cons_injective_3(delta, );




}
}

#[allow(unused_variables)]
fn el_list_cons_injective_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn el_list_cons_injective_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm1, tm3, tm0, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for ConsElList(tm2, tm4, _, ) in self.cons_el_list.iter_old_2(tm0, ) {

self.el_list_cons_injective_4(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn el_list_cons_injective_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm2, tm4, tm0, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for ConsElList(tm1, tm3, _, ) in self.cons_el_list.iter_all_2(tm0, ) {

self.el_list_cons_injective_4(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn el_list_cons_injective_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: El, tm3: ElList, tm4: ElList) {
for _ in [()] {
delta.new_el_equalities.push((tm1, tm2));

delta.new_el_equalities.push((tm2, tm1));

delta.new_el_list_equalities.push((tm3, tm4));

delta.new_el_list_equalities.push((tm4, tm3));






}
}


#[allow(unused_variables)]
fn el_list_snoc_injective_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.el_list_snoc_injective_1(delta, );
self.el_list_snoc_injective_2(delta, );
self.el_list_snoc_injective_3(delta, );




}
}

#[allow(unused_variables)]
fn el_list_snoc_injective_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn el_list_snoc_injective_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm1, tm3, tm0, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for SnocElList(tm2, tm4, _, ) in self.snoc_el_list.iter_old_2(tm0, ) {

self.el_list_snoc_injective_4(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn el_list_snoc_injective_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm2, tm4, tm0, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for SnocElList(tm1, tm3, _, ) in self.snoc_el_list.iter_all_2(tm0, ) {

self.el_list_snoc_injective_4(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn el_list_snoc_injective_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: ElList, tm3: El, tm4: El) {
for _ in [()] {
delta.new_el_list_equalities.push((tm1, tm2));

delta.new_el_list_equalities.push((tm2, tm1));

delta.new_el_equalities.push((tm3, tm4));

delta.new_el_equalities.push((tm4, tm3));






}
}


#[allow(unused_variables)]
fn el_list_cons_nil_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.el_list_cons_nil_1(delta, );
self.el_list_cons_nil_2(delta, );
self.el_list_cons_nil_3(delta, );




}
}

#[allow(unused_variables)]
fn el_list_cons_nil_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn el_list_cons_nil_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm2, tm0, ) in self.nil_el_list.iter_new() {

#[allow(unused_variables)]
for ConsElList(tm1, tm3, _, ) in self.cons_el_list.iter_old_2(tm0, ) {

self.el_list_cons_nil_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn el_list_cons_nil_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm1, tm3, tm0, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for NilElList(tm2, _, ) in self.nil_el_list.iter_all_1(tm0, ) {

self.el_list_cons_nil_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn el_list_cons_nil_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: Structure, tm3: ElList) {
for _ in [()] {
let exists_already = self.absurd.iter_all().next().is_some();
if !exists_already {
delta.new_absurd.push(Absurd());
}



}
}


#[allow(unused_variables)]
fn el_list_snoc_nil_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.el_list_snoc_nil_1(delta, );
self.el_list_snoc_nil_2(delta, );
self.el_list_snoc_nil_3(delta, );




}
}

#[allow(unused_variables)]
fn el_list_snoc_nil_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn el_list_snoc_nil_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm2, tm0, ) in self.nil_el_list.iter_new() {

#[allow(unused_variables)]
for SnocElList(tm1, tm3, _, ) in self.snoc_el_list.iter_old_2(tm0, ) {

self.el_list_snoc_nil_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn el_list_snoc_nil_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm1, tm3, tm0, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for NilElList(tm2, _, ) in self.nil_el_list.iter_all_1(tm0, ) {

self.el_list_snoc_nil_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn el_list_snoc_nil_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: Structure, tm3: El) {
for _ in [()] {
let exists_already = self.absurd.iter_all().next().is_some();
if !exists_already {
delta.new_absurd.push(Absurd());
}



}
}


#[allow(unused_variables)]
fn nil_els_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.nil_els_structure_1(delta, );
self.nil_els_structure_2(delta, );



}
}

#[allow(unused_variables)]
fn nil_els_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn nil_els_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm1, tm0, ) in self.nil_el_list.iter_new() {

self.nil_els_structure_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn nil_els_structure_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: Structure) {
for _ in [()] {
let exists_already = self.els_structure.iter_all_0_1(tm0, tm1).next().is_some();
if !exists_already {
delta.new_els_structure.push(ElsStructure(tm0, tm1));
}



}
}


#[allow(unused_variables)]
fn cons_els_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cons_els_structure_1(delta, );
self.cons_els_structure_2(delta, );
self.cons_els_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn cons_els_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cons_els_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm1, tm2, tm0, ) in self.cons_el_list.iter_new() {

self.cons_els_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cons_els_structure_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
for _ in [()] {
self.cons_els_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cons_els_structure_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(_, tm3, ) in self.el_structure.iter_all_0(tm1, ) {

self.cons_els_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cons_els_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(tm1, tm3, ) in self.el_structure.iter_new() {

#[allow(unused_variables)]
for ConsElList(_, tm2, tm0, ) in self.cons_el_list.iter_old_0(tm1, ) {

self.cons_els_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cons_els_structure_6(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList, tm3: Structure) {
for _ in [()] {
let exists_already = self.els_structure.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_els_structure.push(ElsStructure(tm0, tm3));
}

let exists_already = self.els_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_els_structure.push(ElsStructure(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn snoc_els_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.snoc_els_structure_1(delta, );
self.snoc_els_structure_2(delta, );
self.snoc_els_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn snoc_els_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn snoc_els_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm1, tm2, tm0, ) in self.snoc_el_list.iter_new() {

self.snoc_els_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn snoc_els_structure_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El) {
for _ in [()] {
self.snoc_els_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn snoc_els_structure_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(_, tm3, ) in self.el_structure.iter_all_0(tm2, ) {

self.snoc_els_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn snoc_els_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(tm2, tm3, ) in self.el_structure.iter_new() {

#[allow(unused_variables)]
for SnocElList(tm1, _, tm0, ) in self.snoc_el_list.iter_old_1(tm2, ) {

self.snoc_els_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn snoc_els_structure_6(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El, tm3: Structure) {
for _ in [()] {
let exists_already = self.els_structure.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_els_structure.push(ElsStructure(tm0, tm3));
}

let exists_already = self.els_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_els_structure.push(ElsStructure(tm1, tm3));
}




}
}


#[allow(unused_variables)]
fn var_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.var_structure_1(delta, );
self.var_structure_2(delta, );



}
}

#[allow(unused_variables)]
fn var_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn var_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Var(tm1, tm2, tm0, ) in self.var.iter_new() {

self.var_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn var_structure_3(&self, delta: &mut ModelDelta, tm0: El, tm1: Structure, tm2: ElName) {
for _ in [()] {
let exists_already = self.el_structure.iter_all_0_1(tm0, tm1).next().is_some();
if !exists_already {
delta.new_el_structure.push(ElStructure(tm0, tm1));
}



}
}


#[allow(unused_variables)]
fn ambient_type_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_type_total_1(delta, );
self.ambient_type_total_2(delta, );
self.ambient_type_total_5(delta, );




}
}

#[allow(unused_variables)]
fn ambient_type_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_type_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.type_new.iter().copied() {

self.ambient_type_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn ambient_type_total_3(&self, delta: &mut ModelDelta, tm0: Type) {
for _ in [()] {
self.ambient_type_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn ambient_type_total_4(&self, delta: &mut ModelDelta, tm0: Type) {
for _ in [()] {
let tm1 = match self.ambient_type.iter_all_0(tm0).next() {
    Some(AmbientType(_,  res)) => res,
    None => { 
        delta.new_ambient_type_def.push(AmbientTypeArgs(tm0));
        break;
    },
};

self.ambient_type_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn ambient_type_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm0, tm1, ) in self.ambient_type.iter_new() {

self.ambient_type_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ambient_type_total_6(&self, delta: &mut ModelDelta, tm0: Type, tm1: ElementType) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn underlying_type_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.underlying_type_law_1(delta, );
self.underlying_type_law_2(delta, );
self.underlying_type_law_7(delta, );
self.underlying_type_law_10(delta, );





}
}

#[allow(unused_variables)]
fn underlying_type_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn underlying_type_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.element_type_new.iter().copied() {

self.underlying_type_law_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn underlying_type_law_3(&self, delta: &mut ModelDelta, tm0: ElementType) {
for _ in [()] {
self.underlying_type_law_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn underlying_type_law_4(&self, delta: &mut ModelDelta, tm0: ElementType) {
for _ in [()] {
self.underlying_type_law_5(delta, tm0);


}
}

#[allow(unused_variables)]
fn underlying_type_law_5(&self, delta: &mut ModelDelta, tm0: ElementType) {
for _ in [()] {
self.underlying_type_law_6(delta, tm0);
self.underlying_type_law_9(delta, tm0);



}
}

#[allow(unused_variables)]
fn underlying_type_law_6(&self, delta: &mut ModelDelta, tm0: ElementType) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm1, _, ) in self.ambient_type.iter_all_1(tm0, ) {

self.underlying_type_law_8(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn underlying_type_law_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm1, tm0, ) in self.ambient_type.iter_new() {

self.underlying_type_law_8(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn underlying_type_law_8(&self, delta: &mut ModelDelta, tm0: ElementType, tm1: Type) {
for _ in [()] {
let exists_already = self.underlying_type.iter_all_0_1(tm0, tm1).next().is_some();
if !exists_already {
delta.new_underlying_type.push(UnderlyingType(tm0, tm1));
}



}
}

#[allow(unused_variables)]
fn underlying_type_law_9(&self, delta: &mut ModelDelta, tm0: ElementType) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm2, tm3, _, ) in self.instantiated_type.iter_all_2(tm0, ) {

self.underlying_type_law_11(delta, tm0, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn underlying_type_law_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm2, tm3, tm0, ) in self.instantiated_type.iter_new() {

self.underlying_type_law_11(delta, tm0, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn underlying_type_law_11(&self, delta: &mut ModelDelta, tm0: ElementType, tm2: El, tm3: Type) {
for _ in [()] {
let exists_already = self.underlying_type.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_underlying_type.push(UnderlyingType(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn ambient_el_type_list_nil_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_el_type_list_nil_1(delta, );
self.ambient_el_type_list_nil_2(delta, );
self.ambient_el_type_list_nil_5(delta, );




}
}

#[allow(unused_variables)]
fn ambient_el_type_list_nil_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_nil_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTypeList(tm0, ) in self.nil_type_list.iter_new() {

self.ambient_el_type_list_nil_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_nil_3(&self, delta: &mut ModelDelta, tm0: TypeList) {
for _ in [()] {
self.ambient_el_type_list_nil_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn ambient_el_type_list_nil_4(&self, delta: &mut ModelDelta, tm0: TypeList) {
for _ in [()] {
let tm1 = match self.nil_element_type_list.iter_all().next() {
    Some(NilElementTypeList( res)) => res,
    None => { 
        delta.new_nil_element_type_list_def.push(NilElementTypeListArgs());
        break;
    },
};

self.ambient_el_type_list_nil_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn ambient_el_type_list_nil_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElementTypeList(tm1, ) in self.nil_element_type_list.iter_new() {

#[allow(unused_variables)]
for NilTypeList(tm0, ) in self.nil_type_list.iter_old() {

self.ambient_el_type_list_nil_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_nil_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: ElementTypeList) {
for _ in [()] {
let exists_already = self.ambient_el_type_list.iter_all_0_1(tm0, tm1).next().is_some();
if !exists_already {
delta.new_ambient_el_type_list.push(AmbientElTypeList(tm0, tm1));
}



}
}


#[allow(unused_variables)]
fn ambient_el_type_list_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_el_type_list_cons_1(delta, );
self.ambient_el_type_list_cons_2(delta, );
self.ambient_el_type_list_cons_5(delta, );
self.ambient_el_type_list_cons_8(delta, );
self.ambient_el_type_list_cons_11(delta, );






}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm1, tm2, tm0, ) in self.cons_type_list.iter_new() {

self.ambient_el_type_list_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_3(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList) {
for _ in [()] {
self.ambient_el_type_list_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_4(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientElTypeList(_, tm3, ) in self.ambient_el_type_list.iter_all_0(tm2, ) {

self.ambient_el_type_list_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientElTypeList(tm2, tm3, ) in self.ambient_el_type_list.iter_new() {

#[allow(unused_variables)]
for ConsTypeList(tm1, _, tm0, ) in self.cons_type_list.iter_old_1(tm2, ) {

self.ambient_el_type_list_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList, tm3: ElementTypeList) {
for _ in [()] {
self.ambient_el_type_list_cons_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_7(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList, tm3: ElementTypeList) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(_, tm4, ) in self.ambient_type.iter_all_0(tm1, ) {

self.ambient_el_type_list_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm1, tm4, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for ConsTypeList(_, tm2, tm0, ) in self.cons_type_list.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for AmbientElTypeList(_, tm3, ) in self.ambient_el_type_list.iter_old_0(tm2, ) {

self.ambient_el_type_list_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_9(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList, tm3: ElementTypeList, tm4: ElementType) {
for _ in [()] {
self.ambient_el_type_list_cons_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_10(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList, tm3: ElementTypeList, tm4: ElementType) {
for _ in [()] {
let tm5 = match self.cons_element_type_list.iter_all_0_1(tm4, tm3).next() {
    Some(ConsElementTypeList(_, _,  res)) => res,
    None => { 
        delta.new_cons_element_type_list_def.push(ConsElementTypeListArgs(tm4, tm3));
        break;
    },
};

self.ambient_el_type_list_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElementTypeList(tm4, tm3, tm5, ) in self.cons_element_type_list.iter_new() {

#[allow(unused_variables)]
for AmbientType(tm1, _, ) in self.ambient_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AmbientElTypeList(tm2, _, ) in self.ambient_el_type_list.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for ConsTypeList(_, _, tm0, ) in self.cons_type_list.iter_old_0_1(tm1, tm2, ) {

self.ambient_el_type_list_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_cons_12(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList, tm3: ElementTypeList, tm4: ElementType, tm5: ElementTypeList) {
for _ in [()] {
let exists_already = self.ambient_el_type_list.iter_all_0_1(tm0, tm5).next().is_some();
if !exists_already {
delta.new_ambient_el_type_list.push(AmbientElTypeList(tm0, tm5));
}



}
}


#[allow(unused_variables)]
fn ambient_el_type_list_snoc_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_el_type_list_snoc_1(delta, );
self.ambient_el_type_list_snoc_2(delta, );
self.ambient_el_type_list_snoc_5(delta, );
self.ambient_el_type_list_snoc_8(delta, );
self.ambient_el_type_list_snoc_11(delta, );






}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocTypeList(tm1, tm2, tm0, ) in self.snoc_type_list.iter_new() {

self.ambient_el_type_list_snoc_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_3(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type) {
for _ in [()] {
self.ambient_el_type_list_snoc_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_4(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientElTypeList(_, tm3, ) in self.ambient_el_type_list.iter_all_0(tm1, ) {

self.ambient_el_type_list_snoc_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientElTypeList(tm1, tm3, ) in self.ambient_el_type_list.iter_new() {

#[allow(unused_variables)]
for SnocTypeList(_, tm2, tm0, ) in self.snoc_type_list.iter_old_0(tm1, ) {

self.ambient_el_type_list_snoc_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type, tm3: ElementTypeList) {
for _ in [()] {
self.ambient_el_type_list_snoc_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_7(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type, tm3: ElementTypeList) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(_, tm4, ) in self.ambient_type.iter_all_0(tm2, ) {

self.ambient_el_type_list_snoc_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm2, tm4, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for SnocTypeList(tm1, _, tm0, ) in self.snoc_type_list.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for AmbientElTypeList(_, tm3, ) in self.ambient_el_type_list.iter_old_0(tm1, ) {

self.ambient_el_type_list_snoc_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_9(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type, tm3: ElementTypeList, tm4: ElementType) {
for _ in [()] {
self.ambient_el_type_list_snoc_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_10(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type, tm3: ElementTypeList, tm4: ElementType) {
for _ in [()] {
let tm5 = match self.snoc_element_type_list.iter_all_0_1(tm3, tm4).next() {
    Some(SnocElementTypeList(_, _,  res)) => res,
    None => { 
        delta.new_snoc_element_type_list_def.push(SnocElementTypeListArgs(tm3, tm4));
        break;
    },
};

self.ambient_el_type_list_snoc_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElementTypeList(tm3, tm4, tm5, ) in self.snoc_element_type_list.iter_new() {

#[allow(unused_variables)]
for AmbientType(tm2, _, ) in self.ambient_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AmbientElTypeList(tm1, _, ) in self.ambient_el_type_list.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for SnocTypeList(_, _, tm0, ) in self.snoc_type_list.iter_old_0_1(tm1, tm2, ) {

self.ambient_el_type_list_snoc_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_el_type_list_snoc_12(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type, tm3: ElementTypeList, tm4: ElementType, tm5: ElementTypeList) {
for _ in [()] {
let exists_already = self.ambient_el_type_list.iter_all_0_1(tm0, tm5).next().is_some();
if !exists_already {
delta.new_ambient_el_type_list.push(AmbientElTypeList(tm0, tm5));
}



}
}


#[allow(unused_variables)]
fn nil_el_types_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.nil_el_types_1(delta, );
self.nil_el_types_2(delta, );
self.nil_el_types_5(delta, );




}
}

#[allow(unused_variables)]
fn nil_el_types_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn nil_el_types_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm1, tm0, ) in self.nil_el_list.iter_new() {

self.nil_el_types_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn nil_el_types_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: Structure) {
for _ in [()] {
self.nil_el_types_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn nil_el_types_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: Structure) {
for _ in [()] {
let tm2 = match self.nil_element_type_list.iter_all().next() {
    Some(NilElementTypeList( res)) => res,
    None => { 
        delta.new_nil_element_type_list_def.push(NilElementTypeListArgs());
        break;
    },
};

self.nil_el_types_6(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn nil_el_types_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElementTypeList(tm2, ) in self.nil_element_type_list.iter_new() {

#[allow(unused_variables)]
for NilElList(tm1, tm0, ) in self.nil_el_list.iter_old() {

self.nil_el_types_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn nil_el_types_6(&self, delta: &mut ModelDelta, tm0: ElList, tm1: Structure, tm2: ElementTypeList) {
for _ in [()] {
let exists_already = self.el_types.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_el_types.push(ElTypes(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn cons_el_types_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cons_el_types_1(delta, );
self.cons_el_types_2(delta, );
self.cons_el_types_5(delta, );
self.cons_el_types_8(delta, );
self.cons_el_types_11(delta, );






}
}

#[allow(unused_variables)]
fn cons_el_types_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cons_el_types_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm1, tm2, tm0, ) in self.cons_el_list.iter_new() {

self.cons_el_types_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cons_el_types_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
for _ in [()] {
self.cons_el_types_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cons_el_types_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(_, tm3, ) in self.el_type.iter_all_0(tm1, ) {

self.cons_el_types_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cons_el_types_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(tm1, tm3, ) in self.el_type.iter_new() {

#[allow(unused_variables)]
for ConsElList(_, tm2, tm0, ) in self.cons_el_list.iter_old_0(tm1, ) {

self.cons_el_types_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cons_el_types_6(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList, tm3: ElementType) {
for _ in [()] {
self.cons_el_types_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn cons_el_types_7(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList, tm3: ElementType) {
for _ in [()] {
#[allow(unused_variables)]
for ElTypes(_, tm4, ) in self.el_types.iter_all_0(tm2, ) {

self.cons_el_types_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn cons_el_types_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElTypes(tm2, tm4, ) in self.el_types.iter_new() {

#[allow(unused_variables)]
for ConsElList(tm1, _, tm0, ) in self.cons_el_list.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for ElType(_, tm3, ) in self.el_type.iter_old_0(tm1, ) {

self.cons_el_types_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn cons_el_types_9(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList, tm3: ElementType, tm4: ElementTypeList) {
for _ in [()] {
self.cons_el_types_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn cons_el_types_10(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList, tm3: ElementType, tm4: ElementTypeList) {
for _ in [()] {
let tm5 = match self.cons_element_type_list.iter_all_0_1(tm3, tm4).next() {
    Some(ConsElementTypeList(_, _,  res)) => res,
    None => { 
        delta.new_cons_element_type_list_def.push(ConsElementTypeListArgs(tm3, tm4));
        break;
    },
};

self.cons_el_types_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn cons_el_types_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElementTypeList(tm3, tm4, tm5, ) in self.cons_element_type_list.iter_new() {

#[allow(unused_variables)]
for ElTypes(tm2, _, ) in self.el_types.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for ElType(tm1, _, ) in self.el_type.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for ConsElList(_, _, tm0, ) in self.cons_el_list.iter_old_0_1(tm1, tm2, ) {

self.cons_el_types_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn cons_el_types_12(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList, tm3: ElementType, tm4: ElementTypeList, tm5: ElementTypeList) {
for _ in [()] {
let exists_already = self.el_types.iter_all_0_1(tm0, tm5).next().is_some();
if !exists_already {
delta.new_el_types.push(ElTypes(tm0, tm5));
}



}
}


#[allow(unused_variables)]
fn cons_el_types_reverse_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cons_el_types_reverse_1(delta, );
self.cons_el_types_reverse_2(delta, );
self.cons_el_types_reverse_5(delta, );
self.cons_el_types_reverse_6(delta, );





}
}

#[allow(unused_variables)]
fn cons_el_types_reverse_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cons_el_types_reverse_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm1, tm2, tm0, ) in self.cons_el_list.iter_new() {

self.cons_el_types_reverse_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cons_el_types_reverse_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
for _ in [()] {
self.cons_el_types_reverse_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cons_el_types_reverse_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for ElTypes(_, tm3, ) in self.el_types.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for ConsElementTypeList(tm4, tm5, _, ) in self.cons_element_type_list.iter_all_2(tm3, ) {

self.cons_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}
}

#[allow(unused_variables)]
fn cons_el_types_reverse_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElTypes(tm0, tm3, ) in self.el_types.iter_new() {

#[allow(unused_variables)]
for ConsElList(tm1, tm2, _, ) in self.cons_el_list.iter_old_2(tm0, ) {

#[allow(unused_variables)]
for ConsElementTypeList(tm4, tm5, _, ) in self.cons_element_type_list.iter_old_2(tm3, ) {

self.cons_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn cons_el_types_reverse_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElementTypeList(tm4, tm5, tm3, ) in self.cons_element_type_list.iter_new() {

#[allow(unused_variables)]
for ElTypes(tm0, _, ) in self.el_types.iter_all_1(tm3, ) {

#[allow(unused_variables)]
for ConsElList(tm1, tm2, _, ) in self.cons_el_list.iter_old_2(tm0, ) {

self.cons_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn cons_el_types_reverse_7(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList, tm3: ElementTypeList, tm4: ElementType, tm5: ElementTypeList) {
for _ in [()] {
let exists_already = self.el_type.iter_all_0_1(tm1, tm4).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm1, tm4));
}

let exists_already = self.el_types.iter_all_0_1(tm2, tm5).next().is_some();
if !exists_already {
delta.new_el_types.push(ElTypes(tm2, tm5));
}




}
}


#[allow(unused_variables)]
fn snoc_el_types_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.snoc_el_types_1(delta, );
self.snoc_el_types_2(delta, );
self.snoc_el_types_5(delta, );
self.snoc_el_types_8(delta, );
self.snoc_el_types_11(delta, );






}
}

#[allow(unused_variables)]
fn snoc_el_types_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn snoc_el_types_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm1, tm2, tm0, ) in self.snoc_el_list.iter_new() {

self.snoc_el_types_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn snoc_el_types_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El) {
for _ in [()] {
self.snoc_el_types_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn snoc_el_types_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El) {
for _ in [()] {
#[allow(unused_variables)]
for ElTypes(_, tm3, ) in self.el_types.iter_all_0(tm1, ) {

self.snoc_el_types_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn snoc_el_types_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElTypes(tm1, tm3, ) in self.el_types.iter_new() {

#[allow(unused_variables)]
for SnocElList(_, tm2, tm0, ) in self.snoc_el_list.iter_old_0(tm1, ) {

self.snoc_el_types_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn snoc_el_types_6(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El, tm3: ElementTypeList) {
for _ in [()] {
self.snoc_el_types_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn snoc_el_types_7(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El, tm3: ElementTypeList) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(_, tm4, ) in self.el_type.iter_all_0(tm2, ) {

self.snoc_el_types_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn snoc_el_types_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(tm2, tm4, ) in self.el_type.iter_new() {

#[allow(unused_variables)]
for SnocElList(tm1, _, tm0, ) in self.snoc_el_list.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for ElTypes(_, tm3, ) in self.el_types.iter_old_0(tm1, ) {

self.snoc_el_types_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn snoc_el_types_9(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El, tm3: ElementTypeList, tm4: ElementType) {
for _ in [()] {
self.snoc_el_types_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn snoc_el_types_10(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El, tm3: ElementTypeList, tm4: ElementType) {
for _ in [()] {
let tm5 = match self.snoc_element_type_list.iter_all_0_1(tm3, tm4).next() {
    Some(SnocElementTypeList(_, _,  res)) => res,
    None => { 
        delta.new_snoc_element_type_list_def.push(SnocElementTypeListArgs(tm3, tm4));
        break;
    },
};

self.snoc_el_types_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn snoc_el_types_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElementTypeList(tm3, tm4, tm5, ) in self.snoc_element_type_list.iter_new() {

#[allow(unused_variables)]
for ElTypes(tm1, _, ) in self.el_types.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for ElType(tm2, _, ) in self.el_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for SnocElList(_, _, tm0, ) in self.snoc_el_list.iter_old_0_1(tm1, tm2, ) {

self.snoc_el_types_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn snoc_el_types_12(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El, tm3: ElementTypeList, tm4: ElementType, tm5: ElementTypeList) {
for _ in [()] {
let exists_already = self.el_types.iter_all_0_1(tm0, tm5).next().is_some();
if !exists_already {
delta.new_el_types.push(ElTypes(tm0, tm5));
}



}
}


#[allow(unused_variables)]
fn snoc_el_types_reverse_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.snoc_el_types_reverse_1(delta, );
self.snoc_el_types_reverse_2(delta, );
self.snoc_el_types_reverse_5(delta, );
self.snoc_el_types_reverse_6(delta, );





}
}

#[allow(unused_variables)]
fn snoc_el_types_reverse_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn snoc_el_types_reverse_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm1, tm2, tm0, ) in self.snoc_el_list.iter_new() {

self.snoc_el_types_reverse_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn snoc_el_types_reverse_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El) {
for _ in [()] {
self.snoc_el_types_reverse_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn snoc_el_types_reverse_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El) {
for _ in [()] {
#[allow(unused_variables)]
for ElTypes(_, tm3, ) in self.el_types.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for SnocElementTypeList(tm4, tm5, _, ) in self.snoc_element_type_list.iter_all_2(tm3, ) {

self.snoc_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}
}

#[allow(unused_variables)]
fn snoc_el_types_reverse_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElTypes(tm0, tm3, ) in self.el_types.iter_new() {

#[allow(unused_variables)]
for SnocElList(tm1, tm2, _, ) in self.snoc_el_list.iter_old_2(tm0, ) {

#[allow(unused_variables)]
for SnocElementTypeList(tm4, tm5, _, ) in self.snoc_element_type_list.iter_old_2(tm3, ) {

self.snoc_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn snoc_el_types_reverse_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElementTypeList(tm4, tm5, tm3, ) in self.snoc_element_type_list.iter_new() {

#[allow(unused_variables)]
for ElTypes(tm0, _, ) in self.el_types.iter_all_1(tm3, ) {

#[allow(unused_variables)]
for SnocElList(tm1, tm2, _, ) in self.snoc_el_list.iter_old_2(tm0, ) {

self.snoc_el_types_reverse_7(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn snoc_el_types_reverse_7(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El, tm3: ElementTypeList, tm4: ElementTypeList, tm5: ElementType) {
for _ in [()] {
let exists_already = self.el_types.iter_all_0_1(tm1, tm4).next().is_some();
if !exists_already {
delta.new_el_types.push(ElTypes(tm1, tm4));
}

let exists_already = self.el_type.iter_all_0_1(tm2, tm5).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm2, tm5));
}




}
}


#[allow(unused_variables)]
fn rel_app_types_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rel_app_types_1(delta, );
self.rel_app_types_2(delta, );
self.rel_app_types_5(delta, );
self.rel_app_types_6(delta, );





}
}

#[allow(unused_variables)]
fn rel_app_types_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rel_app_types_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelApp(tm0, tm1, ) in self.rel_app.iter_new() {

self.rel_app_types_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rel_app_types_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
self.rel_app_types_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn rel_app_types_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(_, tm3, ) in self.arity.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for AmbientElTypeList(_, tm2, ) in self.ambient_el_type_list.iter_all_0(tm3, ) {

self.rel_app_types_7(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn rel_app_types_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Arity(tm0, tm3, ) in self.arity.iter_new() {

#[allow(unused_variables)]
for RelApp(_, tm1, ) in self.rel_app.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for AmbientElTypeList(_, tm2, ) in self.ambient_el_type_list.iter_old_0(tm3, ) {

self.rel_app_types_7(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn rel_app_types_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientElTypeList(tm3, tm2, ) in self.ambient_el_type_list.iter_new() {

#[allow(unused_variables)]
for Arity(tm0, _, ) in self.arity.iter_all_1(tm3, ) {

#[allow(unused_variables)]
for RelApp(_, tm1, ) in self.rel_app.iter_old_0(tm0, ) {

self.rel_app_types_7(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn rel_app_types_7(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: ElementTypeList, tm3: TypeList) {
for _ in [()] {
let exists_already = self.el_types.iter_all_0_1(tm1, tm2).next().is_some();
if !exists_already {
delta.new_el_types.push(ElTypes(tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn rel_app_func_app_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rel_app_func_app_1(delta, );
self.rel_app_func_app_2(delta, );
self.rel_app_func_app_3(delta, );
self.rel_app_func_app_4(delta, );





}
}

#[allow(unused_variables)]
fn rel_app_func_app_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rel_app_func_app_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelApp(tm0, tm1, ) in self.rel_app.iter_new() {

#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for SnocElList(tm3, tm4, _, ) in self.snoc_el_list.iter_old_2(tm1, ) {

self.rel_app_func_app_5(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn rel_app_func_app_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm2, tm0, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for RelApp(_, tm1, ) in self.rel_app.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for SnocElList(tm3, tm4, _, ) in self.snoc_el_list.iter_old_2(tm1, ) {

self.rel_app_func_app_5(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn rel_app_func_app_4(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm3, tm4, tm1, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for RelApp(tm0, _, ) in self.rel_app.iter_all_1(tm1, ) {

#[allow(unused_variables)]
for FuncRel(tm2, _, ) in self.func_rel.iter_all_1(tm0, ) {

self.rel_app_func_app_5(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn rel_app_func_app_5(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: Func, tm3: ElList, tm4: El) {
for _ in [()] {
let exists_already = self.func_app.iter_all_0_1_2(tm2, tm3, tm4).next().is_some();
if !exists_already {
delta.new_func_app.push(FuncApp(tm2, tm3, tm4));
}



}
}


#[allow(unused_variables)]
fn rel_app_constrained_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rel_app_constrained_1(delta, );
self.rel_app_constrained_2(delta, );



}
}

#[allow(unused_variables)]
fn rel_app_constrained_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rel_app_constrained_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelApp(tm0, tm1, ) in self.rel_app.iter_new() {

self.rel_app_constrained_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rel_app_constrained_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
let exists_already = self.constrained_els.iter_all_0(tm1).next().is_some();
if !exists_already {
delta.new_constrained_els.push(ConstrainedEls(tm1));
}



}
}


#[allow(unused_variables)]
fn constrained_head_tail_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.constrained_head_tail_1(delta, );
self.constrained_head_tail_2(delta, );
self.constrained_head_tail_3(delta, );




}
}

#[allow(unused_variables)]
fn constrained_head_tail_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn constrained_head_tail_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConstrainedEls(tm0, ) in self.constrained_els.iter_new() {

#[allow(unused_variables)]
for ConsElList(tm1, tm2, _, ) in self.cons_el_list.iter_old_2(tm0, ) {

self.constrained_head_tail_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn constrained_head_tail_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm1, tm2, tm0, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for ConstrainedEls(_, ) in self.constrained_els.iter_all_0(tm0, ) {

self.constrained_head_tail_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn constrained_head_tail_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: El, tm2: ElList) {
for _ in [()] {
let exists_already = self.constrained_el.iter_all_0(tm1).next().is_some();
if !exists_already {
delta.new_constrained_el.push(ConstrainedEl(tm1));
}

let exists_already = self.constrained_els.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_constrained_els.push(ConstrainedEls(tm2));
}




}
}


#[allow(unused_variables)]
fn constrained_init_snoc_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.constrained_init_snoc_1(delta, );
self.constrained_init_snoc_2(delta, );
self.constrained_init_snoc_3(delta, );




}
}

#[allow(unused_variables)]
fn constrained_init_snoc_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn constrained_init_snoc_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConstrainedEls(tm0, ) in self.constrained_els.iter_new() {

#[allow(unused_variables)]
for SnocElList(tm1, tm2, _, ) in self.snoc_el_list.iter_old_2(tm0, ) {

self.constrained_init_snoc_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn constrained_init_snoc_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm1, tm2, tm0, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for ConstrainedEls(_, ) in self.constrained_els.iter_all_0(tm0, ) {

self.constrained_init_snoc_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn constrained_init_snoc_4(&self, delta: &mut ModelDelta, tm0: ElList, tm1: ElList, tm2: El) {
for _ in [()] {
let exists_already = self.constrained_els.iter_all_0(tm1).next().is_some();
if !exists_already {
delta.new_constrained_els.push(ConstrainedEls(tm1));
}

let exists_already = self.constrained_el.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_constrained_el.push(ConstrainedEl(tm2));
}




}
}


#[allow(unused_variables)]
fn dom_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.dom_total_1(delta, );
self.dom_total_2(delta, );
self.dom_total_5(delta, );




}
}

#[allow(unused_variables)]
fn dom_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn dom_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.morphism_new.iter().copied() {

self.dom_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn dom_total_3(&self, delta: &mut ModelDelta, tm0: Morphism) {
for _ in [()] {
self.dom_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn dom_total_4(&self, delta: &mut ModelDelta, tm0: Morphism) {
for _ in [()] {
let tm1 = match self.dom.iter_all_0(tm0).next() {
    Some(Dom(_,  res)) => res,
    None => { 
        delta.new_dom_def.push(DomArgs(tm0));
        break;
    },
};

self.dom_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn dom_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Dom(tm0, tm1, ) in self.dom.iter_new() {

self.dom_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn dom_total_6(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: Structure) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn cod_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cod_total_1(delta, );
self.cod_total_2(delta, );
self.cod_total_5(delta, );




}
}

#[allow(unused_variables)]
fn cod_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cod_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.morphism_new.iter().copied() {

self.cod_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn cod_total_3(&self, delta: &mut ModelDelta, tm0: Morphism) {
for _ in [()] {
self.cod_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn cod_total_4(&self, delta: &mut ModelDelta, tm0: Morphism) {
for _ in [()] {
let tm1 = match self.cod.iter_all_0(tm0).next() {
    Some(Cod(_,  res)) => res,
    None => { 
        delta.new_cod_def.push(CodArgs(tm0));
        break;
    },
};

self.cod_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn cod_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm0, tm1, ) in self.cod.iter_new() {

self.cod_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cod_total_6(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: Structure) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn map_el_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.map_el_structure_1(delta, );
self.map_el_structure_2(delta, );
self.map_el_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn map_el_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn map_el_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm1, tm2, tm0, ) in self.map_el.iter_new() {

self.map_el_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn map_el_structure_3(&self, delta: &mut ModelDelta, tm0: El, tm1: Morphism, tm2: El) {
for _ in [()] {
self.map_el_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn map_el_structure_4(&self, delta: &mut ModelDelta, tm0: El, tm1: Morphism, tm2: El) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(_, tm3, ) in self.cod.iter_all_0(tm1, ) {

self.map_el_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn map_el_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm1, tm3, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for MapEl(_, tm2, tm0, ) in self.map_el.iter_old_0(tm1, ) {

self.map_el_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn map_el_structure_6(&self, delta: &mut ModelDelta, tm0: El, tm1: Morphism, tm2: El, tm3: Structure) {
for _ in [()] {
let exists_already = self.el_structure.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_el_structure.push(ElStructure(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn map_el_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.map_el_defined_1(delta, );
self.map_el_defined_2(delta, );
self.map_el_defined_5(delta, );
self.map_el_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn map_el_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn map_el_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Dom(tm1, tm0, ) in self.dom.iter_new() {

self.map_el_defined_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn map_el_defined_3(&self, delta: &mut ModelDelta, tm0: Structure, tm1: Morphism) {
for _ in [()] {
self.map_el_defined_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn map_el_defined_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(tm2, _, ) in self.el_structure.iter_all_1(tm0, ) {

self.map_el_defined_6(delta, tm1, tm0, tm2);


}

}
}

#[allow(unused_variables)]
fn map_el_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(tm2, tm0, ) in self.el_structure.iter_new() {

#[allow(unused_variables)]
for Dom(tm1, _, ) in self.dom.iter_old_1(tm0, ) {

self.map_el_defined_6(delta, tm1, tm0, tm2);


}

}

}
}

#[allow(unused_variables)]
fn map_el_defined_6(&self, delta: &mut ModelDelta, tm1: Morphism, tm0: Structure, tm2: El) {
for _ in [()] {
self.map_el_defined_7(delta, tm1, tm0, tm2);


}
}

#[allow(unused_variables)]
fn map_el_defined_7(&self, delta: &mut ModelDelta, tm1: Morphism, tm0: Structure, tm2: El) {
for _ in [()] {
let tm3 = match self.map_el.iter_all_0_1(tm1, tm2).next() {
    Some(MapEl(_, _,  res)) => res,
    None => { 
        delta.new_map_el_def.push(MapElArgs(tm1, tm2));
        break;
    },
};

self.map_el_defined_9(delta, tm1, tm0, tm2, tm3);



}
}

#[allow(unused_variables)]
fn map_el_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm1, tm2, tm3, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for ElStructure(_, _, ) in self.el_structure.iter_old_0_1(tm2, tm0, ) {

self.map_el_defined_9(delta, tm1, tm0, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn map_el_defined_9(&self, delta: &mut ModelDelta, tm1: Morphism, tm0: Structure, tm2: El, tm3: El) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn map_els_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.map_els_defined_1(delta, );
self.map_els_defined_2(delta, );
self.map_els_defined_3(delta, );
self.map_els_defined_8(delta, );
self.map_els_defined_11(delta, );
self.map_els_defined_14(delta, );
self.map_els_defined_17(delta, );
self.map_els_defined_20(delta, );
self.map_els_defined_23(delta, );
self.map_els_defined_26(delta, );
self.map_els_defined_29(delta, );
self.map_els_defined_32(delta, );
self.map_els_defined_35(delta, );
self.map_els_defined_38(delta, );















}
}

#[allow(unused_variables)]
fn map_els_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn map_els_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElsStructure(tm1, tm0, ) in self.els_structure.iter_new() {

#[allow(unused_variables)]
for Dom(tm2, _, ) in self.dom.iter_old_1(tm0, ) {

self.map_els_defined_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Dom(tm2, tm0, ) in self.dom.iter_new() {

#[allow(unused_variables)]
for ElsStructure(tm1, _, ) in self.els_structure.iter_all_1(tm0, ) {

self.map_els_defined_4(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElList, tm2: Morphism) {
for _ in [()] {
self.map_els_defined_5(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn map_els_defined_5(&self, delta: &mut ModelDelta, tm0: Structure, tm1: ElList, tm2: Morphism) {
for _ in [()] {
self.map_els_defined_6(delta, tm0, tm2, tm1);


}
}

#[allow(unused_variables)]
fn map_els_defined_6(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList) {
for _ in [()] {
self.map_els_defined_7(delta, tm0, tm2, tm1);
self.map_els_defined_10(delta, tm0, tm2, tm1);
self.map_els_defined_13(delta, tm0, tm2, tm1);




}
}

#[allow(unused_variables)]
fn map_els_defined_7(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm3, _, ) in self.nil_el_list.iter_all_1(tm1, ) {

self.map_els_defined_9(delta, tm0, tm2, tm1, tm3);


}

}
}

#[allow(unused_variables)]
fn map_els_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm3, tm1, ) in self.nil_el_list.iter_new() {

#[allow(unused_variables)]
for ElsStructure(_, tm0, ) in self.els_structure.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for Dom(tm2, _, ) in self.dom.iter_old_1(tm0, ) {

self.map_els_defined_9(delta, tm0, tm2, tm1, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_9(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm3: Structure) {
for _ in [()] {
self.map_els_defined_16(delta, tm0, tm2, tm1, tm3);


}
}

#[allow(unused_variables)]
fn map_els_defined_10(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm4, tm5, _, ) in self.cons_el_list.iter_all_2(tm1, ) {

self.map_els_defined_12(delta, tm0, tm2, tm1, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn map_els_defined_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm4, tm5, tm1, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for ElsStructure(_, tm0, ) in self.els_structure.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for Dom(tm2, _, ) in self.dom.iter_old_1(tm0, ) {

self.map_els_defined_12(delta, tm0, tm2, tm1, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_12(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm4: El, tm5: ElList) {
for _ in [()] {
self.map_els_defined_19(delta, tm0, tm2, tm1, tm4, tm5);


}
}

#[allow(unused_variables)]
fn map_els_defined_13(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm6, tm7, _, ) in self.snoc_el_list.iter_all_2(tm1, ) {

self.map_els_defined_15(delta, tm0, tm2, tm1, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn map_els_defined_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm6, tm7, tm1, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for ElsStructure(_, tm0, ) in self.els_structure.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for Dom(tm2, _, ) in self.dom.iter_old_1(tm0, ) {

self.map_els_defined_15(delta, tm0, tm2, tm1, tm6, tm7);


}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_15(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm6: ElList, tm7: El) {
for _ in [()] {
self.map_els_defined_22(delta, tm0, tm2, tm1, tm6, tm7);


}
}

#[allow(unused_variables)]
fn map_els_defined_16(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm3: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(_, tm8, ) in self.cod.iter_all_0(tm2, ) {

self.map_els_defined_18(delta, tm0, tm2, tm1, tm3, tm8);


}

}
}

#[allow(unused_variables)]
fn map_els_defined_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm2, tm8, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ElsStructure(tm1, _, ) in self.els_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for NilElList(tm3, _, ) in self.nil_el_list.iter_old_1(tm1, ) {

self.map_els_defined_18(delta, tm0, tm2, tm1, tm3, tm8);


}

}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_18(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm3: Structure, tm8: Structure) {
for _ in [()] {
self.map_els_defined_31(delta, tm0, tm2, tm1, tm3, tm8);


}
}

#[allow(unused_variables)]
fn map_els_defined_19(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm4: El, tm5: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(_, _, tm9, ) in self.map_el.iter_all_0_1(tm2, tm4, ) {

self.map_els_defined_21(delta, tm0, tm2, tm1, tm4, tm5, tm9);


}

}
}

#[allow(unused_variables)]
fn map_els_defined_20(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm2, tm4, tm9, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ElsStructure(tm1, _, ) in self.els_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for ConsElList(_, tm5, _, ) in self.cons_el_list.iter_old_0_2(tm4, tm1, ) {

self.map_els_defined_21(delta, tm0, tm2, tm1, tm4, tm5, tm9);


}

}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_21(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm4: El, tm5: ElList, tm9: El) {
for _ in [()] {
self.map_els_defined_25(delta, tm0, tm2, tm1, tm4, tm5, tm9);


}
}

#[allow(unused_variables)]
fn map_els_defined_22(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm6: ElList, tm7: El) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(_, _, tm10, ) in self.map_els.iter_all_0_1(tm2, tm6, ) {

self.map_els_defined_24(delta, tm0, tm2, tm1, tm6, tm7, tm10);


}

}
}

#[allow(unused_variables)]
fn map_els_defined_23(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(tm2, tm6, tm10, ) in self.map_els.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ElsStructure(tm1, _, ) in self.els_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for SnocElList(_, tm7, _, ) in self.snoc_el_list.iter_old_0_2(tm6, tm1, ) {

self.map_els_defined_24(delta, tm0, tm2, tm1, tm6, tm7, tm10);


}

}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_24(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm6: ElList, tm7: El, tm10: ElList) {
for _ in [()] {
self.map_els_defined_28(delta, tm0, tm2, tm1, tm6, tm7, tm10);


}
}

#[allow(unused_variables)]
fn map_els_defined_25(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm4: El, tm5: ElList, tm9: El) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(_, _, tm11, ) in self.map_els.iter_all_0_1(tm2, tm5, ) {

self.map_els_defined_27(delta, tm0, tm2, tm1, tm4, tm5, tm9, tm11);


}

}
}

#[allow(unused_variables)]
fn map_els_defined_26(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(tm2, tm5, tm11, ) in self.map_els.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ElsStructure(tm1, _, ) in self.els_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for ConsElList(tm4, _, _, ) in self.cons_el_list.iter_old_1_2(tm5, tm1, ) {

#[allow(unused_variables)]
for MapEl(_, _, tm9, ) in self.map_el.iter_old_0_1(tm2, tm4, ) {

self.map_els_defined_27(delta, tm0, tm2, tm1, tm4, tm5, tm9, tm11);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_27(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm4: El, tm5: ElList, tm9: El, tm11: ElList) {
for _ in [()] {
self.map_els_defined_34(delta, tm0, tm2, tm1, tm4, tm5, tm9, tm11);


}
}

#[allow(unused_variables)]
fn map_els_defined_28(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm6: ElList, tm7: El, tm10: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(_, _, tm12, ) in self.map_el.iter_all_0_1(tm2, tm7, ) {

self.map_els_defined_30(delta, tm0, tm2, tm1, tm6, tm7, tm10, tm12);


}

}
}

#[allow(unused_variables)]
fn map_els_defined_29(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm2, tm7, tm12, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ElsStructure(tm1, _, ) in self.els_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for SnocElList(tm6, _, _, ) in self.snoc_el_list.iter_old_1_2(tm7, tm1, ) {

#[allow(unused_variables)]
for MapEls(_, _, tm10, ) in self.map_els.iter_old_0_1(tm2, tm6, ) {

self.map_els_defined_30(delta, tm0, tm2, tm1, tm6, tm7, tm10, tm12);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_30(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm6: ElList, tm7: El, tm10: ElList, tm12: El) {
for _ in [()] {
self.map_els_defined_37(delta, tm0, tm2, tm1, tm6, tm7, tm10, tm12);


}
}

#[allow(unused_variables)]
fn map_els_defined_31(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm3: Structure, tm8: Structure) {
for _ in [()] {
let tm13 = match self.nil_el_list.iter_all_0(tm8).next() {
    Some(NilElList(_,  res)) => res,
    None => { 
        delta.new_nil_el_list_def.push(NilElListArgs(tm8));
        break;
    },
};

self.map_els_defined_33(delta, tm0, tm2, tm1, tm3, tm8, tm13);



}
}

#[allow(unused_variables)]
fn map_els_defined_32(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm8, tm13, ) in self.nil_el_list.iter_new() {

#[allow(unused_variables)]
for Cod(tm2, _, ) in self.cod.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ElsStructure(tm1, _, ) in self.els_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for NilElList(tm3, _, ) in self.nil_el_list.iter_old_1(tm1, ) {

self.map_els_defined_33(delta, tm0, tm2, tm1, tm3, tm8, tm13);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_33(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm3: Structure, tm8: Structure, tm13: ElList) {
for _ in [()] {
let exists_already = self.map_els.iter_all_0_1_2(tm2, tm1, tm13).next().is_some();
if !exists_already {
delta.new_map_els.push(MapEls(tm2, tm1, tm13));
}



}
}

#[allow(unused_variables)]
fn map_els_defined_34(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm4: El, tm5: ElList, tm9: El, tm11: ElList) {
for _ in [()] {
let tm14 = match self.cons_el_list.iter_all_0_1(tm9, tm11).next() {
    Some(ConsElList(_, _,  res)) => res,
    None => { 
        delta.new_cons_el_list_def.push(ConsElListArgs(tm9, tm11));
        break;
    },
};

self.map_els_defined_36(delta, tm0, tm2, tm1, tm4, tm5, tm9, tm11, tm14);



}
}

#[allow(unused_variables)]
fn map_els_defined_35(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm9, tm11, tm14, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for MapEls(tm2, tm5, _, ) in self.map_els.iter_old_2(tm11, ) {

#[allow(unused_variables)]
for MapEl(_, tm4, _, ) in self.map_el.iter_old_0_2(tm2, tm9, ) {

#[allow(unused_variables)]
for ConsElList(_, _, tm1, ) in self.cons_el_list.iter_old_0_1(tm4, tm5, ) {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ElsStructure(_, _, ) in self.els_structure.iter_old_0_1(tm1, tm0, ) {

self.map_els_defined_36(delta, tm0, tm2, tm1, tm4, tm5, tm9, tm11, tm14);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_36(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm4: El, tm5: ElList, tm9: El, tm11: ElList, tm14: ElList) {
for _ in [()] {
let exists_already = self.map_els.iter_all_0_1_2(tm2, tm1, tm14).next().is_some();
if !exists_already {
delta.new_map_els.push(MapEls(tm2, tm1, tm14));
}



}
}

#[allow(unused_variables)]
fn map_els_defined_37(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm6: ElList, tm7: El, tm10: ElList, tm12: El) {
for _ in [()] {
let tm15 = match self.snoc_el_list.iter_all_0_1(tm10, tm12).next() {
    Some(SnocElList(_, _,  res)) => res,
    None => { 
        delta.new_snoc_el_list_def.push(SnocElListArgs(tm10, tm12));
        break;
    },
};

self.map_els_defined_39(delta, tm0, tm2, tm1, tm6, tm7, tm10, tm12, tm15);



}
}

#[allow(unused_variables)]
fn map_els_defined_38(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm10, tm12, tm15, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for MapEls(tm2, tm6, _, ) in self.map_els.iter_old_2(tm10, ) {

#[allow(unused_variables)]
for MapEl(_, tm7, _, ) in self.map_el.iter_old_0_2(tm2, tm12, ) {

#[allow(unused_variables)]
for SnocElList(_, _, tm1, ) in self.snoc_el_list.iter_old_0_1(tm6, tm7, ) {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ElsStructure(_, _, ) in self.els_structure.iter_old_0_1(tm1, tm0, ) {

self.map_els_defined_39(delta, tm0, tm2, tm1, tm6, tm7, tm10, tm12, tm15);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn map_els_defined_39(&self, delta: &mut ModelDelta, tm0: Structure, tm2: Morphism, tm1: ElList, tm6: ElList, tm7: El, tm10: ElList, tm12: El, tm15: ElList) {
for _ in [()] {
let exists_already = self.map_els.iter_all_0_1_2(tm2, tm1, tm15).next().is_some();
if !exists_already {
delta.new_map_els.push(MapEls(tm2, tm1, tm15));
}



}
}


#[allow(unused_variables)]
fn map_var_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.map_var_1(delta, );
self.map_var_2(delta, );
self.map_var_5(delta, );
self.map_var_8(delta, );





}
}

#[allow(unused_variables)]
fn map_var_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn map_var_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Var(tm1, tm2, tm0, ) in self.var.iter_new() {

self.map_var_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn map_var_3(&self, delta: &mut ModelDelta, tm0: El, tm1: Structure, tm2: ElName) {
for _ in [()] {
self.map_var_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn map_var_4(&self, delta: &mut ModelDelta, tm0: El, tm1: Structure, tm2: ElName) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm4, _, tm3, ) in self.map_el.iter_all_1(tm0, ) {

self.map_var_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn map_var_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm4, tm0, tm3, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for Var(tm1, tm2, _, ) in self.var.iter_old_2(tm0, ) {

self.map_var_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn map_var_6(&self, delta: &mut ModelDelta, tm0: El, tm1: Structure, tm2: ElName, tm3: El, tm4: Morphism) {
for _ in [()] {
self.map_var_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn map_var_7(&self, delta: &mut ModelDelta, tm0: El, tm1: Structure, tm2: ElName, tm3: El, tm4: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(_, tm5, ) in self.cod.iter_all_0(tm4, ) {

self.map_var_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn map_var_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm4, tm5, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for MapEl(_, tm0, tm3, ) in self.map_el.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for Var(tm1, tm2, _, ) in self.var.iter_old_2(tm0, ) {

self.map_var_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn map_var_9(&self, delta: &mut ModelDelta, tm0: El, tm1: Structure, tm2: ElName, tm3: El, tm4: Morphism, tm5: Structure) {
for _ in [()] {
let exists_already = self.var.iter_all_0_1_2(tm5, tm2, tm3).next().is_some();
if !exists_already {
delta.new_var.push(Var(tm5, tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn map_rel_app_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.map_rel_app_1(delta, );
self.map_rel_app_2(delta, );
self.map_rel_app_5(delta, );




}
}

#[allow(unused_variables)]
fn map_rel_app_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn map_rel_app_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelApp(tm0, tm1, ) in self.rel_app.iter_new() {

self.map_rel_app_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn map_rel_app_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
self.map_rel_app_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn map_rel_app_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(tm3, _, tm2, ) in self.map_els.iter_all_1(tm1, ) {

self.map_rel_app_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn map_rel_app_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(tm3, tm1, tm2, ) in self.map_els.iter_new() {

#[allow(unused_variables)]
for RelApp(tm0, _, ) in self.rel_app.iter_old_1(tm1, ) {

self.map_rel_app_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn map_rel_app_6(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: ElList, tm3: Morphism) {
for _ in [()] {
let exists_already = self.rel_app.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_rel_app.push(RelApp(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn map_preserves_el_type_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.map_preserves_el_type_1(delta, );
self.map_preserves_el_type_2(delta, );
self.map_preserves_el_type_5(delta, );
self.map_preserves_el_type_10(delta, );
self.map_preserves_el_type_13(delta, );
self.map_preserves_el_type_16(delta, );
self.map_preserves_el_type_19(delta, );








}
}

#[allow(unused_variables)]
fn map_preserves_el_type_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(tm0, tm1, ) in self.el_type.iter_new() {

self.map_preserves_el_type_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_3(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType) {
for _ in [()] {
self.map_preserves_el_type_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn map_preserves_el_type_4(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm3, _, tm2, ) in self.map_el.iter_all_1(tm0, ) {

self.map_preserves_el_type_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm3, tm0, tm2, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for ElType(_, tm1, ) in self.el_type.iter_old_0(tm0, ) {

self.map_preserves_el_type_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_6(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: El, tm3: Morphism) {
for _ in [()] {
self.map_preserves_el_type_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn map_preserves_el_type_7(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: El, tm3: Morphism) {
for _ in [()] {
self.map_preserves_el_type_8(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn map_preserves_el_type_8(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: El, tm3: Morphism) {
for _ in [()] {
self.map_preserves_el_type_9(delta, tm0, tm1, tm2, tm3);
self.map_preserves_el_type_12(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn map_preserves_el_type_9(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: El, tm3: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm4, _, ) in self.ambient_type.iter_all_1(tm1, ) {

self.map_preserves_el_type_11(delta, tm0, tm2, tm3, tm1, tm4);


}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm4, tm1, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for ElType(tm0, _, ) in self.el_type.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for MapEl(tm3, _, tm2, ) in self.map_el.iter_old_1(tm0, ) {

self.map_preserves_el_type_11(delta, tm0, tm2, tm3, tm1, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_11(&self, delta: &mut ModelDelta, tm0: El, tm2: El, tm3: Morphism, tm1: ElementType, tm4: Type) {
for _ in [()] {
let exists_already = self.el_type.iter_all_0_1(tm2, tm1).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm2, tm1));
}



}
}

#[allow(unused_variables)]
fn map_preserves_el_type_12(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: El, tm3: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm5, tm6, _, ) in self.instantiated_type.iter_all_2(tm1, ) {

self.map_preserves_el_type_14(delta, tm0, tm2, tm3, tm1, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm5, tm6, tm1, ) in self.instantiated_type.iter_new() {

#[allow(unused_variables)]
for ElType(tm0, _, ) in self.el_type.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for MapEl(tm3, _, tm2, ) in self.map_el.iter_old_1(tm0, ) {

self.map_preserves_el_type_14(delta, tm0, tm2, tm3, tm1, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_14(&self, delta: &mut ModelDelta, tm0: El, tm2: El, tm3: Morphism, tm1: ElementType, tm5: El, tm6: Type) {
for _ in [()] {
self.map_preserves_el_type_15(delta, tm0, tm2, tm3, tm1, tm5, tm6);


}
}

#[allow(unused_variables)]
fn map_preserves_el_type_15(&self, delta: &mut ModelDelta, tm0: El, tm2: El, tm3: Morphism, tm1: ElementType, tm5: El, tm6: Type) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(_, _, tm7, ) in self.map_el.iter_all_0_1(tm3, tm5, ) {

self.map_preserves_el_type_17(delta, tm0, tm2, tm3, tm1, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_16(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm3, tm5, tm7, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for InstantiatedType(_, tm6, tm1, ) in self.instantiated_type.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ElType(tm0, _, ) in self.el_type.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for MapEl(_, _, tm2, ) in self.map_el.iter_old_0_1(tm3, tm0, ) {

self.map_preserves_el_type_17(delta, tm0, tm2, tm3, tm1, tm5, tm6, tm7);


}

}

}

}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_17(&self, delta: &mut ModelDelta, tm0: El, tm2: El, tm3: Morphism, tm1: ElementType, tm5: El, tm6: Type, tm7: El) {
for _ in [()] {
self.map_preserves_el_type_18(delta, tm0, tm2, tm3, tm1, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn map_preserves_el_type_18(&self, delta: &mut ModelDelta, tm0: El, tm2: El, tm3: Morphism, tm1: ElementType, tm5: El, tm6: Type, tm7: El) {
for _ in [()] {
let tm8 = match self.instantiated_type.iter_all_0_1(tm7, tm6).next() {
    Some(InstantiatedType(_, _,  res)) => res,
    None => { 
        delta.new_instantiated_type_def.push(InstantiatedTypeArgs(tm7, tm6));
        break;
    },
};

self.map_preserves_el_type_20(delta, tm0, tm2, tm3, tm1, tm5, tm6, tm7, tm8);



}
}

#[allow(unused_variables)]
fn map_preserves_el_type_19(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm7, tm6, tm8, ) in self.instantiated_type.iter_new() {

#[allow(unused_variables)]
for InstantiatedType(tm5, _, tm1, ) in self.instantiated_type.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for ElType(tm0, _, ) in self.el_type.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for MapEl(tm3, _, _, ) in self.map_el.iter_old_1_2(tm5, tm7, ) {

#[allow(unused_variables)]
for MapEl(_, _, tm2, ) in self.map_el.iter_old_0_1(tm3, tm0, ) {

self.map_preserves_el_type_20(delta, tm0, tm2, tm3, tm1, tm5, tm6, tm7, tm8);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn map_preserves_el_type_20(&self, delta: &mut ModelDelta, tm0: El, tm2: El, tm3: Morphism, tm1: ElementType, tm5: El, tm6: Type, tm7: El, tm8: ElementType) {
for _ in [()] {
let exists_already = self.el_type.iter_all_0_1(tm2, tm8).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm2, tm8));
}



}
}


#[allow(unused_variables)]
fn map_reflects_el_type_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.map_reflects_el_type_1(delta, );
self.map_reflects_el_type_2(delta, );
self.map_reflects_el_type_3(delta, );
self.map_reflects_el_type_8(delta, );
self.map_reflects_el_type_11(delta, );






}
}

#[allow(unused_variables)]
fn map_reflects_el_type_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn map_reflects_el_type_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(tm0, tm1, ) in self.el_type.iter_new() {

#[allow(unused_variables)]
for MapEl(tm2, tm3, _, ) in self.map_el.iter_old_2(tm0, ) {

self.map_reflects_el_type_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn map_reflects_el_type_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm2, tm3, tm0, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for ElType(_, tm1, ) in self.el_type.iter_all_0(tm0, ) {

self.map_reflects_el_type_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn map_reflects_el_type_4(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: Morphism, tm3: El) {
for _ in [()] {
self.map_reflects_el_type_5(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn map_reflects_el_type_5(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: Morphism, tm3: El) {
for _ in [()] {
self.map_reflects_el_type_6(delta, tm0, tm2, tm3, tm1);


}
}

#[allow(unused_variables)]
fn map_reflects_el_type_6(&self, delta: &mut ModelDelta, tm0: El, tm2: Morphism, tm3: El, tm1: ElementType) {
for _ in [()] {
self.map_reflects_el_type_7(delta, tm0, tm2, tm3, tm1);
self.map_reflects_el_type_10(delta, tm0, tm2, tm3, tm1);



}
}

#[allow(unused_variables)]
fn map_reflects_el_type_7(&self, delta: &mut ModelDelta, tm0: El, tm2: Morphism, tm3: El, tm1: ElementType) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm4, _, ) in self.ambient_type.iter_all_1(tm1, ) {

self.map_reflects_el_type_9(delta, tm0, tm2, tm3, tm1, tm4);


}

}
}

#[allow(unused_variables)]
fn map_reflects_el_type_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm4, tm1, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for ElType(tm0, _, ) in self.el_type.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for MapEl(tm2, tm3, _, ) in self.map_el.iter_old_2(tm0, ) {

self.map_reflects_el_type_9(delta, tm0, tm2, tm3, tm1, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn map_reflects_el_type_9(&self, delta: &mut ModelDelta, tm0: El, tm2: Morphism, tm3: El, tm1: ElementType, tm4: Type) {
for _ in [()] {
let exists_already = self.el_type.iter_all_0_1(tm3, tm1).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm3, tm1));
}



}
}

#[allow(unused_variables)]
fn map_reflects_el_type_10(&self, delta: &mut ModelDelta, tm0: El, tm2: Morphism, tm3: El, tm1: ElementType) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm5, tm6, _, ) in self.instantiated_type.iter_all_2(tm1, ) {

self.map_reflects_el_type_12(delta, tm0, tm2, tm3, tm1, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn map_reflects_el_type_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm5, tm6, tm1, ) in self.instantiated_type.iter_new() {

#[allow(unused_variables)]
for ElType(tm0, _, ) in self.el_type.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for MapEl(tm2, tm3, _, ) in self.map_el.iter_old_2(tm0, ) {

self.map_reflects_el_type_12(delta, tm0, tm2, tm3, tm1, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn map_reflects_el_type_12(&self, delta: &mut ModelDelta, tm0: El, tm2: Morphism, tm3: El, tm1: ElementType, tm5: El, tm6: Type) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn map_preserves_ambient_model_els_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.map_preserves_ambient_model_els_1(delta, );
self.map_preserves_ambient_model_els_2(delta, );
self.map_preserves_ambient_model_els_5(delta, );
self.map_preserves_ambient_model_els_8(delta, );





}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm1, tm2, tm0, ) in self.ambient_model_el.iter_new() {

self.map_preserves_ambient_model_els_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_3(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure) {
for _ in [()] {
self.map_preserves_ambient_model_els_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_4(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm4, _, tm3, ) in self.map_el.iter_all_1(tm0, ) {

self.map_preserves_ambient_model_els_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm4, tm0, tm3, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for AmbientModelEl(tm1, tm2, _, ) in self.ambient_model_el.iter_old_2(tm0, ) {

self.map_preserves_ambient_model_els_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_6(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure, tm3: El, tm4: Morphism) {
for _ in [()] {
self.map_preserves_ambient_model_els_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_7(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure, tm3: El, tm4: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(_, tm5, ) in self.cod.iter_all_0(tm4, ) {

self.map_preserves_ambient_model_els_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm4, tm5, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for MapEl(_, tm0, tm3, ) in self.map_el.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for AmbientModelEl(tm1, tm2, _, ) in self.ambient_model_el.iter_old_2(tm0, ) {

self.map_preserves_ambient_model_els_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn map_preserves_ambient_model_els_9(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure, tm3: El, tm4: Morphism, tm5: Structure) {
for _ in [()] {
let exists_already = self.ambient_model_el.iter_all_0_1_2(tm1, tm5, tm3).next().is_some();
if !exists_already {
delta.new_ambient_model_el.push(AmbientModelEl(tm1, tm5, tm3));
}



}
}


#[allow(unused_variables)]
fn in_ker_rule_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.in_ker_rule_1(delta, );
self.in_ker_rule_2(delta, );
self.in_ker_rule_3(delta, );




}
}

#[allow(unused_variables)]
fn in_ker_rule_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn in_ker_rule_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm1, tm2, tm0, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for MapEl(_, tm3, _, ) in self.map_el.iter_old_0_2(tm1, tm0, ) {

self.in_ker_rule_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn in_ker_rule_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm1, tm3, tm0, ) in self.map_el.iter_new() {

#[allow(unused_variables)]
for MapEl(_, tm2, _, ) in self.map_el.iter_all_0_2(tm1, tm0, ) {

self.in_ker_rule_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn in_ker_rule_4(&self, delta: &mut ModelDelta, tm0: El, tm1: Morphism, tm2: El, tm3: El) {
for _ in [()] {
let exists_already = self.in_ker.iter_all_0_1_2(tm1, tm2, tm3).next().is_some();
if !exists_already {
delta.new_in_ker.push(InKer(tm1, tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn el_in_img_rule_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.el_in_img_rule_1(delta, );
self.el_in_img_rule_2(delta, );



}
}

#[allow(unused_variables)]
fn el_in_img_rule_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn el_in_img_rule_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEl(tm1, tm2, tm0, ) in self.map_el.iter_new() {

self.el_in_img_rule_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn el_in_img_rule_3(&self, delta: &mut ModelDelta, tm0: El, tm1: Morphism, tm2: El) {
for _ in [()] {
let exists_already = self.el_in_img.iter_all_0_1(tm1, tm0).next().is_some();
if !exists_already {
delta.new_el_in_img.push(ElInImg(tm1, tm0));
}



}
}


#[allow(unused_variables)]
fn rel_tuple_in_img_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rel_tuple_in_img_law_1(delta, );
self.rel_tuple_in_img_law_2(delta, );
self.rel_tuple_in_img_law_5(delta, );




}
}

#[allow(unused_variables)]
fn rel_tuple_in_img_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rel_tuple_in_img_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelApp(tm0, tm1, ) in self.rel_app.iter_new() {

self.rel_tuple_in_img_law_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rel_tuple_in_img_law_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
self.rel_tuple_in_img_law_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn rel_tuple_in_img_law_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(tm3, _, tm2, ) in self.map_els.iter_all_1(tm1, ) {

self.rel_tuple_in_img_law_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn rel_tuple_in_img_law_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MapEls(tm3, tm1, tm2, ) in self.map_els.iter_new() {

#[allow(unused_variables)]
for RelApp(tm0, _, ) in self.rel_app.iter_old_1(tm1, ) {

self.rel_tuple_in_img_law_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn rel_tuple_in_img_law_6(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: ElList, tm3: Morphism) {
for _ in [()] {
let exists_already = self.rel_tuple_in_img.iter_all_0_1_2(tm3, tm0, tm2).next().is_some();
if !exists_already {
delta.new_rel_tuple_in_img.push(RelTupleInImg(tm3, tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn anonymous_rule_125_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.anonymous_rule_125_1(delta, );
self.anonymous_rule_125_3(delta, );
self.anonymous_rule_125_6(delta, );
self.anonymous_rule_125_9(delta, );
self.anonymous_rule_125_12(delta, );
self.anonymous_rule_125_15(delta, );
self.anonymous_rule_125_18(delta, );
self.anonymous_rule_125_21(delta, );









}
}

#[allow(unused_variables)]
fn anonymous_rule_125_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.anonymous_rule_125_2(delta, );


}
}

#[allow(unused_variables)]
fn anonymous_rule_125_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
let tm0 = match self.type_symbol.iter_all().next() {
    Some(TypeSymbol( res)) => res,
    None => { 
        delta.new_type_symbol_def.push(TypeSymbolArgs());
        break;
    },
};

self.anonymous_rule_125_4(delta, tm0);



}
}

#[allow(unused_variables)]
fn anonymous_rule_125_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm0, ) in self.type_symbol.iter_new() {

self.anonymous_rule_125_4(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn anonymous_rule_125_4(&self, delta: &mut ModelDelta, tm0: SymbolKind) {
for _ in [()] {
self.anonymous_rule_125_5(delta, tm0);


}
}

#[allow(unused_variables)]
fn anonymous_rule_125_5(&self, delta: &mut ModelDelta, tm0: SymbolKind) {
for _ in [()] {
let tm1 = match self.pred_symbol.iter_all().next() {
    Some(PredSymbol( res)) => res,
    None => { 
        delta.new_pred_symbol_def.push(PredSymbolArgs());
        break;
    },
};

self.anonymous_rule_125_7(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn anonymous_rule_125_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredSymbol(tm1, ) in self.pred_symbol.iter_new() {

#[allow(unused_variables)]
for TypeSymbol(tm0, ) in self.type_symbol.iter_old() {

self.anonymous_rule_125_7(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn anonymous_rule_125_7(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind) {
for _ in [()] {
self.anonymous_rule_125_8(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn anonymous_rule_125_8(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind) {
for _ in [()] {
let tm2 = match self.func_symbol.iter_all().next() {
    Some(FuncSymbol( res)) => res,
    None => { 
        delta.new_func_symbol_def.push(FuncSymbolArgs());
        break;
    },
};

self.anonymous_rule_125_10(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn anonymous_rule_125_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncSymbol(tm2, ) in self.func_symbol.iter_new() {

#[allow(unused_variables)]
for PredSymbol(tm1, ) in self.pred_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm0, ) in self.type_symbol.iter_old() {

self.anonymous_rule_125_10(delta, tm0, tm1, tm2);


}

}

}

}
}

#[allow(unused_variables)]
fn anonymous_rule_125_10(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind) {
for _ in [()] {
self.anonymous_rule_125_11(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn anonymous_rule_125_11(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind) {
for _ in [()] {
let tm3 = match self.rule_symbol.iter_all().next() {
    Some(RuleSymbol( res)) => res,
    None => { 
        delta.new_rule_symbol_def.push(RuleSymbolArgs());
        break;
    },
};

self.anonymous_rule_125_13(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn anonymous_rule_125_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleSymbol(tm3, ) in self.rule_symbol.iter_new() {

#[allow(unused_variables)]
for FuncSymbol(tm2, ) in self.func_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm0, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for PredSymbol(tm1, ) in self.pred_symbol.iter_old() {

self.anonymous_rule_125_13(delta, tm0, tm1, tm2, tm3);


}

}

}

}

}
}

#[allow(unused_variables)]
fn anonymous_rule_125_13(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind, tm3: SymbolKind) {
for _ in [()] {
self.anonymous_rule_125_14(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn anonymous_rule_125_14(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind, tm3: SymbolKind) {
for _ in [()] {
let tm4 = match self.enum_symbol.iter_all().next() {
    Some(EnumSymbol( res)) => res,
    None => { 
        delta.new_enum_symbol_def.push(EnumSymbolArgs());
        break;
    },
};

self.anonymous_rule_125_16(delta, tm0, tm1, tm2, tm3, tm4);



}
}

#[allow(unused_variables)]
fn anonymous_rule_125_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm4, ) in self.enum_symbol.iter_new() {

#[allow(unused_variables)]
for RuleSymbol(tm3, ) in self.rule_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm0, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for PredSymbol(tm1, ) in self.pred_symbol.iter_old() {

#[allow(unused_variables)]
for FuncSymbol(tm2, ) in self.func_symbol.iter_old() {

self.anonymous_rule_125_16(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn anonymous_rule_125_16(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind, tm3: SymbolKind, tm4: SymbolKind) {
for _ in [()] {
self.anonymous_rule_125_17(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn anonymous_rule_125_17(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind, tm3: SymbolKind, tm4: SymbolKind) {
for _ in [()] {
let tm5 = match self.ctor_symbol.iter_all().next() {
    Some(CtorSymbol( res)) => res,
    None => { 
        delta.new_ctor_symbol_def.push(CtorSymbolArgs());
        break;
    },
};

self.anonymous_rule_125_19(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn anonymous_rule_125_18(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbol(tm5, ) in self.ctor_symbol.iter_new() {

#[allow(unused_variables)]
for EnumSymbol(tm4, ) in self.enum_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm0, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for PredSymbol(tm1, ) in self.pred_symbol.iter_old() {

#[allow(unused_variables)]
for FuncSymbol(tm2, ) in self.func_symbol.iter_old() {

#[allow(unused_variables)]
for RuleSymbol(tm3, ) in self.rule_symbol.iter_old() {

self.anonymous_rule_125_19(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn anonymous_rule_125_19(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind, tm3: SymbolKind, tm4: SymbolKind, tm5: SymbolKind) {
for _ in [()] {
self.anonymous_rule_125_20(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn anonymous_rule_125_20(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind, tm3: SymbolKind, tm4: SymbolKind, tm5: SymbolKind) {
for _ in [()] {
let tm6 = match self.model_symbol.iter_all().next() {
    Some(ModelSymbol( res)) => res,
    None => { 
        delta.new_model_symbol_def.push(ModelSymbolArgs());
        break;
    },
};

self.anonymous_rule_125_22(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);



}
}

#[allow(unused_variables)]
fn anonymous_rule_125_21(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm6, ) in self.model_symbol.iter_new() {

#[allow(unused_variables)]
for CtorSymbol(tm5, ) in self.ctor_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm0, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for PredSymbol(tm1, ) in self.pred_symbol.iter_old() {

#[allow(unused_variables)]
for FuncSymbol(tm2, ) in self.func_symbol.iter_old() {

#[allow(unused_variables)]
for RuleSymbol(tm3, ) in self.rule_symbol.iter_old() {

#[allow(unused_variables)]
for EnumSymbol(tm4, ) in self.enum_symbol.iter_old() {

self.anonymous_rule_125_22(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn anonymous_rule_125_22(&self, delta: &mut ModelDelta, tm0: SymbolKind, tm1: SymbolKind, tm2: SymbolKind, tm3: SymbolKind, tm4: SymbolKind, tm5: SymbolKind, tm6: SymbolKind) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn symbol_scope_extension_parent_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.symbol_scope_extension_parent_1(delta, );
self.symbol_scope_extension_parent_2(delta, );



}
}

#[allow(unused_variables)]
fn symbol_scope_extension_parent_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn symbol_scope_extension_parent_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeExtension(tm0, tm1, ) in self.symbol_scope_extension.iter_new() {

self.symbol_scope_extension_parent_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn symbol_scope_extension_parent_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
let exists_already = self.symbol_scope_parent.iter_all_0_1(tm1, tm0).next().is_some();
if !exists_already {
delta.new_symbol_scope_parent.push(SymbolScopeParent(tm1, tm0));
}



}
}


#[allow(unused_variables)]
fn symbol_scope_ancestor_reflexivity_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.symbol_scope_ancestor_reflexivity_1(delta, );
self.symbol_scope_ancestor_reflexivity_2(delta, );



}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_reflexivity_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_reflexivity_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.symbol_scope_new.iter().copied() {

self.symbol_scope_ancestor_reflexivity_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_reflexivity_3(&self, delta: &mut ModelDelta, tm0: SymbolScope) {
for _ in [()] {
let exists_already = self.symbol_scope_ancestor.iter_all_0_1(tm0, tm0).next().is_some();
if !exists_already {
delta.new_symbol_scope_ancestor.push(SymbolScopeAncestor(tm0, tm0));
}



}
}


#[allow(unused_variables)]
fn symbol_scope_ancestor_parent_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.symbol_scope_ancestor_parent_1(delta, );
self.symbol_scope_ancestor_parent_2(delta, );
self.symbol_scope_ancestor_parent_5(delta, );




}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_parent_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_parent_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeAncestor(tm0, tm1, ) in self.symbol_scope_ancestor.iter_new() {

self.symbol_scope_ancestor_parent_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_parent_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
self.symbol_scope_ancestor_parent_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_parent_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeParent(_, tm2, ) in self.symbol_scope_parent.iter_all_0(tm1, ) {

self.symbol_scope_ancestor_parent_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_parent_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeParent(tm1, tm2, ) in self.symbol_scope_parent.iter_new() {

#[allow(unused_variables)]
for SymbolScopeAncestor(tm0, _, ) in self.symbol_scope_ancestor.iter_old_1(tm1, ) {

self.symbol_scope_ancestor_parent_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn symbol_scope_ancestor_parent_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope, tm2: SymbolScope) {
for _ in [()] {
let exists_already = self.symbol_scope_ancestor.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_symbol_scope_ancestor.push(SymbolScopeAncestor(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn module_symbol_scope_rule_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.module_symbol_scope_rule_1(delta, );
self.module_symbol_scope_rule_2(delta, );
self.module_symbol_scope_rule_5(delta, );




}
}

#[allow(unused_variables)]
fn module_symbol_scope_rule_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn module_symbol_scope_rule_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsModuleNode(tm0, tm1, ) in self.decls_module_node.iter_new() {

self.module_symbol_scope_rule_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn module_symbol_scope_rule_3(&self, delta: &mut ModelDelta, tm0: ModuleNode, tm1: DeclListNode) {
for _ in [()] {
self.module_symbol_scope_rule_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn module_symbol_scope_rule_4(&self, delta: &mut ModelDelta, tm0: ModuleNode, tm1: DeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(_, tm2, ) in self.decls_symbol_scope.iter_all_0(tm1, ) {

self.module_symbol_scope_rule_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn module_symbol_scope_rule_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(tm1, tm2, ) in self.decls_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclsModuleNode(tm0, _, ) in self.decls_module_node.iter_old_1(tm1, ) {

self.module_symbol_scope_rule_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn module_symbol_scope_rule_6(&self, delta: &mut ModelDelta, tm0: ModuleNode, tm1: DeclListNode, tm2: SymbolScope) {
for _ in [()] {
let exists_already = self.module_symbol_scope.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_module_symbol_scope.push(ModuleSymbolScope(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn decl_symbol_scope_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.decl_symbol_scope_total_1(delta, );
self.decl_symbol_scope_total_2(delta, );
self.decl_symbol_scope_total_5(delta, );




}
}

#[allow(unused_variables)]
fn decl_symbol_scope_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn decl_symbol_scope_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.decl_node_new.iter().copied() {

self.decl_symbol_scope_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn decl_symbol_scope_total_3(&self, delta: &mut ModelDelta, tm0: DeclNode) {
for _ in [()] {
self.decl_symbol_scope_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn decl_symbol_scope_total_4(&self, delta: &mut ModelDelta, tm0: DeclNode) {
for _ in [()] {
let tm1 = match self.decl_symbol_scope.iter_all_0(tm0).next() {
    Some(DeclSymbolScope(_,  res)) => res,
    None => { 
        delta.new_decl_symbol_scope_def.push(DeclSymbolScopeArgs(tm0));
        break;
    },
};

self.decl_symbol_scope_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn decl_symbol_scope_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm1, ) in self.decl_symbol_scope.iter_new() {

self.decl_symbol_scope_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn decl_symbol_scope_total_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: SymbolScope) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn decls_symbol_scope_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.decls_symbol_scope_total_1(delta, );
self.decls_symbol_scope_total_2(delta, );
self.decls_symbol_scope_total_5(delta, );




}
}

#[allow(unused_variables)]
fn decls_symbol_scope_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn decls_symbol_scope_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.decl_list_node_new.iter().copied() {

self.decls_symbol_scope_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn decls_symbol_scope_total_3(&self, delta: &mut ModelDelta, tm0: DeclListNode) {
for _ in [()] {
self.decls_symbol_scope_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn decls_symbol_scope_total_4(&self, delta: &mut ModelDelta, tm0: DeclListNode) {
for _ in [()] {
let tm1 = match self.decls_symbol_scope.iter_all_0(tm0).next() {
    Some(DeclsSymbolScope(_,  res)) => res,
    None => { 
        delta.new_decls_symbol_scope_def.push(DeclsSymbolScopeArgs(tm0));
        break;
    },
};

self.decls_symbol_scope_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn decls_symbol_scope_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(tm0, tm1, ) in self.decls_symbol_scope.iter_new() {

self.decls_symbol_scope_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn decls_symbol_scope_total_6(&self, delta: &mut ModelDelta, tm0: DeclListNode, tm1: SymbolScope) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn arg_symbol_scope_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.arg_symbol_scope_total_1(delta, );
self.arg_symbol_scope_total_2(delta, );
self.arg_symbol_scope_total_5(delta, );




}
}

#[allow(unused_variables)]
fn arg_symbol_scope_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn arg_symbol_scope_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.arg_decl_node_new.iter().copied() {

self.arg_symbol_scope_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn arg_symbol_scope_total_3(&self, delta: &mut ModelDelta, tm0: ArgDeclNode) {
for _ in [()] {
self.arg_symbol_scope_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn arg_symbol_scope_total_4(&self, delta: &mut ModelDelta, tm0: ArgDeclNode) {
for _ in [()] {
let tm1 = match self.arg_symbol_scope.iter_all_0(tm0).next() {
    Some(ArgSymbolScope(_,  res)) => res,
    None => { 
        delta.new_arg_symbol_scope_def.push(ArgSymbolScopeArgs(tm0));
        break;
    },
};

self.arg_symbol_scope_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn arg_symbol_scope_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgSymbolScope(tm0, tm1, ) in self.arg_symbol_scope.iter_new() {

self.arg_symbol_scope_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn arg_symbol_scope_total_6(&self, delta: &mut ModelDelta, tm0: ArgDeclNode, tm1: SymbolScope) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn args_symbol_scope_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.args_symbol_scope_total_1(delta, );
self.args_symbol_scope_total_2(delta, );
self.args_symbol_scope_total_5(delta, );




}
}

#[allow(unused_variables)]
fn args_symbol_scope_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn args_symbol_scope_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.arg_decl_list_node_new.iter().copied() {

self.args_symbol_scope_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn args_symbol_scope_total_3(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode) {
for _ in [()] {
self.args_symbol_scope_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn args_symbol_scope_total_4(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode) {
for _ in [()] {
let tm1 = match self.args_symbol_scope.iter_all_0(tm0).next() {
    Some(ArgsSymbolScope(_,  res)) => res,
    None => { 
        delta.new_args_symbol_scope_def.push(ArgsSymbolScopeArgs(tm0));
        break;
    },
};

self.args_symbol_scope_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn args_symbol_scope_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgsSymbolScope(tm0, tm1, ) in self.args_symbol_scope.iter_new() {

self.args_symbol_scope_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn args_symbol_scope_total_6(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: SymbolScope) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn ctor_symbol_scope_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ctor_symbol_scope_total_1(delta, );
self.ctor_symbol_scope_total_2(delta, );
self.ctor_symbol_scope_total_5(delta, );




}
}

#[allow(unused_variables)]
fn ctor_symbol_scope_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ctor_symbol_scope_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.ctor_decl_node_new.iter().copied() {

self.ctor_symbol_scope_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn ctor_symbol_scope_total_3(&self, delta: &mut ModelDelta, tm0: CtorDeclNode) {
for _ in [()] {
self.ctor_symbol_scope_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn ctor_symbol_scope_total_4(&self, delta: &mut ModelDelta, tm0: CtorDeclNode) {
for _ in [()] {
let tm1 = match self.ctor_symbol_scope.iter_all_0(tm0).next() {
    Some(CtorSymbolScope(_,  res)) => res,
    None => { 
        delta.new_ctor_symbol_scope_def.push(CtorSymbolScopeArgs(tm0));
        break;
    },
};

self.ctor_symbol_scope_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn ctor_symbol_scope_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(tm0, tm1, ) in self.ctor_symbol_scope.iter_new() {

self.ctor_symbol_scope_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ctor_symbol_scope_total_6(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: SymbolScope) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn ctors_symbol_scope_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ctors_symbol_scope_total_1(delta, );
self.ctors_symbol_scope_total_2(delta, );
self.ctors_symbol_scope_total_5(delta, );




}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.ctor_decl_list_node_new.iter().copied() {

self.ctors_symbol_scope_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_total_3(&self, delta: &mut ModelDelta, tm0: CtorDeclListNode) {
for _ in [()] {
self.ctors_symbol_scope_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_total_4(&self, delta: &mut ModelDelta, tm0: CtorDeclListNode) {
for _ in [()] {
let tm1 = match self.ctors_symbol_scope.iter_all_0(tm0).next() {
    Some(CtorsSymbolScope(_,  res)) => res,
    None => { 
        delta.new_ctors_symbol_scope_def.push(CtorsSymbolScopeArgs(tm0));
        break;
    },
};

self.ctors_symbol_scope_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorsSymbolScope(tm0, tm1, ) in self.ctors_symbol_scope.iter_new() {

self.ctors_symbol_scope_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_total_6(&self, delta: &mut ModelDelta, tm0: CtorDeclListNode, tm1: SymbolScope) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn decl_nodes_symbol_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.decl_nodes_symbol_cons_1(delta, );
self.decl_nodes_symbol_cons_2(delta, );
self.decl_nodes_symbol_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn decl_nodes_symbol_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn decl_nodes_symbol_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsDeclListNode(tm0, tm1, tm2, ) in self.cons_decl_list_node.iter_new() {

self.decl_nodes_symbol_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn decl_nodes_symbol_cons_3(&self, delta: &mut ModelDelta, tm0: DeclListNode, tm1: DeclNode, tm2: DeclListNode) {
for _ in [()] {
self.decl_nodes_symbol_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn decl_nodes_symbol_cons_4(&self, delta: &mut ModelDelta, tm0: DeclListNode, tm1: DeclNode, tm2: DeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(_, tm3, ) in self.decls_symbol_scope.iter_all_0(tm0, ) {

self.decl_nodes_symbol_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn decl_nodes_symbol_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(tm0, tm3, ) in self.decls_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ConsDeclListNode(_, tm1, tm2, ) in self.cons_decl_list_node.iter_old_0(tm0, ) {

self.decl_nodes_symbol_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn decl_nodes_symbol_cons_6(&self, delta: &mut ModelDelta, tm0: DeclListNode, tm1: DeclNode, tm2: DeclListNode, tm3: SymbolScope) {
for _ in [()] {
let exists_already = self.decl_symbol_scope.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_decl_symbol_scope.push(DeclSymbolScope(tm1, tm3));
}

let exists_already = self.decls_symbol_scope.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_decls_symbol_scope.push(DeclsSymbolScope(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn pred_args_symbol_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_args_symbol_scope_1(delta, );
self.pred_args_symbol_scope_2(delta, );
self.pred_args_symbol_scope_5(delta, );
self.pred_args_symbol_scope_8(delta, );





}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodePred(tm0, tm1, ) in self.decl_node_pred.iter_new() {

self.pred_args_symbol_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode) {
for _ in [()] {
self.pred_args_symbol_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for PredDecl(_, tm2, tm3, ) in self.pred_decl.iter_all_0(tm1, ) {

self.pred_args_symbol_scope_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredDecl(tm1, tm2, tm3, ) in self.pred_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodePred(tm0, _, ) in self.decl_node_pred.iter_old_1(tm1, ) {

self.pred_args_symbol_scope_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode) {
for _ in [()] {
self.pred_args_symbol_scope_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.pred_args_symbol_scope_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodePred(_, tm1, ) in self.decl_node_pred.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for PredDecl(_, tm2, tm3, ) in self.pred_decl.iter_old_0(tm1, ) {

self.pred_args_symbol_scope_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_args_symbol_scope_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope) {
for _ in [()] {
let exists_already = self.args_symbol_scope.iter_all_0_1(tm3, tm4).next().is_some();
if !exists_already {
delta.new_args_symbol_scope.push(ArgsSymbolScope(tm3, tm4));
}



}
}


#[allow(unused_variables)]
fn func_args_symbol_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.func_args_symbol_scope_1(delta, );
self.func_args_symbol_scope_2(delta, );
self.func_args_symbol_scope_5(delta, );
self.func_args_symbol_scope_8(delta, );





}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeFunc(tm0, tm1, ) in self.decl_node_func.iter_new() {

self.func_args_symbol_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode) {
for _ in [()] {
self.func_args_symbol_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, tm4, ) in self.func_decl.iter_all_0(tm1, ) {

self.func_args_symbol_scope_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDecl(tm1, tm2, tm3, tm4, ) in self.func_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeFunc(tm0, _, ) in self.decl_node_func.iter_old_1(tm1, ) {

self.func_args_symbol_scope_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode) {
for _ in [()] {
self.func_args_symbol_scope_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm5, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.func_args_symbol_scope_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm5, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeFunc(_, tm1, ) in self.decl_node_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, tm4, ) in self.func_decl.iter_old_0(tm1, ) {

self.func_args_symbol_scope_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn func_args_symbol_scope_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope) {
for _ in [()] {
let exists_already = self.args_symbol_scope.iter_all_0_1(tm3, tm5).next().is_some();
if !exists_already {
delta.new_args_symbol_scope.push(ArgsSymbolScope(tm3, tm5));
}



}
}


#[allow(unused_variables)]
fn ctor_args_symbol_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ctor_args_symbol_scope_1(delta, );
self.ctor_args_symbol_scope_2(delta, );
self.ctor_args_symbol_scope_5(delta, );




}
}

#[allow(unused_variables)]
fn ctor_args_symbol_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ctor_args_symbol_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDecl(tm0, tm1, tm2, ) in self.ctor_decl.iter_new() {

self.ctor_args_symbol_scope_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ctor_args_symbol_scope_3(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode) {
for _ in [()] {
self.ctor_args_symbol_scope_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ctor_args_symbol_scope_4(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(_, tm3, ) in self.ctor_symbol_scope.iter_all_0(tm0, ) {

self.ctor_args_symbol_scope_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ctor_args_symbol_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(tm0, tm3, ) in self.ctor_symbol_scope.iter_new() {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

self.ctor_args_symbol_scope_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ctor_args_symbol_scope_6(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope) {
for _ in [()] {
let exists_already = self.args_symbol_scope.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_args_symbol_scope.push(ArgsSymbolScope(tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn args_symbol_scope_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.args_symbol_scope_cons_1(delta, );
self.args_symbol_scope_cons_2(delta, );
self.args_symbol_scope_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn args_symbol_scope_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn args_symbol_scope_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsArgDeclListNode(tm0, tm1, tm2, ) in self.cons_arg_decl_list_node.iter_new() {

self.args_symbol_scope_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn args_symbol_scope_cons_3(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode) {
for _ in [()] {
self.args_symbol_scope_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn args_symbol_scope_cons_4(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ArgsSymbolScope(_, tm3, ) in self.args_symbol_scope.iter_all_0(tm0, ) {

self.args_symbol_scope_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn args_symbol_scope_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArgsSymbolScope(tm0, tm3, ) in self.args_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ConsArgDeclListNode(_, tm1, tm2, ) in self.cons_arg_decl_list_node.iter_old_0(tm0, ) {

self.args_symbol_scope_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn args_symbol_scope_cons_6(&self, delta: &mut ModelDelta, tm0: ArgDeclListNode, tm1: ArgDeclNode, tm2: ArgDeclListNode, tm3: SymbolScope) {
for _ in [()] {
let exists_already = self.arg_symbol_scope.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_arg_symbol_scope.push(ArgSymbolScope(tm1, tm3));
}

let exists_already = self.args_symbol_scope.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_args_symbol_scope.push(ArgsSymbolScope(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn enum_ctors_symbol_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.enum_ctors_symbol_scope_1(delta, );
self.enum_ctors_symbol_scope_2(delta, );
self.enum_ctors_symbol_scope_5(delta, );
self.enum_ctors_symbol_scope_8(delta, );





}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeEnum(tm0, tm1, ) in self.decl_node_enum.iter_new() {

self.enum_ctors_symbol_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode) {
for _ in [()] {
self.enum_ctors_symbol_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(_, tm2, tm3, ) in self.enum_decl.iter_all_0(tm1, ) {

self.enum_ctors_symbol_scope_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm1, tm2, tm3, ) in self.enum_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeEnum(tm0, _, ) in self.decl_node_enum.iter_old_1(tm1, ) {

self.enum_ctors_symbol_scope_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode) {
for _ in [()] {
self.enum_ctors_symbol_scope_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.enum_ctors_symbol_scope_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeEnum(_, tm1, ) in self.decl_node_enum.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EnumDecl(_, tm2, tm3, ) in self.enum_decl.iter_old_0(tm1, ) {

self.enum_ctors_symbol_scope_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn enum_ctors_symbol_scope_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope) {
for _ in [()] {
let exists_already = self.ctors_symbol_scope.iter_all_0_1(tm3, tm4).next().is_some();
if !exists_already {
delta.new_ctors_symbol_scope.push(CtorsSymbolScope(tm3, tm4));
}



}
}


#[allow(unused_variables)]
fn ctors_symbol_scope_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ctors_symbol_scope_cons_1(delta, );
self.ctors_symbol_scope_cons_2(delta, );
self.ctors_symbol_scope_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsCtorDeclListNode(tm0, tm1, tm2, ) in self.cons_ctor_decl_list_node.iter_new() {

self.ctors_symbol_scope_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_cons_3(&self, delta: &mut ModelDelta, tm0: CtorDeclListNode, tm1: CtorDeclNode, tm2: CtorDeclListNode) {
for _ in [()] {
self.ctors_symbol_scope_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_cons_4(&self, delta: &mut ModelDelta, tm0: CtorDeclListNode, tm1: CtorDeclNode, tm2: CtorDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorsSymbolScope(_, tm3, ) in self.ctors_symbol_scope.iter_all_0(tm0, ) {

self.ctors_symbol_scope_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorsSymbolScope(tm0, tm3, ) in self.ctors_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ConsCtorDeclListNode(_, tm1, tm2, ) in self.cons_ctor_decl_list_node.iter_old_0(tm0, ) {

self.ctors_symbol_scope_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ctors_symbol_scope_cons_6(&self, delta: &mut ModelDelta, tm0: CtorDeclListNode, tm1: CtorDeclNode, tm2: CtorDeclListNode, tm3: SymbolScope) {
for _ in [()] {
let exists_already = self.ctor_symbol_scope.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_ctor_symbol_scope.push(CtorSymbolScope(tm1, tm3));
}

let exists_already = self.ctors_symbol_scope.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_ctors_symbol_scope.push(CtorsSymbolScope(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn model_symbol_scope_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.model_symbol_scope_law_1(delta, );
self.model_symbol_scope_law_2(delta, );
self.model_symbol_scope_law_5(delta, );
self.model_symbol_scope_law_8(delta, );
self.model_symbol_scope_law_11(delta, );
self.model_symbol_scope_law_14(delta, );







}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeModel(tm0, tm1, ) in self.decl_node_model.iter_new() {

self.model_symbol_scope_law_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode) {
for _ in [()] {
self.model_symbol_scope_law_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDecl(_, tm2, tm3, ) in self.model_decl.iter_all_0(tm1, ) {

self.model_symbol_scope_law_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDecl(tm1, tm2, tm3, ) in self.model_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeModel(tm0, _, ) in self.decl_node_model.iter_old_1(tm1, ) {

self.model_symbol_scope_law_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode) {
for _ in [()] {
self.model_symbol_scope_law_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.model_symbol_scope_law_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeModel(_, tm1, ) in self.decl_node_model.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelDecl(_, tm2, tm3, ) in self.model_decl.iter_old_0(tm1, ) {

self.model_symbol_scope_law_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope) {
for _ in [()] {
self.model_symbol_scope_law_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(_, tm5, ) in self.decls_symbol_scope.iter_all_0(tm3, ) {

self.model_symbol_scope_law_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(tm3, tm5, ) in self.decls_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodeModel(_, tm1, ) in self.decl_node_model.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelDecl(_, tm2, _, ) in self.model_decl.iter_old_0_2(tm1, tm3, ) {

self.model_symbol_scope_law_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope, tm5: SymbolScope) {
for _ in [()] {
let exists_already = self.symbol_scope_extension.iter_all_0_1(tm4, tm5).next().is_some();
if !exists_already {
delta.new_symbol_scope_extension.push(SymbolScopeExtension(tm4, tm5));
}

self.model_symbol_scope_law_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);



}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope, tm5: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, _, tm6, ) in self.semantic_type.iter_all_0_1(tm4, tm2, ) {

self.model_symbol_scope_law_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm4, tm2, tm6, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for SymbolScopeExtension(_, tm5, ) in self.symbol_scope_extension.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for DeclsSymbolScope(tm3, _, ) in self.decls_symbol_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for DeclNodeModel(_, tm1, ) in self.decl_node_model.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelDecl(_, _, _, ) in self.model_decl.iter_old_0_1_2(tm1, tm2, tm3, ) {

self.model_symbol_scope_law_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_law_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope, tm5: SymbolScope, tm6: Type) {
for _ in [()] {
let exists_already = self.model_member_symbol_scope.iter_all_0_1(tm6, tm5).next().is_some();
if !exists_already {
delta.new_model_member_symbol_scope.push(ModelMemberSymbolScope(tm6, tm5));
}

let exists_already = self.symbol_scope_model.iter_all_0_1(tm5, tm6).next().is_some();
if !exists_already {
delta.new_symbol_scope_model.push(SymbolScopeModel(tm5, tm6));
}




}
}


#[allow(unused_variables)]
fn element_member_symbol_scope_laws_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.element_member_symbol_scope_laws_1(delta, );
self.element_member_symbol_scope_laws_2(delta, );
self.element_member_symbol_scope_laws_5(delta, );
self.element_member_symbol_scope_laws_8(delta, );





}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(tm0, tm1, ) in self.el_type.iter_new() {

self.element_member_symbol_scope_laws_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_3(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType) {
for _ in [()] {
self.element_member_symbol_scope_laws_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_4(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType) {
for _ in [()] {
#[allow(unused_variables)]
for UnderlyingType(_, tm2, ) in self.underlying_type.iter_all_0(tm1, ) {

self.element_member_symbol_scope_laws_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for UnderlyingType(tm1, tm2, ) in self.underlying_type.iter_new() {

#[allow(unused_variables)]
for ElType(tm0, _, ) in self.el_type.iter_old_1(tm1, ) {

self.element_member_symbol_scope_laws_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_6(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: Type) {
for _ in [()] {
self.element_member_symbol_scope_laws_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_7(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: Type) {
for _ in [()] {
#[allow(unused_variables)]
for ModelMemberSymbolScope(_, tm3, ) in self.model_member_symbol_scope.iter_all_0(tm2, ) {

self.element_member_symbol_scope_laws_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelMemberSymbolScope(tm2, tm3, ) in self.model_member_symbol_scope.iter_new() {

#[allow(unused_variables)]
for UnderlyingType(tm1, _, ) in self.underlying_type.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for ElType(tm0, _, ) in self.el_type.iter_old_1(tm1, ) {

self.element_member_symbol_scope_laws_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn element_member_symbol_scope_laws_9(&self, delta: &mut ModelDelta, tm0: El, tm1: ElementType, tm2: Type, tm3: SymbolScope) {
for _ in [()] {
let exists_already = self.element_member_symbol_scope.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_element_member_symbol_scope.push(ElementMemberSymbolScope(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn module_symbol_scope_name_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.module_symbol_scope_name_1(delta, );
self.module_symbol_scope_name_2(delta, );
self.module_symbol_scope_name_5(delta, );




}
}

#[allow(unused_variables)]
fn module_symbol_scope_name_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn module_symbol_scope_name_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleSymbolScope(tm1, tm0, ) in self.module_symbol_scope.iter_new() {

self.module_symbol_scope_name_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn module_symbol_scope_name_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: ModuleNode) {
for _ in [()] {
self.module_symbol_scope_name_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn module_symbol_scope_name_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: ModuleNode) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleName(_, tm2, ) in self.module_name.iter_all_0(tm1, ) {

self.module_symbol_scope_name_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn module_symbol_scope_name_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleName(tm1, tm2, ) in self.module_name.iter_new() {

#[allow(unused_variables)]
for ModuleSymbolScope(_, tm0, ) in self.module_symbol_scope.iter_old_0(tm1, ) {

self.module_symbol_scope_name_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn module_symbol_scope_name_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: ModuleNode, tm2: Ident) {
for _ in [()] {
let exists_already = self.symbol_scope_name.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_symbol_scope_name.push(SymbolScopeName(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn model_symbol_scope_name_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.model_symbol_scope_name_1(delta, );
self.model_symbol_scope_name_2(delta, );
self.model_symbol_scope_name_5(delta, );




}
}

#[allow(unused_variables)]
fn model_symbol_scope_name_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn model_symbol_scope_name_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDecl(tm0, tm1, tm2, ) in self.model_decl.iter_new() {

self.model_symbol_scope_name_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_name_3(&self, delta: &mut ModelDelta, tm0: ModelDeclNode, tm1: Ident, tm2: DeclListNode) {
for _ in [()] {
self.model_symbol_scope_name_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn model_symbol_scope_name_4(&self, delta: &mut ModelDelta, tm0: ModelDeclNode, tm1: Ident, tm2: DeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(_, tm3, ) in self.decls_symbol_scope.iter_all_0(tm2, ) {

self.model_symbol_scope_name_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_name_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclsSymbolScope(tm2, tm3, ) in self.decls_symbol_scope.iter_new() {

#[allow(unused_variables)]
for ModelDecl(tm0, tm1, _, ) in self.model_decl.iter_old_2(tm2, ) {

self.model_symbol_scope_name_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn model_symbol_scope_name_6(&self, delta: &mut ModelDelta, tm0: ModelDeclNode, tm1: Ident, tm2: DeclListNode, tm3: SymbolScope) {
for _ in [()] {
let exists_already = self.symbol_scope_name.iter_all_0_1(tm3, tm1).next().is_some();
if !exists_already {
delta.new_symbol_scope_name.push(SymbolScopeName(tm3, tm1));
}



}
}


#[allow(unused_variables)]
fn scope_extension_symbols_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.scope_extension_symbols_1(delta, );
self.scope_extension_symbols_2(delta, );
self.scope_extension_symbols_5(delta, );




}
}

#[allow(unused_variables)]
fn scope_extension_symbols_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn scope_extension_symbols_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeExtension(tm0, tm1, ) in self.scope_extension.iter_new() {

self.scope_extension_symbols_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn scope_extension_symbols_3(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope) {
for _ in [()] {
self.scope_extension_symbols_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn scope_extension_symbols_4(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(_, tm2, ) in self.scope_symbols.iter_all_0(tm0, ) {

self.scope_extension_symbols_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn scope_extension_symbols_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm0, tm2, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for ScopeExtension(_, tm1, ) in self.scope_extension.iter_old_0(tm0, ) {

self.scope_extension_symbols_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn scope_extension_symbols_6(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope, tm2: SymbolScope) {
for _ in [()] {
let exists_already = self.scope_symbols.iter_all_0_1(tm1, tm2).next().is_some();
if !exists_already {
delta.new_scope_symbols.push(ScopeSymbols(tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn rule_symbol_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_symbol_scope_1(delta, );
self.rule_symbol_scope_2(delta, );
self.rule_symbol_scope_5(delta, );
self.rule_symbol_scope_8(delta, );
self.rule_symbol_scope_9(delta, );






}
}

#[allow(unused_variables)]
fn rule_symbol_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_symbol_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeRule(tm0, tm1, ) in self.decl_node_rule.iter_new() {

self.rule_symbol_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_symbol_scope_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode) {
for _ in [()] {
self.rule_symbol_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn rule_symbol_scope_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm2, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.rule_symbol_scope_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn rule_symbol_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm2, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm0, ) {

self.rule_symbol_scope_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn rule_symbol_scope_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope) {
for _ in [()] {
self.rule_symbol_scope_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn rule_symbol_scope_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantRule(_, tm4, ) in self.rule_descendant_rule.iter_all_0(tm1, ) {

#[allow(unused_variables)]
for EntryScope(_, tm3, ) in self.entry_scope.iter_all_0(tm4, ) {

self.rule_symbol_scope_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn rule_symbol_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantRule(tm1, tm4, ) in self.rule_descendant_rule.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(tm0, _, ) in self.decl_node_rule.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm2, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm3, ) in self.entry_scope.iter_old_0(tm4, ) {

self.rule_symbol_scope_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn rule_symbol_scope_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm4, tm3, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for RuleDescendantRule(tm1, _, ) in self.rule_descendant_rule.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for DeclNodeRule(tm0, _, ) in self.decl_node_rule.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm2, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

self.rule_symbol_scope_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn rule_symbol_scope_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope, tm3: Scope, tm4: RuleDescendantNode) {
for _ in [()] {
let exists_already = self.scope_symbols.iter_all_0_1(tm3, tm2).next().is_some();
if !exists_already {
delta.new_scope_symbols.push(ScopeSymbols(tm3, tm2));
}



}
}


#[allow(unused_variables)]
fn defined_symbol_is_accessible_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.defined_symbol_is_accessible_1(delta, );
self.defined_symbol_is_accessible_2(delta, );



}
}

#[allow(unused_variables)]
fn defined_symbol_is_accessible_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn defined_symbol_is_accessible_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedSymbol(tm0, tm1, tm2, tm3, ) in self.defined_symbol.iter_new() {

self.defined_symbol_is_accessible_3(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn defined_symbol_is_accessible_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: Ident, tm2: SymbolKind, tm3: Loc) {
for _ in [()] {
let exists_already = self.accessible_symbol.iter_all_0_1_2_3(tm0, tm1, tm2, tm3).next().is_some();
if !exists_already {
delta.new_accessible_symbol.push(AccessibleSymbol(tm0, tm1, tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn accessible_symbol_scope_extension_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.accessible_symbol_scope_extension_1(delta, );
self.accessible_symbol_scope_extension_2(delta, );
self.accessible_symbol_scope_extension_5(delta, );




}
}

#[allow(unused_variables)]
fn accessible_symbol_scope_extension_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn accessible_symbol_scope_extension_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeExtension(tm0, tm1, ) in self.symbol_scope_extension.iter_new() {

self.accessible_symbol_scope_extension_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn accessible_symbol_scope_extension_3(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
self.accessible_symbol_scope_extension_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn accessible_symbol_scope_extension_4(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for AccessibleSymbol(_, tm2, tm3, tm4, ) in self.accessible_symbol.iter_all_0(tm0, ) {

self.accessible_symbol_scope_extension_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn accessible_symbol_scope_extension_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AccessibleSymbol(tm0, tm2, tm3, tm4, ) in self.accessible_symbol.iter_new() {

#[allow(unused_variables)]
for SymbolScopeExtension(_, tm1, ) in self.symbol_scope_extension.iter_old_0(tm0, ) {

self.accessible_symbol_scope_extension_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn accessible_symbol_scope_extension_6(&self, delta: &mut ModelDelta, tm0: SymbolScope, tm1: SymbolScope, tm2: Ident, tm3: SymbolKind, tm4: Loc) {
for _ in [()] {
let exists_already = self.accessible_symbol.iter_all_0_1_2_3(tm1, tm2, tm3, tm4).next().is_some();
if !exists_already {
delta.new_accessible_symbol.push(AccessibleSymbol(tm1, tm2, tm3, tm4));
}



}
}


#[allow(unused_variables)]
fn type_decl_defines_symbol_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_decl_defines_symbol_1(delta, );
self.type_decl_defines_symbol_2(delta, );
self.type_decl_defines_symbol_5(delta, );
self.type_decl_defines_symbol_8(delta, );
self.type_decl_defines_symbol_11(delta, );
self.type_decl_defines_symbol_14(delta, );







}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeType(tm0, tm1, ) in self.decl_node_type.iter_new() {

self.type_decl_defines_symbol_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode) {
for _ in [()] {
self.type_decl_defines_symbol_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDecl(_, tm2, ) in self.type_decl.iter_all_0(tm1, ) {

self.type_decl_defines_symbol_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDecl(tm1, tm2, ) in self.type_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeType(tm0, _, ) in self.decl_node_type.iter_old_1(tm1, ) {

self.type_decl_defines_symbol_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident) {
for _ in [()] {
self.type_decl_defines_symbol_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm3, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.type_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm3, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeType(_, tm1, ) in self.decl_node_type.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for TypeDecl(_, tm2, ) in self.type_decl.iter_old_0(tm1, ) {

self.type_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope) {
for _ in [()] {
self.type_decl_defines_symbol_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm4, ) in self.type_symbol.iter_all() {

self.type_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm4, ) in self.type_symbol.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm3, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodeType(_, tm1, ) in self.decl_node_type.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for TypeDecl(_, tm2, ) in self.type_decl.iter_old_0(tm1, ) {

self.type_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope, tm4: SymbolKind) {
for _ in [()] {
self.type_decl_defines_symbol_13(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope, tm4: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDeclNodeLoc(_, tm5, ) in self.type_decl_node_loc.iter_all_0(tm1, ) {

self.type_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDeclNodeLoc(tm1, tm5, ) in self.type_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for TypeSymbol(tm4, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for TypeDecl(_, tm2, ) in self.type_decl.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for DeclNodeType(tm0, _, ) in self.decl_node_type.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm3, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

self.type_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn type_decl_defines_symbol_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope, tm4: SymbolKind, tm5: Loc) {
for _ in [()] {
let exists_already = self.defined_symbol.iter_all_0_1_2_3(tm3, tm2, tm4, tm5).next().is_some();
if !exists_already {
delta.new_defined_symbol.push(DefinedSymbol(tm3, tm2, tm4, tm5));
}



}
}


#[allow(unused_variables)]
fn enum_decl_defines_symbol_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.enum_decl_defines_symbol_1(delta, );
self.enum_decl_defines_symbol_2(delta, );
self.enum_decl_defines_symbol_5(delta, );
self.enum_decl_defines_symbol_8(delta, );
self.enum_decl_defines_symbol_11(delta, );
self.enum_decl_defines_symbol_14(delta, );







}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeEnum(tm0, tm1, ) in self.decl_node_enum.iter_new() {

self.enum_decl_defines_symbol_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode) {
for _ in [()] {
self.enum_decl_defines_symbol_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(_, tm2, tm3, ) in self.enum_decl.iter_all_0(tm1, ) {

self.enum_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm1, tm2, tm3, ) in self.enum_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeEnum(tm0, _, ) in self.decl_node_enum.iter_old_1(tm1, ) {

self.enum_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode) {
for _ in [()] {
self.enum_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.enum_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeEnum(_, tm1, ) in self.decl_node_enum.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EnumDecl(_, tm2, tm3, ) in self.enum_decl.iter_old_0(tm1, ) {

self.enum_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope) {
for _ in [()] {
self.enum_decl_defines_symbol_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm5, ) in self.enum_symbol.iter_all() {

self.enum_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm5, ) in self.enum_symbol.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodeEnum(_, tm1, ) in self.decl_node_enum.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EnumDecl(_, tm2, tm3, ) in self.enum_decl.iter_old_0(tm1, ) {

self.enum_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope, tm5: SymbolKind) {
for _ in [()] {
self.enum_decl_defines_symbol_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope, tm5: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDeclNodeLoc(_, tm6, ) in self.enum_decl_node_loc.iter_all_0(tm1, ) {

self.enum_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDeclNodeLoc(tm1, tm6, ) in self.enum_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for EnumSymbol(tm5, ) in self.enum_symbol.iter_old() {

#[allow(unused_variables)]
for DeclNodeEnum(tm0, _, ) in self.decl_node_enum.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EnumDecl(_, tm2, tm3, ) in self.enum_decl.iter_old_0(tm1, ) {

self.enum_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn enum_decl_defines_symbol_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: EnumDeclNode, tm2: Ident, tm3: CtorDeclListNode, tm4: SymbolScope, tm5: SymbolKind, tm6: Loc) {
for _ in [()] {
let exists_already = self.defined_symbol.iter_all_0_1_2_3(tm4, tm2, tm5, tm6).next().is_some();
if !exists_already {
delta.new_defined_symbol.push(DefinedSymbol(tm4, tm2, tm5, tm6));
}



}
}


#[allow(unused_variables)]
fn model_decl_defines_symbol_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.model_decl_defines_symbol_1(delta, );
self.model_decl_defines_symbol_2(delta, );
self.model_decl_defines_symbol_5(delta, );
self.model_decl_defines_symbol_8(delta, );
self.model_decl_defines_symbol_11(delta, );
self.model_decl_defines_symbol_14(delta, );







}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeModel(tm0, tm1, ) in self.decl_node_model.iter_new() {

self.model_decl_defines_symbol_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode) {
for _ in [()] {
self.model_decl_defines_symbol_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDecl(_, tm2, tm3, ) in self.model_decl.iter_all_0(tm1, ) {

self.model_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDecl(tm1, tm2, tm3, ) in self.model_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeModel(tm0, _, ) in self.decl_node_model.iter_old_1(tm1, ) {

self.model_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode) {
for _ in [()] {
self.model_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.model_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeModel(_, tm1, ) in self.decl_node_model.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelDecl(_, tm2, tm3, ) in self.model_decl.iter_old_0(tm1, ) {

self.model_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope) {
for _ in [()] {
self.model_decl_defines_symbol_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm5, ) in self.model_symbol.iter_all() {

self.model_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm5, ) in self.model_symbol.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodeModel(_, tm1, ) in self.decl_node_model.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelDecl(_, tm2, tm3, ) in self.model_decl.iter_old_0(tm1, ) {

self.model_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope, tm5: SymbolKind) {
for _ in [()] {
self.model_decl_defines_symbol_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope, tm5: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDeclNodeLoc(_, tm6, ) in self.model_decl_node_loc.iter_all_0(tm1, ) {

self.model_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelDeclNodeLoc(tm1, tm6, ) in self.model_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for ModelSymbol(tm5, ) in self.model_symbol.iter_old() {

#[allow(unused_variables)]
for DeclNodeModel(tm0, _, ) in self.decl_node_model.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelDecl(_, tm2, tm3, ) in self.model_decl.iter_old_0(tm1, ) {

self.model_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn model_decl_defines_symbol_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: ModelDeclNode, tm2: Ident, tm3: DeclListNode, tm4: SymbolScope, tm5: SymbolKind, tm6: Loc) {
for _ in [()] {
let exists_already = self.defined_symbol.iter_all_0_1_2_3(tm4, tm2, tm5, tm6).next().is_some();
if !exists_already {
delta.new_defined_symbol.push(DefinedSymbol(tm4, tm2, tm5, tm6));
}



}
}


#[allow(unused_variables)]
fn type_definition_symbol_scope_rule_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_definition_symbol_scope_rule_1(delta, );
self.type_definition_symbol_scope_rule_2(delta, );
self.type_definition_symbol_scope_rule_5(delta, );




}
}

#[allow(unused_variables)]
fn type_definition_symbol_scope_rule_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_definition_symbol_scope_rule_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm1, tm2, tm0, ) in self.semantic_type.iter_new() {

self.type_definition_symbol_scope_rule_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn type_definition_symbol_scope_rule_3(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: Ident) {
for _ in [()] {
self.type_definition_symbol_scope_rule_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn type_definition_symbol_scope_rule_4(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedSymbol(_, _, tm3, tm4, ) in self.defined_symbol.iter_all_0_1(tm1, tm2, ) {

self.type_definition_symbol_scope_rule_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn type_definition_symbol_scope_rule_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedSymbol(tm1, tm2, tm3, tm4, ) in self.defined_symbol.iter_new() {

#[allow(unused_variables)]
for SemanticType(_, _, tm0, ) in self.semantic_type.iter_old_0_1(tm1, tm2, ) {

self.type_definition_symbol_scope_rule_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn type_definition_symbol_scope_rule_6(&self, delta: &mut ModelDelta, tm0: Type, tm1: SymbolScope, tm2: Ident, tm3: SymbolKind, tm4: Loc) {
for _ in [()] {
let exists_already = self.type_definition_symbol_scope.iter_all_0_1(tm0, tm1).next().is_some();
if !exists_already {
delta.new_type_definition_symbol_scope.push(TypeDefinitionSymbolScope(tm0, tm1));
}



}
}


#[allow(unused_variables)]
fn pred_decl_defines_symbol_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_decl_defines_symbol_1(delta, );
self.pred_decl_defines_symbol_2(delta, );
self.pred_decl_defines_symbol_5(delta, );
self.pred_decl_defines_symbol_8(delta, );
self.pred_decl_defines_symbol_11(delta, );
self.pred_decl_defines_symbol_14(delta, );







}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodePred(tm0, tm1, ) in self.decl_node_pred.iter_new() {

self.pred_decl_defines_symbol_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode) {
for _ in [()] {
self.pred_decl_defines_symbol_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for PredDecl(_, tm2, tm3, ) in self.pred_decl.iter_all_0(tm1, ) {

self.pred_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredDecl(tm1, tm2, tm3, ) in self.pred_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodePred(tm0, _, ) in self.decl_node_pred.iter_old_1(tm1, ) {

self.pred_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode) {
for _ in [()] {
self.pred_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.pred_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodePred(_, tm1, ) in self.decl_node_pred.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for PredDecl(_, tm2, tm3, ) in self.pred_decl.iter_old_0(tm1, ) {

self.pred_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope) {
for _ in [()] {
self.pred_decl_defines_symbol_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for PredSymbol(tm5, ) in self.pred_symbol.iter_all() {

self.pred_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredSymbol(tm5, ) in self.pred_symbol.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm4, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodePred(_, tm1, ) in self.decl_node_pred.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for PredDecl(_, tm2, tm3, ) in self.pred_decl.iter_old_0(tm1, ) {

self.pred_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope, tm5: SymbolKind) {
for _ in [()] {
self.pred_decl_defines_symbol_13(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope, tm5: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for PredDeclNodeLoc(_, tm6, ) in self.pred_decl_node_loc.iter_all_0(tm1, ) {

self.pred_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredDeclNodeLoc(tm1, tm6, ) in self.pred_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for PredSymbol(tm5, ) in self.pred_symbol.iter_old() {

#[allow(unused_variables)]
for DeclNodePred(tm0, _, ) in self.decl_node_pred.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm4, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for PredDecl(_, tm2, tm3, ) in self.pred_decl.iter_old_0(tm1, ) {

self.pred_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_decl_defines_symbol_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: PredDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: SymbolScope, tm5: SymbolKind, tm6: Loc) {
for _ in [()] {
let exists_already = self.defined_symbol.iter_all_0_1_2_3(tm4, tm2, tm5, tm6).next().is_some();
if !exists_already {
delta.new_defined_symbol.push(DefinedSymbol(tm4, tm2, tm5, tm6));
}



}
}


#[allow(unused_variables)]
fn func_decl_defines_symbol_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.func_decl_defines_symbol_1(delta, );
self.func_decl_defines_symbol_2(delta, );
self.func_decl_defines_symbol_5(delta, );
self.func_decl_defines_symbol_8(delta, );
self.func_decl_defines_symbol_11(delta, );
self.func_decl_defines_symbol_14(delta, );







}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeFunc(tm0, tm1, ) in self.decl_node_func.iter_new() {

self.func_decl_defines_symbol_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode) {
for _ in [()] {
self.func_decl_defines_symbol_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, tm4, ) in self.func_decl.iter_all_0(tm1, ) {

self.func_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDecl(tm1, tm2, tm3, tm4, ) in self.func_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeFunc(tm0, _, ) in self.decl_node_func.iter_old_1(tm1, ) {

self.func_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode) {
for _ in [()] {
self.func_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm5, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.func_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm5, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeFunc(_, tm1, ) in self.decl_node_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, tm4, ) in self.func_decl.iter_old_0(tm1, ) {

self.func_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope) {
for _ in [()] {
self.func_decl_defines_symbol_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for FuncSymbol(tm6, ) in self.func_symbol.iter_all() {

self.func_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncSymbol(tm6, ) in self.func_symbol.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm5, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodeFunc(_, tm1, ) in self.decl_node_func.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, tm4, ) in self.func_decl.iter_old_0(tm1, ) {

self.func_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope, tm6: SymbolKind) {
for _ in [()] {
self.func_decl_defines_symbol_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope, tm6: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDeclNodeLoc(_, tm7, ) in self.func_decl_node_loc.iter_all_0(tm1, ) {

self.func_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncDeclNodeLoc(tm1, tm7, ) in self.func_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for FuncSymbol(tm6, ) in self.func_symbol.iter_old() {

#[allow(unused_variables)]
for DeclNodeFunc(tm0, _, ) in self.decl_node_func.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm5, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for FuncDecl(_, tm2, tm3, tm4, ) in self.func_decl.iter_old_0(tm1, ) {

self.func_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn func_decl_defines_symbol_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: FuncDeclNode, tm2: Ident, tm3: ArgDeclListNode, tm4: TypeExprNode, tm5: SymbolScope, tm6: SymbolKind, tm7: Loc) {
for _ in [()] {
let exists_already = self.defined_symbol.iter_all_0_1_2_3(tm5, tm2, tm6, tm7).next().is_some();
if !exists_already {
delta.new_defined_symbol.push(DefinedSymbol(tm5, tm2, tm6, tm7));
}



}
}


#[allow(unused_variables)]
fn ctor_decl_defines_symbol_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ctor_decl_defines_symbol_1(delta, );
self.ctor_decl_defines_symbol_2(delta, );
self.ctor_decl_defines_symbol_5(delta, );
self.ctor_decl_defines_symbol_8(delta, );
self.ctor_decl_defines_symbol_11(delta, );






}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDecl(tm0, tm1, tm2, ) in self.ctor_decl.iter_new() {

self.ctor_decl_defines_symbol_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_3(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode) {
for _ in [()] {
self.ctor_decl_defines_symbol_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_4(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(_, tm3, ) in self.ctor_symbol_scope.iter_all_0(tm0, ) {

self.ctor_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(tm0, tm3, ) in self.ctor_symbol_scope.iter_new() {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

self.ctor_decl_defines_symbol_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_6(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope) {
for _ in [()] {
self.ctor_decl_defines_symbol_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_7(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbol(tm4, ) in self.ctor_symbol.iter_all() {

self.ctor_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbol(tm4, ) in self.ctor_symbol.iter_new() {

#[allow(unused_variables)]
for CtorSymbolScope(tm0, tm3, ) in self.ctor_symbol_scope.iter_old() {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

self.ctor_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_9(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope, tm4: SymbolKind) {
for _ in [()] {
self.ctor_decl_defines_symbol_10(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_10(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope, tm4: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDeclNodeLoc(_, tm5, ) in self.ctor_decl_node_loc.iter_all_0(tm0, ) {

self.ctor_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDeclNodeLoc(tm0, tm5, ) in self.ctor_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for CtorSymbol(tm4, ) in self.ctor_symbol.iter_old() {

#[allow(unused_variables)]
for CtorSymbolScope(_, tm3, ) in self.ctor_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

self.ctor_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ctor_decl_defines_symbol_12(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope, tm4: SymbolKind, tm5: Loc) {
for _ in [()] {
let exists_already = self.defined_symbol.iter_all_0_1_2_3(tm3, tm1, tm4, tm5).next().is_some();
if !exists_already {
delta.new_defined_symbol.push(DefinedSymbol(tm3, tm1, tm4, tm5));
}



}
}


#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_definition_symbol_scope_rule_1(delta, );
self.pred_definition_symbol_scope_rule_2(delta, );
self.pred_definition_symbol_scope_rule_5(delta, );
self.pred_definition_symbol_scope_rule_8(delta, );





}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm1, tm2, tm0, ) in self.semantic_pred.iter_new() {

self.pred_definition_symbol_scope_rule_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_3(&self, delta: &mut ModelDelta, tm0: Pred, tm1: SymbolScope, tm2: Ident) {
for _ in [()] {
self.pred_definition_symbol_scope_rule_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_4(&self, delta: &mut ModelDelta, tm0: Pred, tm1: SymbolScope, tm2: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedSymbol(_, _, tm3, tm4, ) in self.defined_symbol.iter_all_0_1(tm1, tm2, ) {

self.pred_definition_symbol_scope_rule_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedSymbol(tm1, tm2, tm3, tm4, ) in self.defined_symbol.iter_new() {

#[allow(unused_variables)]
for SemanticPred(_, _, tm0, ) in self.semantic_pred.iter_old_0_1(tm1, tm2, ) {

self.pred_definition_symbol_scope_rule_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_6(&self, delta: &mut ModelDelta, tm0: Pred, tm1: SymbolScope, tm2: Ident, tm3: SymbolKind, tm4: Loc) {
for _ in [()] {
self.pred_definition_symbol_scope_rule_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_7(&self, delta: &mut ModelDelta, tm0: Pred, tm1: SymbolScope, tm2: Ident, tm3: SymbolKind, tm4: Loc) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(_, tm5, ) in self.pred_rel.iter_all_0(tm0, ) {

self.pred_definition_symbol_scope_rule_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(tm0, tm5, ) in self.pred_rel.iter_new() {

#[allow(unused_variables)]
for SemanticPred(tm1, tm2, _, ) in self.semantic_pred.iter_old_2(tm0, ) {

#[allow(unused_variables)]
for DefinedSymbol(_, _, tm3, tm4, ) in self.defined_symbol.iter_old_0_1(tm1, tm2, ) {

self.pred_definition_symbol_scope_rule_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_definition_symbol_scope_rule_9(&self, delta: &mut ModelDelta, tm0: Pred, tm1: SymbolScope, tm2: Ident, tm3: SymbolKind, tm4: Loc, tm5: Rel) {
for _ in [()] {
let exists_already = self.rel_definition_symbol_scope.iter_all_0_1(tm5, tm1).next().is_some();
if !exists_already {
delta.new_rel_definition_symbol_scope.push(RelDefinitionSymbolScope(tm5, tm1));
}



}
}


#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.func_definition_symbol_scope_rule_1(delta, );
self.func_definition_symbol_scope_rule_2(delta, );
self.func_definition_symbol_scope_rule_5(delta, );
self.func_definition_symbol_scope_rule_8(delta, );





}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm1, tm2, tm0, ) in self.semantic_func.iter_new() {

self.func_definition_symbol_scope_rule_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_3(&self, delta: &mut ModelDelta, tm0: Func, tm1: SymbolScope, tm2: Ident) {
for _ in [()] {
self.func_definition_symbol_scope_rule_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_4(&self, delta: &mut ModelDelta, tm0: Func, tm1: SymbolScope, tm2: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedSymbol(_, _, tm3, tm4, ) in self.defined_symbol.iter_all_0_1(tm1, tm2, ) {

self.func_definition_symbol_scope_rule_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedSymbol(tm1, tm2, tm3, tm4, ) in self.defined_symbol.iter_new() {

#[allow(unused_variables)]
for SemanticFunc(_, _, tm0, ) in self.semantic_func.iter_old_0_1(tm1, tm2, ) {

self.func_definition_symbol_scope_rule_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_6(&self, delta: &mut ModelDelta, tm0: Func, tm1: SymbolScope, tm2: Ident, tm3: SymbolKind, tm4: Loc) {
for _ in [()] {
self.func_definition_symbol_scope_rule_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_7(&self, delta: &mut ModelDelta, tm0: Func, tm1: SymbolScope, tm2: Ident, tm3: SymbolKind, tm4: Loc) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(_, tm5, ) in self.func_rel.iter_all_0(tm0, ) {

self.func_definition_symbol_scope_rule_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm0, tm5, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for SemanticFunc(tm1, tm2, _, ) in self.semantic_func.iter_old_2(tm0, ) {

#[allow(unused_variables)]
for DefinedSymbol(_, _, tm3, tm4, ) in self.defined_symbol.iter_old_0_1(tm1, tm2, ) {

self.func_definition_symbol_scope_rule_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn func_definition_symbol_scope_rule_9(&self, delta: &mut ModelDelta, tm0: Func, tm1: SymbolScope, tm2: Ident, tm3: SymbolKind, tm4: Loc, tm5: Rel) {
for _ in [()] {
let exists_already = self.rel_definition_symbol_scope.iter_all_0_1(tm5, tm1).next().is_some();
if !exists_already {
delta.new_rel_definition_symbol_scope.push(RelDefinitionSymbolScope(tm5, tm1));
}



}
}


#[allow(unused_variables)]
fn rule_decl_defines_symbol_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rule_decl_defines_symbol_1(delta, );
self.rule_decl_defines_symbol_2(delta, );
self.rule_decl_defines_symbol_5(delta, );
self.rule_decl_defines_symbol_8(delta, );
self.rule_decl_defines_symbol_11(delta, );
self.rule_decl_defines_symbol_14(delta, );
self.rule_decl_defines_symbol_17(delta, );








}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeRule(tm0, tm1, ) in self.decl_node_rule.iter_new() {

self.rule_decl_defines_symbol_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode) {
for _ in [()] {
self.rule_decl_defines_symbol_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDecl(_, tm2, ) in self.rule_decl.iter_all_0(tm1, ) {

self.rule_decl_defines_symbol_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDecl(tm1, tm2, ) in self.rule_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(tm0, _, ) in self.decl_node_rule.iter_old_1(tm1, ) {

self.rule_decl_defines_symbol_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode) {
for _ in [()] {
self.rule_decl_defines_symbol_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm3, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.rule_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm3, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for RuleDecl(_, tm2, ) in self.rule_decl.iter_old_0(tm1, ) {

self.rule_decl_defines_symbol_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode, tm3: SymbolScope) {
for _ in [()] {
self.rule_decl_defines_symbol_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode, tm3: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for RuleName(_, tm4, ) in self.rule_name.iter_all_0(tm1, ) {

self.rule_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleName(tm1, tm4, ) in self.rule_name.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(tm0, _, ) in self.decl_node_rule.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm3, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for RuleDecl(_, tm2, ) in self.rule_decl.iter_old_0(tm1, ) {

self.rule_decl_defines_symbol_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Ident) {
for _ in [()] {
self.rule_decl_defines_symbol_13(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for RuleSymbol(tm5, ) in self.rule_symbol.iter_all() {

self.rule_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleSymbol(tm5, ) in self.rule_symbol.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm3, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for RuleDecl(_, tm2, ) in self.rule_decl.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for RuleName(_, tm4, ) in self.rule_name.iter_old_0(tm1, ) {

self.rule_decl_defines_symbol_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Ident, tm5: SymbolKind) {
for _ in [()] {
self.rule_decl_defines_symbol_16(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_16(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Ident, tm5: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDeclNodeLoc(_, tm6, ) in self.rule_decl_node_loc.iter_all_0(tm1, ) {

self.rule_decl_defines_symbol_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDeclNodeLoc(tm1, tm6, ) in self.rule_decl_node_loc.iter_new() {

#[allow(unused_variables)]
for RuleSymbol(tm5, ) in self.rule_symbol.iter_old() {

#[allow(unused_variables)]
for RuleDecl(_, tm2, ) in self.rule_decl.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for DeclNodeRule(tm0, _, ) in self.decl_node_rule.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for RuleName(_, tm4, ) in self.rule_name.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm3, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

self.rule_decl_defines_symbol_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn rule_decl_defines_symbol_18(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Ident, tm5: SymbolKind, tm6: Loc) {
for _ in [()] {
let exists_already = self.defined_symbol.iter_all_0_1_2_3(tm3, tm4, tm5, tm6).next().is_some();
if !exists_already {
delta.new_defined_symbol.push(DefinedSymbol(tm3, tm4, tm5, tm6));
}



}
}


#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.var_atom_should_be_type_ambient_1(delta, );
self.var_atom_should_be_type_ambient_2(delta, );
self.var_atom_should_be_type_ambient_5(delta, );
self.var_atom_should_be_type_ambient_8(delta, );
self.var_atom_should_be_type_ambient_9(delta, );
self.var_atom_should_be_type_ambient_10(delta, );
self.var_atom_should_be_type_ambient_13(delta, );
self.var_atom_should_be_type_ambient_16(delta, );
self.var_atom_should_be_type_ambient_19(delta, );
self.var_atom_should_be_type_ambient_22(delta, );











}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, tm2, ) in self.var_if_atom_node.iter_new() {

self.var_atom_should_be_type_ambient_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
self.var_atom_should_be_type_ambient_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientTypeExpr(_, tm3, ) in self.ambient_type_expr.iter_all_0(tm2, ) {

self.var_atom_should_be_type_ambient_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm3, ) in self.ambient_type_expr.iter_new() {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_ambient_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident) {
for _ in [()] {
self.var_atom_should_be_type_ambient_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_all_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_all_0(tm5, ) {

self.var_atom_should_be_type_ambient_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm6, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(_, tm3, ) in self.ambient_type_expr.iter_old_0(tm2, ) {

self.var_atom_should_be_type_ambient_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm6, tm5, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(_, tm3, ) in self.ambient_type_expr.iter_old_0(tm2, ) {

self.var_atom_should_be_type_ambient_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm5, tm4, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(_, tm3, ) in self.ambient_type_expr.iter_old_0(tm2, ) {

self.var_atom_should_be_type_ambient_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_11(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
self.var_atom_should_be_type_ambient_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_12(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm7, ) in self.type_symbol.iter_all() {

self.var_atom_should_be_type_ambient_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm7, ) in self.type_symbol.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm5, tm4, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm3, ) in self.ambient_type_expr.iter_old() {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, _, ) in self.var_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.var_atom_should_be_type_ambient_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_14(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: SymbolKind) {
for _ in [()] {
self.var_atom_should_be_type_ambient_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_15(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm8, ) in self.enum_symbol.iter_all() {

self.var_atom_should_be_type_ambient_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_16(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm8, ) in self.enum_symbol.iter_new() {

#[allow(unused_variables)]
for TypeSymbol(tm7, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm3, ) in self.ambient_type_expr.iter_old() {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

self.var_atom_should_be_type_ambient_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_17(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: SymbolKind, tm8: SymbolKind) {
for _ in [()] {
self.var_atom_should_be_type_ambient_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_18(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: SymbolKind, tm8: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm9, ) in self.model_symbol.iter_all() {

self.var_atom_should_be_type_ambient_20(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_19(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm9, ) in self.model_symbol.iter_new() {

#[allow(unused_variables)]
for EnumSymbol(tm8, ) in self.enum_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm7, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm3, ) in self.ambient_type_expr.iter_old() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm6, ) in self.rule_descendant_if_atom.iter_old() {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, _, ) in self.var_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.var_atom_should_be_type_ambient_20(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_20(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: SymbolKind, tm8: SymbolKind, tm9: SymbolKind) {
for _ in [()] {
self.var_atom_should_be_type_ambient_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_21(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: SymbolKind, tm8: SymbolKind, tm9: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(_, tm10, ) in self.if_atom_node_loc.iter_all_0(tm0, ) {

self.var_atom_should_be_type_ambient_23(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_22(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(tm0, tm10, ) in self.if_atom_node_loc.iter_new() {

#[allow(unused_variables)]
for ModelSymbol(tm9, ) in self.model_symbol.iter_old() {

#[allow(unused_variables)]
for EnumSymbol(tm8, ) in self.enum_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm7, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm3, ) in self.ambient_type_expr.iter_old() {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, _, ) in self.var_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.var_atom_should_be_type_ambient_23(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_ambient_23(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: SymbolKind, tm8: SymbolKind, tm9: SymbolKind, tm10: Loc) {
for _ in [()] {
let exists_already = self.should_be_symbol_3.iter_all_0_1_2_3_4_5(tm3, tm7, tm8, tm9, tm4, tm10).next().is_some();
if !exists_already {
delta.new_should_be_symbol_3.push(ShouldBeSymbol3(tm3, tm7, tm8, tm9, tm4, tm10));
}



}
}


#[allow(unused_variables)]
fn var_atom_should_be_type_member_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.var_atom_should_be_type_member_1(delta, );
self.var_atom_should_be_type_member_2(delta, );
self.var_atom_should_be_type_member_5(delta, );
self.var_atom_should_be_type_member_8(delta, );
self.var_atom_should_be_type_member_9(delta, );
self.var_atom_should_be_type_member_12(delta, );
self.var_atom_should_be_type_member_15(delta, );
self.var_atom_should_be_type_member_18(delta, );
self.var_atom_should_be_type_member_21(delta, );
self.var_atom_should_be_type_member_24(delta, );
self.var_atom_should_be_type_member_27(delta, );












}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, tm2, ) in self.var_if_atom_node.iter_new() {

self.var_atom_should_be_type_member_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
self.var_atom_should_be_type_member_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for MemberTypeExpr(_, tm3, tm4, ) in self.member_type_expr.iter_all_0(tm2, ) {

self.var_atom_should_be_type_member_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MemberTypeExpr(tm2, tm3, tm4, ) in self.member_type_expr.iter_new() {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_member_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident) {
for _ in [()] {
self.var_atom_should_be_type_member_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm7, tm5, ) in self.semantic_el.iter_all_0(tm3, ) {

#[allow(unused_variables)]
for ElType(_, tm6, ) in self.el_type.iter_all_0(tm5, ) {

self.var_atom_should_be_type_member_10(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(tm5, tm6, ) in self.el_type.iter_new() {

#[allow(unused_variables)]
for SemanticEl(tm3, tm7, _, ) in self.semantic_el.iter_old_2(tm5, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_member_10(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm3, tm7, tm5, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for ElType(_, tm6, ) in self.el_type.iter_all_0(tm5, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_member_10(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_10(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure) {
for _ in [()] {
self.var_atom_should_be_type_member_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_11(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for UnderlyingType(_, tm8, ) in self.underlying_type.iter_all_0(tm6, ) {

self.var_atom_should_be_type_member_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for UnderlyingType(tm6, tm8, ) in self.underlying_type.iter_new() {

#[allow(unused_variables)]
for ElType(tm5, _, ) in self.el_type.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SemanticEl(tm3, tm7, _, ) in self.semantic_el.iter_old_2(tm5, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_member_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_13(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type) {
for _ in [()] {
self.var_atom_should_be_type_member_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_14(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type) {
for _ in [()] {
#[allow(unused_variables)]
for ModelMemberSymbolScope(_, tm9, ) in self.model_member_symbol_scope.iter_all_0(tm8, ) {

self.var_atom_should_be_type_member_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelMemberSymbolScope(tm8, tm9, ) in self.model_member_symbol_scope.iter_new() {

#[allow(unused_variables)]
for UnderlyingType(tm6, _, ) in self.underlying_type.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for ElType(tm5, _, ) in self.el_type.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SemanticEl(tm3, tm7, _, ) in self.semantic_el.iter_old_2(tm5, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_member_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_16(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope) {
for _ in [()] {
self.var_atom_should_be_type_member_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_17(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm10, ) in self.type_symbol.iter_all() {

self.var_atom_should_be_type_member_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_18(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeSymbol(tm10, ) in self.type_symbol.iter_new() {

#[allow(unused_variables)]
for ModelMemberSymbolScope(tm8, tm9, ) in self.model_member_symbol_scope.iter_old() {

#[allow(unused_variables)]
for UnderlyingType(tm6, _, ) in self.underlying_type.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for ElType(tm5, _, ) in self.el_type.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SemanticEl(tm3, tm7, _, ) in self.semantic_el.iter_old_2(tm5, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_member_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_19(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope, tm10: SymbolKind) {
for _ in [()] {
self.var_atom_should_be_type_member_20(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_20(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope, tm10: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm11, ) in self.enum_symbol.iter_all() {

self.var_atom_should_be_type_member_22(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_21(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumSymbol(tm11, ) in self.enum_symbol.iter_new() {

#[allow(unused_variables)]
for TypeSymbol(tm10, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for ModelMemberSymbolScope(tm8, tm9, ) in self.model_member_symbol_scope.iter_old() {

#[allow(unused_variables)]
for UnderlyingType(tm6, _, ) in self.underlying_type.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for ElType(tm5, _, ) in self.el_type.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SemanticEl(tm3, tm7, _, ) in self.semantic_el.iter_old_2(tm5, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_member_22(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_22(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope, tm10: SymbolKind, tm11: SymbolKind) {
for _ in [()] {
self.var_atom_should_be_type_member_23(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_23(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope, tm10: SymbolKind, tm11: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm12, ) in self.model_symbol.iter_all() {

self.var_atom_should_be_type_member_25(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_24(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelSymbol(tm12, ) in self.model_symbol.iter_new() {

#[allow(unused_variables)]
for EnumSymbol(tm11, ) in self.enum_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm10, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for ModelMemberSymbolScope(tm8, tm9, ) in self.model_member_symbol_scope.iter_old() {

#[allow(unused_variables)]
for UnderlyingType(tm6, _, ) in self.underlying_type.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for ElType(tm5, _, ) in self.el_type.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SemanticEl(tm3, tm7, _, ) in self.semantic_el.iter_old_2(tm5, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_atom_should_be_type_member_25(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_25(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope, tm10: SymbolKind, tm11: SymbolKind, tm12: SymbolKind) {
for _ in [()] {
self.var_atom_should_be_type_member_26(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12);


}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_26(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope, tm10: SymbolKind, tm11: SymbolKind, tm12: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(_, tm13, ) in self.if_atom_node_loc.iter_all_0(tm0, ) {

self.var_atom_should_be_type_member_28(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12, tm13);


}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_27(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(tm0, tm13, ) in self.if_atom_node_loc.iter_new() {

#[allow(unused_variables)]
for ModelSymbol(tm12, ) in self.model_symbol.iter_old() {

#[allow(unused_variables)]
for EnumSymbol(tm11, ) in self.enum_symbol.iter_old() {

#[allow(unused_variables)]
for TypeSymbol(tm10, ) in self.type_symbol.iter_old() {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for MemberTypeExpr(_, tm3, tm4, ) in self.member_type_expr.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for ModelMemberSymbolScope(tm8, tm9, ) in self.model_member_symbol_scope.iter_old() {

#[allow(unused_variables)]
for UnderlyingType(tm6, _, ) in self.underlying_type.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for ElType(tm5, _, ) in self.el_type.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm7, _, ) in self.semantic_el.iter_old_0_2(tm3, tm5, ) {

self.var_atom_should_be_type_member_28(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12, tm13);


}

}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_atom_should_be_type_member_28(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: ElementType, tm7: Structure, tm8: Type, tm9: SymbolScope, tm10: SymbolKind, tm11: SymbolKind, tm12: SymbolKind, tm13: Loc) {
for _ in [()] {
let exists_already = self.should_be_symbol_3.iter_all_0_1_2_3_4_5(tm4, tm10, tm11, tm12, tm9, tm13).next().is_some();
if !exists_already {
delta.new_should_be_symbol_3.push(ShouldBeSymbol3(tm4, tm10, tm11, tm12, tm9, tm13));
}



}
}


#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_if_atom_should_be_pred_1(delta, );
self.pred_if_atom_should_be_pred_2(delta, );
self.pred_if_atom_should_be_pred_5(delta, );
self.pred_if_atom_should_be_pred_6(delta, );
self.pred_if_atom_should_be_pred_7(delta, );
self.pred_if_atom_should_be_pred_10(delta, );
self.pred_if_atom_should_be_pred_13(delta, );








}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredIfAtomNode(tm0, tm1, tm2, ) in self.pred_if_atom_node.iter_new() {

self.pred_if_atom_should_be_pred_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pred_if_atom_should_be_pred_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm5, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_all_0(tm4, ) {

self.pred_if_atom_should_be_pred_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm5, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_should_be_pred_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm5, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_should_be_pred_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_should_be_pred_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_8(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
self.pred_if_atom_should_be_pred_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_9(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for PredSymbol(tm6, ) in self.pred_symbol.iter_all() {

self.pred_if_atom_should_be_pred_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredSymbol(tm6, ) in self.pred_symbol.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_should_be_pred_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_11(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind) {
for _ in [()] {
self.pred_if_atom_should_be_pred_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_12(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(_, tm7, ) in self.if_atom_node_loc.iter_all_0(tm0, ) {

self.pred_if_atom_should_be_pred_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(tm0, tm7, ) in self.if_atom_node_loc.iter_new() {

#[allow(unused_variables)]
for PredSymbol(tm6, ) in self.pred_symbol.iter_old() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm5, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_should_be_pred_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_should_be_pred_14(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind, tm7: Loc) {
for _ in [()] {
let exists_already = self.should_be_symbol.iter_all_0_1_2_3(tm1, tm6, tm3, tm7).next().is_some();
if !exists_already {
delta.new_should_be_symbol.push(ShouldBeSymbol(tm1, tm6, tm3, tm7));
}



}
}


#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_then_atom_should_be_pred_1(delta, );
self.pred_then_atom_should_be_pred_2(delta, );
self.pred_then_atom_should_be_pred_5(delta, );
self.pred_then_atom_should_be_pred_6(delta, );
self.pred_then_atom_should_be_pred_7(delta, );
self.pred_then_atom_should_be_pred_10(delta, );
self.pred_then_atom_should_be_pred_13(delta, );








}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredThenAtomNode(tm0, tm1, tm2, ) in self.pred_then_atom_node.iter_new() {

self.pred_then_atom_should_be_pred_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pred_then_atom_should_be_pred_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm5, ) in self.rule_descendant_then_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_all_0(tm4, ) {

self.pred_then_atom_should_be_pred_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm5, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_should_be_pred_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm5, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_should_be_pred_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_should_be_pred_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_8(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
self.pred_then_atom_should_be_pred_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_9(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for PredSymbol(tm6, ) in self.pred_symbol.iter_all() {

self.pred_then_atom_should_be_pred_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredSymbol(tm6, ) in self.pred_symbol.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_should_be_pred_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_11(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind) {
for _ in [()] {
self.pred_then_atom_should_be_pred_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_12(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomNodeLoc(_, tm7, ) in self.then_atom_node_loc.iter_all_0(tm0, ) {

self.pred_then_atom_should_be_pred_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomNodeLoc(tm0, tm7, ) in self.then_atom_node_loc.iter_new() {

#[allow(unused_variables)]
for PredSymbol(tm6, ) in self.pred_symbol.iter_old() {

#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm5, ) in self.rule_descendant_then_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_should_be_pred_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_should_be_pred_14(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind, tm7: Loc) {
for _ in [()] {
let exists_already = self.should_be_symbol.iter_all_0_1_2_3(tm1, tm6, tm3, tm7).next().is_some();
if !exists_already {
delta.new_should_be_symbol.push(ShouldBeSymbol(tm1, tm6, tm3, tm7));
}



}
}


#[allow(unused_variables)]
fn app_atom_should_be_func_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.app_atom_should_be_func_1(delta, );
self.app_atom_should_be_func_2(delta, );
self.app_atom_should_be_func_5(delta, );
self.app_atom_should_be_func_6(delta, );
self.app_atom_should_be_func_7(delta, );
self.app_atom_should_be_func_10(delta, );
self.app_atom_should_be_func_13(delta, );
self.app_atom_should_be_func_16(delta, );









}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm0, tm1, tm2, ) in self.app_term_node.iter_new() {

self.app_atom_should_be_func_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.app_atom_should_be_func_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm5, ) in self.rule_descendant_term.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_all_0(tm4, ) {

self.app_atom_should_be_func_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm5, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.app_atom_should_be_func_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm5, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.app_atom_should_be_func_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.app_atom_should_be_func_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_8(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
self.app_atom_should_be_func_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for FuncSymbol(tm6, ) in self.func_symbol.iter_all() {

self.app_atom_should_be_func_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncSymbol(tm6, ) in self.func_symbol.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.app_atom_should_be_func_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_11(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind) {
for _ in [()] {
self.app_atom_should_be_func_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_12(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbol(tm7, ) in self.ctor_symbol.iter_all() {

self.app_atom_should_be_func_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbol(tm7, ) in self.ctor_symbol.iter_new() {

#[allow(unused_variables)]
for FuncSymbol(tm6, ) in self.func_symbol.iter_old() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.app_atom_should_be_func_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_14(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind, tm7: SymbolKind) {
for _ in [()] {
self.app_atom_should_be_func_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_15(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind, tm7: SymbolKind) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(_, tm8, ) in self.term_node_loc.iter_all_0(tm0, ) {

self.app_atom_should_be_func_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_16(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm0, tm8, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for CtorSymbol(tm7, ) in self.ctor_symbol.iter_old() {

#[allow(unused_variables)]
for FuncSymbol(tm6, ) in self.func_symbol.iter_old() {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm5, ) in self.rule_descendant_term.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.app_atom_should_be_func_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_atom_should_be_func_17(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: SymbolKind, tm7: SymbolKind, tm8: Loc) {
for _ in [()] {
let exists_already = self.should_be_symbol_2.iter_all_0_1_2_3_4(tm1, tm6, tm7, tm3, tm8).next().is_some();
if !exists_already {
delta.new_should_be_symbol_2.push(ShouldBeSymbol2(tm1, tm6, tm7, tm3, tm8));
}



}
}


#[allow(unused_variables)]
fn type_list_len_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_list_len_total_1(delta, );
self.type_list_len_total_2(delta, );
self.type_list_len_total_5(delta, );




}
}

#[allow(unused_variables)]
fn type_list_len_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_list_len_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.type_list_new.iter().copied() {

self.type_list_len_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn type_list_len_total_3(&self, delta: &mut ModelDelta, tm0: TypeList) {
for _ in [()] {
self.type_list_len_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn type_list_len_total_4(&self, delta: &mut ModelDelta, tm0: TypeList) {
for _ in [()] {
let tm1 = match self.type_list_len.iter_all_0(tm0).next() {
    Some(TypeListLen(_,  res)) => res,
    None => { 
        delta.new_type_list_len_def.push(TypeListLenArgs(tm0));
        break;
    },
};

self.type_list_len_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn type_list_len_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm0, tm1, ) in self.type_list_len.iter_new() {

self.type_list_len_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn type_list_len_total_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Nat) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn type_list_len_nil_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_list_len_nil_1(delta, );
self.type_list_len_nil_2(delta, );
self.type_list_len_nil_5(delta, );




}
}

#[allow(unused_variables)]
fn type_list_len_nil_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_list_len_nil_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTypeList(tm0, ) in self.nil_type_list.iter_new() {

self.type_list_len_nil_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn type_list_len_nil_3(&self, delta: &mut ModelDelta, tm0: TypeList) {
for _ in [()] {
self.type_list_len_nil_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn type_list_len_nil_4(&self, delta: &mut ModelDelta, tm0: TypeList) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(_, tm1, ) in self.type_list_len.iter_all_0(tm0, ) {

self.type_list_len_nil_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn type_list_len_nil_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm0, tm1, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for NilTypeList(_, ) in self.nil_type_list.iter_old_0(tm0, ) {

self.type_list_len_nil_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn type_list_len_nil_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Nat) {
for _ in [()] {
let exists_already = self.zero.iter_all_0(tm1).next().is_some();
if !exists_already {
delta.new_zero.push(Zero(tm1));
}



}
}


#[allow(unused_variables)]
fn type_list_len_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_list_len_cons_1(delta, );
self.type_list_len_cons_2(delta, );
self.type_list_len_cons_5(delta, );
self.type_list_len_cons_8(delta, );





}
}

#[allow(unused_variables)]
fn type_list_len_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_list_len_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTypeList(tm1, tm2, tm0, ) in self.cons_type_list.iter_new() {

self.type_list_len_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn type_list_len_cons_3(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList) {
for _ in [()] {
self.type_list_len_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn type_list_len_cons_4(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(_, tm3, ) in self.type_list_len.iter_all_0(tm0, ) {

self.type_list_len_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn type_list_len_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm0, tm3, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for ConsTypeList(tm1, tm2, _, ) in self.cons_type_list.iter_old_2(tm0, ) {

self.type_list_len_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn type_list_len_cons_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList, tm3: Nat) {
for _ in [()] {
self.type_list_len_cons_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn type_list_len_cons_7(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList, tm3: Nat) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(_, tm4, ) in self.type_list_len.iter_all_0(tm2, ) {

self.type_list_len_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn type_list_len_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm2, tm4, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for ConsTypeList(tm1, _, tm0, ) in self.cons_type_list.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm3, ) in self.type_list_len.iter_old_0(tm0, ) {

self.type_list_len_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn type_list_len_cons_9(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: Type, tm2: TypeList, tm3: Nat, tm4: Nat) {
for _ in [()] {
let exists_already = self.succ.iter_all_0_1(tm4, tm3).next().is_some();
if !exists_already {
delta.new_succ.push(Succ(tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn type_list_len_snoc_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.type_list_len_snoc_1(delta, );
self.type_list_len_snoc_2(delta, );
self.type_list_len_snoc_5(delta, );
self.type_list_len_snoc_8(delta, );





}
}

#[allow(unused_variables)]
fn type_list_len_snoc_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn type_list_len_snoc_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocTypeList(tm1, tm2, tm0, ) in self.snoc_type_list.iter_new() {

self.type_list_len_snoc_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn type_list_len_snoc_3(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type) {
for _ in [()] {
self.type_list_len_snoc_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn type_list_len_snoc_4(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(_, tm3, ) in self.type_list_len.iter_all_0(tm0, ) {

self.type_list_len_snoc_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn type_list_len_snoc_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm0, tm3, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for SnocTypeList(tm1, tm2, _, ) in self.snoc_type_list.iter_old_2(tm0, ) {

self.type_list_len_snoc_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn type_list_len_snoc_6(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type, tm3: Nat) {
for _ in [()] {
self.type_list_len_snoc_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn type_list_len_snoc_7(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type, tm3: Nat) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(_, tm4, ) in self.type_list_len.iter_all_0(tm1, ) {

self.type_list_len_snoc_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn type_list_len_snoc_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm1, tm4, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for SnocTypeList(_, tm2, tm0, ) in self.snoc_type_list.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm3, ) in self.type_list_len.iter_old_0(tm0, ) {

self.type_list_len_snoc_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn type_list_len_snoc_9(&self, delta: &mut ModelDelta, tm0: TypeList, tm1: TypeList, tm2: Type, tm3: Nat, tm4: Nat) {
for _ in [()] {
let exists_already = self.succ.iter_all_0_1(tm4, tm3).next().is_some();
if !exists_already {
delta.new_succ.push(Succ(tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn term_list_len_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.term_list_len_total_1(delta, );
self.term_list_len_total_2(delta, );
self.term_list_len_total_5(delta, );




}
}

#[allow(unused_variables)]
fn term_list_len_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn term_list_len_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.term_list_node_new.iter().copied() {

self.term_list_len_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn term_list_len_total_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
self.term_list_len_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn term_list_len_total_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
let tm1 = match self.term_list_len.iter_all_0(tm0).next() {
    Some(TermListLen(_,  res)) => res,
    None => { 
        delta.new_term_list_len_def.push(TermListLenArgs(tm0));
        break;
    },
};

self.term_list_len_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn term_list_len_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(tm0, tm1, ) in self.term_list_len.iter_new() {

self.term_list_len_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn term_list_len_total_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Nat) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn term_list_len_nil_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.term_list_len_nil_1(delta, );
self.term_list_len_nil_2(delta, );
self.term_list_len_nil_5(delta, );




}
}

#[allow(unused_variables)]
fn term_list_len_nil_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn term_list_len_nil_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTermListNode(tm0, ) in self.nil_term_list_node.iter_new() {

self.term_list_len_nil_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn term_list_len_nil_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
self.term_list_len_nil_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn term_list_len_nil_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(_, tm1, ) in self.term_list_len.iter_all_0(tm0, ) {

self.term_list_len_nil_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn term_list_len_nil_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(tm0, tm1, ) in self.term_list_len.iter_new() {

#[allow(unused_variables)]
for NilTermListNode(_, ) in self.nil_term_list_node.iter_old_0(tm0, ) {

self.term_list_len_nil_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn term_list_len_nil_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Nat) {
for _ in [()] {
let exists_already = self.zero.iter_all_0(tm1).next().is_some();
if !exists_already {
delta.new_zero.push(Zero(tm1));
}



}
}


#[allow(unused_variables)]
fn term_list_len_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.term_list_len_cons_1(delta, );
self.term_list_len_cons_2(delta, );
self.term_list_len_cons_5(delta, );
self.term_list_len_cons_8(delta, );





}
}

#[allow(unused_variables)]
fn term_list_len_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn term_list_len_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTermListNode(tm0, tm1, tm2, ) in self.cons_term_list_node.iter_new() {

self.term_list_len_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn term_list_len_cons_3(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
self.term_list_len_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn term_list_len_cons_4(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(_, tm3, ) in self.term_list_len.iter_all_0(tm0, ) {

self.term_list_len_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn term_list_len_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(tm0, tm3, ) in self.term_list_len.iter_new() {

#[allow(unused_variables)]
for ConsTermListNode(_, tm1, tm2, ) in self.cons_term_list_node.iter_old_0(tm0, ) {

self.term_list_len_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn term_list_len_cons_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: Nat) {
for _ in [()] {
self.term_list_len_cons_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn term_list_len_cons_7(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: Nat) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(_, tm4, ) in self.term_list_len.iter_all_0(tm2, ) {

self.term_list_len_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn term_list_len_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(tm2, tm4, ) in self.term_list_len.iter_new() {

#[allow(unused_variables)]
for TermListLen(tm0, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for ConsTermListNode(_, tm1, _, ) in self.cons_term_list_node.iter_old_0_2(tm0, tm2, ) {

self.term_list_len_cons_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn term_list_len_cons_9(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: Nat, tm4: Nat) {
for _ in [()] {
let exists_already = self.succ.iter_all_0_1(tm4, tm3).next().is_some();
if !exists_already {
delta.new_succ.push(Succ(tm4, tm3));
}



}
}


#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_if_atom_arg_num_should_match_1(delta, );
self.pred_if_atom_arg_num_should_match_2(delta, );
self.pred_if_atom_arg_num_should_match_5(delta, );
self.pred_if_atom_arg_num_should_match_8(delta, );
self.pred_if_atom_arg_num_should_match_9(delta, );
self.pred_if_atom_arg_num_should_match_10(delta, );
self.pred_if_atom_arg_num_should_match_13(delta, );
self.pred_if_atom_arg_num_should_match_14(delta, );
self.pred_if_atom_arg_num_should_match_15(delta, );
self.pred_if_atom_arg_num_should_match_18(delta, );











}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredIfAtomNode(tm0, tm1, tm2, ) in self.pred_if_atom_node.iter_new() {

self.pred_if_atom_arg_num_should_match_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pred_if_atom_arg_num_should_match_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(_, tm3, ) in self.term_list_len.iter_all_0(tm2, ) {

self.pred_if_atom_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_new() {

#[allow(unused_variables)]
for PredIfAtomNode(tm0, tm1, _, ) in self.pred_if_atom_node.iter_old_2(tm2, ) {

self.pred_if_atom_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat) {
for _ in [()] {
self.pred_if_atom_arg_num_should_match_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_all_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_all_0(tm5, ) {

self.pred_if_atom_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm6, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, _, ) in self.pred_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.pred_if_atom_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm6, tm5, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, _, ) in self.pred_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.pred_if_atom_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm5, tm4, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, _, ) in self.pred_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.pred_if_atom_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_11(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
self.pred_if_atom_arg_num_should_match_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_12(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(_, _, tm9, ) in self.semantic_pred.iter_all_0_1(tm4, tm1, ) {

#[allow(unused_variables)]
for PredArity(_, tm8, ) in self.pred_arity.iter_all_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_all_0(tm8, ) {

self.pred_if_atom_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm4, tm1, tm9, ) in self.semantic_pred.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm5, _, ) in self.scope_symbols.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for PredArity(_, tm8, ) in self.pred_arity.iter_old_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, _, tm2, ) in self.pred_if_atom_node.iter_old_0_1(tm0, tm1, ) {

#[allow(unused_variables)]
for TermListLen(_, tm3, ) in self.term_list_len.iter_old_0(tm2, ) {

self.pred_if_atom_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredArity(tm9, tm8, ) in self.pred_arity.iter_new() {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for SemanticPred(tm4, tm1, _, ) in self.semantic_pred.iter_all_2(tm9, ) {

#[allow(unused_variables)]
for PredIfAtomNode(tm0, _, _, ) in self.pred_if_atom_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm5, tm4, ) {

self.pred_if_atom_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm8, tm7, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for PredArity(tm9, _, ) in self.pred_arity.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for SemanticPred(tm4, tm1, _, ) in self.semantic_pred.iter_all_2(tm9, ) {

#[allow(unused_variables)]
for PredIfAtomNode(tm0, _, _, ) in self.pred_if_atom_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm5, tm4, ) {

self.pred_if_atom_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_16(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Pred) {
for _ in [()] {
self.pred_if_atom_arg_num_should_match_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_17(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Pred) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(_, tm10, ) in self.if_atom_node_loc.iter_all_0(tm0, ) {

self.pred_if_atom_arg_num_should_match_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_18(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomNodeLoc(tm0, tm10, ) in self.if_atom_node_loc.iter_new() {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, _, ) in self.pred_if_atom_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for SemanticPred(_, _, tm9, ) in self.semantic_pred.iter_old_0_1(tm4, tm1, ) {

#[allow(unused_variables)]
for PredArity(_, tm8, ) in self.pred_arity.iter_old_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

self.pred_if_atom_arg_num_should_match_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_arg_num_should_match_19(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Pred, tm10: Loc) {
for _ in [()] {
let exists_already = self.pred_arg_num_should_match.iter_all_0_1_2(tm3, tm7, tm10).next().is_some();
if !exists_already {
delta.new_pred_arg_num_should_match.push(PredArgNumShouldMatch(tm3, tm7, tm10));
}



}
}


#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_then_atom_arg_num_should_match_1(delta, );
self.pred_then_atom_arg_num_should_match_2(delta, );
self.pred_then_atom_arg_num_should_match_5(delta, );
self.pred_then_atom_arg_num_should_match_8(delta, );
self.pred_then_atom_arg_num_should_match_9(delta, );
self.pred_then_atom_arg_num_should_match_10(delta, );
self.pred_then_atom_arg_num_should_match_13(delta, );
self.pred_then_atom_arg_num_should_match_14(delta, );
self.pred_then_atom_arg_num_should_match_15(delta, );
self.pred_then_atom_arg_num_should_match_18(delta, );











}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredThenAtomNode(tm0, tm1, tm2, ) in self.pred_then_atom_node.iter_new() {

self.pred_then_atom_arg_num_should_match_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pred_then_atom_arg_num_should_match_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(_, tm3, ) in self.term_list_len.iter_all_0(tm2, ) {

self.pred_then_atom_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_new() {

#[allow(unused_variables)]
for PredThenAtomNode(tm0, tm1, _, ) in self.pred_then_atom_node.iter_old_2(tm2, ) {

self.pred_then_atom_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat) {
for _ in [()] {
self.pred_then_atom_arg_num_should_match_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_7(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm6, ) in self.rule_descendant_then_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_all_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_all_0(tm5, ) {

self.pred_then_atom_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm6, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, _, ) in self.pred_then_atom_node.iter_old_0_2(tm0, tm2, ) {

self.pred_then_atom_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm6, tm5, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, _, ) in self.pred_then_atom_node.iter_old_0_2(tm0, tm2, ) {

self.pred_then_atom_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm5, tm4, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, _, ) in self.pred_then_atom_node.iter_old_0_2(tm0, tm2, ) {

self.pred_then_atom_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_11(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
self.pred_then_atom_arg_num_should_match_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_12(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(_, _, tm9, ) in self.semantic_pred.iter_all_0_1(tm4, tm1, ) {

#[allow(unused_variables)]
for PredArity(_, tm8, ) in self.pred_arity.iter_all_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_all_0(tm8, ) {

self.pred_then_atom_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm4, tm1, tm9, ) in self.semantic_pred.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm5, _, ) in self.scope_symbols.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for PredArity(_, tm8, ) in self.pred_arity.iter_old_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, _, tm2, ) in self.pred_then_atom_node.iter_old_0_1(tm0, tm1, ) {

#[allow(unused_variables)]
for TermListLen(_, tm3, ) in self.term_list_len.iter_old_0(tm2, ) {

self.pred_then_atom_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredArity(tm9, tm8, ) in self.pred_arity.iter_new() {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for SemanticPred(tm4, tm1, _, ) in self.semantic_pred.iter_all_2(tm9, ) {

#[allow(unused_variables)]
for PredThenAtomNode(tm0, _, _, ) in self.pred_then_atom_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm6, ) in self.rule_descendant_then_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm5, tm4, ) {

self.pred_then_atom_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm8, tm7, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for PredArity(tm9, _, ) in self.pred_arity.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for SemanticPred(tm4, tm1, _, ) in self.semantic_pred.iter_all_2(tm9, ) {

#[allow(unused_variables)]
for PredThenAtomNode(tm0, _, _, ) in self.pred_then_atom_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm6, ) in self.rule_descendant_then_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm5, tm4, ) {

self.pred_then_atom_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_16(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Pred) {
for _ in [()] {
self.pred_then_atom_arg_num_should_match_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_17(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Pred) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomNodeLoc(_, tm10, ) in self.then_atom_node_loc.iter_all_0(tm0, ) {

self.pred_then_atom_arg_num_should_match_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_18(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomNodeLoc(tm0, tm10, ) in self.then_atom_node_loc.iter_new() {

#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm6, ) in self.rule_descendant_then_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, _, ) in self.pred_then_atom_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for SemanticPred(_, _, tm9, ) in self.semantic_pred.iter_old_0_1(tm4, tm1, ) {

#[allow(unused_variables)]
for PredArity(_, tm8, ) in self.pred_arity.iter_old_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

self.pred_then_atom_arg_num_should_match_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_arg_num_should_match_19(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Pred, tm10: Loc) {
for _ in [()] {
let exists_already = self.pred_arg_num_should_match.iter_all_0_1_2(tm3, tm7, tm10).next().is_some();
if !exists_already {
delta.new_pred_arg_num_should_match.push(PredArgNumShouldMatch(tm3, tm7, tm10));
}



}
}


#[allow(unused_variables)]
fn app_term_arg_num_should_match_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.app_term_arg_num_should_match_1(delta, );
self.app_term_arg_num_should_match_2(delta, );
self.app_term_arg_num_should_match_5(delta, );
self.app_term_arg_num_should_match_8(delta, );
self.app_term_arg_num_should_match_9(delta, );
self.app_term_arg_num_should_match_10(delta, );
self.app_term_arg_num_should_match_13(delta, );
self.app_term_arg_num_should_match_14(delta, );
self.app_term_arg_num_should_match_15(delta, );
self.app_term_arg_num_should_match_18(delta, );











}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm0, tm1, tm2, ) in self.app_term_node.iter_new() {

self.app_term_arg_num_should_match_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.app_term_arg_num_should_match_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(_, tm3, ) in self.term_list_len.iter_all_0(tm2, ) {

self.app_term_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_new() {

#[allow(unused_variables)]
for AppTermNode(tm0, tm1, _, ) in self.app_term_node.iter_old_2(tm2, ) {

self.app_term_arg_num_should_match_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Nat) {
for _ in [()] {
self.app_term_arg_num_should_match_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Nat) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm6, ) in self.rule_descendant_term.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_all_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_all_0(tm5, ) {

self.app_term_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm6, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

self.app_term_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm6, tm5, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

self.app_term_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm5, tm4, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

self.app_term_arg_num_should_match_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_11(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
self.app_term_arg_num_should_match_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_12(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(_, _, tm9, ) in self.semantic_func.iter_all_0_1(tm4, tm1, ) {

#[allow(unused_variables)]
for Domain(_, tm8, ) in self.domain.iter_all_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_all_0(tm8, ) {

self.app_term_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm4, tm1, tm9, ) in self.semantic_func.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm5, _, ) in self.scope_symbols.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for Domain(_, tm8, ) in self.domain.iter_old_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for AppTermNode(_, _, tm2, ) in self.app_term_node.iter_old_0_1(tm0, tm1, ) {

#[allow(unused_variables)]
for TermListLen(_, tm3, ) in self.term_list_len.iter_old_0(tm2, ) {

self.app_term_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Domain(tm9, tm8, ) in self.domain.iter_new() {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for SemanticFunc(tm4, tm1, _, ) in self.semantic_func.iter_all_2(tm9, ) {

#[allow(unused_variables)]
for AppTermNode(tm0, _, _, ) in self.app_term_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm6, ) in self.rule_descendant_term.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm5, tm4, ) {

self.app_term_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeListLen(tm8, tm7, ) in self.type_list_len.iter_new() {

#[allow(unused_variables)]
for Domain(tm9, _, ) in self.domain.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for SemanticFunc(tm4, tm1, _, ) in self.semantic_func.iter_all_2(tm9, ) {

#[allow(unused_variables)]
for AppTermNode(tm0, _, _, ) in self.app_term_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm6, ) in self.rule_descendant_term.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm5, tm4, ) {

self.app_term_arg_num_should_match_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_16(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Func) {
for _ in [()] {
self.app_term_arg_num_should_match_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_17(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Func) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(_, tm10, ) in self.term_node_loc.iter_all_0(tm0, ) {

self.app_term_arg_num_should_match_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_18(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm0, tm10, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm6, ) in self.rule_descendant_term.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for TermListLen(tm2, tm3, ) in self.term_list_len.iter_old() {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for SemanticFunc(_, _, tm9, ) in self.semantic_func.iter_old_0_1(tm4, tm1, ) {

#[allow(unused_variables)]
for Domain(_, tm8, ) in self.domain.iter_old_0(tm9, ) {

#[allow(unused_variables)]
for TypeListLen(_, tm7, ) in self.type_list_len.iter_old_0(tm8, ) {

self.app_term_arg_num_should_match_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_arg_num_should_match_19(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Nat, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Nat, tm8: TypeList, tm9: Func, tm10: Loc) {
for _ in [()] {
let exists_already = self.func_arg_num_should_match.iter_all_0_1_2(tm3, tm7, tm10).next().is_some();
if !exists_already {
delta.new_func_arg_num_should_match.push(FuncArgNumShouldMatch(tm3, tm7, tm10));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_stmts_stmt_cons_1(delta, );
self.cfg_edge_stmts_stmt_cons_2(delta, );
self.cfg_edge_stmts_stmt_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdgeStmtsStmt(tm0, tm1, ) in self.cfg_edge_stmts_stmt.iter_new() {

self.cfg_edge_stmts_stmt_cons_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_cons_3(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode) {
for _ in [()] {
self.cfg_edge_stmts_stmt_cons_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_cons_4(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(_, tm2, tm3, ) in self.cons_stmt_list_node.iter_all_0(tm0, ) {

self.cfg_edge_stmts_stmt_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm0, tm2, tm3, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for CfgEdgeStmtsStmt(_, tm1, ) in self.cfg_edge_stmts_stmt.iter_old_0(tm0, ) {

self.cfg_edge_stmts_stmt_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_cons_6(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtNode, tm3: StmtListNode) {
for _ in [()] {
let exists_already = self.cfg_edge_stmts_stmt.iter_all_0_1(tm3, tm1).next().is_some();
if !exists_already {
delta.new_cfg_edge_stmts_stmt.push(CfgEdgeStmtsStmt(tm3, tm1));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_stmts_stmt_singleton_1(delta, );
self.cfg_edge_stmts_stmt_singleton_2(delta, );
self.cfg_edge_stmts_stmt_singleton_5(delta, );
self.cfg_edge_stmts_stmt_singleton_8(delta, );





}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdgeStmtsStmt(tm0, tm1, ) in self.cfg_edge_stmts_stmt.iter_new() {

self.cfg_edge_stmts_stmt_singleton_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_3(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode) {
for _ in [()] {
self.cfg_edge_stmts_stmt_singleton_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_4(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(_, tm2, tm3, ) in self.cons_stmt_list_node.iter_all_0(tm0, ) {

self.cfg_edge_stmts_stmt_singleton_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm0, tm2, tm3, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for CfgEdgeStmtsStmt(_, tm1, ) in self.cfg_edge_stmts_stmt.iter_old_0(tm0, ) {

self.cfg_edge_stmts_stmt_singleton_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_6(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtNode, tm3: StmtListNode) {
for _ in [()] {
self.cfg_edge_stmts_stmt_singleton_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_7(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtNode, tm3: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for NilStmtListNode(_, ) in self.nil_stmt_list_node.iter_all_0(tm3, ) {

self.cfg_edge_stmts_stmt_singleton_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilStmtListNode(tm3, ) in self.nil_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for CfgEdgeStmtsStmt(tm0, tm1, ) in self.cfg_edge_stmts_stmt.iter_old() {

#[allow(unused_variables)]
for ConsStmtListNode(_, tm2, _, ) in self.cons_stmt_list_node.iter_old_0_2(tm0, tm3, ) {

self.cfg_edge_stmts_stmt_singleton_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmts_stmt_singleton_9(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtNode, tm3: StmtListNode) {
for _ in [()] {
let exists_already = self.cfg_edge.iter_all_0_1(tm2, tm1).next().is_some();
if !exists_already {
delta.new_cfg_edge.push(CfgEdge(tm2, tm1));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_stmt_stmts_cons_1(delta, );
self.cfg_edge_stmt_stmts_cons_2(delta, );
self.cfg_edge_stmt_stmts_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdgeStmtStmts(tm0, tm1, ) in self.cfg_edge_stmt_stmts.iter_new() {

self.cfg_edge_stmt_stmts_cons_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_cons_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
for _ in [()] {
self.cfg_edge_stmt_stmts_cons_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_cons_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(_, tm2, tm3, ) in self.cons_stmt_list_node.iter_all_0(tm1, ) {

self.cfg_edge_stmt_stmts_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm1, tm2, tm3, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for CfgEdgeStmtStmts(tm0, _, ) in self.cfg_edge_stmt_stmts.iter_old_1(tm1, ) {

self.cfg_edge_stmt_stmts_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_cons_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode, tm2: StmtNode, tm3: StmtListNode) {
for _ in [()] {
let exists_already = self.cfg_edge.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_cfg_edge.push(CfgEdge(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_stmt_stmts_nil_1(delta, );
self.cfg_edge_stmt_stmts_nil_2(delta, );
self.cfg_edge_stmt_stmts_nil_5(delta, );
self.cfg_edge_stmt_stmts_nil_8(delta, );





}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdgeStmtStmts(tm0, tm1, ) in self.cfg_edge_stmt_stmts.iter_new() {

self.cfg_edge_stmt_stmts_nil_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
for _ in [()] {
self.cfg_edge_stmt_stmts_nil_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for NilStmtListNode(_, ) in self.nil_stmt_list_node.iter_all_0(tm1, ) {

self.cfg_edge_stmt_stmts_nil_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilStmtListNode(tm1, ) in self.nil_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for CfgEdgeStmtStmts(tm0, _, ) in self.cfg_edge_stmt_stmts.iter_old_1(tm1, ) {

self.cfg_edge_stmt_stmts_nil_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
for _ in [()] {
self.cfg_edge_stmt_stmts_nil_7(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdgeStmtsStmt(_, tm2, ) in self.cfg_edge_stmts_stmt.iter_all_0(tm1, ) {

self.cfg_edge_stmt_stmts_nil_9(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdgeStmtsStmt(tm1, tm2, ) in self.cfg_edge_stmts_stmt.iter_new() {

#[allow(unused_variables)]
for NilStmtListNode(_, ) in self.nil_stmt_list_node.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for CfgEdgeStmtStmts(tm0, _, ) in self.cfg_edge_stmt_stmts.iter_old_1(tm1, ) {

self.cfg_edge_stmt_stmts_nil_9(delta, tm0, tm1, tm2);


}

}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_stmts_nil_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtListNode, tm2: StmtNode) {
for _ in [()] {
let exists_already = self.cfg_edge.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_cfg_edge.push(CfgEdge(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_fork_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_fork_cons_1(delta, );
self.cfg_edge_fork_cons_2(delta, );
self.cfg_edge_fork_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn cfg_edge_fork_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_fork_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdgeFork(tm0, tm1, ) in self.cfg_edge_fork.iter_new() {

self.cfg_edge_fork_cons_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_fork_cons_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
self.cfg_edge_fork_cons_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_fork_cons_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtBlockListNode(_, tm2, tm3, ) in self.cons_stmt_block_list_node.iter_all_0(tm1, ) {

self.cfg_edge_fork_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_fork_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtBlockListNode(tm1, tm2, tm3, ) in self.cons_stmt_block_list_node.iter_new() {

#[allow(unused_variables)]
for CfgEdgeFork(tm0, _, ) in self.cfg_edge_fork.iter_old_1(tm1, ) {

self.cfg_edge_fork_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_fork_cons_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: StmtListNode, tm3: StmtBlockListNode) {
for _ in [()] {
let exists_already = self.cfg_edge_fork.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_cfg_edge_fork.push(CfgEdgeFork(tm0, tm3));
}

let exists_already = self.cfg_edge_stmt_stmts.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_cfg_edge_stmt_stmts.push(CfgEdgeStmtStmts(tm0, tm2));
}




}
}


#[allow(unused_variables)]
fn cfg_edge_join_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_join_cons_1(delta, );
self.cfg_edge_join_cons_2(delta, );
self.cfg_edge_join_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn cfg_edge_join_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_join_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdgeJoin(tm0, tm1, ) in self.cfg_edge_join.iter_new() {

self.cfg_edge_join_cons_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_join_cons_3(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtNode) {
for _ in [()] {
self.cfg_edge_join_cons_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_join_cons_4(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtBlockListNode(_, tm2, tm3, ) in self.cons_stmt_block_list_node.iter_all_0(tm0, ) {

self.cfg_edge_join_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_join_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtBlockListNode(tm0, tm2, tm3, ) in self.cons_stmt_block_list_node.iter_new() {

#[allow(unused_variables)]
for CfgEdgeJoin(_, tm1, ) in self.cfg_edge_join.iter_old_0(tm0, ) {

self.cfg_edge_join_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_join_cons_6(&self, delta: &mut ModelDelta, tm0: StmtBlockListNode, tm1: StmtNode, tm2: StmtListNode, tm3: StmtBlockListNode) {
for _ in [()] {
let exists_already = self.cfg_edge_join.iter_all_0_1(tm3, tm1).next().is_some();
if !exists_already {
delta.new_cfg_edge_join.push(CfgEdgeJoin(tm3, tm1));
}

let exists_already = self.cfg_edge_stmts_stmt.iter_all_0_1(tm2, tm1).next().is_some();
if !exists_already {
delta.new_cfg_edge_stmts_stmt.push(CfgEdgeStmtsStmt(tm2, tm1));
}




}
}


#[allow(unused_variables)]
fn cfg_edge_if_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_if_1(delta, );
self.cfg_edge_if_2(delta, );
self.cfg_edge_if_5(delta, );
self.cfg_edge_if_8(delta, );





}
}

#[allow(unused_variables)]
fn cfg_edge_if_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_if_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm0, tm1, tm2, ) in self.cons_stmt_list_node.iter_new() {

self.cfg_edge_if_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_if_3(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode) {
for _ in [()] {
self.cfg_edge_if_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cfg_edge_if_4(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for IfStmtNode(_, tm3, ) in self.if_stmt_node.iter_all_0(tm1, ) {

self.cfg_edge_if_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_if_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfStmtNode(tm1, tm3, ) in self.if_stmt_node.iter_new() {

#[allow(unused_variables)]
for ConsStmtListNode(tm0, _, tm2, ) in self.cons_stmt_list_node.iter_old_1(tm1, ) {

self.cfg_edge_if_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_if_6(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: IfAtomNode) {
for _ in [()] {
self.cfg_edge_if_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn cfg_edge_if_7(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: IfAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(_, tm4, tm5, ) in self.cons_stmt_list_node.iter_all_0(tm2, ) {

self.cfg_edge_if_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_if_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm2, tm4, tm5, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for ConsStmtListNode(tm0, tm1, _, ) in self.cons_stmt_list_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for IfStmtNode(_, tm3, ) in self.if_stmt_node.iter_old_0(tm1, ) {

self.cfg_edge_if_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_if_9(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: IfAtomNode, tm4: StmtNode, tm5: StmtListNode) {
for _ in [()] {
let exists_already = self.cfg_edge.iter_all_0_1(tm1, tm4).next().is_some();
if !exists_already {
delta.new_cfg_edge.push(CfgEdge(tm1, tm4));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_then_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_then_1(delta, );
self.cfg_edge_then_2(delta, );
self.cfg_edge_then_5(delta, );
self.cfg_edge_then_8(delta, );





}
}

#[allow(unused_variables)]
fn cfg_edge_then_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_then_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm0, tm1, tm2, ) in self.cons_stmt_list_node.iter_new() {

self.cfg_edge_then_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_then_3(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode) {
for _ in [()] {
self.cfg_edge_then_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cfg_edge_then_4(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ThenStmtNode(_, tm3, ) in self.then_stmt_node.iter_all_0(tm1, ) {

self.cfg_edge_then_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_then_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenStmtNode(tm1, tm3, ) in self.then_stmt_node.iter_new() {

#[allow(unused_variables)]
for ConsStmtListNode(tm0, _, tm2, ) in self.cons_stmt_list_node.iter_old_1(tm1, ) {

self.cfg_edge_then_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_then_6(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: ThenAtomNode) {
for _ in [()] {
self.cfg_edge_then_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn cfg_edge_then_7(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: ThenAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(_, tm4, tm5, ) in self.cons_stmt_list_node.iter_all_0(tm2, ) {

self.cfg_edge_then_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_then_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm2, tm4, tm5, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for ConsStmtListNode(tm0, tm1, _, ) in self.cons_stmt_list_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for ThenStmtNode(_, tm3, ) in self.then_stmt_node.iter_old_0(tm1, ) {

self.cfg_edge_then_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_then_9(&self, delta: &mut ModelDelta, tm0: StmtListNode, tm1: StmtNode, tm2: StmtListNode, tm3: ThenAtomNode, tm4: StmtNode, tm5: StmtListNode) {
for _ in [()] {
let exists_already = self.cfg_edge.iter_all_0_1(tm1, tm4).next().is_some();
if !exists_already {
delta.new_cfg_edge.push(CfgEdge(tm1, tm4));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_branch_fork_blocks_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_branch_fork_blocks_1(delta, );
self.cfg_edge_branch_fork_blocks_2(delta, );



}
}

#[allow(unused_variables)]
fn cfg_edge_branch_fork_blocks_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_branch_fork_blocks_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BranchStmtNode(tm0, tm1, ) in self.branch_stmt_node.iter_new() {

self.cfg_edge_branch_fork_blocks_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_branch_fork_blocks_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
let exists_already = self.cfg_edge_fork.iter_all_0_1(tm0, tm1).next().is_some();
if !exists_already {
delta.new_cfg_edge_fork.push(CfgEdgeFork(tm0, tm1));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_match_fork_blocks_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_match_fork_blocks_1(delta, );
self.cfg_edge_match_fork_blocks_2(delta, );
self.cfg_edge_match_fork_blocks_5(delta, );




}
}

#[allow(unused_variables)]
fn cfg_edge_match_fork_blocks_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_match_fork_blocks_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.cfg_edge_match_fork_blocks_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_fork_blocks_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.cfg_edge_match_fork_blocks_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cfg_edge_match_fork_blocks_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(_, tm3, ) in self.desugared_case_block_list.iter_all_0(tm2, ) {

self.cfg_edge_match_fork_blocks_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_fork_blocks_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(tm2, tm3, ) in self.desugared_case_block_list.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, _, ) in self.match_stmt_node.iter_old_2(tm2, ) {

self.cfg_edge_match_fork_blocks_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_fork_blocks_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: StmtBlockListNode) {
for _ in [()] {
let exists_already = self.cfg_edge_fork.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_cfg_edge_fork.push(CfgEdgeFork(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_branch_join_blocks_1(delta, );
self.cfg_edge_branch_join_blocks_2(delta, );
self.cfg_edge_branch_join_blocks_5(delta, );
self.cfg_edge_branch_join_blocks_8(delta, );





}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BranchStmtNode(tm0, tm1, ) in self.branch_stmt_node.iter_new() {

self.cfg_edge_branch_join_blocks_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
self.cfg_edge_branch_join_blocks_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm2, _, tm3, ) in self.cons_stmt_list_node.iter_all_1(tm0, ) {

self.cfg_edge_branch_join_blocks_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm2, tm0, tm3, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for BranchStmtNode(_, tm1, ) in self.branch_stmt_node.iter_old_0(tm0, ) {

self.cfg_edge_branch_join_blocks_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: StmtListNode, tm3: StmtListNode) {
for _ in [()] {
self.cfg_edge_branch_join_blocks_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: StmtListNode, tm3: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(_, tm4, tm5, ) in self.cons_stmt_list_node.iter_all_0(tm3, ) {

self.cfg_edge_branch_join_blocks_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm3, tm4, tm5, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for ConsStmtListNode(tm2, tm0, _, ) in self.cons_stmt_list_node.iter_old_2(tm3, ) {

#[allow(unused_variables)]
for BranchStmtNode(_, tm1, ) in self.branch_stmt_node.iter_old_0(tm0, ) {

self.cfg_edge_branch_join_blocks_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_branch_join_blocks_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: StmtListNode, tm3: StmtListNode, tm4: StmtNode, tm5: StmtListNode) {
for _ in [()] {
let exists_already = self.cfg_edge_join.iter_all_0_1(tm1, tm4).next().is_some();
if !exists_already {
delta.new_cfg_edge_join.push(CfgEdgeJoin(tm1, tm4));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_match_join_blocks_1(delta, );
self.cfg_edge_match_join_blocks_2(delta, );
self.cfg_edge_match_join_blocks_5(delta, );
self.cfg_edge_match_join_blocks_8(delta, );
self.cfg_edge_match_join_blocks_11(delta, );






}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.cfg_edge_match_join_blocks_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.cfg_edge_match_join_blocks_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm3, _, tm4, ) in self.cons_stmt_list_node.iter_all_1(tm0, ) {

self.cfg_edge_match_join_blocks_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm3, tm0, tm4, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(_, tm1, tm2, ) in self.match_stmt_node.iter_old_0(tm0, ) {

self.cfg_edge_match_join_blocks_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: StmtListNode, tm4: StmtListNode) {
for _ in [()] {
self.cfg_edge_match_join_blocks_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: StmtListNode, tm4: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(_, tm5, tm6, ) in self.cons_stmt_list_node.iter_all_0(tm4, ) {

self.cfg_edge_match_join_blocks_9(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm4, tm5, tm6, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for ConsStmtListNode(tm3, tm0, _, ) in self.cons_stmt_list_node.iter_old_2(tm4, ) {

#[allow(unused_variables)]
for MatchStmtNode(_, tm1, tm2, ) in self.match_stmt_node.iter_old_0(tm0, ) {

self.cfg_edge_match_join_blocks_9(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: StmtListNode, tm4: StmtListNode, tm5: StmtNode, tm6: StmtListNode) {
for _ in [()] {
self.cfg_edge_match_join_blocks_10(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_10(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: StmtListNode, tm4: StmtListNode, tm5: StmtNode, tm6: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(_, tm7, ) in self.desugared_case_block_list.iter_all_0(tm2, ) {

self.cfg_edge_match_join_blocks_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DesugaredCaseBlockList(tm2, tm7, ) in self.desugared_case_block_list.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, _, ) in self.match_stmt_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for ConsStmtListNode(tm3, _, tm4, ) in self.cons_stmt_list_node.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for ConsStmtListNode(_, tm5, tm6, ) in self.cons_stmt_list_node.iter_old_0(tm4, ) {

self.cfg_edge_match_join_blocks_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_match_join_blocks_12(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: StmtListNode, tm4: StmtListNode, tm5: StmtNode, tm6: StmtListNode, tm7: StmtBlockListNode) {
for _ in [()] {
let exists_already = self.cfg_edge_join.iter_all_0_1(tm7, tm5).next().is_some();
if !exists_already {
delta.new_cfg_edge_join.push(CfgEdgeJoin(tm7, tm5));
}



}
}


#[allow(unused_variables)]
fn before_rule_structure_total_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.before_rule_structure_total_1(delta, );
self.before_rule_structure_total_2(delta, );
self.before_rule_structure_total_5(delta, );




}
}

#[allow(unused_variables)]
fn before_rule_structure_total_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn before_rule_structure_total_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.rule_decl_node_new.iter().copied() {

self.before_rule_structure_total_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn before_rule_structure_total_3(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
for _ in [()] {
self.before_rule_structure_total_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn before_rule_structure_total_4(&self, delta: &mut ModelDelta, tm0: RuleDeclNode) {
for _ in [()] {
let tm1 = match self.before_rule_structure.iter_all_0(tm0).next() {
    Some(BeforeRuleStructure(_,  res)) => res,
    None => { 
        delta.new_before_rule_structure_def.push(BeforeRuleStructureArgs(tm0));
        break;
    },
};

self.before_rule_structure_total_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn before_rule_structure_total_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeRuleStructure(tm0, tm1, ) in self.before_rule_structure.iter_new() {

self.before_rule_structure_total_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn before_rule_structure_total_6(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: Structure) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_model_el_structure_module_scope_1(delta, );
self.ambient_model_el_structure_module_scope_2(delta, );
self.ambient_model_el_structure_module_scope_5(delta, );
self.ambient_model_el_structure_module_scope_6(delta, );
self.ambient_model_el_structure_module_scope_9(delta, );






}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeRule(tm0, tm1, ) in self.decl_node_rule.iter_new() {

self.ambient_model_el_structure_module_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode) {
for _ in [()] {
self.ambient_model_el_structure_module_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm2, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for ModuleSymbolScope(tm3, _, ) in self.module_symbol_scope.iter_all_1(tm2, ) {

self.ambient_model_el_structure_module_scope_7(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModuleSymbolScope(tm3, tm2, ) in self.module_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm0, ) {

self.ambient_model_el_structure_module_scope_7(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm2, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModuleSymbolScope(tm3, _, ) in self.module_symbol_scope.iter_all_1(tm2, ) {

self.ambient_model_el_structure_module_scope_7(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope, tm3: ModuleNode) {
for _ in [()] {
self.ambient_model_el_structure_module_scope_8(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_8(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope, tm3: ModuleNode) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeRuleStructure(_, tm4, ) in self.before_rule_structure.iter_all_0(tm1, ) {

self.ambient_model_el_structure_module_scope_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeRuleStructure(tm1, tm4, ) in self.before_rule_structure.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(tm0, _, ) in self.decl_node_rule.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm2, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModuleSymbolScope(tm3, _, ) in self.module_symbol_scope.iter_old_1(tm2, ) {

self.ambient_model_el_structure_module_scope_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_module_scope_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope, tm3: ModuleNode, tm4: Structure) {
for _ in [()] {
let exists_already = self.ambient_model_el_structure.iter_all_0_1(tm1, tm4).next().is_some();
if !exists_already {
delta.new_ambient_model_el_structure.push(AmbientModelElStructure(tm1, tm4));
}



}
}


#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_model_el_structure_model_scope_1(delta, );
self.ambient_model_el_structure_model_scope_2(delta, );
self.ambient_model_el_structure_model_scope_5(delta, );
self.ambient_model_el_structure_model_scope_8(delta, );
self.ambient_model_el_structure_model_scope_11(delta, );






}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeRule(tm0, tm1, ) in self.decl_node_rule.iter_new() {

self.ambient_model_el_structure_model_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode) {
for _ in [()] {
self.ambient_model_el_structure_model_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm2, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.ambient_model_el_structure_model_scope_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm2, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm0, ) {

self.ambient_model_el_structure_model_scope_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope) {
for _ in [()] {
self.ambient_model_el_structure_model_scope_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for ModelMemberSymbolScope(tm3, _, ) in self.model_member_symbol_scope.iter_all_1(tm2, ) {

self.ambient_model_el_structure_model_scope_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ModelMemberSymbolScope(tm3, tm2, ) in self.model_member_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm0, ) {

self.ambient_model_el_structure_model_scope_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope, tm3: Type) {
for _ in [()] {
self.ambient_model_el_structure_model_scope_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope, tm3: Type) {
for _ in [()] {
let tm4 = match self.ambient_model_el_morphism.iter_all_0(tm1).next() {
    Some(AmbientModelElMorphism(_,  res)) => res,
    None => { 
        delta.new_ambient_model_el_morphism_def.push(AmbientModelElMorphismArgs(tm1));
        break;
    },
};

self.ambient_model_el_structure_model_scope_12(delta, tm0, tm1, tm2, tm3, tm4);



}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElMorphism(tm1, tm4, ) in self.ambient_model_el_morphism.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(tm0, _, ) in self.decl_node_rule.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, tm2, ) in self.decl_symbol_scope.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ModelMemberSymbolScope(tm3, _, ) in self.model_member_symbol_scope.iter_old_1(tm2, ) {

self.ambient_model_el_structure_model_scope_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_model_scope_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: RuleDeclNode, tm2: SymbolScope, tm3: Type, tm4: Morphism) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_model_el_morphism_signature_1(delta, );
self.ambient_model_el_morphism_signature_2(delta, );
self.ambient_model_el_morphism_signature_5(delta, );
self.ambient_model_el_morphism_signature_8(delta, );





}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElMorphism(tm1, tm0, ) in self.ambient_model_el_morphism.iter_new() {

self.ambient_model_el_morphism_signature_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_3(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: RuleDeclNode) {
for _ in [()] {
self.ambient_model_el_morphism_signature_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_4(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: RuleDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeRuleStructure(_, tm2, ) in self.before_rule_structure.iter_all_0(tm1, ) {

self.ambient_model_el_morphism_signature_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeRuleStructure(tm1, tm2, ) in self.before_rule_structure.iter_new() {

#[allow(unused_variables)]
for AmbientModelElMorphism(_, tm0, ) in self.ambient_model_el_morphism.iter_old_0(tm1, ) {

self.ambient_model_el_morphism_signature_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_6(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: RuleDeclNode, tm2: Structure) {
for _ in [()] {
let exists_already = self.dom.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_dom.push(Dom(tm0, tm2));
}

self.ambient_model_el_morphism_signature_7(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_7(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: RuleDeclNode, tm2: Structure) {
for _ in [()] {
let tm3 = match self.ambient_model_el_structure.iter_all_0(tm1).next() {
    Some(AmbientModelElStructure(_,  res)) => res,
    None => { 
        delta.new_ambient_model_el_structure_def.push(AmbientModelElStructureArgs(tm1));
        break;
    },
};

self.ambient_model_el_morphism_signature_9(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElStructure(tm1, tm3, ) in self.ambient_model_el_structure.iter_new() {

#[allow(unused_variables)]
for AmbientModelElMorphism(_, tm0, ) in self.ambient_model_el_morphism.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for Dom(_, tm2, ) in self.dom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for BeforeRuleStructure(_, _, ) in self.before_rule_structure.iter_old_0_1(tm1, tm2, ) {

self.ambient_model_el_morphism_signature_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_signature_9(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: RuleDeclNode, tm2: Structure, tm3: Structure) {
for _ in [()] {
let exists_already = self.cod.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_cod.push(Cod(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn ambient_model_el_structure_els_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_model_el_structure_els_1(delta, );
self.ambient_model_el_structure_els_2(delta, );
self.ambient_model_el_structure_els_5(delta, );
self.ambient_model_el_structure_els_8(delta, );
self.ambient_model_el_structure_els_11(delta, );
self.ambient_model_el_structure_els_14(delta, );
self.ambient_model_el_structure_els_17(delta, );








}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElStructure(tm1, tm0, ) in self.ambient_model_el_structure.iter_new() {

self.ambient_model_el_structure_els_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_3(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode) {
for _ in [()] {
self.ambient_model_el_structure_els_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeRule(tm2, _, ) in self.decl_node_rule.iter_all_1(tm1, ) {

self.ambient_model_el_structure_els_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeRule(tm2, tm1, ) in self.decl_node_rule.iter_new() {

#[allow(unused_variables)]
for AmbientModelElStructure(_, tm0, ) in self.ambient_model_el_structure.iter_old_0(tm1, ) {

self.ambient_model_el_structure_els_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_6(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode) {
for _ in [()] {
self.ambient_model_el_structure_els_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_7(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm3, ) in self.decl_symbol_scope.iter_all_0(tm2, ) {

self.ambient_model_el_structure_els_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm2, tm3, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(_, tm0, ) in self.ambient_model_el_structure.iter_old_0(tm1, ) {

self.ambient_model_el_structure_els_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_9(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode, tm3: SymbolScope) {
for _ in [()] {
self.ambient_model_el_structure_els_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_10(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode, tm3: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeAncestor(_, tm4, ) in self.symbol_scope_ancestor.iter_all_0(tm3, ) {

self.ambient_model_el_structure_els_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeAncestor(tm3, tm4, ) in self.symbol_scope_ancestor.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm2, _, ) in self.decl_symbol_scope.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(_, tm0, ) in self.ambient_model_el_structure.iter_old_0(tm1, ) {

self.ambient_model_el_structure_els_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_12(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode, tm3: SymbolScope, tm4: SymbolScope) {
for _ in [()] {
self.ambient_model_el_structure_els_13(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_13(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode, tm3: SymbolScope, tm4: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(_, tm5, ) in self.symbol_scope_model.iter_all_0(tm4, ) {

self.ambient_model_el_structure_els_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(tm4, tm5, ) in self.symbol_scope_model.iter_new() {

#[allow(unused_variables)]
for SymbolScopeAncestor(tm3, _, ) in self.symbol_scope_ancestor.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for DeclSymbolScope(tm2, _, ) in self.decl_symbol_scope.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for DeclNodeRule(_, tm1, ) in self.decl_node_rule.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(_, tm0, ) in self.ambient_model_el_structure.iter_old_0(tm1, ) {

self.ambient_model_el_structure_els_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_15(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode, tm3: SymbolScope, tm4: SymbolScope, tm5: Type) {
for _ in [()] {
self.ambient_model_el_structure_els_16(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_16(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode, tm3: SymbolScope, tm4: SymbolScope, tm5: Type) {
for _ in [()] {
let tm6 = match self.ambient_model_el.iter_all_0_1(tm4, tm0).next() {
    Some(AmbientModelEl(_, _,  res)) => res,
    None => { 
        delta.new_ambient_model_el_def.push(AmbientModelElArgs(tm4, tm0));
        break;
    },
};

self.ambient_model_el_structure_els_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);



}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm4, tm0, tm6, ) in self.ambient_model_el.iter_new() {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for DeclNodeRule(tm2, _, ) in self.decl_node_rule.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for SymbolScopeAncestor(tm3, _, ) in self.symbol_scope_ancestor.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for DeclSymbolScope(_, _, ) in self.decl_symbol_scope.iter_old_0_1(tm2, tm3, ) {

#[allow(unused_variables)]
for SymbolScopeModel(_, tm5, ) in self.symbol_scope_model.iter_old_0(tm4, ) {

self.ambient_model_el_structure_els_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_structure_els_18(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: DeclNode, tm3: SymbolScope, tm4: SymbolScope, tm5: Type, tm6: El) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn ambient_model_el_parent_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_model_el_parent_law_1(delta, );
self.ambient_model_el_parent_law_2(delta, );
self.ambient_model_el_parent_law_5(delta, );
self.ambient_model_el_parent_law_8(delta, );
self.ambient_model_el_parent_law_9(delta, );
self.ambient_model_el_parent_law_12(delta, );
self.ambient_model_el_parent_law_15(delta, );
self.ambient_model_el_parent_law_18(delta, );
self.ambient_model_el_parent_law_21(delta, );
self.ambient_model_el_parent_law_24(delta, );
self.ambient_model_el_parent_law_27(delta, );












}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElStructure(tm1, tm0, ) in self.ambient_model_el_structure.iter_new() {

self.ambient_model_el_parent_law_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_3(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode) {
for _ in [()] {
self.ambient_model_el_parent_law_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm3, _, tm2, ) in self.ambient_model_el.iter_all_1(tm0, ) {

self.ambient_model_el_parent_law_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm3, tm0, tm2, ) in self.ambient_model_el.iter_new() {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

self.ambient_model_el_parent_law_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_6(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope) {
for _ in [()] {
self.ambient_model_el_parent_law_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_7(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeParent(_, tm5, ) in self.symbol_scope_parent.iter_all_0(tm3, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm4, ) in self.ambient_model_el.iter_all_0_1(tm5, tm0, ) {

self.ambient_model_el_parent_law_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeParent(tm3, tm5, ) in self.symbol_scope_parent.iter_new() {

#[allow(unused_variables)]
for AmbientModelEl(_, tm0, tm2, ) in self.ambient_model_el.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm4, ) in self.ambient_model_el.iter_old_0_1(tm5, tm0, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

self.ambient_model_el_parent_law_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm5, tm0, tm4, ) in self.ambient_model_el.iter_new() {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for SymbolScopeParent(tm3, _, ) in self.symbol_scope_parent.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm2, ) in self.ambient_model_el.iter_old_0_1(tm3, tm0, ) {

self.ambient_model_el_parent_law_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_10(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope) {
for _ in [()] {
self.ambient_model_el_parent_law_11(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_11(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(_, tm6, ) in self.symbol_scope_model.iter_all_0(tm3, ) {

self.ambient_model_el_parent_law_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(tm3, tm6, ) in self.symbol_scope_model.iter_new() {

#[allow(unused_variables)]
for SymbolScopeParent(_, tm5, ) in self.symbol_scope_parent.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, tm0, tm4, ) in self.ambient_model_el.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm2, ) in self.ambient_model_el.iter_old_0_1(tm3, tm0, ) {

self.ambient_model_el_parent_law_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_13(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type) {
for _ in [()] {
self.ambient_model_el_parent_law_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_14(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type) {
for _ in [()] {
#[allow(unused_variables)]
for ParentModelFunc(_, tm7, ) in self.parent_model_func.iter_all_0(tm6, ) {

self.ambient_model_el_parent_law_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ParentModelFunc(tm6, tm7, ) in self.parent_model_func.iter_new() {

#[allow(unused_variables)]
for SymbolScopeModel(tm3, _, ) in self.symbol_scope_model.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SymbolScopeParent(_, tm5, ) in self.symbol_scope_parent.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, tm0, tm4, ) in self.ambient_model_el.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm2, ) in self.ambient_model_el.iter_old_0_1(tm3, tm0, ) {

self.ambient_model_el_parent_law_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_16(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func) {
for _ in [()] {
self.ambient_model_el_parent_law_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_17(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(_, tm8, ) in self.func_rel.iter_all_0(tm7, ) {

self.ambient_model_el_parent_law_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_18(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm7, tm8, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for ParentModelFunc(tm6, _, ) in self.parent_model_func.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for SymbolScopeModel(tm3, _, ) in self.symbol_scope_model.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SymbolScopeParent(_, tm5, ) in self.symbol_scope_parent.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, tm0, tm4, ) in self.ambient_model_el.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm2, ) in self.ambient_model_el.iter_old_0_1(tm3, tm0, ) {

self.ambient_model_el_parent_law_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_19(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func, tm8: Rel) {
for _ in [()] {
self.ambient_model_el_parent_law_20(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_20(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func, tm8: Rel) {
for _ in [()] {
let tm9 = match self.nil_el_list.iter_all_0(tm0).next() {
    Some(NilElList(_,  res)) => res,
    None => { 
        delta.new_nil_el_list_def.push(NilElListArgs(tm0));
        break;
    },
};

self.ambient_model_el_parent_law_22(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);



}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_21(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm0, tm9, ) in self.nil_el_list.iter_new() {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for FuncRel(tm7, tm8, ) in self.func_rel.iter_old() {

#[allow(unused_variables)]
for ParentModelFunc(tm6, _, ) in self.parent_model_func.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for SymbolScopeModel(tm3, _, ) in self.symbol_scope_model.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for SymbolScopeParent(_, tm5, ) in self.symbol_scope_parent.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm2, ) in self.ambient_model_el.iter_old_0_1(tm3, tm0, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm4, ) in self.ambient_model_el.iter_old_0_1(tm5, tm0, ) {

self.ambient_model_el_parent_law_22(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_22(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func, tm8: Rel, tm9: ElList) {
for _ in [()] {
self.ambient_model_el_parent_law_23(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_23(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func, tm8: Rel, tm9: ElList) {
for _ in [()] {
let tm10 = match self.cons_el_list.iter_all_0_1(tm4, tm9).next() {
    Some(ConsElList(_, _,  res)) => res,
    None => { 
        delta.new_cons_el_list_def.push(ConsElListArgs(tm4, tm9));
        break;
    },
};

self.ambient_model_el_parent_law_25(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);



}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_24(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm4, tm9, tm10, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for NilElList(tm0, _, ) in self.nil_el_list.iter_old_1(tm9, ) {

#[allow(unused_variables)]
for AmbientModelEl(tm5, _, _, ) in self.ambient_model_el.iter_old_1_2(tm0, tm4, ) {

#[allow(unused_variables)]
for SymbolScopeParent(tm3, _, ) in self.symbol_scope_parent.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for SymbolScopeModel(_, tm6, ) in self.symbol_scope_model.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for ParentModelFunc(_, tm7, ) in self.parent_model_func.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, tm2, ) in self.ambient_model_el.iter_old_0_1(tm3, tm0, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for FuncRel(_, tm8, ) in self.func_rel.iter_old_0(tm7, ) {

self.ambient_model_el_parent_law_25(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_25(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func, tm8: Rel, tm9: ElList, tm10: ElList) {
for _ in [()] {
self.ambient_model_el_parent_law_26(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_26(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func, tm8: Rel, tm9: ElList, tm10: ElList) {
for _ in [()] {
let tm11 = match self.cons_el_list.iter_all_0_1(tm2, tm10).next() {
    Some(ConsElList(_, _,  res)) => res,
    None => { 
        delta.new_cons_el_list_def.push(ConsElListArgs(tm2, tm10));
        break;
    },
};

self.ambient_model_el_parent_law_28(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11);



}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_27(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm2, tm10, tm11, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for ConsElList(tm4, tm9, _, ) in self.cons_el_list.iter_old_2(tm10, ) {

#[allow(unused_variables)]
for NilElList(tm0, _, ) in self.nil_el_list.iter_old_1(tm9, ) {

#[allow(unused_variables)]
for AmbientModelEl(tm5, _, _, ) in self.ambient_model_el.iter_old_1_2(tm0, tm4, ) {

#[allow(unused_variables)]
for SymbolScopeParent(tm3, _, ) in self.symbol_scope_parent.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, _, _, ) in self.ambient_model_el.iter_old_0_1_2(tm3, tm0, tm2, ) {

#[allow(unused_variables)]
for AmbientModelElStructure(tm1, _, ) in self.ambient_model_el_structure.iter_old_1(tm0, ) {

#[allow(unused_variables)]
for SymbolScopeModel(_, tm6, ) in self.symbol_scope_model.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for ParentModelFunc(_, tm7, ) in self.parent_model_func.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for FuncRel(_, tm8, ) in self.func_rel.iter_old_0(tm7, ) {

self.ambient_model_el_parent_law_28(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11);


}

}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_parent_law_28(&self, delta: &mut ModelDelta, tm0: Structure, tm1: RuleDeclNode, tm2: El, tm3: SymbolScope, tm4: El, tm5: SymbolScope, tm6: Type, tm7: Func, tm8: Rel, tm9: ElList, tm10: ElList, tm11: ElList) {
for _ in [()] {
let exists_already = self.rel_app.iter_all_0_1(tm8, tm11).next().is_some();
if !exists_already {
delta.new_rel_app.push(RelApp(tm8, tm11));
}



}
}


#[allow(unused_variables)]
fn before_first_rule_stmt_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.before_first_rule_stmt_1(delta, );
self.before_first_rule_stmt_2(delta, );
self.before_first_rule_stmt_5(delta, );
self.before_first_rule_stmt_8(delta, );





}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDecl(tm0, tm1, ) in self.rule_decl.iter_new() {

self.before_first_rule_stmt_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_3(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode) {
for _ in [()] {
self.before_first_rule_stmt_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_4(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(_, tm2, tm3, ) in self.cons_stmt_list_node.iter_all_0(tm1, ) {

self.before_first_rule_stmt_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsStmtListNode(tm1, tm2, tm3, ) in self.cons_stmt_list_node.iter_new() {

#[allow(unused_variables)]
for RuleDecl(tm0, _, ) in self.rule_decl.iter_old_1(tm1, ) {

self.before_first_rule_stmt_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_6(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode, tm2: StmtNode, tm3: StmtListNode) {
for _ in [()] {
self.before_first_rule_stmt_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_7(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode, tm2: StmtNode, tm3: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElStructure(_, tm4, ) in self.ambient_model_el_structure.iter_all_0(tm0, ) {

self.before_first_rule_stmt_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElStructure(tm0, tm4, ) in self.ambient_model_el_structure.iter_new() {

#[allow(unused_variables)]
for RuleDecl(_, tm1, ) in self.rule_decl.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ConsStmtListNode(_, tm2, tm3, ) in self.cons_stmt_list_node.iter_old_0(tm1, ) {

self.before_first_rule_stmt_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn before_first_rule_stmt_9(&self, delta: &mut ModelDelta, tm0: RuleDeclNode, tm1: StmtListNode, tm2: StmtNode, tm3: StmtListNode, tm4: Structure) {
for _ in [()] {
let exists_already = self.before_stmt_structure.iter_all_0_1(tm2, tm4).next().is_some();
if !exists_already {
delta.new_before_stmt_structure.push(BeforeStmtStructure(tm2, tm4));
}



}
}


#[allow(unused_variables)]
fn cfg_edge_stmt_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cfg_edge_stmt_structure_1(delta, );
self.cfg_edge_stmt_structure_2(delta, );
self.cfg_edge_stmt_structure_5(delta, );
self.cfg_edge_stmt_structure_8(delta, );





}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CfgEdge(tm0, tm1, ) in self.cfg_edge.iter_new() {

self.cfg_edge_stmt_structure_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtNode) {
for _ in [()] {
self.cfg_edge_stmt_structure_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(_, tm2, ) in self.stmt_morphism.iter_all_0(tm0, ) {

self.cfg_edge_stmt_structure_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(tm0, tm2, ) in self.stmt_morphism.iter_new() {

#[allow(unused_variables)]
for CfgEdge(_, tm1, ) in self.cfg_edge.iter_old_0(tm0, ) {

self.cfg_edge_stmt_structure_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtNode, tm2: Morphism) {
for _ in [()] {
self.cfg_edge_stmt_structure_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtNode, tm2: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(_, tm3, ) in self.cod.iter_all_0(tm2, ) {

self.cfg_edge_stmt_structure_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm2, tm3, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for StmtMorphism(tm0, _, ) in self.stmt_morphism.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for CfgEdge(_, tm1, ) in self.cfg_edge.iter_old_0(tm0, ) {

self.cfg_edge_stmt_structure_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn cfg_edge_stmt_structure_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtNode, tm2: Morphism, tm3: Structure) {
for _ in [()] {
let exists_already = self.before_stmt_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_before_stmt_structure.push(BeforeStmtStructure(tm1, tm3));
}



}
}


#[allow(unused_variables)]
fn if_atom_morphism_dom_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.if_atom_morphism_dom_1(delta, );
self.if_atom_morphism_dom_2(delta, );
self.if_atom_morphism_dom_3(delta, );




}
}

#[allow(unused_variables)]
fn if_atom_morphism_dom_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn if_atom_morphism_dom_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Dom(tm1, tm0, ) in self.dom.iter_new() {

#[allow(unused_variables)]
for IfAtomMorphism(tm2, tm3, _, ) in self.if_atom_morphism.iter_old_2(tm1, ) {

self.if_atom_morphism_dom_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn if_atom_morphism_dom_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomMorphism(tm2, tm3, tm1, ) in self.if_atom_morphism.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_all_0(tm1, ) {

self.if_atom_morphism_dom_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn if_atom_morphism_dom_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: Morphism, tm2: IfAtomNode, tm3: Structure) {
for _ in [()] {
delta.new_structure_equalities.push((tm0, tm3));

delta.new_structure_equalities.push((tm3, tm0));




}
}


#[allow(unused_variables)]
fn then_atom_morphism_dom_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_atom_morphism_dom_1(delta, );
self.then_atom_morphism_dom_2(delta, );
self.then_atom_morphism_dom_3(delta, );




}
}

#[allow(unused_variables)]
fn then_atom_morphism_dom_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_atom_morphism_dom_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Dom(tm1, tm0, ) in self.dom.iter_new() {

#[allow(unused_variables)]
for ThenAtomMorphism(tm2, tm3, _, ) in self.then_atom_morphism.iter_old_2(tm1, ) {

self.then_atom_morphism_dom_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn then_atom_morphism_dom_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomMorphism(tm2, tm3, tm1, ) in self.then_atom_morphism.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_all_0(tm1, ) {

self.then_atom_morphism_dom_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn then_atom_morphism_dom_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: Morphism, tm2: ThenAtomNode, tm3: Structure) {
for _ in [()] {
delta.new_structure_equalities.push((tm0, tm3));

delta.new_structure_equalities.push((tm3, tm0));




}
}


#[allow(unused_variables)]
fn branch_stmt_morphism_dom_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.branch_stmt_morphism_dom_1(delta, );
self.branch_stmt_morphism_dom_2(delta, );
self.branch_stmt_morphism_dom_3(delta, );




}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_dom_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_dom_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Dom(tm1, tm0, ) in self.dom.iter_new() {

#[allow(unused_variables)]
for BranchStmtMorphism(tm2, tm3, _, ) in self.branch_stmt_morphism.iter_old_2(tm1, ) {

self.branch_stmt_morphism_dom_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_dom_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BranchStmtMorphism(tm2, tm3, tm1, ) in self.branch_stmt_morphism.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_all_0(tm1, ) {

self.branch_stmt_morphism_dom_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_dom_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: Morphism, tm2: StmtNode, tm3: Structure) {
for _ in [()] {
delta.new_structure_equalities.push((tm0, tm3));

delta.new_structure_equalities.push((tm3, tm0));




}
}


#[allow(unused_variables)]
fn match_stmt_morphism_dom_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_stmt_morphism_dom_1(delta, );
self.match_stmt_morphism_dom_2(delta, );
self.match_stmt_morphism_dom_3(delta, );




}
}

#[allow(unused_variables)]
fn match_stmt_morphism_dom_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_dom_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Dom(tm1, tm0, ) in self.dom.iter_new() {

#[allow(unused_variables)]
for MatchStmtMorphism(tm2, tm3, _, ) in self.match_stmt_morphism.iter_old_2(tm1, ) {

self.match_stmt_morphism_dom_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_dom_3(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtMorphism(tm2, tm3, tm1, ) in self.match_stmt_morphism.iter_new() {

#[allow(unused_variables)]
for Dom(_, tm0, ) in self.dom.iter_all_0(tm1, ) {

self.match_stmt_morphism_dom_4(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_dom_4(&self, delta: &mut ModelDelta, tm0: Structure, tm1: Morphism, tm2: StmtNode, tm3: Structure) {
for _ in [()] {
delta.new_structure_equalities.push((tm0, tm3));

delta.new_structure_equalities.push((tm3, tm0));




}
}


#[allow(unused_variables)]
fn if_stmt_morphism_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.if_stmt_morphism_defined_1(delta, );
self.if_stmt_morphism_defined_2(delta, );
self.if_stmt_morphism_defined_5(delta, );
self.if_stmt_morphism_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfStmtNode(tm0, tm1, ) in self.if_stmt_node.iter_new() {

self.if_stmt_morphism_defined_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
for _ in [()] {
self.if_stmt_morphism_defined_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeStmtStructure(_, tm2, ) in self.before_stmt_structure.iter_all_0(tm0, ) {

self.if_stmt_morphism_defined_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeStmtStructure(tm0, tm2, ) in self.before_stmt_structure.iter_new() {

#[allow(unused_variables)]
for IfStmtNode(_, tm1, ) in self.if_stmt_node.iter_old_0(tm0, ) {

self.if_stmt_morphism_defined_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode, tm2: Structure) {
for _ in [()] {
self.if_stmt_morphism_defined_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode, tm2: Structure) {
for _ in [()] {
let tm3 = match self.if_atom_morphism.iter_all_0_1(tm1, tm2).next() {
    Some(IfAtomMorphism(_, _,  res)) => res,
    None => { 
        delta.new_if_atom_morphism_def.push(IfAtomMorphismArgs(tm1, tm2));
        break;
    },
};

self.if_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomMorphism(tm1, tm2, tm3, ) in self.if_atom_morphism.iter_new() {

#[allow(unused_variables)]
for BeforeStmtStructure(tm0, _, ) in self.before_stmt_structure.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for IfStmtNode(_, _, ) in self.if_stmt_node.iter_old_0_1(tm0, tm1, ) {

self.if_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_defined_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode, tm2: Structure, tm3: Morphism) {
for _ in [()] {
let exists_already = self.stmt_morphism.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_stmt_morphism.push(StmtMorphism(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn then_stmt_morphism_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_stmt_morphism_defined_1(delta, );
self.then_stmt_morphism_defined_2(delta, );
self.then_stmt_morphism_defined_5(delta, );
self.then_stmt_morphism_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenStmtNode(tm0, tm1, ) in self.then_stmt_node.iter_new() {

self.then_stmt_morphism_defined_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
self.then_stmt_morphism_defined_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeStmtStructure(_, tm2, ) in self.before_stmt_structure.iter_all_0(tm0, ) {

self.then_stmt_morphism_defined_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeStmtStructure(tm0, tm2, ) in self.before_stmt_structure.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(_, tm1, ) in self.then_stmt_node.iter_old_0(tm0, ) {

self.then_stmt_morphism_defined_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: Structure) {
for _ in [()] {
self.then_stmt_morphism_defined_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: Structure) {
for _ in [()] {
let tm3 = match self.then_atom_morphism.iter_all_0_1(tm1, tm2).next() {
    Some(ThenAtomMorphism(_, _,  res)) => res,
    None => { 
        delta.new_then_atom_morphism_def.push(ThenAtomMorphismArgs(tm1, tm2));
        break;
    },
};

self.then_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomMorphism(tm1, tm2, tm3, ) in self.then_atom_morphism.iter_new() {

#[allow(unused_variables)]
for BeforeStmtStructure(tm0, _, ) in self.before_stmt_structure.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for ThenStmtNode(_, _, ) in self.then_stmt_node.iter_old_0_1(tm0, tm1, ) {

self.then_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn then_stmt_morphism_defined_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: Structure, tm3: Morphism) {
for _ in [()] {
let exists_already = self.stmt_morphism.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_stmt_morphism.push(StmtMorphism(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn branch_stmt_morphism_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.branch_stmt_morphism_defined_1(delta, );
self.branch_stmt_morphism_defined_2(delta, );
self.branch_stmt_morphism_defined_5(delta, );
self.branch_stmt_morphism_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BranchStmtNode(tm0, tm1, ) in self.branch_stmt_node.iter_new() {

self.branch_stmt_morphism_defined_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
self.branch_stmt_morphism_defined_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeStmtStructure(_, tm2, ) in self.before_stmt_structure.iter_all_0(tm0, ) {

self.branch_stmt_morphism_defined_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeStmtStructure(tm0, tm2, ) in self.before_stmt_structure.iter_new() {

#[allow(unused_variables)]
for BranchStmtNode(_, tm1, ) in self.branch_stmt_node.iter_old_0(tm0, ) {

self.branch_stmt_morphism_defined_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: Structure) {
for _ in [()] {
self.branch_stmt_morphism_defined_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: Structure) {
for _ in [()] {
let tm3 = match self.branch_stmt_morphism.iter_all_0_1(tm0, tm2).next() {
    Some(BranchStmtMorphism(_, _,  res)) => res,
    None => { 
        delta.new_branch_stmt_morphism_def.push(BranchStmtMorphismArgs(tm0, tm2));
        break;
    },
};

self.branch_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);



}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BranchStmtMorphism(tm0, tm2, tm3, ) in self.branch_stmt_morphism.iter_new() {

#[allow(unused_variables)]
for BeforeStmtStructure(_, _, ) in self.before_stmt_structure.iter_old_0_1(tm0, tm2, ) {

#[allow(unused_variables)]
for BranchStmtNode(_, tm1, ) in self.branch_stmt_node.iter_old_0(tm0, ) {

self.branch_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_defined_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: Structure, tm3: Morphism) {
for _ in [()] {
let exists_already = self.stmt_morphism.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_stmt_morphism.push(StmtMorphism(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn match_stmt_morphism_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_stmt_morphism_defined_1(delta, );
self.match_stmt_morphism_defined_2(delta, );
self.match_stmt_morphism_defined_5(delta, );
self.match_stmt_morphism_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.match_stmt_morphism_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.match_stmt_morphism_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeStmtStructure(_, tm3, ) in self.before_stmt_structure.iter_all_0(tm0, ) {

self.match_stmt_morphism_defined_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BeforeStmtStructure(tm0, tm3, ) in self.before_stmt_structure.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(_, tm1, tm2, ) in self.match_stmt_node.iter_old_0(tm0, ) {

self.match_stmt_morphism_defined_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: Structure) {
for _ in [()] {
self.match_stmt_morphism_defined_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: Structure) {
for _ in [()] {
let tm4 = match self.match_stmt_morphism.iter_all_0_1(tm0, tm3).next() {
    Some(MatchStmtMorphism(_, _,  res)) => res,
    None => { 
        delta.new_match_stmt_morphism_def.push(MatchStmtMorphismArgs(tm0, tm3));
        break;
    },
};

self.match_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3, tm4);



}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtMorphism(tm0, tm3, tm4, ) in self.match_stmt_morphism.iter_new() {

#[allow(unused_variables)]
for BeforeStmtStructure(_, _, ) in self.before_stmt_structure.iter_old_0_1(tm0, tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(_, tm1, tm2, ) in self.match_stmt_node.iter_old_0(tm0, ) {

self.match_stmt_morphism_defined_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_defined_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: Structure, tm4: Morphism) {
for _ in [()] {
let exists_already = self.stmt_morphism.iter_all_0_1(tm0, tm4).next().is_some();
if !exists_already {
delta.new_stmt_morphism.push(StmtMorphism(tm0, tm4));
}



}
}


#[allow(unused_variables)]
fn ambient_model_el_morphism_is_if_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_model_el_morphism_is_if_1(delta, );
self.ambient_model_el_morphism_is_if_2(delta, );



}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_is_if_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_is_if_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelElMorphism(tm1, tm0, ) in self.ambient_model_el_morphism.iter_new() {

self.ambient_model_el_morphism_is_if_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_morphism_is_if_3(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: RuleDeclNode) {
for _ in [()] {
let exists_already = self.if_morphism.iter_all_0(tm0).next().is_some();
if !exists_already {
delta.new_if_morphism.push(IfMorphism(tm0));
}



}
}


#[allow(unused_variables)]
fn if_stmt_morphism_is_if_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.if_stmt_morphism_is_if_1(delta, );
self.if_stmt_morphism_is_if_2(delta, );
self.if_stmt_morphism_is_if_5(delta, );




}
}

#[allow(unused_variables)]
fn if_stmt_morphism_is_if_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_is_if_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfStmtNode(tm0, tm1, ) in self.if_stmt_node.iter_new() {

self.if_stmt_morphism_is_if_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_is_if_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
for _ in [()] {
self.if_stmt_morphism_is_if_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn if_stmt_morphism_is_if_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(_, tm2, ) in self.stmt_morphism.iter_all_0(tm0, ) {

self.if_stmt_morphism_is_if_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_is_if_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(tm0, tm2, ) in self.stmt_morphism.iter_new() {

#[allow(unused_variables)]
for IfStmtNode(_, tm1, ) in self.if_stmt_node.iter_old_0(tm0, ) {

self.if_stmt_morphism_is_if_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn if_stmt_morphism_is_if_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode, tm2: Morphism) {
for _ in [()] {
let exists_already = self.if_morphism.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_if_morphism.push(IfMorphism(tm2));
}



}
}


#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_equal_stmt_morphism_is_surj_1(delta, );
self.then_equal_stmt_morphism_is_surj_2(delta, );
self.then_equal_stmt_morphism_is_surj_5(delta, );
self.then_equal_stmt_morphism_is_surj_8(delta, );





}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenStmtNode(tm0, tm1, ) in self.then_stmt_node.iter_new() {

self.then_equal_stmt_morphism_is_surj_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
self.then_equal_stmt_morphism_is_surj_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for EqualThenAtomNode(_, tm2, tm3, ) in self.equal_then_atom_node.iter_all_0(tm1, ) {

self.then_equal_stmt_morphism_is_surj_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EqualThenAtomNode(tm1, tm2, tm3, ) in self.equal_then_atom_node.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(tm0, _, ) in self.then_stmt_node.iter_old_1(tm1, ) {

self.then_equal_stmt_morphism_is_surj_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: TermNode, tm3: TermNode) {
for _ in [()] {
self.then_equal_stmt_morphism_is_surj_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: TermNode, tm3: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(_, tm4, ) in self.stmt_morphism.iter_all_0(tm0, ) {

self.then_equal_stmt_morphism_is_surj_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(tm0, tm4, ) in self.stmt_morphism.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(_, tm1, ) in self.then_stmt_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EqualThenAtomNode(_, tm2, tm3, ) in self.equal_then_atom_node.iter_old_0(tm1, ) {

self.then_equal_stmt_morphism_is_surj_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn then_equal_stmt_morphism_is_surj_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: TermNode, tm3: TermNode, tm4: Morphism) {
for _ in [()] {
let exists_already = self.surj_then_morphism.iter_all_0(tm4).next().is_some();
if !exists_already {
delta.new_surj_then_morphism.push(SurjThenMorphism(tm4));
}



}
}


#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_pred_stmt_morphism_is_surj_1(delta, );
self.then_pred_stmt_morphism_is_surj_2(delta, );
self.then_pred_stmt_morphism_is_surj_5(delta, );
self.then_pred_stmt_morphism_is_surj_8(delta, );





}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenStmtNode(tm0, tm1, ) in self.then_stmt_node.iter_new() {

self.then_pred_stmt_morphism_is_surj_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
self.then_pred_stmt_morphism_is_surj_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for PredThenAtomNode(_, tm2, tm3, ) in self.pred_then_atom_node.iter_all_0(tm1, ) {

self.then_pred_stmt_morphism_is_surj_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredThenAtomNode(tm1, tm2, tm3, ) in self.pred_then_atom_node.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(tm0, _, ) in self.then_stmt_node.iter_old_1(tm1, ) {

self.then_pred_stmt_morphism_is_surj_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: Ident, tm3: TermListNode) {
for _ in [()] {
self.then_pred_stmt_morphism_is_surj_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: Ident, tm3: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(_, tm4, ) in self.stmt_morphism.iter_all_0(tm0, ) {

self.then_pred_stmt_morphism_is_surj_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(tm0, tm4, ) in self.stmt_morphism.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(_, tm1, ) in self.then_stmt_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm2, tm3, ) in self.pred_then_atom_node.iter_old_0(tm1, ) {

self.then_pred_stmt_morphism_is_surj_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn then_pred_stmt_morphism_is_surj_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: Ident, tm3: TermListNode, tm4: Morphism) {
for _ in [()] {
let exists_already = self.surj_then_morphism.iter_all_0(tm4).next().is_some();
if !exists_already {
delta.new_surj_then_morphism.push(SurjThenMorphism(tm4));
}



}
}


#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_defined_stmt_morphism_is_non_surj_1(delta, );
self.then_defined_stmt_morphism_is_non_surj_2(delta, );
self.then_defined_stmt_morphism_is_non_surj_5(delta, );
self.then_defined_stmt_morphism_is_non_surj_8(delta, );





}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenStmtNode(tm0, tm1, ) in self.then_stmt_node.iter_new() {

self.then_defined_stmt_morphism_is_non_surj_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
self.then_defined_stmt_morphism_is_non_surj_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm2, tm3, ) in self.defined_then_atom_node.iter_all_0(tm1, ) {

self.then_defined_stmt_morphism_is_non_surj_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedThenAtomNode(tm1, tm2, tm3, ) in self.defined_then_atom_node.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(tm0, _, ) in self.then_stmt_node.iter_old_1(tm1, ) {

self.then_defined_stmt_morphism_is_non_surj_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: OptTermNode, tm3: TermNode) {
for _ in [()] {
self.then_defined_stmt_morphism_is_non_surj_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: OptTermNode, tm3: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(_, tm4, ) in self.stmt_morphism.iter_all_0(tm0, ) {

self.then_defined_stmt_morphism_is_non_surj_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(tm0, tm4, ) in self.stmt_morphism.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(_, tm1, ) in self.then_stmt_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm2, tm3, ) in self.defined_then_atom_node.iter_old_0(tm1, ) {

self.then_defined_stmt_morphism_is_non_surj_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn then_defined_stmt_morphism_is_non_surj_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: OptTermNode, tm3: TermNode, tm4: Morphism) {
for _ in [()] {
let exists_already = self.non_surj_then_morphism.iter_all_0(tm4).next().is_some();
if !exists_already {
delta.new_non_surj_then_morphism.push(NonSurjThenMorphism(tm4));
}



}
}


#[allow(unused_variables)]
fn branch_stmt_morphism_is_noop_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.branch_stmt_morphism_is_noop_1(delta, );
self.branch_stmt_morphism_is_noop_2(delta, );
self.branch_stmt_morphism_is_noop_5(delta, );




}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_is_noop_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_is_noop_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for BranchStmtNode(tm0, tm1, ) in self.branch_stmt_node.iter_new() {

self.branch_stmt_morphism_is_noop_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_is_noop_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
self.branch_stmt_morphism_is_noop_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_is_noop_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(_, tm2, ) in self.stmt_morphism.iter_all_0(tm0, ) {

self.branch_stmt_morphism_is_noop_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_is_noop_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(tm0, tm2, ) in self.stmt_morphism.iter_new() {

#[allow(unused_variables)]
for BranchStmtNode(_, tm1, ) in self.branch_stmt_node.iter_old_0(tm0, ) {

self.branch_stmt_morphism_is_noop_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn branch_stmt_morphism_is_noop_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: StmtBlockListNode, tm2: Morphism) {
for _ in [()] {
let exists_already = self.noop_morphism.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_noop_morphism.push(NoopMorphism(tm2));
}



}
}


#[allow(unused_variables)]
fn match_stmt_morphism_is_if_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_stmt_morphism_is_if_1(delta, );
self.match_stmt_morphism_is_if_2(delta, );
self.match_stmt_morphism_is_if_5(delta, );




}
}

#[allow(unused_variables)]
fn match_stmt_morphism_is_if_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_is_if_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.match_stmt_morphism_is_if_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_is_if_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.match_stmt_morphism_is_if_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn match_stmt_morphism_is_if_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(_, tm3, ) in self.stmt_morphism.iter_all_0(tm0, ) {

self.match_stmt_morphism_is_if_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_is_if_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(tm0, tm3, ) in self.stmt_morphism.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(_, tm1, tm2, ) in self.match_stmt_node.iter_old_0(tm0, ) {

self.match_stmt_morphism_is_if_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn match_stmt_morphism_is_if_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: Morphism) {
for _ in [()] {
let exists_already = self.if_morphism.iter_all_0(tm3).next().is_some();
if !exists_already {
delta.new_if_morphism.push(IfMorphism(tm3));
}



}
}


#[allow(unused_variables)]
fn stmt_structure_morphism_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.stmt_structure_morphism_1(delta, );
self.stmt_structure_morphism_2(delta, );
self.stmt_structure_morphism_5(delta, );




}
}

#[allow(unused_variables)]
fn stmt_structure_morphism_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn stmt_structure_morphism_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtMorphism(tm0, tm1, ) in self.stmt_morphism.iter_new() {

self.stmt_structure_morphism_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn stmt_structure_morphism_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: Morphism) {
for _ in [()] {
self.stmt_structure_morphism_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn stmt_structure_morphism_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(_, tm2, ) in self.cod.iter_all_0(tm1, ) {

self.stmt_structure_morphism_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn stmt_structure_morphism_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm1, tm2, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for StmtMorphism(tm0, _, ) in self.stmt_morphism.iter_old_1(tm1, ) {

self.stmt_structure_morphism_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn stmt_structure_morphism_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: Morphism, tm2: Structure) {
for _ in [()] {
let exists_already = self.stmt_structure.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_stmt_structure.push(StmtStructure(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn if_stmt_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.if_stmt_structure_1(delta, );
self.if_stmt_structure_2(delta, );
self.if_stmt_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn if_stmt_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn if_stmt_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfStmtNode(tm0, tm1, ) in self.if_stmt_node.iter_new() {

self.if_stmt_structure_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn if_stmt_structure_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
for _ in [()] {
self.if_stmt_structure_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn if_stmt_structure_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtStructure(_, tm2, ) in self.stmt_structure.iter_all_0(tm0, ) {

self.if_stmt_structure_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn if_stmt_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtStructure(tm0, tm2, ) in self.stmt_structure.iter_new() {

#[allow(unused_variables)]
for IfStmtNode(_, tm1, ) in self.if_stmt_node.iter_old_0(tm0, ) {

self.if_stmt_structure_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn if_stmt_structure_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: IfAtomNode, tm2: Structure) {
for _ in [()] {
let exists_already = self.if_atom_structure.iter_all_0_1(tm1, tm2).next().is_some();
if !exists_already {
delta.new_if_atom_structure.push(IfAtomStructure(tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn then_stmt_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_stmt_structure_1(delta, );
self.then_stmt_structure_2(delta, );
self.then_stmt_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn then_stmt_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_stmt_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenStmtNode(tm0, tm1, ) in self.then_stmt_node.iter_new() {

self.then_stmt_structure_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn then_stmt_structure_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
self.then_stmt_structure_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn then_stmt_structure_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtStructure(_, tm2, ) in self.stmt_structure.iter_all_0(tm0, ) {

self.then_stmt_structure_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn then_stmt_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtStructure(tm0, tm2, ) in self.stmt_structure.iter_new() {

#[allow(unused_variables)]
for ThenStmtNode(_, tm1, ) in self.then_stmt_node.iter_old_0(tm0, ) {

self.then_stmt_structure_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn then_stmt_structure_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: ThenAtomNode, tm2: Structure) {
for _ in [()] {
let exists_already = self.then_atom_structure.iter_all_0_1(tm1, tm2).next().is_some();
if !exists_already {
delta.new_then_atom_structure.push(ThenAtomStructure(tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn match_stmt_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_stmt_structure_1(delta, );
self.match_stmt_structure_2(delta, );
self.match_stmt_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn match_stmt_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_stmt_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.match_stmt_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_stmt_structure_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.match_stmt_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn match_stmt_structure_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for StmtStructure(_, tm3, ) in self.stmt_structure.iter_all_0(tm0, ) {

self.match_stmt_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn match_stmt_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for StmtStructure(tm0, tm3, ) in self.stmt_structure.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(_, tm1, tm2, ) in self.match_stmt_node.iter_old_0(tm0, ) {

self.match_stmt_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn match_stmt_structure_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm1, tm3));
}



}
}


#[allow(unused_variables)]
fn equal_if_atom_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.equal_if_atom_structure_1(delta, );
self.equal_if_atom_structure_2(delta, );
self.equal_if_atom_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn equal_if_atom_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn equal_if_atom_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EqualIfAtomNode(tm0, tm1, tm2, ) in self.equal_if_atom_node.iter_new() {

self.equal_if_atom_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn equal_if_atom_structure_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
self.equal_if_atom_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn equal_if_atom_structure_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomStructure(_, tm3, ) in self.if_atom_structure.iter_all_0(tm0, ) {

self.equal_if_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn equal_if_atom_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomStructure(tm0, tm3, ) in self.if_atom_structure.iter_new() {

#[allow(unused_variables)]
for EqualIfAtomNode(_, tm1, tm2, ) in self.equal_if_atom_node.iter_old_0(tm0, ) {

self.equal_if_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn equal_if_atom_structure_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm1, tm3));
}

let exists_already = self.term_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn defined_if_atom_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.defined_if_atom_structure_1(delta, );
self.defined_if_atom_structure_2(delta, );
self.defined_if_atom_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn defined_if_atom_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn defined_if_atom_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedIfAtomNode(tm0, tm1, ) in self.defined_if_atom_node.iter_new() {

self.defined_if_atom_structure_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn defined_if_atom_structure_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode) {
for _ in [()] {
self.defined_if_atom_structure_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn defined_if_atom_structure_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomStructure(_, tm2, ) in self.if_atom_structure.iter_all_0(tm0, ) {

self.defined_if_atom_structure_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn defined_if_atom_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomStructure(tm0, tm2, ) in self.if_atom_structure.iter_new() {

#[allow(unused_variables)]
for DefinedIfAtomNode(_, tm1, ) in self.defined_if_atom_node.iter_old_0(tm0, ) {

self.defined_if_atom_structure_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn defined_if_atom_structure_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: Structure) {
for _ in [()] {
let exists_already = self.term_structure.iter_all_0_1(tm1, tm2).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn pred_if_atom_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_if_atom_structure_1(delta, );
self.pred_if_atom_structure_2(delta, );
self.pred_if_atom_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn pred_if_atom_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_if_atom_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredIfAtomNode(tm0, tm1, tm2, ) in self.pred_if_atom_node.iter_new() {

self.pred_if_atom_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_structure_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pred_if_atom_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_if_atom_structure_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomStructure(_, tm3, ) in self.if_atom_structure.iter_all_0(tm0, ) {

self.pred_if_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomStructure(tm0, tm3, ) in self.if_atom_structure.iter_new() {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_structure_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.terms_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_terms_structure.push(TermsStructure(tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn var_if_atom_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.var_if_atom_structure_1(delta, );
self.var_if_atom_structure_2(delta, );
self.var_if_atom_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn var_if_atom_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn var_if_atom_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, tm2, ) in self.var_if_atom_node.iter_new() {

self.var_if_atom_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_structure_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
self.var_if_atom_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn var_if_atom_structure_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomStructure(_, tm3, ) in self.if_atom_structure.iter_all_0(tm0, ) {

self.var_if_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IfAtomStructure(tm0, tm3, ) in self.if_atom_structure.iter_new() {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

self.var_if_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_structure_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm1, tm3));
}

let exists_already = self.type_expr_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_type_expr_structure.push(TypeExprStructure(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn equal_then_atom_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.equal_then_atom_structure_1(delta, );
self.equal_then_atom_structure_2(delta, );
self.equal_then_atom_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn equal_then_atom_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn equal_then_atom_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EqualThenAtomNode(tm0, tm1, tm2, ) in self.equal_then_atom_node.iter_new() {

self.equal_then_atom_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn equal_then_atom_structure_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
self.equal_then_atom_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn equal_then_atom_structure_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomStructure(_, tm3, ) in self.then_atom_structure.iter_all_0(tm0, ) {

self.equal_then_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn equal_then_atom_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomStructure(tm0, tm3, ) in self.then_atom_structure.iter_new() {

#[allow(unused_variables)]
for EqualThenAtomNode(_, tm1, tm2, ) in self.equal_then_atom_node.iter_old_0(tm0, ) {

self.equal_then_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn equal_then_atom_structure_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm1, tm3));
}

let exists_already = self.term_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn defined_then_atom_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.defined_then_atom_structure_1(delta, );
self.defined_then_atom_structure_2(delta, );
self.defined_then_atom_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn defined_then_atom_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn defined_then_atom_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, tm1, tm2, ) in self.defined_then_atom_node.iter_new() {

self.defined_then_atom_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn defined_then_atom_structure_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
self.defined_then_atom_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn defined_then_atom_structure_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomStructure(_, tm3, ) in self.then_atom_structure.iter_all_0(tm0, ) {

self.defined_then_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn defined_then_atom_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomStructure(tm0, tm3, ) in self.then_atom_structure.iter_new() {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, tm2, ) in self.defined_then_atom_node.iter_old_0(tm0, ) {

self.defined_then_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn defined_then_atom_structure_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.opt_term_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_opt_term_structure.push(OptTermStructure(tm1, tm3));
}

let exists_already = self.term_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn pred_then_atom_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_then_atom_structure_1(delta, );
self.pred_then_atom_structure_2(delta, );
self.pred_then_atom_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn pred_then_atom_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_then_atom_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredThenAtomNode(tm0, tm1, tm2, ) in self.pred_then_atom_node.iter_new() {

self.pred_then_atom_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_structure_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pred_then_atom_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_then_atom_structure_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomStructure(_, tm3, ) in self.then_atom_structure.iter_all_0(tm0, ) {

self.pred_then_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ThenAtomStructure(tm0, tm3, ) in self.then_atom_structure.iter_new() {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_structure_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.terms_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_terms_structure.push(TermsStructure(tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn member_type_expr_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.member_type_expr_structure_1(delta, );
self.member_type_expr_structure_2(delta, );
self.member_type_expr_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn member_type_expr_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn member_type_expr_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MemberTypeExpr(tm0, tm1, tm2, ) in self.member_type_expr.iter_new() {

self.member_type_expr_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn member_type_expr_structure_3(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: TermNode, tm2: Ident) {
for _ in [()] {
self.member_type_expr_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn member_type_expr_structure_4(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: TermNode, tm2: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for TypeExprStructure(_, tm3, ) in self.type_expr_structure.iter_all_0(tm0, ) {

self.member_type_expr_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn member_type_expr_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeExprStructure(tm0, tm3, ) in self.type_expr_structure.iter_new() {

#[allow(unused_variables)]
for MemberTypeExpr(_, tm1, tm2, ) in self.member_type_expr.iter_old_0(tm0, ) {

self.member_type_expr_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn member_type_expr_structure_6(&self, delta: &mut ModelDelta, tm0: TypeExprNode, tm1: TermNode, tm2: Ident, tm3: Structure) {
for _ in [()] {
let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm1, tm3));
}



}
}


#[allow(unused_variables)]
fn cons_term_list_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.cons_term_list_structure_1(delta, );
self.cons_term_list_structure_2(delta, );
self.cons_term_list_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn cons_term_list_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn cons_term_list_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTermListNode(tm0, tm1, tm2, ) in self.cons_term_list_node.iter_new() {

self.cons_term_list_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn cons_term_list_structure_3(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
self.cons_term_list_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn cons_term_list_structure_4(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermsStructure(_, tm3, ) in self.terms_structure.iter_all_0(tm0, ) {

self.cons_term_list_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn cons_term_list_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermsStructure(tm0, tm3, ) in self.terms_structure.iter_new() {

#[allow(unused_variables)]
for ConsTermListNode(_, tm1, tm2, ) in self.cons_term_list_node.iter_old_0(tm0, ) {

self.cons_term_list_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn cons_term_list_structure_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.term_structure.iter_all_0_1(tm1, tm3).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm1, tm3));
}

let exists_already = self.terms_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_terms_structure.push(TermsStructure(tm2, tm3));
}




}
}


#[allow(unused_variables)]
fn some_opt_term_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.some_opt_term_structure_1(delta, );
self.some_opt_term_structure_2(delta, );
self.some_opt_term_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn some_opt_term_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn some_opt_term_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SomeTermNode(tm0, tm1, ) in self.some_term_node.iter_new() {

self.some_opt_term_structure_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn some_opt_term_structure_3(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode) {
for _ in [()] {
self.some_opt_term_structure_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn some_opt_term_structure_4(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for OptTermStructure(_, tm2, ) in self.opt_term_structure.iter_all_0(tm0, ) {

self.some_opt_term_structure_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn some_opt_term_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for OptTermStructure(tm0, tm2, ) in self.opt_term_structure.iter_new() {

#[allow(unused_variables)]
for SomeTermNode(_, tm1, ) in self.some_term_node.iter_old_0(tm0, ) {

self.some_opt_term_structure_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn some_opt_term_structure_6(&self, delta: &mut ModelDelta, tm0: OptTermNode, tm1: TermNode, tm2: Structure) {
for _ in [()] {
let exists_already = self.term_structure.iter_all_0_1(tm1, tm2).next().is_some();
if !exists_already {
delta.new_term_structure.push(TermStructure(tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn app_term_structure_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.app_term_structure_1(delta, );
self.app_term_structure_2(delta, );
self.app_term_structure_5(delta, );




}
}

#[allow(unused_variables)]
fn app_term_structure_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn app_term_structure_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm0, tm1, tm2, ) in self.app_term_node.iter_new() {

self.app_term_structure_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn app_term_structure_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.app_term_structure_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn app_term_structure_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermStructure(_, tm3, ) in self.term_structure.iter_all_0(tm0, ) {

self.app_term_structure_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn app_term_structure_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermStructure(tm0, tm3, ) in self.term_structure.iter_new() {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.app_term_structure_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn app_term_structure_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Structure) {
for _ in [()] {
let exists_already = self.terms_structure.iter_all_0_1(tm2, tm3).next().is_some();
if !exists_already {
delta.new_terms_structure.push(TermsStructure(tm2, tm3));
}



}
}


#[allow(unused_variables)]
fn semantic_name_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_name_defined_1(delta, );
self.semantic_name_defined_2(delta, );
self.semantic_name_defined_5(delta, );




}
}

#[allow(unused_variables)]
fn semantic_name_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_name_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarInScope(tm0, tm1, ) in self.var_in_scope.iter_new() {

self.semantic_name_defined_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_name_defined_3(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope) {
for _ in [()] {
self.semantic_name_defined_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_name_defined_4(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope) {
for _ in [()] {
let tm2 = match self.semantic_name.iter_all_0_1(tm0, tm1).next() {
    Some(SemanticName(_, _,  res)) => res,
    None => { 
        delta.new_semantic_name_def.push(SemanticNameArgs(tm0, tm1));
        break;
    },
};

self.semantic_name_defined_6(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn semantic_name_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticName(tm0, tm1, tm2, ) in self.semantic_name.iter_new() {

#[allow(unused_variables)]
for VarInScope(_, _, ) in self.var_in_scope.iter_old_0_1(tm0, tm1, ) {

self.semantic_name_defined_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn semantic_name_defined_6(&self, delta: &mut ModelDelta, tm0: VirtIdent, tm1: Scope, tm2: ElName) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn semantic_name_extension_scope_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_name_extension_scope_1(delta, );
self.semantic_name_extension_scope_2(delta, );
self.semantic_name_extension_scope_5(delta, );
self.semantic_name_extension_scope_8(delta, );





}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeExtension(tm0, tm1, ) in self.scope_extension.iter_new() {

self.semantic_name_extension_scope_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_3(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope) {
for _ in [()] {
self.semantic_name_extension_scope_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_4(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticName(tm3, _, tm2, ) in self.semantic_name.iter_all_1(tm0, ) {

self.semantic_name_extension_scope_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticName(tm3, tm0, tm2, ) in self.semantic_name.iter_new() {

#[allow(unused_variables)]
for ScopeExtension(_, tm1, ) in self.scope_extension.iter_old_0(tm0, ) {

self.semantic_name_extension_scope_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_6(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope, tm2: ElName, tm3: VirtIdent) {
for _ in [()] {
self.semantic_name_extension_scope_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_7(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope, tm2: ElName, tm3: VirtIdent) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticName(_, _, tm4, ) in self.semantic_name.iter_all_0_1(tm3, tm1, ) {

self.semantic_name_extension_scope_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticName(tm3, tm1, tm4, ) in self.semantic_name.iter_new() {

#[allow(unused_variables)]
for ScopeExtension(tm0, _, ) in self.scope_extension.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for SemanticName(_, _, tm2, ) in self.semantic_name.iter_old_0_1(tm3, tm0, ) {

self.semantic_name_extension_scope_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_name_extension_scope_9(&self, delta: &mut ModelDelta, tm0: Scope, tm1: Scope, tm2: ElName, tm3: VirtIdent, tm4: ElName) {
for _ in [()] {
delta.new_el_name_equalities.push((tm2, tm4));

delta.new_el_name_equalities.push((tm4, tm2));




}
}


#[allow(unused_variables)]
fn semantic_el_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_el_defined_1(delta, );
self.semantic_el_defined_2(delta, );
self.semantic_el_defined_5(delta, );
self.semantic_el_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn semantic_el_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_el_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for tm0 in self.term_node_new.iter().copied() {

self.semantic_el_defined_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn semantic_el_defined_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
self.semantic_el_defined_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn semantic_el_defined_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermStructure(_, tm1, ) in self.term_structure.iter_all_0(tm0, ) {

self.semantic_el_defined_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_el_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermStructure(tm0, tm1, ) in self.term_structure.iter_new() {

self.semantic_el_defined_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_el_defined_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Structure) {
for _ in [()] {
self.semantic_el_defined_7(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_el_defined_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Structure) {
for _ in [()] {
let tm2 = match self.semantic_el.iter_all_0_1(tm0, tm1).next() {
    Some(SemanticEl(_, _,  res)) => res,
    None => { 
        delta.new_semantic_el_def.push(SemanticElArgs(tm0, tm1));
        break;
    },
};

self.semantic_el_defined_9(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn semantic_el_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm0, tm1, tm2, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for TermStructure(_, _, ) in self.term_structure.iter_old_0_1(tm0, tm1, ) {

self.semantic_el_defined_9(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn semantic_el_defined_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Structure, tm2: El) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn semantic_els_nil_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_els_nil_1(delta, );
self.semantic_els_nil_2(delta, );
self.semantic_els_nil_5(delta, );
self.semantic_els_nil_8(delta, );





}
}

#[allow(unused_variables)]
fn semantic_els_nil_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_els_nil_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilTermListNode(tm0, ) in self.nil_term_list_node.iter_new() {

self.semantic_els_nil_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn semantic_els_nil_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
self.semantic_els_nil_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn semantic_els_nil_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermsStructure(_, tm1, ) in self.terms_structure.iter_all_0(tm0, ) {

self.semantic_els_nil_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn semantic_els_nil_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermsStructure(tm0, tm1, ) in self.terms_structure.iter_new() {

#[allow(unused_variables)]
for NilTermListNode(_, ) in self.nil_term_list_node.iter_old_0(tm0, ) {

self.semantic_els_nil_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn semantic_els_nil_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Structure) {
for _ in [()] {
self.semantic_els_nil_7(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn semantic_els_nil_7(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Structure) {
for _ in [()] {
let tm2 = match self.nil_el_list.iter_all_0(tm1).next() {
    Some(NilElList(_,  res)) => res,
    None => { 
        delta.new_nil_el_list_def.push(NilElListArgs(tm1));
        break;
    },
};

self.semantic_els_nil_9(delta, tm0, tm1, tm2);



}
}

#[allow(unused_variables)]
fn semantic_els_nil_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilElList(tm1, tm2, ) in self.nil_el_list.iter_new() {

#[allow(unused_variables)]
for TermsStructure(tm0, _, ) in self.terms_structure.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for NilTermListNode(_, ) in self.nil_term_list_node.iter_old_0(tm0, ) {

self.semantic_els_nil_9(delta, tm0, tm1, tm2);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_els_nil_9(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: Structure, tm2: ElList) {
for _ in [()] {
let exists_already = self.semantic_els.iter_all_0_1_2(tm0, tm1, tm2).next().is_some();
if !exists_already {
delta.new_semantic_els.push(SemanticEls(tm0, tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn semantic_els_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_els_cons_1(delta, );
self.semantic_els_cons_2(delta, );
self.semantic_els_cons_5(delta, );
self.semantic_els_cons_8(delta, );
self.semantic_els_cons_11(delta, );






}
}

#[allow(unused_variables)]
fn semantic_els_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_els_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTermListNode(tm0, tm1, tm2, ) in self.cons_term_list_node.iter_new() {

self.semantic_els_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn semantic_els_cons_3(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
self.semantic_els_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn semantic_els_cons_4(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm4, tm3, ) in self.semantic_el.iter_all_0(tm1, ) {

self.semantic_els_cons_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn semantic_els_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm1, tm4, tm3, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for ConsTermListNode(tm0, _, tm2, ) in self.cons_term_list_node.iter_old_1(tm1, ) {

self.semantic_els_cons_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn semantic_els_cons_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: El, tm4: Structure) {
for _ in [()] {
self.semantic_els_cons_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn semantic_els_cons_7(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: El, tm4: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(_, _, tm5, ) in self.semantic_els.iter_all_0_1(tm2, tm4, ) {

self.semantic_els_cons_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn semantic_els_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(tm2, tm4, tm5, ) in self.semantic_els.iter_new() {

#[allow(unused_variables)]
for SemanticEl(tm1, _, tm3, ) in self.semantic_el.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for ConsTermListNode(tm0, _, _, ) in self.cons_term_list_node.iter_old_1_2(tm1, tm2, ) {

self.semantic_els_cons_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn semantic_els_cons_9(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList) {
for _ in [()] {
self.semantic_els_cons_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn semantic_els_cons_10(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList) {
for _ in [()] {
let tm6 = match self.cons_el_list.iter_all_0_1(tm3, tm5).next() {
    Some(ConsElList(_, _,  res)) => res,
    None => { 
        delta.new_cons_el_list_def.push(ConsElListArgs(tm3, tm5));
        break;
    },
};

self.semantic_els_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);



}
}

#[allow(unused_variables)]
fn semantic_els_cons_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsElList(tm3, tm5, tm6, ) in self.cons_el_list.iter_new() {

#[allow(unused_variables)]
for SemanticEls(tm2, tm4, _, ) in self.semantic_els.iter_old_2(tm5, ) {

#[allow(unused_variables)]
for SemanticEl(tm1, _, _, ) in self.semantic_el.iter_old_1_2(tm4, tm3, ) {

#[allow(unused_variables)]
for ConsTermListNode(tm0, _, _, ) in self.cons_term_list_node.iter_old_1_2(tm1, tm2, ) {

self.semantic_els_cons_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}
}

#[allow(unused_variables)]
fn semantic_els_cons_12(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList, tm6: ElList) {
for _ in [()] {
let exists_already = self.semantic_els.iter_all_0_1_2(tm0, tm4, tm6).next().is_some();
if !exists_already {
delta.new_semantic_els.push(SemanticEls(tm0, tm4, tm6));
}



}
}


#[allow(unused_variables)]
fn semantic_el_struct_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_el_struct_1(delta, );
self.semantic_el_struct_2(delta, );



}
}

#[allow(unused_variables)]
fn semantic_el_struct_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_el_struct_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm1, tm2, tm0, ) in self.semantic_el.iter_new() {

self.semantic_el_struct_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn semantic_el_struct_3(&self, delta: &mut ModelDelta, tm0: El, tm1: TermNode, tm2: Structure) {
for _ in [()] {
let exists_already = self.el_structure.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_el_structure.push(ElStructure(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn semantic_els_struct_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.semantic_els_struct_1(delta, );
self.semantic_els_struct_2(delta, );



}
}

#[allow(unused_variables)]
fn semantic_els_struct_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn semantic_els_struct_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(tm1, tm2, tm0, ) in self.semantic_els.iter_new() {

self.semantic_els_struct_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn semantic_els_struct_3(&self, delta: &mut ModelDelta, tm0: ElList, tm1: TermListNode, tm2: Structure) {
for _ in [()] {
let exists_already = self.els_structure.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_els_structure.push(ElsStructure(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn ambient_model_el_struct_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_model_el_struct_1(delta, );
self.ambient_model_el_struct_2(delta, );



}
}

#[allow(unused_variables)]
fn ambient_model_el_struct_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_model_el_struct_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm1, tm2, tm0, ) in self.ambient_model_el.iter_new() {

self.ambient_model_el_struct_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_struct_3(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure) {
for _ in [()] {
let exists_already = self.el_structure.iter_all_0_1(tm0, tm2).next().is_some();
if !exists_already {
delta.new_el_structure.push(ElStructure(tm0, tm2));
}



}
}


#[allow(unused_variables)]
fn ambient_model_el_type_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ambient_model_el_type_1(delta, );
self.ambient_model_el_type_2(delta, );
self.ambient_model_el_type_5(delta, );
self.ambient_model_el_type_8(delta, );





}
}

#[allow(unused_variables)]
fn ambient_model_el_type_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ambient_model_el_type_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm1, tm2, tm0, ) in self.ambient_model_el.iter_new() {

self.ambient_model_el_type_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_type_3(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure) {
for _ in [()] {
self.ambient_model_el_type_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ambient_model_el_type_4(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(_, tm3, ) in self.symbol_scope_model.iter_all_0(tm1, ) {

self.ambient_model_el_type_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_type_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SymbolScopeModel(tm1, tm3, ) in self.symbol_scope_model.iter_new() {

#[allow(unused_variables)]
for AmbientModelEl(_, tm2, tm0, ) in self.ambient_model_el.iter_old_0(tm1, ) {

self.ambient_model_el_type_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_type_6(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure, tm3: Type) {
for _ in [()] {
self.ambient_model_el_type_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ambient_model_el_type_7(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure, tm3: Type) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(_, tm4, ) in self.ambient_type.iter_all_0(tm3, ) {

self.ambient_model_el_type_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn ambient_model_el_type_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm3, tm4, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for SymbolScopeModel(tm1, _, ) in self.symbol_scope_model.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for AmbientModelEl(_, tm2, tm0, ) in self.ambient_model_el.iter_old_0(tm1, ) {

self.ambient_model_el_type_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn ambient_model_el_type_9(&self, delta: &mut ModelDelta, tm0: El, tm1: SymbolScope, tm2: Structure, tm3: Type, tm4: ElementType) {
for _ in [()] {
let exists_already = self.el_type.iter_all_0_1(tm0, tm4).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm0, tm4));
}



}
}


#[allow(unused_variables)]
fn app_term_semantics_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.app_term_semantics_1(delta, );
self.app_term_semantics_2(delta, );
self.app_term_semantics_5(delta, );
self.app_term_semantics_8(delta, );
self.app_term_semantics_11(delta, );
self.app_term_semantics_12(delta, );
self.app_term_semantics_13(delta, );
self.app_term_semantics_16(delta, );
self.app_term_semantics_17(delta, );
self.app_term_semantics_20(delta, );











}
}

#[allow(unused_variables)]
fn app_term_semantics_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn app_term_semantics_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm0, tm1, tm2, ) in self.app_term_node.iter_new() {

self.app_term_semantics_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn app_term_semantics_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.app_term_semantics_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn app_term_semantics_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm4, tm3, ) in self.semantic_el.iter_all_0(tm0, ) {

self.app_term_semantics_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn app_term_semantics_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm0, tm4, tm3, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.app_term_semantics_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure) {
for _ in [()] {
self.app_term_semantics_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn app_term_semantics_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(_, _, tm5, ) in self.semantic_els.iter_all_0_1(tm2, tm4, ) {

self.app_term_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn app_term_semantics_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(tm2, tm4, tm5, ) in self.semantic_els.iter_new() {

#[allow(unused_variables)]
for SemanticEl(tm0, _, tm3, ) in self.semantic_el.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

self.app_term_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList) {
for _ in [()] {
self.app_term_semantics_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn app_term_semantics_10(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm8, ) in self.rule_descendant_term.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm7, ) in self.entry_scope.iter_all_0(tm8, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm6, ) in self.scope_symbols.iter_all_0(tm7, ) {

self.app_term_semantics_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm8, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm7, ) in self.entry_scope.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm6, ) in self.scope_symbols.iter_old_0(tm7, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm4, tm3, ) in self.semantic_el.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for SemanticEls(tm2, _, tm5, ) in self.semantic_els.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

self.app_term_semantics_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm8, tm7, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm6, ) in self.scope_symbols.iter_old_0(tm7, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm4, tm3, ) in self.semantic_el.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for SemanticEls(tm2, _, tm5, ) in self.semantic_els.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

self.app_term_semantics_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm7, tm6, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm8, _, ) in self.entry_scope.iter_all_1(tm7, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm4, tm3, ) in self.semantic_el.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for SemanticEls(tm2, _, tm5, ) in self.semantic_els.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

self.app_term_semantics_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_14(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList, tm6: SymbolScope, tm7: Scope, tm8: RuleDescendantNode) {
for _ in [()] {
self.app_term_semantics_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}
}

#[allow(unused_variables)]
fn app_term_semantics_15(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList, tm6: SymbolScope, tm7: Scope, tm8: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(_, _, tm10, ) in self.semantic_func.iter_all_0_1(tm6, tm1, ) {

#[allow(unused_variables)]
for FuncRel(_, tm9, ) in self.func_rel.iter_all_0(tm10, ) {

self.app_term_semantics_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_16(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm6, tm1, tm10, ) in self.semantic_func.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm7, _, ) in self.scope_symbols.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for FuncRel(_, tm9, ) in self.func_rel.iter_old_0(tm10, ) {

#[allow(unused_variables)]
for EntryScope(tm8, _, ) in self.entry_scope.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for AppTermNode(_, _, tm2, ) in self.app_term_node.iter_old_0_1(tm0, tm1, ) {

#[allow(unused_variables)]
for SemanticEls(_, tm4, tm5, ) in self.semantic_els.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticEl(_, _, tm3, ) in self.semantic_el.iter_old_0_1(tm0, tm4, ) {

self.app_term_semantics_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for FuncRel(tm10, tm9, ) in self.func_rel.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm7, tm6, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for SemanticFunc(_, tm1, _, ) in self.semantic_func.iter_all_0_2(tm6, tm10, ) {

#[allow(unused_variables)]
for EntryScope(tm8, _, ) in self.entry_scope.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for AppTermNode(_, _, tm2, ) in self.app_term_node.iter_old_0_1(tm0, tm1, ) {

#[allow(unused_variables)]
for SemanticEls(_, tm4, tm5, ) in self.semantic_els.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for SemanticEl(_, _, tm3, ) in self.semantic_el.iter_old_0_1(tm0, tm4, ) {

self.app_term_semantics_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_18(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList, tm6: SymbolScope, tm7: Scope, tm8: RuleDescendantNode, tm9: Rel, tm10: Func) {
for _ in [()] {
self.app_term_semantics_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}
}

#[allow(unused_variables)]
fn app_term_semantics_19(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList, tm6: SymbolScope, tm7: Scope, tm8: RuleDescendantNode, tm9: Rel, tm10: Func) {
for _ in [()] {
let tm11 = match self.snoc_el_list.iter_all_0_1(tm5, tm3).next() {
    Some(SnocElList(_, _,  res)) => res,
    None => { 
        delta.new_snoc_el_list_def.push(SnocElListArgs(tm5, tm3));
        break;
    },
};

self.app_term_semantics_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11);



}
}

#[allow(unused_variables)]
fn app_term_semantics_20(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SnocElList(tm5, tm3, tm11, ) in self.snoc_el_list.iter_new() {

#[allow(unused_variables)]
for FuncRel(tm10, tm9, ) in self.func_rel.iter_old() {

#[allow(unused_variables)]
for SemanticEls(tm2, tm4, _, ) in self.semantic_els.iter_old_2(tm5, ) {

#[allow(unused_variables)]
for SemanticEl(tm0, _, _, ) in self.semantic_el.iter_old_1_2(tm4, tm3, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, _, ) in self.app_term_node.iter_old_0_2(tm0, tm2, ) {

#[allow(unused_variables)]
for SemanticFunc(tm6, _, _, ) in self.semantic_func.iter_old_1_2(tm1, tm10, ) {

#[allow(unused_variables)]
for ScopeSymbols(tm7, _, ) in self.scope_symbols.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for EntryScope(tm8, _, ) in self.entry_scope.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, _, ) in self.rule_descendant_term.iter_old_0_1(tm0, tm8, ) {

self.app_term_semantics_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn app_term_semantics_21(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: El, tm4: Structure, tm5: ElList, tm6: SymbolScope, tm7: Scope, tm8: RuleDescendantNode, tm9: Rel, tm10: Func, tm11: ElList) {
for _ in [()] {
let exists_already = self.rel_app.iter_all_0_1(tm9, tm11).next().is_some();
if !exists_already {
delta.new_rel_app.push(RelApp(tm9, tm11));
}



}
}


#[allow(unused_variables)]
fn var_term_semantics_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.var_term_semantics_1(delta, );
self.var_term_semantics_2(delta, );
self.var_term_semantics_5(delta, );
self.var_term_semantics_6(delta, );
self.var_term_semantics_9(delta, );
self.var_term_semantics_12(delta, );







}
}

#[allow(unused_variables)]
fn var_term_semantics_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn var_term_semantics_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarTermNode(tm0, tm1, ) in self.var_term_node.iter_new() {

self.var_term_semantics_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn var_term_semantics_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
for _ in [()] {
self.var_term_semantics_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn var_term_semantics_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm3, ) in self.rule_descendant_term.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for ExitScope(_, tm2, ) in self.exit_scope.iter_all_0(tm3, ) {

self.var_term_semantics_7(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn var_term_semantics_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm3, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ExitScope(_, tm2, ) in self.exit_scope.iter_old_0(tm3, ) {

self.var_term_semantics_7(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn var_term_semantics_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ExitScope(tm3, tm2, ) in self.exit_scope.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTerm(tm0, _, ) in self.rule_descendant_term.iter_all_1(tm3, ) {

#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_old_0(tm0, ) {

self.var_term_semantics_7(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn var_term_semantics_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode) {
for _ in [()] {
self.var_term_semantics_8(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn var_term_semantics_8(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticName(_, _, tm4, ) in self.semantic_name.iter_all_0_1(tm1, tm2, ) {

self.var_term_semantics_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn var_term_semantics_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticName(tm1, tm2, tm4, ) in self.semantic_name.iter_new() {

#[allow(unused_variables)]
for ExitScope(tm3, _, ) in self.exit_scope.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for VarTermNode(tm0, _, ) in self.var_term_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, _, ) in self.rule_descendant_term.iter_old_0_1(tm0, tm3, ) {

self.var_term_semantics_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn var_term_semantics_10(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode, tm4: ElName) {
for _ in [()] {
self.var_term_semantics_11(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn var_term_semantics_11(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode, tm4: ElName) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm6, tm5, ) in self.semantic_el.iter_all_0(tm0, ) {

self.var_term_semantics_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn var_term_semantics_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm0, tm6, tm5, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm3, ) in self.rule_descendant_term.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ExitScope(_, tm2, ) in self.exit_scope.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for SemanticName(_, _, tm4, ) in self.semantic_name.iter_old_0_1(tm1, tm2, ) {

self.var_term_semantics_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_term_semantics_13(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode, tm4: ElName, tm5: El, tm6: Structure) {
for _ in [()] {
let exists_already = self.var.iter_all_0_1_2(tm6, tm4, tm5).next().is_some();
if !exists_already {
delta.new_var.push(Var(tm6, tm4, tm5));
}



}
}


#[allow(unused_variables)]
fn wildcard_name_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.wildcard_name_defined_1(delta, );
self.wildcard_name_defined_2(delta, );
self.wildcard_name_defined_5(delta, );




}
}

#[allow(unused_variables)]
fn wildcard_name_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn wildcard_name_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for WildcardTermNode(tm0, ) in self.wildcard_term_node.iter_new() {

self.wildcard_name_defined_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn wildcard_name_defined_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
self.wildcard_name_defined_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn wildcard_name_defined_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
let tm1 = match self.wildcard_name.iter_all_0(tm0).next() {
    Some(WildcardName(_,  res)) => res,
    None => { 
        delta.new_wildcard_name_def.push(WildcardNameArgs(tm0));
        break;
    },
};

self.wildcard_name_defined_6(delta, tm0, tm1);



}
}

#[allow(unused_variables)]
fn wildcard_name_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for WildcardName(tm0, tm1, ) in self.wildcard_name.iter_new() {

#[allow(unused_variables)]
for WildcardTermNode(_, ) in self.wildcard_term_node.iter_old_0(tm0, ) {

self.wildcard_name_defined_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn wildcard_name_defined_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: ElName) {
for _ in [()] {

}
}


#[allow(unused_variables)]
fn wildcard_term_semantics_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.wildcard_term_semantics_1(delta, );
self.wildcard_term_semantics_2(delta, );
self.wildcard_term_semantics_5(delta, );
self.wildcard_term_semantics_8(delta, );





}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for WildcardTermNode(tm0, ) in self.wildcard_term_node.iter_new() {

self.wildcard_term_semantics_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
self.wildcard_term_semantics_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for WildcardName(_, tm1, ) in self.wildcard_name.iter_all_0(tm0, ) {

self.wildcard_term_semantics_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for WildcardName(tm0, tm1, ) in self.wildcard_name.iter_new() {

#[allow(unused_variables)]
for WildcardTermNode(_, ) in self.wildcard_term_node.iter_old_0(tm0, ) {

self.wildcard_term_semantics_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: ElName) {
for _ in [()] {
self.wildcard_term_semantics_7(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: ElName) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm3, tm2, ) in self.semantic_el.iter_all_0(tm0, ) {

self.wildcard_term_semantics_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm0, tm3, tm2, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for WildcardTermNode(_, ) in self.wildcard_term_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for WildcardName(_, tm1, ) in self.wildcard_name.iter_old_0(tm0, ) {

self.wildcard_term_semantics_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn wildcard_term_semantics_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: ElName, tm2: El, tm3: Structure) {
for _ in [()] {
let exists_already = self.var.iter_all_0_1_2(tm3, tm1, tm2).next().is_some();
if !exists_already {
delta.new_var.push(Var(tm3, tm1, tm2));
}



}
}


#[allow(unused_variables)]
fn equal_if_atom_semantics_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.equal_if_atom_semantics_1(delta, );
self.equal_if_atom_semantics_2(delta, );
self.equal_if_atom_semantics_5(delta, );
self.equal_if_atom_semantics_8(delta, );





}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EqualIfAtomNode(tm0, tm1, tm2, ) in self.equal_if_atom_node.iter_new() {

self.equal_if_atom_semantics_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
self.equal_if_atom_semantics_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm4, tm3, ) in self.semantic_el.iter_all_0(tm1, ) {

self.equal_if_atom_semantics_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm1, tm4, tm3, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for EqualIfAtomNode(tm0, _, tm2, ) in self.equal_if_atom_node.iter_old_1(tm1, ) {

self.equal_if_atom_semantics_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: El, tm4: Structure) {
for _ in [()] {
self.equal_if_atom_semantics_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: El, tm4: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, _, tm5, ) in self.semantic_el.iter_all_0_1(tm2, tm4, ) {

self.equal_if_atom_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm2, tm4, tm5, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for SemanticEl(tm1, _, tm3, ) in self.semantic_el.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for EqualIfAtomNode(tm0, _, _, ) in self.equal_if_atom_node.iter_old_1_2(tm1, tm2, ) {

self.equal_if_atom_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn equal_if_atom_semantics_9(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TermNode, tm3: El, tm4: Structure, tm5: El) {
for _ in [()] {
delta.new_el_equalities.push((tm3, tm5));

delta.new_el_equalities.push((tm5, tm3));




}
}


#[allow(unused_variables)]
fn pred_if_atom_semantics_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_if_atom_semantics_1(delta, );
self.pred_if_atom_semantics_2(delta, );
self.pred_if_atom_semantics_5(delta, );
self.pred_if_atom_semantics_6(delta, );
self.pred_if_atom_semantics_7(delta, );
self.pred_if_atom_semantics_10(delta, );
self.pred_if_atom_semantics_11(delta, );
self.pred_if_atom_semantics_14(delta, );









}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredIfAtomNode(tm0, tm1, tm2, ) in self.pred_if_atom_node.iter_new() {

self.pred_if_atom_semantics_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pred_if_atom_semantics_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm5, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_all_0(tm4, ) {

self.pred_if_atom_semantics_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm5, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_semantics_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm5, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_semantics_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, tm1, tm2, ) in self.pred_if_atom_node.iter_old_0(tm0, ) {

self.pred_if_atom_semantics_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_8(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
self.pred_if_atom_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_9(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(_, _, tm7, ) in self.semantic_pred.iter_all_0_1(tm3, tm1, ) {

#[allow(unused_variables)]
for PredRel(_, tm6, ) in self.pred_rel.iter_all_0(tm7, ) {

self.pred_if_atom_semantics_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm3, tm1, tm7, ) in self.semantic_pred.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, _, ) in self.scope_symbols.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for PredRel(_, tm6, ) in self.pred_rel.iter_old_0(tm7, ) {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, _, tm2, ) in self.pred_if_atom_node.iter_old_0_1(tm0, tm1, ) {

self.pred_if_atom_semantics_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(tm7, tm6, ) in self.pred_rel.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for SemanticPred(_, tm1, _, ) in self.semantic_pred.iter_all_0_2(tm3, tm7, ) {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for PredIfAtomNode(_, _, tm2, ) in self.pred_if_atom_node.iter_old_0_1(tm0, tm1, ) {

self.pred_if_atom_semantics_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_12(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Rel, tm7: Pred) {
for _ in [()] {
self.pred_if_atom_semantics_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_13(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Rel, tm7: Pred) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(_, tm9, tm8, ) in self.semantic_els.iter_all_0(tm2, ) {

self.pred_if_atom_semantics_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(tm2, tm9, tm8, ) in self.semantic_els.iter_new() {

#[allow(unused_variables)]
for PredRel(tm7, tm6, ) in self.pred_rel.iter_old() {

#[allow(unused_variables)]
for PredIfAtomNode(tm0, tm1, _, ) in self.pred_if_atom_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm5, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for SemanticPred(tm3, _, _, ) in self.semantic_pred.iter_old_1_2(tm1, tm7, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm4, tm3, ) {

self.pred_if_atom_semantics_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_if_atom_semantics_15(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Rel, tm7: Pred, tm8: ElList, tm9: Structure) {
for _ in [()] {
let exists_already = self.rel_app.iter_all_0_1(tm6, tm8).next().is_some();
if !exists_already {
delta.new_rel_app.push(RelApp(tm6, tm8));
}



}
}


#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.var_if_atom_semantics_ambient_1(delta, );
self.var_if_atom_semantics_ambient_2(delta, );
self.var_if_atom_semantics_ambient_5(delta, );
self.var_if_atom_semantics_ambient_8(delta, );
self.var_if_atom_semantics_ambient_9(delta, );
self.var_if_atom_semantics_ambient_10(delta, );
self.var_if_atom_semantics_ambient_13(delta, );
self.var_if_atom_semantics_ambient_14(delta, );
self.var_if_atom_semantics_ambient_17(delta, );










}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, tm2, ) in self.var_if_atom_node.iter_new() {

self.var_if_atom_semantics_ambient_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
self.var_if_atom_semantics_ambient_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientTypeExpr(_, tm3, ) in self.ambient_type_expr.iter_all_0(tm2, ) {

self.var_if_atom_semantics_ambient_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm3, ) in self.ambient_type_expr.iter_new() {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_if_atom_semantics_ambient_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident) {
for _ in [()] {
self.var_if_atom_semantics_ambient_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_all_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_all_0(tm5, ) {

self.var_if_atom_semantics_ambient_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, tm6, ) in self.rule_descendant_if_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(_, tm3, ) in self.ambient_type_expr.iter_old_0(tm2, ) {

self.var_if_atom_semantics_ambient_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm6, tm5, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(_, tm3, ) in self.ambient_type_expr.iter_old_0(tm2, ) {

self.var_if_atom_semantics_ambient_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm5, tm4, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, tm2, ) in self.var_if_atom_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(_, tm3, ) in self.ambient_type_expr.iter_old_0(tm2, ) {

self.var_if_atom_semantics_ambient_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_11(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
self.var_if_atom_semantics_ambient_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_12(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, _, tm8, ) in self.semantic_type.iter_all_0_1(tm4, tm3, ) {

#[allow(unused_variables)]
for AmbientType(_, tm7, ) in self.ambient_type.iter_all_0(tm8, ) {

self.var_if_atom_semantics_ambient_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm4, tm3, tm8, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm5, _, ) in self.scope_symbols.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AmbientType(_, tm7, ) in self.ambient_type.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, _, ) in self.ambient_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, _, ) in self.var_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.var_if_atom_semantics_ambient_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm8, tm7, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm5, tm4, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for SemanticType(_, tm3, _, ) in self.semantic_type.iter_all_0_2(tm4, tm8, ) {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, _, ) in self.ambient_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(tm0, _, ) in self.rule_descendant_if_atom.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for VarIfAtomNode(_, tm1, _, ) in self.var_if_atom_node.iter_old_0_2(tm0, tm2, ) {

self.var_if_atom_semantics_ambient_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_15(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: ElementType, tm8: Type) {
for _ in [()] {
self.var_if_atom_semantics_ambient_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_16(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: ElementType, tm8: Type) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm10, tm9, ) in self.semantic_el.iter_all_0(tm1, ) {

self.var_if_atom_semantics_ambient_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm1, tm10, tm9, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for AmbientType(tm8, tm7, ) in self.ambient_type.iter_old() {

#[allow(unused_variables)]
for AmbientTypeExpr(tm2, tm3, ) in self.ambient_type_expr.iter_old() {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, _, _, ) in self.var_if_atom_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for RuleDescendantIfAtom(_, tm6, ) in self.rule_descendant_if_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for SemanticType(tm4, _, _, ) in self.semantic_type.iter_old_1_2(tm3, tm8, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm5, tm4, ) {

self.var_if_atom_semantics_ambient_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_ambient_18(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: Ident, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: ElementType, tm8: Type, tm9: El, tm10: Structure) {
for _ in [()] {
let exists_already = self.el_type.iter_all_0_1(tm9, tm7).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm9, tm7));
}



}
}


#[allow(unused_variables)]
fn var_if_atom_semantics_member_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.var_if_atom_semantics_member_1(delta, );
self.var_if_atom_semantics_member_2(delta, );
self.var_if_atom_semantics_member_5(delta, );
self.var_if_atom_semantics_member_8(delta, );
self.var_if_atom_semantics_member_11(delta, );
self.var_if_atom_semantics_member_14(delta, );
self.var_if_atom_semantics_member_17(delta, );
self.var_if_atom_semantics_member_20(delta, );









}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, tm2, ) in self.var_if_atom_node.iter_new() {

self.var_if_atom_semantics_member_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_3(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
self.var_if_atom_semantics_member_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_4(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode) {
for _ in [()] {
#[allow(unused_variables)]
for MemberTypeExpr(_, tm3, tm4, ) in self.member_type_expr.iter_all_0(tm2, ) {

self.var_if_atom_semantics_member_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MemberTypeExpr(tm2, tm3, tm4, ) in self.member_type_expr.iter_new() {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

self.var_if_atom_semantics_member_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_6(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident) {
for _ in [()] {
self.var_if_atom_semantics_member_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_7(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm6, tm5, ) in self.semantic_el.iter_all_0(tm1, ) {

self.var_if_atom_semantics_member_9(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm1, tm6, tm5, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, _, tm2, ) in self.var_if_atom_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for MemberTypeExpr(_, tm3, tm4, ) in self.member_type_expr.iter_old_0(tm2, ) {

self.var_if_atom_semantics_member_9(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_9(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure) {
for _ in [()] {
self.var_if_atom_semantics_member_10(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_10(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, _, tm7, ) in self.semantic_el.iter_all_0_1(tm3, tm6, ) {

self.var_if_atom_semantics_member_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm3, tm6, tm7, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for SemanticEl(tm1, _, tm5, ) in self.semantic_el.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, _, _, ) in self.var_if_atom_node.iter_old_1_2(tm1, tm2, ) {

self.var_if_atom_semantics_member_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_12(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure, tm7: El) {
for _ in [()] {
self.var_if_atom_semantics_member_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_13(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure, tm7: El) {
for _ in [()] {
#[allow(unused_variables)]
for ElementMemberSymbolScope(_, tm8, ) in self.element_member_symbol_scope.iter_all_0(tm7, ) {

self.var_if_atom_semantics_member_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElementMemberSymbolScope(tm7, tm8, ) in self.element_member_symbol_scope.iter_new() {

#[allow(unused_variables)]
for SemanticEl(tm3, tm6, _, ) in self.semantic_el.iter_old_2(tm7, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, tm4, ) in self.member_type_expr.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for SemanticEl(_, _, tm5, ) in self.semantic_el.iter_old_0_1(tm1, tm6, ) {

self.var_if_atom_semantics_member_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_15(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure, tm7: El, tm8: SymbolScope) {
for _ in [()] {
self.var_if_atom_semantics_member_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_16(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure, tm7: El, tm8: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, _, tm9, ) in self.semantic_type.iter_all_0_1(tm8, tm4, ) {

self.var_if_atom_semantics_member_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm8, tm4, tm9, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for ElementMemberSymbolScope(tm7, _, ) in self.element_member_symbol_scope.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for SemanticEl(tm3, tm6, _, ) in self.semantic_el.iter_old_2(tm7, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, _, ) in self.member_type_expr.iter_old_1_2(tm3, tm4, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for SemanticEl(_, _, tm5, ) in self.semantic_el.iter_old_0_1(tm1, tm6, ) {

self.var_if_atom_semantics_member_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_18(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure, tm7: El, tm8: SymbolScope, tm9: Type) {
for _ in [()] {
self.var_if_atom_semantics_member_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_19(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure, tm7: El, tm8: SymbolScope, tm9: Type) {
for _ in [()] {
let tm10 = match self.instantiated_type.iter_all_0_1(tm7, tm9).next() {
    Some(InstantiatedType(_, _,  res)) => res,
    None => { 
        delta.new_instantiated_type_def.push(InstantiatedTypeArgs(tm7, tm9));
        break;
    },
};

self.var_if_atom_semantics_member_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);



}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_20(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for InstantiatedType(tm7, tm9, tm10, ) in self.instantiated_type.iter_new() {

#[allow(unused_variables)]
for ElementMemberSymbolScope(_, tm8, ) in self.element_member_symbol_scope.iter_old_0(tm7, ) {

#[allow(unused_variables)]
for SemanticType(_, tm4, _, ) in self.semantic_type.iter_old_0_2(tm8, tm9, ) {

#[allow(unused_variables)]
for SemanticEl(tm3, tm6, _, ) in self.semantic_el.iter_old_2(tm7, ) {

#[allow(unused_variables)]
for MemberTypeExpr(tm2, _, _, ) in self.member_type_expr.iter_old_1_2(tm3, tm4, ) {

#[allow(unused_variables)]
for VarIfAtomNode(tm0, tm1, _, ) in self.var_if_atom_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for SemanticEl(_, _, tm5, ) in self.semantic_el.iter_old_0_1(tm1, tm6, ) {

self.var_if_atom_semantics_member_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn var_if_atom_semantics_member_21(&self, delta: &mut ModelDelta, tm0: IfAtomNode, tm1: TermNode, tm2: TypeExprNode, tm3: TermNode, tm4: Ident, tm5: El, tm6: Structure, tm7: El, tm8: SymbolScope, tm9: Type, tm10: ElementType) {
for _ in [()] {
let exists_already = self.el_type.iter_all_0_1(tm5, tm10).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm5, tm10));
}



}
}


#[allow(unused_variables)]
fn equal_then_atom_semantics_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.equal_then_atom_semantics_1(delta, );
self.equal_then_atom_semantics_2(delta, );
self.equal_then_atom_semantics_5(delta, );
self.equal_then_atom_semantics_8(delta, );





}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EqualThenAtomNode(tm0, tm1, tm2, ) in self.equal_then_atom_node.iter_new() {

self.equal_then_atom_semantics_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
self.equal_then_atom_semantics_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm4, tm3, ) in self.semantic_el.iter_all_0(tm1, ) {

self.equal_then_atom_semantics_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm1, tm4, tm3, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for EqualThenAtomNode(tm0, _, tm2, ) in self.equal_then_atom_node.iter_old_1(tm1, ) {

self.equal_then_atom_semantics_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: El, tm4: Structure) {
for _ in [()] {
self.equal_then_atom_semantics_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_7(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: El, tm4: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, _, tm5, ) in self.semantic_el.iter_all_0_1(tm2, tm4, ) {

self.equal_then_atom_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm2, tm4, tm5, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for SemanticEl(tm1, _, tm3, ) in self.semantic_el.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for EqualThenAtomNode(tm0, _, _, ) in self.equal_then_atom_node.iter_old_1_2(tm1, tm2, ) {

self.equal_then_atom_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn equal_then_atom_semantics_9(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode, tm3: El, tm4: Structure, tm5: El) {
for _ in [()] {
delta.new_el_equalities.push((tm3, tm5));

delta.new_el_equalities.push((tm5, tm3));




}
}


#[allow(unused_variables)]
fn defined_then_atom_semantics_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.defined_then_atom_semantics_1(delta, );
self.defined_then_atom_semantics_2(delta, );
self.defined_then_atom_semantics_5(delta, );
self.defined_then_atom_semantics_8(delta, );
self.defined_then_atom_semantics_11(delta, );






}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, tm1, tm2, ) in self.defined_then_atom_node.iter_new() {

self.defined_then_atom_semantics_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
self.defined_then_atom_semantics_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for SomeTermNode(_, tm3, ) in self.some_term_node.iter_all_0(tm1, ) {

self.defined_then_atom_semantics_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SomeTermNode(tm1, tm3, ) in self.some_term_node.iter_new() {

#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, _, tm2, ) in self.defined_then_atom_node.iter_old_1(tm1, ) {

self.defined_then_atom_semantics_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: TermNode) {
for _ in [()] {
self.defined_then_atom_semantics_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_7(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm5, tm4, ) in self.semantic_el.iter_all_0(tm3, ) {

self.defined_then_atom_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm3, tm5, tm4, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for SomeTermNode(tm1, _, ) in self.some_term_node.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, _, tm2, ) in self.defined_then_atom_node.iter_old_1(tm1, ) {

self.defined_then_atom_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_9(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: TermNode, tm4: El, tm5: Structure) {
for _ in [()] {
self.defined_then_atom_semantics_10(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_10(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: TermNode, tm4: El, tm5: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, _, tm6, ) in self.semantic_el.iter_all_0_1(tm2, tm5, ) {

self.defined_then_atom_semantics_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm2, tm5, tm6, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for SemanticEl(tm3, _, tm4, ) in self.semantic_el.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for SomeTermNode(tm1, _, ) in self.some_term_node.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, _, _, ) in self.defined_then_atom_node.iter_old_1_2(tm1, tm2, ) {

self.defined_then_atom_semantics_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_atom_semantics_12(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: TermNode, tm4: El, tm5: Structure, tm6: El) {
for _ in [()] {
delta.new_el_equalities.push((tm4, tm6));

delta.new_el_equalities.push((tm6, tm4));




}
}


#[allow(unused_variables)]
fn pred_then_atom_semantics_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pred_then_atom_semantics_1(delta, );
self.pred_then_atom_semantics_2(delta, );
self.pred_then_atom_semantics_5(delta, );
self.pred_then_atom_semantics_6(delta, );
self.pred_then_atom_semantics_7(delta, );
self.pred_then_atom_semantics_10(delta, );
self.pred_then_atom_semantics_11(delta, );
self.pred_then_atom_semantics_14(delta, );









}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredThenAtomNode(tm0, tm1, tm2, ) in self.pred_then_atom_node.iter_new() {

self.pred_then_atom_semantics_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pred_then_atom_semantics_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm5, ) in self.rule_descendant_then_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_all_0(tm4, ) {

self.pred_then_atom_semantics_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm5, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_semantics_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm5, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_semantics_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, tm1, tm2, ) in self.pred_then_atom_node.iter_old_0(tm0, ) {

self.pred_then_atom_semantics_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_8(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
self.pred_then_atom_semantics_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_9(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(_, _, tm7, ) in self.semantic_pred.iter_all_0_1(tm3, tm1, ) {

#[allow(unused_variables)]
for PredRel(_, tm6, ) in self.pred_rel.iter_all_0(tm7, ) {

self.pred_then_atom_semantics_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticPred(tm3, tm1, tm7, ) in self.semantic_pred.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, _, ) in self.scope_symbols.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for PredRel(_, tm6, ) in self.pred_rel.iter_old_0(tm7, ) {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, _, tm2, ) in self.pred_then_atom_node.iter_old_0_1(tm0, tm1, ) {

self.pred_then_atom_semantics_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredRel(tm7, tm6, ) in self.pred_rel.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for SemanticPred(_, tm1, _, ) in self.semantic_pred.iter_all_0_2(tm3, tm7, ) {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for PredThenAtomNode(_, _, tm2, ) in self.pred_then_atom_node.iter_old_0_1(tm0, tm1, ) {

self.pred_then_atom_semantics_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_12(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Rel, tm7: Pred) {
for _ in [()] {
self.pred_then_atom_semantics_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_13(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Rel, tm7: Pred) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(_, tm9, tm8, ) in self.semantic_els.iter_all_0(tm2, ) {

self.pred_then_atom_semantics_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEls(tm2, tm9, tm8, ) in self.semantic_els.iter_new() {

#[allow(unused_variables)]
for PredRel(tm7, tm6, ) in self.pred_rel.iter_old() {

#[allow(unused_variables)]
for PredThenAtomNode(tm0, tm1, _, ) in self.pred_then_atom_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm5, ) in self.rule_descendant_then_atom.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for SemanticPred(tm3, _, _, ) in self.semantic_pred.iter_old_1_2(tm1, tm7, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, _, ) in self.scope_symbols.iter_old_0_1(tm4, tm3, ) {

self.pred_then_atom_semantics_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pred_then_atom_semantics_15(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Rel, tm7: Pred, tm8: ElList, tm9: Structure) {
for _ in [()] {
let exists_already = self.rel_app.iter_all_0_1(tm6, tm8).next().is_some();
if !exists_already {
delta.new_rel_app.push(RelApp(tm6, tm8));
}



}
}


#[allow(unused_variables)]
fn rel_app_parent_model_el_law_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.rel_app_parent_model_el_law_1(delta, );
self.rel_app_parent_model_el_law_2(delta, );
self.rel_app_parent_model_el_law_5(delta, );
self.rel_app_parent_model_el_law_8(delta, );
self.rel_app_parent_model_el_law_11(delta, );






}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelApp(tm0, tm1, ) in self.rel_app.iter_new() {

self.rel_app_parent_model_el_law_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_3(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
self.rel_app_parent_model_el_law_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_4(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList) {
for _ in [()] {
#[allow(unused_variables)]
for ElsStructure(_, tm2, ) in self.els_structure.iter_all_0(tm1, ) {

self.rel_app_parent_model_el_law_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElsStructure(tm1, tm2, ) in self.els_structure.iter_new() {

#[allow(unused_variables)]
for RelApp(tm0, _, ) in self.rel_app.iter_old_1(tm1, ) {

self.rel_app_parent_model_el_law_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_6(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: Structure) {
for _ in [()] {
self.rel_app_parent_model_el_law_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_7(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for RelDefinitionSymbolScope(_, tm3, ) in self.rel_definition_symbol_scope.iter_all_0(tm0, ) {

self.rel_app_parent_model_el_law_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm0, tm3, ) in self.rel_definition_symbol_scope.iter_new() {

#[allow(unused_variables)]
for RelApp(_, tm1, ) in self.rel_app.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ElsStructure(_, tm2, ) in self.els_structure.iter_old_0(tm1, ) {

self.rel_app_parent_model_el_law_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_9(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: Structure, tm3: SymbolScope) {
for _ in [()] {
self.rel_app_parent_model_el_law_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_10(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: Structure, tm3: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(_, _, tm4, ) in self.ambient_model_el.iter_all_0_1(tm3, tm2, ) {

self.rel_app_parent_model_el_law_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientModelEl(tm3, tm2, tm4, ) in self.ambient_model_el.iter_new() {

#[allow(unused_variables)]
for RelDefinitionSymbolScope(tm0, _, ) in self.rel_definition_symbol_scope.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for RelApp(_, tm1, ) in self.rel_app.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ElsStructure(_, _, ) in self.els_structure.iter_old_0_1(tm1, tm2, ) {

self.rel_app_parent_model_el_law_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn rel_app_parent_model_el_law_12(&self, delta: &mut ModelDelta, tm0: Rel, tm1: ElList, tm2: Structure, tm3: SymbolScope, tm4: El) {
for _ in [()] {
let exists_already = self.rel_app_parent_model_el.iter_all_0_1_2(tm0, tm1, tm4).next().is_some();
if !exists_already {
delta.new_rel_app_parent_model_el.push(RelAppParentModelEl(tm0, tm1, tm4));
}



}
}


#[allow(unused_variables)]
fn terms_should_be_epic_ok_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.terms_should_be_epic_ok_cons_1(delta, );
self.terms_should_be_epic_ok_cons_2(delta, );
self.terms_should_be_epic_ok_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermsShouldBeEpicOk(tm0, ) in self.terms_should_be_epic_ok.iter_new() {

self.terms_should_be_epic_ok_cons_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_cons_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
self.terms_should_be_epic_ok_cons_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_cons_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTermListNode(_, tm1, tm2, ) in self.cons_term_list_node.iter_all_0(tm0, ) {

self.terms_should_be_epic_ok_cons_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTermListNode(tm0, tm1, tm2, ) in self.cons_term_list_node.iter_new() {

#[allow(unused_variables)]
for TermsShouldBeEpicOk(_, ) in self.terms_should_be_epic_ok.iter_old_0(tm0, ) {

self.terms_should_be_epic_ok_cons_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_cons_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
let exists_already = self.term_should_be_epic_ok.iter_all_0(tm1).next().is_some();
if !exists_already {
delta.new_term_should_be_epic_ok.push(TermShouldBeEpicOk(tm1));
}

let exists_already = self.terms_should_be_epic_ok.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_terms_should_be_epic_ok.push(TermsShouldBeEpicOk(tm2));
}




}
}


#[allow(unused_variables)]
fn terms_should_be_epic_ok_app_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.terms_should_be_epic_ok_app_1(delta, );
self.terms_should_be_epic_ok_app_2(delta, );
self.terms_should_be_epic_ok_app_5(delta, );




}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_app_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_app_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermShouldBeEpicOk(tm0, ) in self.term_should_be_epic_ok.iter_new() {

self.terms_should_be_epic_ok_app_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_app_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
self.terms_should_be_epic_ok_app_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_app_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_all_0(tm0, ) {

self.terms_should_be_epic_ok_app_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_app_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm0, tm1, tm2, ) in self.app_term_node.iter_new() {

#[allow(unused_variables)]
for TermShouldBeEpicOk(_, ) in self.term_should_be_epic_ok.iter_old_0(tm0, ) {

self.terms_should_be_epic_ok_app_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn terms_should_be_epic_ok_app_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
let exists_already = self.terms_should_be_epic_ok.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_terms_should_be_epic_ok.push(TermsShouldBeEpicOk(tm2));
}



}
}


#[allow(unused_variables)]
fn then_atom_epic_ok_equal_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_atom_epic_ok_equal_1(delta, );
self.then_atom_epic_ok_equal_2(delta, );



}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_equal_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_equal_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EqualThenAtomNode(tm0, tm1, tm2, ) in self.equal_then_atom_node.iter_new() {

self.then_atom_epic_ok_equal_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_equal_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: TermNode, tm2: TermNode) {
for _ in [()] {
let exists_already = self.term_should_be_epic_ok.iter_all_0(tm1).next().is_some();
if !exists_already {
delta.new_term_should_be_epic_ok.push(TermShouldBeEpicOk(tm1));
}

let exists_already = self.term_should_be_epic_ok.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_term_should_be_epic_ok.push(TermShouldBeEpicOk(tm2));
}




}
}


#[allow(unused_variables)]
fn then_atom_epic_ok_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_atom_epic_ok_defined_1(delta, );
self.then_atom_epic_ok_defined_2(delta, );



}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, tm1, tm2, ) in self.defined_then_atom_node.iter_new() {

self.then_atom_epic_ok_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_defined_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
let exists_already = self.term_should_be_epic_ok.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_term_should_be_epic_ok.push(TermShouldBeEpicOk(tm2));
}



}
}


#[allow(unused_variables)]
fn then_atom_epic_ok_pred_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.then_atom_epic_ok_pred_1(delta, );
self.then_atom_epic_ok_pred_2(delta, );



}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_pred_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_pred_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for PredThenAtomNode(tm0, tm1, tm2, ) in self.pred_then_atom_node.iter_new() {

self.then_atom_epic_ok_pred_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn then_atom_epic_ok_pred_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
let exists_already = self.terms_should_be_epic_ok.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_terms_should_be_epic_ok.push(TermsShouldBeEpicOk(tm2));
}



}
}


#[allow(unused_variables)]
fn surjective_codomain_should_be_ok_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.surjective_codomain_should_be_ok_1(delta, );
self.surjective_codomain_should_be_ok_2(delta, );
self.surjective_codomain_should_be_ok_5(delta, );
self.surjective_codomain_should_be_ok_6(delta, );





}
}

#[allow(unused_variables)]
fn surjective_codomain_should_be_ok_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn surjective_codomain_should_be_ok_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SurjThenMorphism(tm0, ) in self.surj_then_morphism.iter_new() {

self.surjective_codomain_should_be_ok_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn surjective_codomain_should_be_ok_3(&self, delta: &mut ModelDelta, tm0: Morphism) {
for _ in [()] {
self.surjective_codomain_should_be_ok_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn surjective_codomain_should_be_ok_4(&self, delta: &mut ModelDelta, tm0: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(_, tm1, ) in self.cod.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for ElStructure(tm2, _, ) in self.el_structure.iter_all_1(tm1, ) {

self.surjective_codomain_should_be_ok_7(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn surjective_codomain_should_be_ok_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(tm2, tm1, ) in self.el_structure.iter_new() {

#[allow(unused_variables)]
for SurjThenMorphism(tm0, ) in self.surj_then_morphism.iter_old() {

#[allow(unused_variables)]
for Cod(_, _, ) in self.cod.iter_old_0_1(tm0, tm1, ) {

self.surjective_codomain_should_be_ok_7(delta, tm0, tm1, tm2);


}

}

}

}
}

#[allow(unused_variables)]
fn surjective_codomain_should_be_ok_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm0, tm1, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for SurjThenMorphism(_, ) in self.surj_then_morphism.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ElStructure(tm2, _, ) in self.el_structure.iter_all_1(tm1, ) {

self.surjective_codomain_should_be_ok_7(delta, tm0, tm1, tm2);


}

}

}

}
}

#[allow(unused_variables)]
fn surjective_codomain_should_be_ok_7(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: Structure, tm2: El) {
for _ in [()] {
let exists_already = self.el_should_be_surjective_ok.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_el_should_be_surjective_ok.push(ElShouldBeSurjectiveOk(tm2));
}



}
}


#[allow(unused_variables)]
fn non_surjective_codomain_should_be_ok_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.non_surjective_codomain_should_be_ok_1(delta, );
self.non_surjective_codomain_should_be_ok_2(delta, );
self.non_surjective_codomain_should_be_ok_5(delta, );
self.non_surjective_codomain_should_be_ok_6(delta, );





}
}

#[allow(unused_variables)]
fn non_surjective_codomain_should_be_ok_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn non_surjective_codomain_should_be_ok_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NonSurjThenMorphism(tm0, ) in self.non_surj_then_morphism.iter_new() {

self.non_surjective_codomain_should_be_ok_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn non_surjective_codomain_should_be_ok_3(&self, delta: &mut ModelDelta, tm0: Morphism) {
for _ in [()] {
self.non_surjective_codomain_should_be_ok_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn non_surjective_codomain_should_be_ok_4(&self, delta: &mut ModelDelta, tm0: Morphism) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(_, tm1, ) in self.cod.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for ElStructure(tm2, _, ) in self.el_structure.iter_all_1(tm1, ) {

self.non_surjective_codomain_should_be_ok_7(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn non_surjective_codomain_should_be_ok_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElStructure(tm2, tm1, ) in self.el_structure.iter_new() {

#[allow(unused_variables)]
for NonSurjThenMorphism(tm0, ) in self.non_surj_then_morphism.iter_old() {

#[allow(unused_variables)]
for Cod(_, _, ) in self.cod.iter_old_0_1(tm0, tm1, ) {

self.non_surjective_codomain_should_be_ok_7(delta, tm0, tm1, tm2);


}

}

}

}
}

#[allow(unused_variables)]
fn non_surjective_codomain_should_be_ok_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Cod(tm0, tm1, ) in self.cod.iter_new() {

#[allow(unused_variables)]
for NonSurjThenMorphism(_, ) in self.non_surj_then_morphism.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for ElStructure(tm2, _, ) in self.el_structure.iter_all_1(tm1, ) {

self.non_surjective_codomain_should_be_ok_7(delta, tm0, tm1, tm2);


}

}

}

}
}

#[allow(unused_variables)]
fn non_surjective_codomain_should_be_ok_7(&self, delta: &mut ModelDelta, tm0: Morphism, tm1: Structure, tm2: El) {
for _ in [()] {
let exists_already = self.el_should_be_surjective_ok.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_el_should_be_surjective_ok.push(ElShouldBeSurjectiveOk(tm2));
}



}
}


#[allow(unused_variables)]
fn surjective_img_el_is_ok_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.surjective_img_el_is_ok_1(delta, );
self.surjective_img_el_is_ok_2(delta, );
self.surjective_img_el_is_ok_5(delta, );




}
}

#[allow(unused_variables)]
fn surjective_img_el_is_ok_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn surjective_img_el_is_ok_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElShouldBeSurjectiveOk(tm0, ) in self.el_should_be_surjective_ok.iter_new() {

self.surjective_img_el_is_ok_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn surjective_img_el_is_ok_3(&self, delta: &mut ModelDelta, tm0: El) {
for _ in [()] {
self.surjective_img_el_is_ok_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn surjective_img_el_is_ok_4(&self, delta: &mut ModelDelta, tm0: El) {
for _ in [()] {
#[allow(unused_variables)]
for ElInImg(tm1, _, ) in self.el_in_img.iter_all_1(tm0, ) {

self.surjective_img_el_is_ok_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn surjective_img_el_is_ok_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElInImg(tm1, tm0, ) in self.el_in_img.iter_new() {

#[allow(unused_variables)]
for ElShouldBeSurjectiveOk(_, ) in self.el_should_be_surjective_ok.iter_old_0(tm0, ) {

self.surjective_img_el_is_ok_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn surjective_img_el_is_ok_6(&self, delta: &mut ModelDelta, tm0: El, tm1: Morphism) {
for _ in [()] {
let exists_already = self.el_is_surjective_ok.iter_all_0(tm0).next().is_some();
if !exists_already {
delta.new_el_is_surjective_ok.push(ElIsSurjectiveOk(tm0));
}



}
}


#[allow(unused_variables)]
fn surjective_exempted_then_defined_term_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.surjective_exempted_then_defined_term_1(delta, );
self.surjective_exempted_then_defined_term_2(delta, );
self.surjective_exempted_then_defined_term_5(delta, );




}
}

#[allow(unused_variables)]
fn surjective_exempted_then_defined_term_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn surjective_exempted_then_defined_term_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, tm1, tm2, ) in self.defined_then_atom_node.iter_new() {

self.surjective_exempted_then_defined_term_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn surjective_exempted_then_defined_term_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
self.surjective_exempted_then_defined_term_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn surjective_exempted_then_defined_term_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm4, tm3, ) in self.semantic_el.iter_all_0(tm2, ) {

self.surjective_exempted_then_defined_term_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn surjective_exempted_then_defined_term_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm2, tm4, tm3, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, tm1, _, ) in self.defined_then_atom_node.iter_old_2(tm2, ) {

self.surjective_exempted_then_defined_term_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn surjective_exempted_then_defined_term_6(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: El, tm4: Structure) {
for _ in [()] {
let exists_already = self.el_is_surjective_ok.iter_all_0(tm3).next().is_some();
if !exists_already {
delta.new_el_is_surjective_ok.push(ElIsSurjectiveOk(tm3));
}



}
}


#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.defined_then_should_be_given_by_ctor_1(delta, );
self.defined_then_should_be_given_by_ctor_2(delta, );
self.defined_then_should_be_given_by_ctor_5(delta, );
self.defined_then_should_be_given_by_ctor_6(delta, );
self.defined_then_should_be_given_by_ctor_7(delta, );
self.defined_then_should_be_given_by_ctor_10(delta, );
self.defined_then_should_be_given_by_ctor_13(delta, );
self.defined_then_should_be_given_by_ctor_14(delta, );
self.defined_then_should_be_given_by_ctor_15(delta, );
self.defined_then_should_be_given_by_ctor_18(delta, );











}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DefinedThenAtomNode(tm0, tm1, tm2, ) in self.defined_then_atom_node.iter_new() {

self.defined_then_should_be_given_by_ctor_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_3(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
self.defined_then_should_be_given_by_ctor_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_4(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(_, tm5, ) in self.rule_descendant_then_atom.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_all_0(tm4, ) {

self.defined_then_should_be_given_by_ctor_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, tm5, ) in self.rule_descendant_then_atom.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, tm2, ) in self.defined_then_atom_node.iter_old_0(tm0, ) {

self.defined_then_should_be_given_by_ctor_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm5, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, tm2, ) in self.defined_then_atom_node.iter_old_0(tm0, ) {

self.defined_then_should_be_given_by_ctor_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, tm2, ) in self.defined_then_atom_node.iter_old_0(tm0, ) {

self.defined_then_should_be_given_by_ctor_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_8(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
self.defined_then_should_be_given_by_ctor_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_9(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm7, tm6, ) in self.semantic_el.iter_all_0(tm2, ) {

self.defined_then_should_be_given_by_ctor_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm2, tm7, tm6, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, _, ) in self.defined_then_atom_node.iter_old_0_2(tm0, tm2, ) {

self.defined_then_should_be_given_by_ctor_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_11(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: El, tm7: Structure) {
for _ in [()] {
self.defined_then_should_be_given_by_ctor_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_12(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: El, tm7: Structure) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(_, tm8, ) in self.el_type.iter_all_0(tm6, ) {

#[allow(unused_variables)]
for AmbientType(tm9, _, ) in self.ambient_type.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for SemanticType(_, tm10, _, ) in self.semantic_type.iter_all_0_2(tm3, tm9, ) {

self.defined_then_should_be_given_by_ctor_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(tm6, tm8, ) in self.el_type.iter_new() {

#[allow(unused_variables)]
for AmbientType(tm9, _, ) in self.ambient_type.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for SemanticEl(tm2, tm7, _, ) in self.semantic_el.iter_old_2(tm6, ) {

#[allow(unused_variables)]
for SemanticType(tm3, tm10, _, ) in self.semantic_type.iter_old_2(tm9, ) {

#[allow(unused_variables)]
for ScopeSymbols(tm4, _, ) in self.scope_symbols.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, _, ) in self.defined_then_atom_node.iter_old_0_2(tm0, tm2, ) {

self.defined_then_should_be_given_by_ctor_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm3, tm10, tm9, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, _, ) in self.scope_symbols.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AmbientType(_, tm8, ) in self.ambient_type.iter_old_0(tm9, ) {

#[allow(unused_variables)]
for ElType(tm6, _, ) in self.el_type.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for SemanticEl(tm2, tm7, _, ) in self.semantic_el.iter_old_2(tm6, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, _, ) in self.defined_then_atom_node.iter_old_0_2(tm0, tm2, ) {

self.defined_then_should_be_given_by_ctor_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm9, tm8, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for ElType(tm6, _, ) in self.el_type.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for SemanticEl(tm2, tm7, _, ) in self.semantic_el.iter_old_2(tm6, ) {

#[allow(unused_variables)]
for SemanticType(tm3, tm10, _, ) in self.semantic_type.iter_all_2(tm9, ) {

#[allow(unused_variables)]
for ScopeSymbols(tm4, _, ) in self.scope_symbols.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, _, ) in self.defined_then_atom_node.iter_old_0_2(tm0, tm2, ) {

self.defined_then_should_be_given_by_ctor_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_16(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: El, tm7: Structure, tm8: ElementType, tm9: Type, tm10: Ident) {
for _ in [()] {
self.defined_then_should_be_given_by_ctor_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_17(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: El, tm7: Structure, tm8: ElementType, tm9: Type, tm10: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm11, _, tm12, ) in self.enum_decl.iter_all_1(tm10, ) {

self.defined_then_should_be_given_by_ctor_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12);


}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_18(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm11, tm10, tm12, ) in self.enum_decl.iter_new() {

#[allow(unused_variables)]
for AmbientType(tm9, tm8, ) in self.ambient_type.iter_old() {

#[allow(unused_variables)]
for SemanticType(tm3, _, _, ) in self.semantic_type.iter_old_1_2(tm10, tm9, ) {

#[allow(unused_variables)]
for ScopeSymbols(tm4, _, ) in self.scope_symbols.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for ElType(tm6, _, ) in self.el_type.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantThenAtom(tm0, _, ) in self.rule_descendant_then_atom.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for DefinedThenAtomNode(_, tm1, tm2, ) in self.defined_then_atom_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm7, _, ) in self.semantic_el.iter_old_0_2(tm2, tm6, ) {

self.defined_then_should_be_given_by_ctor_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn defined_then_should_be_given_by_ctor_19(&self, delta: &mut ModelDelta, tm0: ThenAtomNode, tm1: OptTermNode, tm2: TermNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: El, tm7: Structure, tm8: ElementType, tm9: Type, tm10: Ident, tm11: EnumDeclNode, tm12: CtorDeclListNode) {
for _ in [()] {
let exists_already = self.should_be_obtained_by_ctor.iter_all_0_1(tm2, tm11).next().is_some();
if !exists_already {
delta.new_should_be_obtained_by_ctor.push(ShouldBeObtainedByCtor(tm2, tm11));
}



}
}


#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ctor_app_is_given_by_ctor_1(delta, );
self.ctor_app_is_given_by_ctor_2(delta, );
self.ctor_app_is_given_by_ctor_5(delta, );
self.ctor_app_is_given_by_ctor_8(delta, );





}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm0, tm1, tm2, ) in self.app_term_node.iter_new() {

self.ctor_app_is_given_by_ctor_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_3(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.ctor_app_is_given_by_ctor_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_4(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDecl(tm3, _, tm4, ) in self.ctor_decl.iter_all_1(tm1, ) {

self.ctor_app_is_given_by_ctor_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDecl(tm3, tm1, tm4, ) in self.ctor_decl.iter_new() {

#[allow(unused_variables)]
for AppTermNode(tm0, _, tm2, ) in self.app_term_node.iter_old_1(tm1, ) {

self.ctor_app_is_given_by_ctor_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: CtorDeclNode, tm4: ArgDeclListNode) {
for _ in [()] {
self.ctor_app_is_given_by_ctor_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: CtorDeclNode, tm4: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(_, tm5, ) in self.ctor_enum.iter_all_0(tm3, ) {

self.ctor_app_is_given_by_ctor_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(tm3, tm5, ) in self.ctor_enum.iter_new() {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm4, ) in self.ctor_decl.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for AppTermNode(tm0, _, tm2, ) in self.app_term_node.iter_old_1(tm1, ) {

self.ctor_app_is_given_by_ctor_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn ctor_app_is_given_by_ctor_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: CtorDeclNode, tm4: ArgDeclListNode, tm5: EnumDeclNode) {
for _ in [()] {
let exists_already = self.is_given_by_ctor.iter_all_0_1(tm0, tm5).next().is_some();
if !exists_already {
delta.new_is_given_by_ctor.push(IsGivenByCtor(tm0, tm5));
}



}
}


#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.function_can_be_made_defined_if_codomain_normal_type_1(delta, );
self.function_can_be_made_defined_if_codomain_normal_type_2(delta, );
self.function_can_be_made_defined_if_codomain_normal_type_5(delta, );
self.function_can_be_made_defined_if_codomain_normal_type_8(delta, );
self.function_can_be_made_defined_if_codomain_normal_type_11(delta, );
self.function_can_be_made_defined_if_codomain_normal_type_14(delta, );







}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclNodeType(tm0, tm1, ) in self.decl_node_type.iter_new() {

self.function_can_be_made_defined_if_codomain_normal_type_3(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_3(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode) {
for _ in [()] {
self.function_can_be_made_defined_if_codomain_normal_type_4(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_4(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDecl(_, tm2, ) in self.type_decl.iter_all_0(tm1, ) {

self.function_can_be_made_defined_if_codomain_normal_type_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TypeDecl(tm1, tm2, ) in self.type_decl.iter_new() {

#[allow(unused_variables)]
for DeclNodeType(tm0, _, ) in self.decl_node_type.iter_old_1(tm1, ) {

self.function_can_be_made_defined_if_codomain_normal_type_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_6(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident) {
for _ in [()] {
self.function_can_be_made_defined_if_codomain_normal_type_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_7(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(_, tm3, ) in self.decl_symbol_scope.iter_all_0(tm0, ) {

self.function_can_be_made_defined_if_codomain_normal_type_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm3, ) in self.decl_symbol_scope.iter_new() {

#[allow(unused_variables)]
for DeclNodeType(_, tm1, ) in self.decl_node_type.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for TypeDecl(_, tm2, ) in self.type_decl.iter_old_0(tm1, ) {

self.function_can_be_made_defined_if_codomain_normal_type_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_9(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope) {
for _ in [()] {
self.function_can_be_made_defined_if_codomain_normal_type_10(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_10(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, _, tm4, ) in self.semantic_type.iter_all_0_1(tm3, tm2, ) {

self.function_can_be_made_defined_if_codomain_normal_type_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm3, tm2, tm4, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, _, ) in self.decl_symbol_scope.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for TypeDecl(tm1, _, ) in self.type_decl.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for DeclNodeType(_, _, ) in self.decl_node_type.iter_old_0_1(tm0, tm1, ) {

self.function_can_be_made_defined_if_codomain_normal_type_12(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_12(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope, tm4: Type) {
for _ in [()] {
self.function_can_be_made_defined_if_codomain_normal_type_13(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_13(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope, tm4: Type) {
for _ in [()] {
#[allow(unused_variables)]
for Codomain(tm5, _, ) in self.codomain.iter_all_1(tm4, ) {

self.function_can_be_made_defined_if_codomain_normal_type_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_14(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for Codomain(tm5, tm4, ) in self.codomain.iter_new() {

#[allow(unused_variables)]
for DeclSymbolScope(tm0, tm3, ) in self.decl_symbol_scope.iter_old() {

#[allow(unused_variables)]
for SemanticType(_, tm2, _, ) in self.semantic_type.iter_old_0_2(tm3, tm4, ) {

#[allow(unused_variables)]
for TypeDecl(tm1, _, ) in self.type_decl.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for DeclNodeType(_, _, ) in self.decl_node_type.iter_old_0_1(tm0, tm1, ) {

self.function_can_be_made_defined_if_codomain_normal_type_15(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn function_can_be_made_defined_if_codomain_normal_type_15(&self, delta: &mut ModelDelta, tm0: DeclNode, tm1: TypeDeclNode, tm2: Ident, tm3: SymbolScope, tm4: Type, tm5: Func) {
for _ in [()] {
let exists_already = self.function_can_be_made_defined.iter_all_0(tm5).next().is_some();
if !exists_already {
delta.new_function_can_be_made_defined.push(FunctionCanBeMadeDefined(tm5));
}



}
}


#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.function_can_be_defined_if_constructor_1(delta, );
self.function_can_be_defined_if_constructor_2(delta, );
self.function_can_be_defined_if_constructor_5(delta, );
self.function_can_be_defined_if_constructor_8(delta, );





}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDecl(tm0, tm1, tm2, ) in self.ctor_decl.iter_new() {

self.function_can_be_defined_if_constructor_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_3(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode) {
for _ in [()] {
self.function_can_be_defined_if_constructor_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_4(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(_, tm3, ) in self.ctor_symbol_scope.iter_all_0(tm0, ) {

self.function_can_be_defined_if_constructor_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbolScope(tm0, tm3, ) in self.ctor_symbol_scope.iter_new() {

#[allow(unused_variables)]
for CtorDecl(_, tm1, tm2, ) in self.ctor_decl.iter_old_0(tm0, ) {

self.function_can_be_defined_if_constructor_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_6(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope) {
for _ in [()] {
self.function_can_be_defined_if_constructor_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_7(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(_, _, tm4, ) in self.semantic_func.iter_all_0_1(tm3, tm1, ) {

self.function_can_be_defined_if_constructor_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticFunc(tm3, tm1, tm4, ) in self.semantic_func.iter_new() {

#[allow(unused_variables)]
for CtorSymbolScope(tm0, _, ) in self.ctor_symbol_scope.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for CtorDecl(_, _, tm2, ) in self.ctor_decl.iter_old_0_1(tm0, tm1, ) {

self.function_can_be_defined_if_constructor_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn function_can_be_defined_if_constructor_9(&self, delta: &mut ModelDelta, tm0: CtorDeclNode, tm1: Ident, tm2: ArgDeclListNode, tm3: SymbolScope, tm4: Func) {
for _ in [()] {
let exists_already = self.function_can_be_made_defined.iter_all_0(tm4).next().is_some();
if !exists_already {
delta.new_function_can_be_made_defined.push(FunctionCanBeMadeDefined(tm4));
}



}
}


#[allow(unused_variables)]
fn case_pattern_is_variable_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.case_pattern_is_variable_defined_1(delta, );
self.case_pattern_is_variable_defined_2(delta, );
self.case_pattern_is_variable_defined_5(delta, );
self.case_pattern_is_variable_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm0, tm1, tm2, ) in self.match_case.iter_new() {

self.case_pattern_is_variable_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.case_pattern_is_variable_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for VarTermNode(_, tm3, ) in self.var_term_node.iter_all_0(tm1, ) {

self.case_pattern_is_variable_defined_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarTermNode(tm1, tm3, ) in self.var_term_node.iter_new() {

#[allow(unused_variables)]
for MatchCase(tm0, _, tm2, ) in self.match_case.iter_old_1(tm1, ) {

self.case_pattern_is_variable_defined_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_6(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: VirtIdent) {
for _ in [()] {
self.case_pattern_is_variable_defined_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_7(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: VirtIdent) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(_, tm4, ) in self.term_node_loc.iter_all_0(tm1, ) {

self.case_pattern_is_variable_defined_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm1, tm4, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for VarTermNode(_, tm3, ) in self.var_term_node.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for MatchCase(tm0, _, tm2, ) in self.match_case.iter_old_1(tm1, ) {

self.case_pattern_is_variable_defined_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_is_variable_defined_9(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: VirtIdent, tm4: Loc) {
for _ in [()] {
let exists_already = self.case_pattern_is_variable.iter_all_0(tm4).next().is_some();
if !exists_already {
delta.new_case_pattern_is_variable.push(CasePatternIsVariable(tm4));
}



}
}


#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.case_pattern_is_wildcard_defined_1(delta, );
self.case_pattern_is_wildcard_defined_2(delta, );
self.case_pattern_is_wildcard_defined_5(delta, );
self.case_pattern_is_wildcard_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm0, tm1, tm2, ) in self.match_case.iter_new() {

self.case_pattern_is_wildcard_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.case_pattern_is_wildcard_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for WildcardTermNode(_, ) in self.wildcard_term_node.iter_all_0(tm1, ) {

self.case_pattern_is_wildcard_defined_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for WildcardTermNode(tm1, ) in self.wildcard_term_node.iter_new() {

#[allow(unused_variables)]
for MatchCase(tm0, _, tm2, ) in self.match_case.iter_old_1(tm1, ) {

self.case_pattern_is_wildcard_defined_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_6(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.case_pattern_is_wildcard_defined_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_7(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(_, tm3, ) in self.term_node_loc.iter_all_0(tm1, ) {

self.case_pattern_is_wildcard_defined_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm1, tm3, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for WildcardTermNode(_, ) in self.wildcard_term_node.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for MatchCase(tm0, _, tm2, ) in self.match_case.iter_old_1(tm1, ) {

self.case_pattern_is_wildcard_defined_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_is_wildcard_defined_9(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: Loc) {
for _ in [()] {
let exists_already = self.case_pattern_is_wildcard.iter_all_0(tm3).next().is_some();
if !exists_already {
delta.new_case_pattern_is_wildcard.push(CasePatternIsWildcard(tm3));
}



}
}


#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.case_pattern_app_should_be_constructor_1(delta, );
self.case_pattern_app_should_be_constructor_2(delta, );
self.case_pattern_app_should_be_constructor_5(delta, );
self.case_pattern_app_should_be_constructor_6(delta, );
self.case_pattern_app_should_be_constructor_7(delta, );
self.case_pattern_app_should_be_constructor_10(delta, );
self.case_pattern_app_should_be_constructor_13(delta, );
self.case_pattern_app_should_be_constructor_16(delta, );









}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm0, tm1, tm2, ) in self.match_case.iter_new() {

self.case_pattern_app_should_be_constructor_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.case_pattern_app_should_be_constructor_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCase(_, tm5, ) in self.rule_descendant_match_case.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_all_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_all_0(tm4, ) {

self.case_pattern_app_should_be_constructor_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantMatchCase(tm0, tm5, ) in self.rule_descendant_match_case.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm4, ) in self.entry_scope.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

self.case_pattern_app_should_be_constructor_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm5, tm4, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm3, ) in self.scope_symbols.iter_old_0(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantMatchCase(tm0, _, ) in self.rule_descendant_match_case.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

self.case_pattern_app_should_be_constructor_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantMatchCase(tm0, _, ) in self.rule_descendant_match_case.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

self.case_pattern_app_should_be_constructor_8(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}

}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_8(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
self.case_pattern_app_should_be_constructor_9(delta, tm0, tm1, tm2, tm3, tm4, tm5);


}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_9(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(_, tm6, tm7, ) in self.app_term_node.iter_all_0(tm1, ) {

self.case_pattern_app_should_be_constructor_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm1, tm6, tm7, ) in self.app_term_node.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantMatchCase(tm0, _, ) in self.rule_descendant_match_case.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for MatchCase(_, _, tm2, ) in self.match_case.iter_old_0_1(tm0, tm1, ) {

self.case_pattern_app_should_be_constructor_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_11(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Ident, tm7: TermListNode) {
for _ in [()] {
self.case_pattern_app_should_be_constructor_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7);


}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_12(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Ident, tm7: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(_, tm8, ) in self.term_node_loc.iter_all_0(tm1, ) {

self.case_pattern_app_should_be_constructor_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm1, tm8, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantMatchCase(tm0, _, ) in self.rule_descendant_match_case.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for MatchCase(_, _, tm2, ) in self.match_case.iter_old_0_1(tm0, tm1, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm6, tm7, ) in self.app_term_node.iter_old_0(tm1, ) {

self.case_pattern_app_should_be_constructor_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_14(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Ident, tm7: TermListNode, tm8: Loc) {
for _ in [()] {
self.case_pattern_app_should_be_constructor_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_15(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Ident, tm7: TermListNode, tm8: Loc) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbol(tm9, ) in self.ctor_symbol.iter_all() {

self.case_pattern_app_should_be_constructor_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_16(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorSymbol(tm9, ) in self.ctor_symbol.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm4, tm3, ) in self.scope_symbols.iter_old() {

#[allow(unused_variables)]
for EntryScope(tm5, _, ) in self.entry_scope.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for RuleDescendantMatchCase(tm0, _, ) in self.rule_descendant_match_case.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for MatchCase(_, tm1, tm2, ) in self.match_case.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for TermNodeLoc(_, tm8, ) in self.term_node_loc.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm6, tm7, ) in self.app_term_node.iter_old_0(tm1, ) {

self.case_pattern_app_should_be_constructor_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn case_pattern_app_should_be_constructor_17(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: SymbolScope, tm4: Scope, tm5: RuleDescendantNode, tm6: Ident, tm7: TermListNode, tm8: Loc, tm9: SymbolKind) {
for _ in [()] {
let exists_already = self.should_be_symbol.iter_all_0_1_2_3(tm6, tm9, tm3, tm8).next().is_some();
if !exists_already {
delta.new_should_be_symbol.push(ShouldBeSymbol(tm6, tm9, tm3, tm8));
}



}
}


#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_case_pattern_ctor_defined_1(delta, );
self.match_case_pattern_ctor_defined_2(delta, );
self.match_case_pattern_ctor_defined_5(delta, );
self.match_case_pattern_ctor_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm0, tm1, tm2, ) in self.match_case.iter_new() {

self.match_case_pattern_ctor_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.match_case_pattern_ctor_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(_, tm3, tm4, ) in self.app_term_node.iter_all_0(tm1, ) {

self.match_case_pattern_ctor_defined_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm1, tm3, tm4, ) in self.app_term_node.iter_new() {

#[allow(unused_variables)]
for MatchCase(tm0, _, tm2, ) in self.match_case.iter_old_1(tm1, ) {

self.match_case_pattern_ctor_defined_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_6(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: Ident, tm4: TermListNode) {
for _ in [()] {
self.match_case_pattern_ctor_defined_7(delta, tm0, tm1, tm2, tm3, tm4);


}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_7(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: Ident, tm4: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDecl(tm5, _, tm6, ) in self.ctor_decl.iter_all_1(tm3, ) {

self.match_case_pattern_ctor_defined_9(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorDecl(tm5, tm3, tm6, ) in self.ctor_decl.iter_new() {

#[allow(unused_variables)]
for AppTermNode(tm1, _, tm4, ) in self.app_term_node.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for MatchCase(tm0, _, tm2, ) in self.match_case.iter_old_1(tm1, ) {

self.match_case_pattern_ctor_defined_9(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn match_case_pattern_ctor_defined_9(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: Ident, tm4: TermListNode, tm5: CtorDeclNode, tm6: ArgDeclListNode) {
for _ in [()] {
let exists_already = self.match_case_pattern_ctor.iter_all_0_1(tm0, tm5).next().is_some();
if !exists_already {
delta.new_match_case_pattern_ctor.push(MatchCasePatternCtor(tm0, tm5));
}



}
}


#[allow(unused_variables)]
fn is_pattern_ctor_arg_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.is_pattern_ctor_arg_cons_1(delta, );
self.is_pattern_ctor_arg_cons_2(delta, );
self.is_pattern_ctor_arg_cons_5(delta, );




}
}

#[allow(unused_variables)]
fn is_pattern_ctor_arg_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn is_pattern_ctor_arg_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ArePatternCtorArgs(tm0, ) in self.are_pattern_ctor_args.iter_new() {

self.is_pattern_ctor_arg_cons_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn is_pattern_ctor_arg_cons_3(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
self.is_pattern_ctor_arg_cons_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn is_pattern_ctor_arg_cons_4(&self, delta: &mut ModelDelta, tm0: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTermListNode(_, tm1, tm2, ) in self.cons_term_list_node.iter_all_0(tm0, ) {

self.is_pattern_ctor_arg_cons_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn is_pattern_ctor_arg_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsTermListNode(tm0, tm1, tm2, ) in self.cons_term_list_node.iter_new() {

#[allow(unused_variables)]
for ArePatternCtorArgs(_, ) in self.are_pattern_ctor_args.iter_old_0(tm0, ) {

self.is_pattern_ctor_arg_cons_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn is_pattern_ctor_arg_cons_6(&self, delta: &mut ModelDelta, tm0: TermListNode, tm1: TermNode, tm2: TermListNode) {
for _ in [()] {
let exists_already = self.is_pattern_ctor_arg.iter_all_0(tm1).next().is_some();
if !exists_already {
delta.new_is_pattern_ctor_arg.push(IsPatternCtorArg(tm1));
}

let exists_already = self.are_pattern_ctor_args.iter_all_0(tm2).next().is_some();
if !exists_already {
delta.new_are_pattern_ctor_args.push(ArePatternCtorArgs(tm2));
}




}
}


#[allow(unused_variables)]
fn are_pattern_ctor_args_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.are_pattern_ctor_args_defined_1(delta, );
self.are_pattern_ctor_args_defined_2(delta, );
self.are_pattern_ctor_args_defined_5(delta, );




}
}

#[allow(unused_variables)]
fn are_pattern_ctor_args_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn are_pattern_ctor_args_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCase(tm0, tm1, tm2, ) in self.match_case.iter_new() {

self.are_pattern_ctor_args_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn are_pattern_ctor_args_defined_3(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
self.are_pattern_ctor_args_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn are_pattern_ctor_args_defined_4(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(_, tm3, tm4, ) in self.app_term_node.iter_all_0(tm1, ) {

self.are_pattern_ctor_args_defined_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn are_pattern_ctor_args_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm1, tm3, tm4, ) in self.app_term_node.iter_new() {

#[allow(unused_variables)]
for MatchCase(tm0, _, tm2, ) in self.match_case.iter_old_1(tm1, ) {

self.are_pattern_ctor_args_defined_6(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn are_pattern_ctor_args_defined_6(&self, delta: &mut ModelDelta, tm0: MatchCaseNode, tm1: TermNode, tm2: StmtListNode, tm3: Ident, tm4: TermListNode) {
for _ in [()] {
let exists_already = self.are_pattern_ctor_args.iter_all_0(tm4).next().is_some();
if !exists_already {
delta.new_are_pattern_ctor_args.push(ArePatternCtorArgs(tm4));
}



}
}


#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pattern_ctor_arg_is_app_defined_1(delta, );
self.pattern_ctor_arg_is_app_defined_2(delta, );
self.pattern_ctor_arg_is_app_defined_5(delta, );
self.pattern_ctor_arg_is_app_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IsPatternCtorArg(tm0, ) in self.is_pattern_ctor_arg.iter_new() {

self.pattern_ctor_arg_is_app_defined_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
self.pattern_ctor_arg_is_app_defined_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_all_0(tm0, ) {

self.pattern_ctor_arg_is_app_defined_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AppTermNode(tm0, tm1, tm2, ) in self.app_term_node.iter_new() {

#[allow(unused_variables)]
for IsPatternCtorArg(_, ) in self.is_pattern_ctor_arg.iter_old_0(tm0, ) {

self.pattern_ctor_arg_is_app_defined_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
self.pattern_ctor_arg_is_app_defined_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(_, tm3, ) in self.term_node_loc.iter_all_0(tm0, ) {

self.pattern_ctor_arg_is_app_defined_9(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm0, tm3, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for IsPatternCtorArg(_, ) in self.is_pattern_ctor_arg.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for AppTermNode(_, tm1, tm2, ) in self.app_term_node.iter_old_0(tm0, ) {

self.pattern_ctor_arg_is_app_defined_9(delta, tm0, tm1, tm2, tm3);


}

}

}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_is_app_defined_9(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: Ident, tm2: TermListNode, tm3: Loc) {
for _ in [()] {
let exists_already = self.pattern_ctor_arg_is_app.iter_all_0(tm3).next().is_some();
if !exists_already {
delta.new_pattern_ctor_arg_is_app.push(PatternCtorArgIsApp(tm3));
}



}
}


#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.pattern_ctor_arg_var_is_not_fresh_defined_1(delta, );
self.pattern_ctor_arg_var_is_not_fresh_defined_2(delta, );
self.pattern_ctor_arg_var_is_not_fresh_defined_5(delta, );
self.pattern_ctor_arg_var_is_not_fresh_defined_8(delta, );
self.pattern_ctor_arg_var_is_not_fresh_defined_9(delta, );
self.pattern_ctor_arg_var_is_not_fresh_defined_12(delta, );
self.pattern_ctor_arg_var_is_not_fresh_defined_15(delta, );








}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for IsPatternCtorArg(tm0, ) in self.is_pattern_ctor_arg.iter_new() {

self.pattern_ctor_arg_var_is_not_fresh_defined_3(delta, tm0);


}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_3(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
self.pattern_ctor_arg_var_is_not_fresh_defined_4(delta, tm0);


}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_4(&self, delta: &mut ModelDelta, tm0: TermNode) {
for _ in [()] {
#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_all_0(tm0, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_6(delta, tm0, tm1);


}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarTermNode(tm0, tm1, ) in self.var_term_node.iter_new() {

#[allow(unused_variables)]
for IsPatternCtorArg(_, ) in self.is_pattern_ctor_arg.iter_old_0(tm0, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_6(delta, tm0, tm1);


}

}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_6(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
for _ in [()] {
self.pattern_ctor_arg_var_is_not_fresh_defined_7(delta, tm0, tm1);


}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_7(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm3, ) in self.rule_descendant_term.iter_all_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm2, ) in self.entry_scope.iter_all_0(tm3, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_10(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm0, tm3, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for IsPatternCtorArg(_, ) in self.is_pattern_ctor_arg.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm2, ) in self.entry_scope.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_old_0(tm0, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_10(delta, tm0, tm1, tm2, tm3);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm3, tm2, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for IsPatternCtorArg(tm0, ) in self.is_pattern_ctor_arg.iter_old() {

#[allow(unused_variables)]
for RuleDescendantTerm(_, _, ) in self.rule_descendant_term.iter_all_0_1(tm0, tm3, ) {

#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_old_0(tm0, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_10(delta, tm0, tm1, tm2, tm3);


}

}

}

}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_10(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode) {
for _ in [()] {
self.pattern_ctor_arg_var_is_not_fresh_defined_11(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_11(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for VarInScope(_, _, ) in self.var_in_scope.iter_all_0_1(tm1, tm2, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_13(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for VarInScope(tm1, tm2, ) in self.var_in_scope.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm3, _, ) in self.entry_scope.iter_old_1(tm2, ) {

#[allow(unused_variables)]
for VarTermNode(tm0, _, ) in self.var_term_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for IsPatternCtorArg(_, ) in self.is_pattern_ctor_arg.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, _, ) in self.rule_descendant_term.iter_old_0_1(tm0, tm3, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_13(delta, tm0, tm1, tm2, tm3);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_13(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode) {
for _ in [()] {
self.pattern_ctor_arg_var_is_not_fresh_defined_14(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_14(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(_, tm4, ) in self.term_node_loc.iter_all_0(tm0, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_16(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for TermNodeLoc(tm0, tm4, ) in self.term_node_loc.iter_new() {

#[allow(unused_variables)]
for IsPatternCtorArg(_, ) in self.is_pattern_ctor_arg.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm3, ) in self.rule_descendant_term.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for EntryScope(_, tm2, ) in self.entry_scope.iter_old_0(tm3, ) {

#[allow(unused_variables)]
for VarTermNode(_, tm1, ) in self.var_term_node.iter_old_0(tm0, ) {

#[allow(unused_variables)]
for VarInScope(_, _, ) in self.var_in_scope.iter_old_0_1(tm1, tm2, ) {

self.pattern_ctor_arg_var_is_not_fresh_defined_16(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn pattern_ctor_arg_var_is_not_fresh_defined_16(&self, delta: &mut ModelDelta, tm0: TermNode, tm1: VirtIdent, tm2: Scope, tm3: RuleDescendantNode, tm4: Loc) {
for _ in [()] {
let exists_already = self.pattern_ctor_arg_var_is_not_fresh.iter_all_0(tm4).next().is_some();
if !exists_already {
delta.new_pattern_ctor_arg_var_is_not_fresh.push(PatternCtorArgVarIsNotFresh(tm4));
}



}
}


#[allow(unused_variables)]
fn contains_ctor_case_head_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.contains_ctor_case_head_1(delta, );
self.contains_ctor_case_head_2(delta, );
self.contains_ctor_case_head_5(delta, );




}
}

#[allow(unused_variables)]
fn contains_ctor_case_head_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn contains_ctor_case_head_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, tm1, tm2, ) in self.cons_match_case_list_node.iter_new() {

self.contains_ctor_case_head_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn contains_ctor_case_head_3(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.contains_ctor_case_head_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn contains_ctor_case_head_4(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCasePatternCtor(_, tm3, ) in self.match_case_pattern_ctor.iter_all_0(tm1, ) {

self.contains_ctor_case_head_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn contains_ctor_case_head_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCasePatternCtor(tm1, tm3, ) in self.match_case_pattern_ctor.iter_new() {

#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, _, tm2, ) in self.cons_match_case_list_node.iter_old_1(tm1, ) {

self.contains_ctor_case_head_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn contains_ctor_case_head_6(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: CtorDeclNode) {
for _ in [()] {
let exists_already = self.cases_contain_ctor.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_cases_contain_ctor.push(CasesContainCtor(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn contains_ctor_case_tail_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.contains_ctor_case_tail_1(delta, );
self.contains_ctor_case_tail_2(delta, );
self.contains_ctor_case_tail_5(delta, );




}
}

#[allow(unused_variables)]
fn contains_ctor_case_tail_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn contains_ctor_case_tail_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, tm1, tm2, ) in self.cons_match_case_list_node.iter_new() {

self.contains_ctor_case_tail_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn contains_ctor_case_tail_3(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.contains_ctor_case_tail_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn contains_ctor_case_tail_4(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CasesContainCtor(_, tm3, ) in self.cases_contain_ctor.iter_all_0(tm2, ) {

self.contains_ctor_case_tail_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn contains_ctor_case_tail_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CasesContainCtor(tm2, tm3, ) in self.cases_contain_ctor.iter_new() {

#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, tm1, _, ) in self.cons_match_case_list_node.iter_old_2(tm2, ) {

self.contains_ctor_case_tail_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn contains_ctor_case_tail_6(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: CtorDeclNode) {
for _ in [()] {
let exists_already = self.cases_contain_ctor.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_cases_contain_ctor.push(CasesContainCtor(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_stmt_contains_ctor_of_enum_defined_1(delta, );
self.match_stmt_contains_ctor_of_enum_defined_2(delta, );
self.match_stmt_contains_ctor_of_enum_defined_5(delta, );
self.match_stmt_contains_ctor_of_enum_defined_8(delta, );





}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.match_stmt_contains_ctor_of_enum_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.match_stmt_contains_ctor_of_enum_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CasesContainCtor(_, tm3, ) in self.cases_contain_ctor.iter_all_0(tm2, ) {

self.match_stmt_contains_ctor_of_enum_defined_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CasesContainCtor(tm2, tm3, ) in self.cases_contain_ctor.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, _, ) in self.match_stmt_node.iter_old_2(tm2, ) {

self.match_stmt_contains_ctor_of_enum_defined_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: CtorDeclNode) {
for _ in [()] {
self.match_stmt_contains_ctor_of_enum_defined_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: CtorDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(_, tm4, ) in self.ctor_enum.iter_all_0(tm3, ) {

self.match_stmt_contains_ctor_of_enum_defined_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(tm3, tm4, ) in self.ctor_enum.iter_new() {

#[allow(unused_variables)]
for CasesContainCtor(tm2, _, ) in self.cases_contain_ctor.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, _, ) in self.match_stmt_node.iter_old_2(tm2, ) {

self.match_stmt_contains_ctor_of_enum_defined_9(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_of_enum_defined_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: CtorDeclNode, tm4: EnumDeclNode) {
for _ in [()] {
let exists_already = self.match_stmt_contains_ctor_of_enum.iter_all_0_1_2(tm0, tm3, tm4).next().is_some();
if !exists_already {
delta.new_match_stmt_contains_ctor_of_enum.push(MatchStmtContainsCtorOfEnum(tm0, tm3, tm4));
}



}
}


#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ctor_cases_determine_enum_singleton_1(delta, );
self.ctor_cases_determine_enum_singleton_2(delta, );
self.ctor_cases_determine_enum_singleton_5(delta, );
self.ctor_cases_determine_enum_singleton_8(delta, );
self.ctor_cases_determine_enum_singleton_9(delta, );






}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, tm1, tm2, ) in self.cons_match_case_list_node.iter_new() {

self.ctor_cases_determine_enum_singleton_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_3(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.ctor_cases_determine_enum_singleton_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_4(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for NilMatchCaseListNode(_, ) in self.nil_match_case_list_node.iter_all_0(tm2, ) {

self.ctor_cases_determine_enum_singleton_6(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for NilMatchCaseListNode(tm2, ) in self.nil_match_case_list_node.iter_new() {

#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, tm1, _, ) in self.cons_match_case_list_node.iter_old_2(tm2, ) {

self.ctor_cases_determine_enum_singleton_6(delta, tm0, tm1, tm2);


}

}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_6(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.ctor_cases_determine_enum_singleton_7(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_7(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCasePatternCtor(_, tm4, ) in self.match_case_pattern_ctor.iter_all_0(tm1, ) {

#[allow(unused_variables)]
for CtorEnum(_, tm3, ) in self.ctor_enum.iter_all_0(tm4, ) {

self.ctor_cases_determine_enum_singleton_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(tm4, tm3, ) in self.ctor_enum.iter_new() {

#[allow(unused_variables)]
for NilMatchCaseListNode(tm2, ) in self.nil_match_case_list_node.iter_old() {

#[allow(unused_variables)]
for MatchCasePatternCtor(tm1, _, ) in self.match_case_pattern_ctor.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, _, _, ) in self.cons_match_case_list_node.iter_old_1_2(tm1, tm2, ) {

self.ctor_cases_determine_enum_singleton_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCasePatternCtor(tm1, tm4, ) in self.match_case_pattern_ctor.iter_new() {

#[allow(unused_variables)]
for NilMatchCaseListNode(tm2, ) in self.nil_match_case_list_node.iter_old() {

#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, _, _, ) in self.cons_match_case_list_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for CtorEnum(_, tm3, ) in self.ctor_enum.iter_all_0(tm4, ) {

self.ctor_cases_determine_enum_singleton_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_singleton_10(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: CtorDeclNode) {
for _ in [()] {
let exists_already = self.cases_determined_enum.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_cases_determined_enum.push(CasesDeterminedEnum(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.ctor_cases_determine_enum_cons_1(delta, );
self.ctor_cases_determine_enum_cons_2(delta, );
self.ctor_cases_determine_enum_cons_5(delta, );
self.ctor_cases_determine_enum_cons_8(delta, );
self.ctor_cases_determine_enum_cons_9(delta, );






}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, tm1, tm2, ) in self.cons_match_case_list_node.iter_new() {

self.ctor_cases_determine_enum_cons_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_3(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.ctor_cases_determine_enum_cons_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_4(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CasesDeterminedEnum(_, tm3, ) in self.cases_determined_enum.iter_all_0(tm2, ) {

self.ctor_cases_determine_enum_cons_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, tm3, ) in self.cases_determined_enum.iter_new() {

#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, tm1, _, ) in self.cons_match_case_list_node.iter_old_2(tm2, ) {

self.ctor_cases_determine_enum_cons_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_6(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: EnumDeclNode) {
for _ in [()] {
self.ctor_cases_determine_enum_cons_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_7(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: EnumDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCasePatternCtor(_, tm4, ) in self.match_case_pattern_ctor.iter_all_0(tm1, ) {

#[allow(unused_variables)]
for CtorEnum(_, _, ) in self.ctor_enum.iter_all_0_1(tm4, tm3, ) {

self.ctor_cases_determine_enum_cons_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(tm4, tm3, ) in self.ctor_enum.iter_new() {

#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, _, ) in self.cases_determined_enum.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for MatchCasePatternCtor(tm1, _, ) in self.match_case_pattern_ctor.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, _, _, ) in self.cons_match_case_list_node.iter_old_1_2(tm1, tm2, ) {

self.ctor_cases_determine_enum_cons_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchCasePatternCtor(tm1, tm4, ) in self.match_case_pattern_ctor.iter_new() {

#[allow(unused_variables)]
for CtorEnum(_, tm3, ) in self.ctor_enum.iter_all_0(tm4, ) {

#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, _, ) in self.cases_determined_enum.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for ConsMatchCaseListNode(tm0, _, _, ) in self.cons_match_case_list_node.iter_old_1_2(tm1, tm2, ) {

self.ctor_cases_determine_enum_cons_10(delta, tm0, tm1, tm2, tm3, tm4);


}

}

}

}

}
}

#[allow(unused_variables)]
fn ctor_cases_determine_enum_cons_10(&self, delta: &mut ModelDelta, tm0: MatchCaseListNode, tm1: MatchCaseNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: CtorDeclNode) {
for _ in [()] {
let exists_already = self.cases_determined_enum.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_cases_determined_enum.push(CasesDeterminedEnum(tm0, tm3));
}



}
}


#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_term_type_if_cases_determine_enum_1(delta, );
self.match_term_type_if_cases_determine_enum_2(delta, );
self.match_term_type_if_cases_determine_enum_5(delta, );
self.match_term_type_if_cases_determine_enum_8(delta, );
self.match_term_type_if_cases_determine_enum_9(delta, );
self.match_term_type_if_cases_determine_enum_10(delta, );
self.match_term_type_if_cases_determine_enum_13(delta, );
self.match_term_type_if_cases_determine_enum_16(delta, );
self.match_term_type_if_cases_determine_enum_17(delta, );
self.match_term_type_if_cases_determine_enum_20(delta, );











}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.match_term_type_if_cases_determine_enum_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.match_term_type_if_cases_determine_enum_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CasesDeterminedEnum(_, tm3, ) in self.cases_determined_enum.iter_all_0(tm2, ) {

self.match_term_type_if_cases_determine_enum_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, tm3, ) in self.cases_determined_enum.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, _, ) in self.match_stmt_node.iter_old_2(tm2, ) {

self.match_term_type_if_cases_determine_enum_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode) {
for _ in [()] {
self.match_term_type_if_cases_determine_enum_7(delta, tm0, tm1, tm2, tm3);


}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_7(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm6, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_all_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_all_0(tm5, ) {

self.match_term_type_if_cases_determine_enum_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_8(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm6, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, tm3, ) in self.cases_determined_enum.iter_old() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, _, ) in self.match_stmt_node.iter_old_1_2(tm1, tm2, ) {

self.match_term_type_if_cases_determine_enum_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_9(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm6, tm5, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, tm3, ) in self.cases_determined_enum.iter_old() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, _, ) in self.match_stmt_node.iter_old_1_2(tm1, tm2, ) {

self.match_term_type_if_cases_determine_enum_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm5, tm4, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_all_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_all_1(tm6, ) {

#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, tm3, ) in self.cases_determined_enum.iter_old() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, _, ) in self.match_stmt_node.iter_old_1_2(tm1, tm2, ) {

self.match_term_type_if_cases_determine_enum_11(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_11(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
self.match_term_type_if_cases_determine_enum_12(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_12(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(_, tm7, tm8, ) in self.enum_decl.iter_all_0(tm3, ) {

self.match_term_type_if_cases_determine_enum_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_13(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm3, tm7, tm8, ) in self.enum_decl.iter_new() {

#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, _, ) in self.cases_determined_enum.iter_old_1(tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, _, ) in self.match_stmt_node.iter_old_2(tm2, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm6, ) in self.rule_descendant_term.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

self.match_term_type_if_cases_determine_enum_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_14(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Ident, tm8: CtorDeclListNode) {
for _ in [()] {
self.match_term_type_if_cases_determine_enum_15(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8);


}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_15(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Ident, tm8: CtorDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, _, tm10, ) in self.semantic_type.iter_all_0_1(tm4, tm7, ) {

#[allow(unused_variables)]
for AmbientType(_, tm9, ) in self.ambient_type.iter_all_0(tm10, ) {

self.match_term_type_if_cases_determine_enum_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_16(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm4, tm7, tm10, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(tm5, _, ) in self.scope_symbols.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for AmbientType(_, tm9, ) in self.ambient_type.iter_old_0(tm10, ) {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, tm3, ) in self.cases_determined_enum.iter_old() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, _, ) in self.match_stmt_node.iter_old_1_2(tm1, tm2, ) {

#[allow(unused_variables)]
for EnumDecl(_, _, tm8, ) in self.enum_decl.iter_old_0_1(tm3, tm7, ) {

self.match_term_type_if_cases_determine_enum_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_17(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm10, tm9, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for CasesDeterminedEnum(tm2, tm3, ) in self.cases_determined_enum.iter_old() {

#[allow(unused_variables)]
for SemanticType(tm4, tm7, _, ) in self.semantic_type.iter_all_2(tm10, ) {

#[allow(unused_variables)]
for EnumDecl(_, _, tm8, ) in self.enum_decl.iter_old_0_1(tm3, tm7, ) {

#[allow(unused_variables)]
for ScopeSymbols(tm5, _, ) in self.scope_symbols.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for EntryScope(tm6, _, ) in self.entry_scope.iter_old_1(tm5, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_old_1(tm6, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, _, ) in self.match_stmt_node.iter_old_1_2(tm1, tm2, ) {

self.match_term_type_if_cases_determine_enum_18(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_18(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Ident, tm8: CtorDeclListNode, tm9: ElementType, tm10: Type) {
for _ in [()] {
self.match_term_type_if_cases_determine_enum_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10);


}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_19(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Ident, tm8: CtorDeclListNode, tm9: ElementType, tm10: Type) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(_, tm12, tm11, ) in self.semantic_el.iter_all_0(tm1, ) {

self.match_term_type_if_cases_determine_enum_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12);


}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_20(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm1, tm12, tm11, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for RuleDescendantTerm(_, tm6, ) in self.rule_descendant_term.iter_old_0(tm1, ) {

#[allow(unused_variables)]
for EntryScope(_, tm5, ) in self.entry_scope.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm4, ) in self.scope_symbols.iter_old_0(tm5, ) {

#[allow(unused_variables)]
for AmbientType(tm10, tm9, ) in self.ambient_type.iter_old() {

#[allow(unused_variables)]
for SemanticType(_, tm7, _, ) in self.semantic_type.iter_old_0_2(tm4, tm10, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

#[allow(unused_variables)]
for CasesDeterminedEnum(_, tm3, ) in self.cases_determined_enum.iter_old_0(tm2, ) {

#[allow(unused_variables)]
for EnumDecl(_, _, tm8, ) in self.enum_decl.iter_old_0_1(tm3, tm7, ) {

self.match_term_type_if_cases_determine_enum_21(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9, tm10, tm11, tm12);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_term_type_if_cases_determine_enum_21(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: EnumDeclNode, tm4: SymbolScope, tm5: Scope, tm6: RuleDescendantNode, tm7: Ident, tm8: CtorDeclListNode, tm9: ElementType, tm10: Type, tm11: El, tm12: Structure) {
for _ in [()] {
let exists_already = self.el_type.iter_all_0_1(tm11, tm9).next().is_some();
if !exists_already {
delta.new_el_type.push(ElType(tm11, tm9));
}



}
}


#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_stmt_should_contain_ctor_defined_1(delta, );
self.match_stmt_should_contain_ctor_defined_2(delta, );
self.match_stmt_should_contain_ctor_defined_5(delta, );
self.match_stmt_should_contain_ctor_defined_6(delta, );
self.match_stmt_should_contain_ctor_defined_7(delta, );
self.match_stmt_should_contain_ctor_defined_10(delta, );
self.match_stmt_should_contain_ctor_defined_11(delta, );
self.match_stmt_should_contain_ctor_defined_12(delta, );
self.match_stmt_should_contain_ctor_defined_15(delta, );
self.match_stmt_should_contain_ctor_defined_18(delta, );
self.match_stmt_should_contain_ctor_defined_21(delta, );












}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.match_stmt_should_contain_ctor_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.match_stmt_should_contain_ctor_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm6, tm4, ) in self.ambient_type.iter_all() {

#[allow(unused_variables)]
for ElType(tm3, _, ) in self.el_type.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm5, _, ) in self.semantic_el.iter_all_0_2(tm1, tm3, ) {

self.match_stmt_should_contain_ctor_defined_8(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ElType(tm3, tm4, ) in self.el_type.iter_new() {

#[allow(unused_variables)]
for AmbientType(tm6, _, ) in self.ambient_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for SemanticEl(tm1, tm5, _, ) in self.semantic_el.iter_old_2(tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_8(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_6(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticEl(tm1, tm5, tm3, ) in self.semantic_el.iter_new() {

#[allow(unused_variables)]
for ElType(_, tm4, ) in self.el_type.iter_all_0(tm3, ) {

#[allow(unused_variables)]
for AmbientType(tm6, _, ) in self.ambient_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_8(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_7(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for AmbientType(tm6, tm4, ) in self.ambient_type.iter_new() {

#[allow(unused_variables)]
for ElType(tm3, _, ) in self.el_type.iter_all_1(tm4, ) {

#[allow(unused_variables)]
for SemanticEl(tm1, tm5, _, ) in self.semantic_el.iter_all_2(tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_8(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_8(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm6: Type) {
for _ in [()] {
self.match_stmt_should_contain_ctor_defined_9(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6);


}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_9(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm6: Type) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(_, tm9, ) in self.rule_descendant_term.iter_all_0(tm1, ) {

#[allow(unused_variables)]
for EntryScope(_, tm8, ) in self.entry_scope.iter_all_0(tm9, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm7, ) in self.scope_symbols.iter_all_0(tm8, ) {

self.match_stmt_should_contain_ctor_defined_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_10(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for RuleDescendantTerm(tm1, tm9, ) in self.rule_descendant_term.iter_new() {

#[allow(unused_variables)]
for EntryScope(_, tm8, ) in self.entry_scope.iter_old_0(tm9, ) {

#[allow(unused_variables)]
for ScopeSymbols(_, tm7, ) in self.scope_symbols.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for AmbientType(tm6, tm4, ) in self.ambient_type.iter_old() {

#[allow(unused_variables)]
for ElType(tm3, _, ) in self.el_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm5, _, ) in self.semantic_el.iter_old_0_2(tm1, tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_11(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EntryScope(tm9, tm8, ) in self.entry_scope.iter_new() {

#[allow(unused_variables)]
for ScopeSymbols(_, tm7, ) in self.scope_symbols.iter_old_0(tm8, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_all_1(tm9, ) {

#[allow(unused_variables)]
for AmbientType(tm6, tm4, ) in self.ambient_type.iter_old() {

#[allow(unused_variables)]
for ElType(tm3, _, ) in self.el_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm5, _, ) in self.semantic_el.iter_old_0_2(tm1, tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_12(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for ScopeSymbols(tm8, tm7, ) in self.scope_symbols.iter_new() {

#[allow(unused_variables)]
for EntryScope(tm9, _, ) in self.entry_scope.iter_all_1(tm8, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_all_1(tm9, ) {

#[allow(unused_variables)]
for AmbientType(tm6, tm4, ) in self.ambient_type.iter_old() {

#[allow(unused_variables)]
for ElType(tm3, _, ) in self.el_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm5, _, ) in self.semantic_el.iter_old_0_2(tm1, tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_13(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_13(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm6: Type, tm7: SymbolScope, tm8: Scope, tm9: RuleDescendantNode) {
for _ in [()] {
self.match_stmt_should_contain_ctor_defined_14(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm6, tm7, tm8, tm9);


}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_14(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm6: Type, tm7: SymbolScope, tm8: Scope, tm9: RuleDescendantNode) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(_, tm10, _, ) in self.semantic_type.iter_all_0_2(tm7, tm6, ) {

self.match_stmt_should_contain_ctor_defined_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9, tm6, tm10);


}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_15(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for SemanticType(tm7, tm10, tm6, ) in self.semantic_type.iter_new() {

#[allow(unused_variables)]
for AmbientType(_, tm4, ) in self.ambient_type.iter_old_0(tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(tm8, _, ) in self.scope_symbols.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for ElType(tm3, _, ) in self.el_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for EntryScope(tm9, _, ) in self.entry_scope.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_old_1(tm9, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm5, _, ) in self.semantic_el.iter_old_0_2(tm1, tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_16(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9, tm6, tm10);


}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_16(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm7: SymbolScope, tm8: Scope, tm9: RuleDescendantNode, tm6: Type, tm10: Ident) {
for _ in [()] {
self.match_stmt_should_contain_ctor_defined_17(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9, tm6, tm10);


}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_17(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm7: SymbolScope, tm8: Scope, tm9: RuleDescendantNode, tm6: Type, tm10: Ident) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm11, _, tm12, ) in self.enum_decl.iter_all_1(tm10, ) {

self.match_stmt_should_contain_ctor_defined_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9, tm6, tm10, tm11, tm12);


}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_18(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for EnumDecl(tm11, tm10, tm12, ) in self.enum_decl.iter_new() {

#[allow(unused_variables)]
for AmbientType(tm6, tm4, ) in self.ambient_type.iter_old() {

#[allow(unused_variables)]
for SemanticType(tm7, _, _, ) in self.semantic_type.iter_old_1_2(tm10, tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(tm8, _, ) in self.scope_symbols.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for ElType(tm3, _, ) in self.el_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for EntryScope(tm9, _, ) in self.entry_scope.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_old_1(tm9, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm5, _, ) in self.semantic_el.iter_old_0_2(tm1, tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_19(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9, tm6, tm10, tm11, tm12);


}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_19(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm7: SymbolScope, tm8: Scope, tm9: RuleDescendantNode, tm6: Type, tm10: Ident, tm11: EnumDeclNode, tm12: CtorDeclListNode) {
for _ in [()] {
self.match_stmt_should_contain_ctor_defined_20(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9, tm6, tm10, tm11, tm12);


}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_20(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm7: SymbolScope, tm8: Scope, tm9: RuleDescendantNode, tm6: Type, tm10: Ident, tm11: EnumDeclNode, tm12: CtorDeclListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(tm13, _, ) in self.ctor_enum.iter_all_1(tm11, ) {

self.match_stmt_should_contain_ctor_defined_22(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9, tm6, tm10, tm12, tm11, tm13);


}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_21(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CtorEnum(tm13, tm11, ) in self.ctor_enum.iter_new() {

#[allow(unused_variables)]
for AmbientType(tm6, tm4, ) in self.ambient_type.iter_old() {

#[allow(unused_variables)]
for ElType(tm3, _, ) in self.el_type.iter_old_1(tm4, ) {

#[allow(unused_variables)]
for EnumDecl(_, tm10, tm12, ) in self.enum_decl.iter_old_0(tm11, ) {

#[allow(unused_variables)]
for SemanticType(tm7, _, _, ) in self.semantic_type.iter_old_1_2(tm10, tm6, ) {

#[allow(unused_variables)]
for ScopeSymbols(tm8, _, ) in self.scope_symbols.iter_old_1(tm7, ) {

#[allow(unused_variables)]
for EntryScope(tm9, _, ) in self.entry_scope.iter_old_1(tm8, ) {

#[allow(unused_variables)]
for RuleDescendantTerm(tm1, _, ) in self.rule_descendant_term.iter_old_1(tm9, ) {

#[allow(unused_variables)]
for SemanticEl(_, tm5, _, ) in self.semantic_el.iter_old_0_2(tm1, tm3, ) {

#[allow(unused_variables)]
for MatchStmtNode(tm0, _, tm2, ) in self.match_stmt_node.iter_old_1(tm1, ) {

self.match_stmt_should_contain_ctor_defined_22(delta, tm0, tm1, tm2, tm3, tm4, tm5, tm7, tm8, tm9, tm6, tm10, tm12, tm11, tm13);


}

}

}

}

}

}

}

}

}

}

}
}

#[allow(unused_variables)]
fn match_stmt_should_contain_ctor_defined_22(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: El, tm4: ElementType, tm5: Structure, tm7: SymbolScope, tm8: Scope, tm9: RuleDescendantNode, tm6: Type, tm10: Ident, tm12: CtorDeclListNode, tm11: EnumDeclNode, tm13: CtorDeclNode) {
for _ in [()] {
let exists_already = self.match_stmt_should_contain_ctor.iter_all_0_1(tm0, tm13).next().is_some();
if !exists_already {
delta.new_match_stmt_should_contain_ctor.push(MatchStmtShouldContainCtor(tm0, tm13));
}



}
}


#[allow(unused_variables)]
fn match_stmt_contains_ctor_defined_0(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
self.match_stmt_contains_ctor_defined_1(delta, );
self.match_stmt_contains_ctor_defined_2(delta, );
self.match_stmt_contains_ctor_defined_5(delta, );




}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_defined_1(&self, delta: &mut ModelDelta, ) {
for _ in [()] {

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_defined_2(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, tm2, ) in self.match_stmt_node.iter_new() {

self.match_stmt_contains_ctor_defined_3(delta, tm0, tm1, tm2);


}

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_defined_3(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
self.match_stmt_contains_ctor_defined_4(delta, tm0, tm1, tm2);


}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_defined_4(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode) {
for _ in [()] {
#[allow(unused_variables)]
for CasesContainCtor(_, tm3, ) in self.cases_contain_ctor.iter_all_0(tm2, ) {

self.match_stmt_contains_ctor_defined_6(delta, tm0, tm1, tm2, tm3);


}

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_defined_5(&self, delta: &mut ModelDelta, ) {
for _ in [()] {
#[allow(unused_variables)]
for CasesContainCtor(tm2, tm3, ) in self.cases_contain_ctor.iter_new() {

#[allow(unused_variables)]
for MatchStmtNode(tm0, tm1, _, ) in self.match_stmt_node.iter_old_2(tm2, ) {

self.match_stmt_contains_ctor_defined_6(delta, tm0, tm1, tm2, tm3);


}

}

}
}

#[allow(unused_variables)]
fn match_stmt_contains_ctor_defined_6(&self, delta: &mut ModelDelta, tm0: StmtNode, tm1: TermNode, tm2: MatchCaseListNode, tm3: CtorDeclNode) {
for _ in [()] {
let exists_already = self.match_stmt_contains_ctor.iter_all_0_1(tm0, tm3).next().is_some();
if !exists_already {
delta.new_match_stmt_contains_ctor.push(MatchStmtContainsCtor(tm0, tm3));
}



}
}


fn drop_dirt(&mut self) {
    self.empty_join_is_dirty = false;

self.absurd.drop_dirt();
self.type_decl.drop_dirt();
self.arg_decl_node_name.drop_dirt();
self.arg_decl_node_type.drop_dirt();
self.nil_arg_decl_list_node.drop_dirt();
self.cons_arg_decl_list_node.drop_dirt();
self.pred_decl.drop_dirt();
self.func_decl.drop_dirt();
self.ctor_decl.drop_dirt();
self.nil_ctor_decl_list_node.drop_dirt();
self.cons_ctor_decl_list_node.drop_dirt();
self.enum_decl.drop_dirt();
self.nil_term_list_node.drop_dirt();
self.cons_term_list_node.drop_dirt();
self.ambient_type_expr.drop_dirt();
self.member_type_expr.drop_dirt();
self.mor_type_expr.drop_dirt();
self.none_term_node.drop_dirt();
self.some_term_node.drop_dirt();
self.var_term_node.drop_dirt();
self.wildcard_term_node.drop_dirt();
self.app_term_node.drop_dirt();
self.match_case.drop_dirt();
self.nil_match_case_list_node.drop_dirt();
self.cons_match_case_list_node.drop_dirt();
self.equal_if_atom_node.drop_dirt();
self.defined_if_atom_node.drop_dirt();
self.pred_if_atom_node.drop_dirt();
self.var_if_atom_node.drop_dirt();
self.equal_then_atom_node.drop_dirt();
self.defined_then_atom_node.drop_dirt();
self.pred_then_atom_node.drop_dirt();
self.if_stmt_node.drop_dirt();
self.then_stmt_node.drop_dirt();
self.branch_stmt_node.drop_dirt();
self.match_stmt_node.drop_dirt();
self.nil_stmt_list_node.drop_dirt();
self.cons_stmt_list_node.drop_dirt();
self.nil_stmt_block_list_node.drop_dirt();
self.cons_stmt_block_list_node.drop_dirt();
self.rule_decl.drop_dirt();
self.model_decl.drop_dirt();
self.decl_node_type.drop_dirt();
self.decl_node_pred.drop_dirt();
self.decl_node_func.drop_dirt();
self.decl_node_rule.drop_dirt();
self.decl_node_enum.drop_dirt();
self.decl_node_model.drop_dirt();
self.nil_decl_list_node.drop_dirt();
self.cons_decl_list_node.drop_dirt();
self.decls_module_node.drop_dirt();
self.var_in_scope.drop_dirt();
self.scope_extension.drop_dirt();
self.scope_single_child.drop_dirt();
self.scope_extension_siblings.drop_dirt();
self.is_normal_type.drop_dirt();
self.is_enum_type.drop_dirt();
self.is_model_type.drop_dirt();
self.is_mor_type.drop_dirt();
self.illegal_member_type_expr_in_signature.drop_dirt();
self.is_total_func.drop_dirt();
self.rel_app.drop_dirt();
self.el_type.drop_dirt();
self.el_types.drop_dirt();
self.constrained_el.drop_dirt();
self.constrained_els.drop_dirt();
self.in_ker.drop_dirt();
self.el_in_img.drop_dirt();
self.rel_tuple_in_img.drop_dirt();
self.symbol_scope_extension.drop_dirt();
self.symbol_scope_ancestor.drop_dirt();
self.element_member_symbol_scope.drop_dirt();
self.defined_symbol.drop_dirt();
self.accessible_symbol.drop_dirt();
self.should_be_symbol.drop_dirt();
self.should_be_symbol_2.drop_dirt();
self.should_be_symbol_3.drop_dirt();
self.pred_arg_num_should_match.drop_dirt();
self.func_arg_num_should_match.drop_dirt();
self.cfg_edge.drop_dirt();
self.cfg_edge_stmts_stmt.drop_dirt();
self.cfg_edge_stmt_stmts.drop_dirt();
self.cfg_edge_fork.drop_dirt();
self.cfg_edge_join.drop_dirt();
self.before_stmt_structure.drop_dirt();
self.stmt_morphism.drop_dirt();
self.if_morphism.drop_dirt();
self.surj_then_morphism.drop_dirt();
self.non_surj_then_morphism.drop_dirt();
self.noop_morphism.drop_dirt();
self.stmt_structure.drop_dirt();
self.if_atom_structure.drop_dirt();
self.then_atom_structure.drop_dirt();
self.term_structure.drop_dirt();
self.terms_structure.drop_dirt();
self.opt_term_structure.drop_dirt();
self.type_expr_structure.drop_dirt();
self.term_should_be_epic_ok.drop_dirt();
self.terms_should_be_epic_ok.drop_dirt();
self.el_should_be_surjective_ok.drop_dirt();
self.el_is_surjective_ok.drop_dirt();
self.should_be_obtained_by_ctor.drop_dirt();
self.is_given_by_ctor.drop_dirt();
self.function_can_be_made_defined.drop_dirt();
self.case_pattern_is_variable.drop_dirt();
self.case_pattern_is_wildcard.drop_dirt();
self.is_pattern_ctor_arg.drop_dirt();
self.are_pattern_ctor_args.drop_dirt();
self.pattern_ctor_arg_is_app.drop_dirt();
self.pattern_ctor_arg_var_is_not_fresh.drop_dirt();
self.cases_contain_ctor.drop_dirt();
self.match_stmt_contains_ctor_of_enum.drop_dirt();
self.match_stmt_should_contain_ctor.drop_dirt();
self.match_stmt_contains_ctor.drop_dirt();
self.real_virt_ident.drop_dirt();
self.virt_real_ident.drop_dirt();
self.var.drop_dirt();
self.rule_name.drop_dirt();
self.module_name.drop_dirt();
self.type_decl_node_loc.drop_dirt();
self.arg_decl_node_loc.drop_dirt();
self.arg_decl_list_node_loc.drop_dirt();
self.pred_decl_node_loc.drop_dirt();
self.func_decl_node_loc.drop_dirt();
self.ctor_decl_node_loc.drop_dirt();
self.enum_decl_node_loc.drop_dirt();
self.model_decl_node_loc.drop_dirt();
self.term_node_loc.drop_dirt();
self.term_list_node_loc.drop_dirt();
self.match_case_node_loc.drop_dirt();
self.opt_term_node_loc.drop_dirt();
self.if_atom_node_loc.drop_dirt();
self.then_atom_node_loc.drop_dirt();
self.stmt_node_loc.drop_dirt();
self.stmt_list_node_loc.drop_dirt();
self.rule_decl_node_loc.drop_dirt();
self.decl_node_loc.drop_dirt();
self.decl_list_node_loc.drop_dirt();
self.module_node_loc.drop_dirt();
self.type_expr_node_loc.drop_dirt();
self.rule_descendant_rule.drop_dirt();
self.rule_descendant_term.drop_dirt();
self.rule_descendant_term_list.drop_dirt();
self.rule_descendant_opt_term.drop_dirt();
self.rule_descendant_if_atom.drop_dirt();
self.rule_descendant_then_atom.drop_dirt();
self.rule_descendant_match_case.drop_dirt();
self.rule_descendant_match_case_list.drop_dirt();
self.rule_descendant_stmt.drop_dirt();
self.rule_descendant_stmt_list.drop_dirt();
self.rule_descendant_stmt_block_list.drop_dirt();
self.rule_descendant_type_expr.drop_dirt();
self.entry_scope.drop_dirt();
self.exit_scope.drop_dirt();
self.ctor_enum.drop_dirt();
self.ctors_enum.drop_dirt();
self.cases_discriminee.drop_dirt();
self.case_discriminee.drop_dirt();
self.desugared_case_equality_atom.drop_dirt();
self.desugared_case_equality_stmt.drop_dirt();
self.desugared_case_block.drop_dirt();
self.desugared_case_block_list.drop_dirt();
self.nil_type_list.drop_dirt();
self.cons_type_list.drop_dirt();
self.snoc_type_list.drop_dirt();
self.semantic_type.drop_dirt();
self.decl_symbol_scope.drop_dirt();
self.mor_type.drop_dirt();
self.mor_type_dom_func.drop_dirt();
self.mor_type_cod_func.drop_dirt();
self.type_definition_symbol_scope.drop_dirt();
self.func_rel.drop_dirt();
self.rel_definition_symbol_scope.drop_dirt();
self.domain.drop_dirt();
self.codomain.drop_dirt();
self.type_name.drop_dirt();
self.virtual_symbol_scope.drop_dirt();
self.parent_model_func.drop_dirt();
self.symbol_scope_model.drop_dirt();
self.flat_domain.drop_dirt();
self.semantic_signature_type_expr.drop_dirt();
self.type_symbol.drop_dirt();
self.enum_symbol.drop_dirt();
self.model_symbol.drop_dirt();
self.semantic_arg_type.drop_dirt();
self.arg_symbol_scope.drop_dirt();
self.semantic_arg_types.drop_dirt();
self.semantic_pred.drop_dirt();
self.pred_arity.drop_dirt();
self.semantic_func.drop_dirt();
self.ctor_symbol_scope.drop_dirt();
self.pred_rel.drop_dirt();
self.rel_name.drop_dirt();
self.arity.drop_dirt();
self.dom.drop_dirt();
self.cod.drop_dirt();
self.flat_arity.drop_dirt();
self.module_symbol_scope.drop_dirt();
self.nil_el_list.drop_dirt();
self.cons_el_list.drop_dirt();
self.snoc_el_list.drop_dirt();
self.el_structure.drop_dirt();
self.els_structure.drop_dirt();
self.ambient_type.drop_dirt();
self.instantiated_type.drop_dirt();
self.underlying_type.drop_dirt();
self.nil_element_type_list.drop_dirt();
self.cons_element_type_list.drop_dirt();
self.snoc_element_type_list.drop_dirt();
self.ambient_el_type_list.drop_dirt();
self.func_app.drop_dirt();
self.map_el.drop_dirt();
self.map_els.drop_dirt();
self.ambient_model_el.drop_dirt();
self.pred_symbol.drop_dirt();
self.func_symbol.drop_dirt();
self.rule_symbol.drop_dirt();
self.ctor_symbol.drop_dirt();
self.symbol_scope_parent.drop_dirt();
self.decls_symbol_scope.drop_dirt();
self.args_symbol_scope.drop_dirt();
self.ctors_symbol_scope.drop_dirt();
self.model_member_symbol_scope.drop_dirt();
self.symbol_scope_name.drop_dirt();
self.scope_symbols.drop_dirt();
self.semantic_el.drop_dirt();
self.zero.drop_dirt();
self.succ.drop_dirt();
self.type_list_len.drop_dirt();
self.term_list_len.drop_dirt();
self.before_rule_structure.drop_dirt();
self.ambient_model_el_structure.drop_dirt();
self.ambient_model_el_morphism.drop_dirt();
self.if_atom_morphism.drop_dirt();
self.then_atom_morphism.drop_dirt();
self.branch_stmt_morphism.drop_dirt();
self.match_stmt_morphism.drop_dirt();
self.semantic_name.drop_dirt();
self.semantic_els.drop_dirt();
self.wildcard_name.drop_dirt();
self.rel_app_parent_model_el.drop_dirt();
self.match_case_pattern_ctor.drop_dirt();
self.cases_determined_enum.drop_dirt();

self.ident_old.append(&mut self.ident_new);
self.virt_ident_old.append(&mut self.virt_ident_new);
self.type_decl_node_old.append(&mut self.type_decl_node_new);
self.arg_decl_node_old.append(&mut self.arg_decl_node_new);
self.type_expr_node_old.append(&mut self.type_expr_node_new);
self.arg_decl_list_node_old.append(&mut self.arg_decl_list_node_new);
self.pred_decl_node_old.append(&mut self.pred_decl_node_new);
self.func_decl_node_old.append(&mut self.func_decl_node_new);
self.ctor_decl_node_old.append(&mut self.ctor_decl_node_new);
self.ctor_decl_list_node_old.append(&mut self.ctor_decl_list_node_new);
self.enum_decl_node_old.append(&mut self.enum_decl_node_new);
self.term_node_old.append(&mut self.term_node_new);
self.term_list_node_old.append(&mut self.term_list_node_new);
self.opt_term_node_old.append(&mut self.opt_term_node_new);
self.match_case_node_old.append(&mut self.match_case_node_new);
self.stmt_list_node_old.append(&mut self.stmt_list_node_new);
self.match_case_list_node_old.append(&mut self.match_case_list_node_new);
self.if_atom_node_old.append(&mut self.if_atom_node_new);
self.then_atom_node_old.append(&mut self.then_atom_node_new);
self.stmt_node_old.append(&mut self.stmt_node_new);
self.stmt_block_list_node_old.append(&mut self.stmt_block_list_node_new);
self.rule_decl_node_old.append(&mut self.rule_decl_node_new);
self.model_decl_node_old.append(&mut self.model_decl_node_new);
self.decl_list_node_old.append(&mut self.decl_list_node_new);
self.decl_node_old.append(&mut self.decl_node_new);
self.module_node_old.append(&mut self.module_node_new);
self.loc_old.append(&mut self.loc_new);
self.rule_descendant_node_old.append(&mut self.rule_descendant_node_new);
self.scope_old.append(&mut self.scope_new);
self.type_old.append(&mut self.type_new);
self.type_list_old.append(&mut self.type_list_new);
self.symbol_scope_old.append(&mut self.symbol_scope_new);
self.func_old.append(&mut self.func_new);
self.pred_old.append(&mut self.pred_new);
self.rel_old.append(&mut self.rel_new);
self.structure_old.append(&mut self.structure_new);
self.el_old.append(&mut self.el_new);
self.el_list_old.append(&mut self.el_list_new);
self.el_name_old.append(&mut self.el_name_new);
self.element_type_old.append(&mut self.element_type_new);
self.element_type_list_old.append(&mut self.element_type_list_new);
self.morphism_old.append(&mut self.morphism_new);
self.symbol_kind_old.append(&mut self.symbol_kind_new);
self.nat_old.append(&mut self.nat_new);
}
}
impl fmt::Display for Eqlog {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.ident_equalities.class_table().with(Header("Ident"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.virt_ident_equalities.class_table().with(Header("VirtIdent"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.type_decl_node_equalities.class_table().with(Header("TypeDeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.arg_decl_node_equalities.class_table().with(Header("ArgDeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.type_expr_node_equalities.class_table().with(Header("TypeExprNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.arg_decl_list_node_equalities.class_table().with(Header("ArgDeclListNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.pred_decl_node_equalities.class_table().with(Header("PredDeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.func_decl_node_equalities.class_table().with(Header("FuncDeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.ctor_decl_node_equalities.class_table().with(Header("CtorDeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.ctor_decl_list_node_equalities.class_table().with(Header("CtorDeclListNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.enum_decl_node_equalities.class_table().with(Header("EnumDeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.term_node_equalities.class_table().with(Header("TermNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.term_list_node_equalities.class_table().with(Header("TermListNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.opt_term_node_equalities.class_table().with(Header("OptTermNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.match_case_node_equalities.class_table().with(Header("MatchCaseNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.stmt_list_node_equalities.class_table().with(Header("StmtListNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.match_case_list_node_equalities.class_table().with(Header("MatchCaseListNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.if_atom_node_equalities.class_table().with(Header("IfAtomNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.then_atom_node_equalities.class_table().with(Header("ThenAtomNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.stmt_node_equalities.class_table().with(Header("StmtNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.stmt_block_list_node_equalities.class_table().with(Header("StmtBlockListNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.rule_decl_node_equalities.class_table().with(Header("RuleDeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.model_decl_node_equalities.class_table().with(Header("ModelDeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.decl_list_node_equalities.class_table().with(Header("DeclListNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.decl_node_equalities.class_table().with(Header("DeclNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.module_node_equalities.class_table().with(Header("ModuleNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.loc_equalities.class_table().with(Header("Loc"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.rule_descendant_node_equalities.class_table().with(Header("RuleDescendantNode"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.scope_equalities.class_table().with(Header("Scope"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.type_equalities.class_table().with(Header("Type"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.type_list_equalities.class_table().with(Header("TypeList"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.symbol_scope_equalities.class_table().with(Header("SymbolScope"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.func_equalities.class_table().with(Header("Func"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.pred_equalities.class_table().with(Header("Pred"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.rel_equalities.class_table().with(Header("Rel"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.structure_equalities.class_table().with(Header("Structure"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.el_equalities.class_table().with(Header("El"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.el_list_equalities.class_table().with(Header("ElList"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.el_name_equalities.class_table().with(Header("ElName"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.element_type_equalities.class_table().with(Header("ElementType"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.element_type_list_equalities.class_table().with(Header("ElementTypeList"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.morphism_equalities.class_table().with(Header("Morphism"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.symbol_kind_equalities.class_table().with(Header("SymbolKind"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;self.nat_equalities.class_table().with(Header("Nat"))
.with(Modify::new(Segment::all())
.with(Alignment::center()))
.with(
    Style::modern()
        .top_intersection('─')
        .header_intersection('┬')
)
.fmt(f)?;
        self.absurd.fmt(f)?;self.type_decl.fmt(f)?;self.arg_decl_node_name.fmt(f)?;self.arg_decl_node_type.fmt(f)?;self.nil_arg_decl_list_node.fmt(f)?;self.cons_arg_decl_list_node.fmt(f)?;self.pred_decl.fmt(f)?;self.func_decl.fmt(f)?;self.ctor_decl.fmt(f)?;self.nil_ctor_decl_list_node.fmt(f)?;self.cons_ctor_decl_list_node.fmt(f)?;self.enum_decl.fmt(f)?;self.nil_term_list_node.fmt(f)?;self.cons_term_list_node.fmt(f)?;self.ambient_type_expr.fmt(f)?;self.member_type_expr.fmt(f)?;self.mor_type_expr.fmt(f)?;self.none_term_node.fmt(f)?;self.some_term_node.fmt(f)?;self.var_term_node.fmt(f)?;self.wildcard_term_node.fmt(f)?;self.app_term_node.fmt(f)?;self.match_case.fmt(f)?;self.nil_match_case_list_node.fmt(f)?;self.cons_match_case_list_node.fmt(f)?;self.equal_if_atom_node.fmt(f)?;self.defined_if_atom_node.fmt(f)?;self.pred_if_atom_node.fmt(f)?;self.var_if_atom_node.fmt(f)?;self.equal_then_atom_node.fmt(f)?;self.defined_then_atom_node.fmt(f)?;self.pred_then_atom_node.fmt(f)?;self.if_stmt_node.fmt(f)?;self.then_stmt_node.fmt(f)?;self.branch_stmt_node.fmt(f)?;self.match_stmt_node.fmt(f)?;self.nil_stmt_list_node.fmt(f)?;self.cons_stmt_list_node.fmt(f)?;self.nil_stmt_block_list_node.fmt(f)?;self.cons_stmt_block_list_node.fmt(f)?;self.rule_decl.fmt(f)?;self.model_decl.fmt(f)?;self.decl_node_type.fmt(f)?;self.decl_node_pred.fmt(f)?;self.decl_node_func.fmt(f)?;self.decl_node_rule.fmt(f)?;self.decl_node_enum.fmt(f)?;self.decl_node_model.fmt(f)?;self.nil_decl_list_node.fmt(f)?;self.cons_decl_list_node.fmt(f)?;self.decls_module_node.fmt(f)?;self.var_in_scope.fmt(f)?;self.scope_extension.fmt(f)?;self.scope_single_child.fmt(f)?;self.scope_extension_siblings.fmt(f)?;self.is_normal_type.fmt(f)?;self.is_enum_type.fmt(f)?;self.is_model_type.fmt(f)?;self.is_mor_type.fmt(f)?;self.illegal_member_type_expr_in_signature.fmt(f)?;self.is_total_func.fmt(f)?;self.rel_app.fmt(f)?;self.el_type.fmt(f)?;self.el_types.fmt(f)?;self.constrained_el.fmt(f)?;self.constrained_els.fmt(f)?;self.in_ker.fmt(f)?;self.el_in_img.fmt(f)?;self.rel_tuple_in_img.fmt(f)?;self.symbol_scope_extension.fmt(f)?;self.symbol_scope_ancestor.fmt(f)?;self.element_member_symbol_scope.fmt(f)?;self.defined_symbol.fmt(f)?;self.accessible_symbol.fmt(f)?;self.should_be_symbol.fmt(f)?;self.should_be_symbol_2.fmt(f)?;self.should_be_symbol_3.fmt(f)?;self.pred_arg_num_should_match.fmt(f)?;self.func_arg_num_should_match.fmt(f)?;self.cfg_edge.fmt(f)?;self.cfg_edge_stmts_stmt.fmt(f)?;self.cfg_edge_stmt_stmts.fmt(f)?;self.cfg_edge_fork.fmt(f)?;self.cfg_edge_join.fmt(f)?;self.before_stmt_structure.fmt(f)?;self.stmt_morphism.fmt(f)?;self.if_morphism.fmt(f)?;self.surj_then_morphism.fmt(f)?;self.non_surj_then_morphism.fmt(f)?;self.noop_morphism.fmt(f)?;self.stmt_structure.fmt(f)?;self.if_atom_structure.fmt(f)?;self.then_atom_structure.fmt(f)?;self.term_structure.fmt(f)?;self.terms_structure.fmt(f)?;self.opt_term_structure.fmt(f)?;self.type_expr_structure.fmt(f)?;self.term_should_be_epic_ok.fmt(f)?;self.terms_should_be_epic_ok.fmt(f)?;self.el_should_be_surjective_ok.fmt(f)?;self.el_is_surjective_ok.fmt(f)?;self.should_be_obtained_by_ctor.fmt(f)?;self.is_given_by_ctor.fmt(f)?;self.function_can_be_made_defined.fmt(f)?;self.case_pattern_is_variable.fmt(f)?;self.case_pattern_is_wildcard.fmt(f)?;self.is_pattern_ctor_arg.fmt(f)?;self.are_pattern_ctor_args.fmt(f)?;self.pattern_ctor_arg_is_app.fmt(f)?;self.pattern_ctor_arg_var_is_not_fresh.fmt(f)?;self.cases_contain_ctor.fmt(f)?;self.match_stmt_contains_ctor_of_enum.fmt(f)?;self.match_stmt_should_contain_ctor.fmt(f)?;self.match_stmt_contains_ctor.fmt(f)?;self.real_virt_ident.fmt(f)?;self.virt_real_ident.fmt(f)?;self.var.fmt(f)?;self.rule_name.fmt(f)?;self.module_name.fmt(f)?;self.type_decl_node_loc.fmt(f)?;self.arg_decl_node_loc.fmt(f)?;self.arg_decl_list_node_loc.fmt(f)?;self.pred_decl_node_loc.fmt(f)?;self.func_decl_node_loc.fmt(f)?;self.ctor_decl_node_loc.fmt(f)?;self.enum_decl_node_loc.fmt(f)?;self.model_decl_node_loc.fmt(f)?;self.term_node_loc.fmt(f)?;self.term_list_node_loc.fmt(f)?;self.match_case_node_loc.fmt(f)?;self.opt_term_node_loc.fmt(f)?;self.if_atom_node_loc.fmt(f)?;self.then_atom_node_loc.fmt(f)?;self.stmt_node_loc.fmt(f)?;self.stmt_list_node_loc.fmt(f)?;self.rule_decl_node_loc.fmt(f)?;self.decl_node_loc.fmt(f)?;self.decl_list_node_loc.fmt(f)?;self.module_node_loc.fmt(f)?;self.type_expr_node_loc.fmt(f)?;self.rule_descendant_rule.fmt(f)?;self.rule_descendant_term.fmt(f)?;self.rule_descendant_term_list.fmt(f)?;self.rule_descendant_opt_term.fmt(f)?;self.rule_descendant_if_atom.fmt(f)?;self.rule_descendant_then_atom.fmt(f)?;self.rule_descendant_match_case.fmt(f)?;self.rule_descendant_match_case_list.fmt(f)?;self.rule_descendant_stmt.fmt(f)?;self.rule_descendant_stmt_list.fmt(f)?;self.rule_descendant_stmt_block_list.fmt(f)?;self.rule_descendant_type_expr.fmt(f)?;self.entry_scope.fmt(f)?;self.exit_scope.fmt(f)?;self.ctor_enum.fmt(f)?;self.ctors_enum.fmt(f)?;self.cases_discriminee.fmt(f)?;self.case_discriminee.fmt(f)?;self.desugared_case_equality_atom.fmt(f)?;self.desugared_case_equality_stmt.fmt(f)?;self.desugared_case_block.fmt(f)?;self.desugared_case_block_list.fmt(f)?;self.nil_type_list.fmt(f)?;self.cons_type_list.fmt(f)?;self.snoc_type_list.fmt(f)?;self.semantic_type.fmt(f)?;self.decl_symbol_scope.fmt(f)?;self.mor_type.fmt(f)?;self.mor_type_dom_func.fmt(f)?;self.mor_type_cod_func.fmt(f)?;self.type_definition_symbol_scope.fmt(f)?;self.func_rel.fmt(f)?;self.rel_definition_symbol_scope.fmt(f)?;self.domain.fmt(f)?;self.codomain.fmt(f)?;self.type_name.fmt(f)?;self.virtual_symbol_scope.fmt(f)?;self.parent_model_func.fmt(f)?;self.symbol_scope_model.fmt(f)?;self.flat_domain.fmt(f)?;self.semantic_signature_type_expr.fmt(f)?;self.type_symbol.fmt(f)?;self.enum_symbol.fmt(f)?;self.model_symbol.fmt(f)?;self.semantic_arg_type.fmt(f)?;self.arg_symbol_scope.fmt(f)?;self.semantic_arg_types.fmt(f)?;self.semantic_pred.fmt(f)?;self.pred_arity.fmt(f)?;self.semantic_func.fmt(f)?;self.ctor_symbol_scope.fmt(f)?;self.pred_rel.fmt(f)?;self.rel_name.fmt(f)?;self.arity.fmt(f)?;self.dom.fmt(f)?;self.cod.fmt(f)?;self.flat_arity.fmt(f)?;self.module_symbol_scope.fmt(f)?;self.nil_el_list.fmt(f)?;self.cons_el_list.fmt(f)?;self.snoc_el_list.fmt(f)?;self.el_structure.fmt(f)?;self.els_structure.fmt(f)?;self.ambient_type.fmt(f)?;self.instantiated_type.fmt(f)?;self.underlying_type.fmt(f)?;self.nil_element_type_list.fmt(f)?;self.cons_element_type_list.fmt(f)?;self.snoc_element_type_list.fmt(f)?;self.ambient_el_type_list.fmt(f)?;self.func_app.fmt(f)?;self.map_el.fmt(f)?;self.map_els.fmt(f)?;self.ambient_model_el.fmt(f)?;self.pred_symbol.fmt(f)?;self.func_symbol.fmt(f)?;self.rule_symbol.fmt(f)?;self.ctor_symbol.fmt(f)?;self.symbol_scope_parent.fmt(f)?;self.decls_symbol_scope.fmt(f)?;self.args_symbol_scope.fmt(f)?;self.ctors_symbol_scope.fmt(f)?;self.model_member_symbol_scope.fmt(f)?;self.symbol_scope_name.fmt(f)?;self.scope_symbols.fmt(f)?;self.semantic_el.fmt(f)?;self.zero.fmt(f)?;self.succ.fmt(f)?;self.type_list_len.fmt(f)?;self.term_list_len.fmt(f)?;self.before_rule_structure.fmt(f)?;self.ambient_model_el_structure.fmt(f)?;self.ambient_model_el_morphism.fmt(f)?;self.if_atom_morphism.fmt(f)?;self.then_atom_morphism.fmt(f)?;self.branch_stmt_morphism.fmt(f)?;self.match_stmt_morphism.fmt(f)?;self.semantic_name.fmt(f)?;self.semantic_els.fmt(f)?;self.wildcard_name.fmt(f)?;self.rel_app_parent_model_el.fmt(f)?;self.match_case_pattern_ctor.fmt(f)?;self.cases_determined_enum.fmt(f)?;
        Ok(())
    }
}
