pred absurd();

// ## Identifiers
//
// The `Ident` type corresponds to actual strings that occur in the source
// file. The `VirtIdent` type represent ids that do not occur verbatim in
// source code, but semantically correspond to identifiers. For example, each
// occurence of a wildcard token _ corresponds to a separate `VirtIdent` which
// does not arise from an `Ident`.
type Ident;
type VirtIdent;

func real_virt_ident(Ident) -> VirtIdent;
func virt_real_ident(VirtIdent) -> Ident;

rule real_virt_ident_total {
    if ident: Ident;
    then real_virt_ident(ident)!;
}
rule virt_real_ident_retraction {
    if virt_ident = real_virt_ident(ident);
    then virt_real_ident(virt_ident) = ident;
}

// ## Abstract syntax tree (AST) nodes

type TypeDeclNode;
pred type_decl(TypeDeclNode, name: Ident);

type ArgDeclNode;
// arg_decl_node_name is optional (but must be unique), arg_decl_node_type is
// mandatory and must be unique.
pred arg_decl_node_name(ArgDeclNode, name: Ident);
pred arg_decl_node_type(ArgDeclNode, typ: Ident);

type ArgDeclListNode;
pred nil_arg_decl_list_node(ArgDeclListNode);
pred cons_arg_decl_list_node(ArgDeclListNode, head: ArgDeclNode, tail: ArgDeclListNode);

type PredDeclNode;
pred pred_decl(PredDeclNode, name: Ident, args: ArgDeclListNode);

type FuncDeclNode;
pred func_decl(FuncDeclNode, name: Ident, args: ArgDeclListNode, result_type: Ident);

type CtorDeclNode;
pred ctor_decl(CtorDeclNode, name: Ident, args: ArgDeclListNode);

type CtorDeclListNode;
pred nil_ctor_decl_list_node(CtorDeclListNode);
pred cons_ctor_decl_list_node(CtorDeclListNode, head: CtorDeclNode, tail: CtorDeclListNode);

type EnumDeclNode;
pred enum_decl(EnumDeclNode, name: Ident, ctors: CtorDeclListNode);

type TermNode;

type TermListNode;
pred nil_term_list_node(nil: TermListNode);
pred cons_term_list_node(node: TermListNode, head: TermNode, tail: TermListNode);

type TypeExprNode;
pred ambient_type_expr(node: TypeExprNode, ty_ident: Ident);
pred member_type_expr(node: TypeExprNode, tm: TermNode, ty_ident: Ident);

type OptTermNode;
pred none_term_node(OptTermNode);
pred some_term_node(OptTermNode, value: TermNode);

pred var_term_node(TermNode, VirtIdent);
pred wildcard_term_node(TermNode);
pred app_term_node(TermNode, function: Ident, args: TermListNode);

type MatchCaseNode;
pred match_case(node: MatchCaseNode, pattern: TermNode, body: StmtListNode);

type MatchCaseListNode;
pred nil_match_case_list_node(nil: MatchCaseListNode);
pred cons_match_case_list_node(node: MatchCaseListNode, head: MatchCaseNode, tail: MatchCaseListNode);

type IfAtomNode;
pred equal_if_atom_node(IfAtomNode, lhs: TermNode, rhs: TermNode);
pred defined_if_atom_node(IfAtomNode, term: TermNode);
pred pred_if_atom_node(IfAtomNode, predicate: Ident, args: TermListNode);
pred var_if_atom_node(IfAtomNode, var: TermNode, type_expr: TypeExprNode);

type ThenAtomNode;
pred equal_then_atom_node(ThenAtomNode, lhs: TermNode, rhs: TermNode);
pred defined_then_atom_node(ThenAtomNode, var: OptTermNode, tm: TermNode);
pred pred_then_atom_node(ThenAtomNode, predicate: Ident, args: TermListNode);

type StmtNode;
pred if_stmt_node(StmtNode, IfAtomNode);
pred then_stmt_node(StmtNode, ThenAtomNode);
pred branch_stmt_node(StmtNode, blocks: StmtBlockListNode);
pred match_stmt_node(StmtNode, term: TermNode, cases: MatchCaseListNode);

type StmtListNode;
pred nil_stmt_list_node(nil: StmtListNode);
pred cons_stmt_list_node(node: StmtListNode, head: StmtNode, tail: StmtListNode);

type StmtBlockListNode;
pred nil_stmt_block_list_node(node: StmtBlockListNode);
pred cons_stmt_block_list_node(node: StmtBlockListNode, head: StmtListNode, tail: StmtBlockListNode);

type RuleDeclNode;
pred rule_decl(node: RuleDeclNode, stmts: StmtListNode);
// This is defined for non-anonymous RuleDeclNode elements only.
func rule_name(RuleDeclNode) -> Ident;

type ModelDeclNode;
pred model_decl(node: ModelDeclNode, name: Ident, body: DeclListNode);

type DeclNode;
pred decl_node_type(DeclNode, TypeDeclNode);
pred decl_node_pred(DeclNode, PredDeclNode);
pred decl_node_func(DeclNode, FuncDeclNode);
pred decl_node_rule(DeclNode, RuleDeclNode);
pred decl_node_enum(DeclNode, EnumDeclNode);
pred decl_node_model(DeclNode, ModelDeclNode);

type DeclListNode;
pred nil_decl_list_node(DeclListNode);
pred cons_decl_list_node(DeclListNode, head: DeclNode, tail: DeclListNode);

type ModuleNode;
pred decls_module_node(ModuleNode, DeclListNode);

func module_name(module: ModuleNode) -> Ident;

// ### Locations
type Loc;

func type_decl_node_loc(TypeDeclNode) -> Loc;
func arg_decl_node_loc(ArgDeclNode) -> Loc;
func arg_decl_list_node_loc(ArgDeclListNode) -> Loc;
func pred_decl_node_loc(PredDeclNode) -> Loc;
func func_decl_node_loc(FuncDeclNode) -> Loc;
func ctor_decl_node_loc(CtorDeclNode) -> Loc;
func enum_decl_node_loc(EnumDeclNode) -> Loc;
func model_decl_node_loc(ModelDeclNode) -> Loc;
func term_node_loc(TermNode) -> Loc;
func term_list_node_loc(TermListNode) -> Loc;
func match_case_node_loc(MatchCaseNode) -> Loc;
func opt_term_node_loc(OptTermNode) -> Loc;
func if_atom_node_loc(IfAtomNode) -> Loc;
func then_atom_node_loc(ThenAtomNode) -> Loc;
func stmt_node_loc(StmtNode) -> Loc;
func stmt_list_node_loc(StmtListNode) -> Loc;
func rule_decl_node_loc(RuleDeclNode) -> Loc;
func decl_node_loc(DeclNode) -> Loc;
func decl_list_node_loc(DeclListNode) -> Loc;
func module_node_loc(ModuleNode) -> Loc;

// ### Descendant nodes of rules
//
// Every node that can appear as a descendant of a `RuleDeclNode` can be
// coerced into a `RuleDescendantNode`.
type RuleDescendantNode;

func rule_descendant_rule(RuleDeclNode) -> RuleDescendantNode;
func rule_descendant_term(TermNode) -> RuleDescendantNode;
func rule_descendant_term_list(TermListNode) -> RuleDescendantNode;
func rule_descendant_opt_term(OptTermNode) -> RuleDescendantNode;
func rule_descendant_if_atom(IfAtomNode) -> RuleDescendantNode;
func rule_descendant_then_atom(ThenAtomNode) -> RuleDescendantNode;
func rule_descendant_match_case(MatchCaseNode) -> RuleDescendantNode;
func rule_descendant_match_case_list(MatchCaseListNode) -> RuleDescendantNode;
func rule_descendant_stmt(StmtNode) -> RuleDescendantNode;
func rule_descendant_stmt_list(StmtListNode) -> RuleDescendantNode;
func rule_descendant_stmt_block_list(StmtBlockListNode) -> RuleDescendantNode;
func rule_descendant_type_expr(TypeExprNode) -> RuleDescendantNode;

rule rule_descendant_rule_total {
    if rul: RuleDeclNode;
    then rule_descendant_rule(rul)!;
}
rule rule_descendant_term_total {
    if tm: TermNode;
    then rule_descendant_term(tm)!;
}
rule rule_descendant_term_list_total {
    if tms: TermListNode;
    then rule_descendant_term_list(tms)!;
}
rule rule_descendant_opt_term_total {
    if opt_tm: OptTermNode;
    then rule_descendant_opt_term(opt_tm)!;
}
rule rule_descendant_if_atom_total {
    if atom: IfAtomNode;
    then rule_descendant_if_atom(atom)!;
}
rule rule_descendant_then_atom_total {
    if atom: ThenAtomNode;
    then rule_descendant_then_atom(atom)!;
}
rule rule_descendant_match_case_total {
    if case: MatchCaseNode;
    then rule_descendant_match_case(case)!;
}
rule rule_descendant_match_case_list_total {
    if cases: MatchCaseListNode;
    then rule_descendant_match_case_list(cases)!;
}
rule rule_descendant_stmt_total {
    if stmt: StmtNode;
    then rule_descendant_stmt(stmt)!;
}
rule rule_descendant_stmt_list_total {
    if stmts: StmtListNode;
    then rule_descendant_stmt_list(stmts)!;
}
rule rule_descendant_stmt_block_list_total {
    if blocks: StmtBlockListNode;
    then rule_descendant_stmt_block_list(blocks)!;
}
rule rule_descendant_type_expr_total {
    if type_expr: TypeExprNode;
    then rule_descendant_type_expr(type_expr)!;
}

/// ### Scopes

type Scope;

pred var_in_scope(VirtIdent, Scope);
pred scope_extension(smaller: Scope, larger: Scope);

rule scope_extension_vars {
    if var_in_scope(ident, scope);
    if scope_extension(scope, extension);
    then var_in_scope(ident, extension);
}

func entry_scope(RuleDescendantNode) -> Scope;
func exit_scope(RuleDescendantNode) -> Scope;

rule entry_exit_scope_total {
    if descendant: RuleDescendantNode;
    then entry_scope(descendant)!;
    then exit_scope(descendant)!;
}
rule exit_scope_extends_entry_scope {
    if node: RuleDescendantNode;
    if entry = entry_scope(node);
    if exit = exit_scope(node);
    then scope_extension(entry, exit);
}

pred scope_single_child(child: RuleDescendantNode, parent: RuleDescendantNode);
pred scope_extension_siblings(first_child: RuleDescendantNode, second_child: RuleDescendantNode, parent: RuleDescendantNode);

rule scope_single_child_scopes {
    if scope_single_child(child, parent);
    if parent_entry = entry_scope(parent);
    if parent_exit = exit_scope(parent);
    then entry_scope(child) = parent_entry;
    then exit_scope(child) = parent_exit;
}

rule scope_extension_siblings_parent_first {
    if scope_extension_siblings(first_child, _, parent);
    if parent_entry = entry_scope(parent);
    then entry_scope(first_child) = parent_entry;
}

rule scope_extension_siblings_first_second {
    if scope_extension_siblings(first_child, second_child, _);
    if first_exit = exit_scope(first_child);
    then entry_scope(second_child) = first_exit;
}

rule scope_extension_siblings_second_parent {
    if scope_extension_siblings(_, second_child, parent);
    if second_exit = exit_scope(second_child);
    then exit_scope(parent) = second_exit;
}

rule scopes_rule_stmts {
    if rule_decl(rul, stmts);

    if descendant_rule = rule_descendant_rule(rul);
    if descendant_stmts = rule_descendant_stmt_list(stmts);

    then scope_single_child(descendant_stmts, descendant_rule);
}

rule scopes_stmt_list_cons {
    if cons_stmt_list_node(stmts, head, tail);

    if descendant_stmts = rule_descendant_stmt_list(stmts);
    if descendant_head = rule_descendant_stmt(head);
    if descendant_tail = rule_descendant_stmt_list(tail);

    then scope_extension_siblings(descendant_head, descendant_tail, descendant_stmts);
}

rule scopes_stmt_block_list_cons {
    if cons_stmt_block_list_node(blocks, head, tail);
    if descendant_blocks = rule_descendant_stmt_block_list(blocks);
    if descendant_head = rule_descendant_stmt_list(head);
    if descendant_tail = rule_descendant_stmt_block_list(tail);

    if blocks_entry = entry_scope(descendant_blocks);

    then blocks_entry = entry_scope(descendant_head);
    then blocks_entry = entry_scope(descendant_tail);
}

rule scopes_stmt_if {
    if if_stmt_node(stmt, atom);
    if descendant_stmt = rule_descendant_stmt(stmt);
    if descendant_atom = rule_descendant_if_atom(atom);

    then scope_single_child(descendant_atom, descendant_stmt);
}
rule scopes_stmt_then {
    if then_stmt_node(stmt, atom);
    if descendant_stmt = rule_descendant_stmt(stmt);
    if descendant_atom = rule_descendant_then_atom(atom);

    then scope_single_child(descendant_atom, descendant_stmt);
}
rule scopes_stmt_branch {
    if branch_stmt_node(stmt, blocks);
    if descendant_stmt = rule_descendant_stmt(stmt);
    if descendant_block_list = rule_descendant_stmt_block_list(blocks);

    then scope_single_child(descendant_block_list, descendant_stmt);
}
rule scopes_stmt_match {
    if match_stmt_node(stmt, term, cases);
    if stmt_descendant = rule_descendant_stmt(stmt);
    if descendant_term = rule_descendant_term(term);
    if descendant_cases = rule_descendant_match_case_list(cases);

    then scope_extension_siblings(descendant_term, descendant_cases, stmt_descendant);
}

rule scopes_if_atom_equal {
    if equal_if_atom_node(atom, lhs, rhs);
    if atom_descendant = rule_descendant_if_atom(atom);
    if descendant_lhs = rule_descendant_term(lhs);
    if descendant_rhs = rule_descendant_term(rhs);

    then scope_extension_siblings(descendant_lhs, descendant_rhs, atom_descendant);
}
rule scopes_if_atom_defined {
    if defined_if_atom_node(atom, tm);
    if atom_descendant = rule_descendant_if_atom(atom);
    if descendant_tm = rule_descendant_term(tm);

    then scope_single_child(descendant_tm, atom_descendant);
}
rule scopes_if_atom_pred {
    if pred_if_atom_node(atom, _, tms);
    if atom_descendant = rule_descendant_if_atom(atom);
    if tms_descendant = rule_descendant_term_list(tms);

    then scope_single_child(tms_descendant, atom_descendant);
}
rule scopes_if_atom_var {
    if var_if_atom_node(atom, tm, type_expr);
    if atom_descendant = rule_descendant_if_atom(atom);
    if tm_descendant = rule_descendant_term(tm);
    if type_expr_descendant = rule_descendant_type_expr(type_expr);

    // We don't want the newly introduced (variable) term to be in scope for
    // the type it's supposed to have. Otherwise we'd have things like
    // ```
    //   if x : x.member_type;
    // ```
    // which is nonsensical. So that's why we can't make the entry scope of
    // type_expr node agree with the exit scope of the term, even though
    // syntactically the variable preceeds the type expression. The other way
    // round makes a bit more sense, but we could also think about just not
    // enforcing a relation between the type expr node and the variable node.
    then scope_extension_siblings(type_expr_descendant, tm_descendant, atom_descendant);
}

rule scopes_then_atom_equal {
    if equal_then_atom_node(atom, lhs, rhs);

    if atom_descendant = rule_descendant_then_atom(atom);
    if lhs_descendant = rule_descendant_term(lhs);
    if rhs_descendant = rule_descendant_term(rhs);

    then scope_extension_siblings(lhs_descendant, rhs_descendant, atom_descendant);
}
rule scopes_then_atom_defined {
    if defined_then_atom_node(atom, var_tm, tm);
    if atom_descendant = rule_descendant_then_atom(atom);
    if var_tm_descendant = rule_descendant_opt_term(var_tm);
    if tm_descendant = rule_descendant_term(tm);

    then scope_extension_siblings(var_tm_descendant, tm_descendant, atom_descendant);
}
rule scopes_then_atom_pred {
    if pred_then_atom_node(atom, _, tms);
    if atom_descendant = rule_descendant_then_atom(atom);
    if tms_descendant = rule_descendant_term_list(tms);

    then scope_extension_siblings(atom_descendant, tms_descendant, atom_descendant);
}

// No rules for match case nodes -- they're taken care of by desugaring to BlockListNodes.

rule scopes_term_list_cons {
    if cons_term_list_node(tms, head, tail);
    if tms_descendant = rule_descendant_term_list(tms);
    if head_descendant = rule_descendant_term(head);
    if tail_descendant = rule_descendant_term_list(tail);

    then scope_extension_siblings(head_descendant, tail_descendant, tms_descendant);
}
rule scopes_opt_term_some {
    if some_term_node(opt_tm, tm);
    if opt_tm_descendant = rule_descendant_opt_term(opt_tm);
    if tm_descendant = rule_descendant_term(tm);

    then scope_single_child(tm_descendant, opt_tm_descendant);
}
rule scopes_term_app {
    if app_term_node(tm, _, args);
    if tm_descendant = rule_descendant_term(tm);
    if args_descendant = rule_descendant_term_list(args);

    then scope_single_child(args_descendant, tm_descendant);
}
rule scopes_term_var {
    if var_term_node(tm, virt_ident);
    if tm_descendant = rule_descendant_term(tm);
    if tm_exit = exit_scope(tm_descendant);

    then var_in_scope(virt_ident, tm_exit);
}
rule scopes_member_type_expr {
    if member_type_expr(type_expr, tm, _);
    if type_expr_descendant = rule_descendant_type_expr(type_expr);
    if tm_descendant = rule_descendant_term(tm);
    then scope_single_child(tm_descendant, type_expr_descendant);
}

// ### The enum constructor belong to

func ctor_enum(CtorDeclNode) -> EnumDeclNode;
func ctors_enum(CtorDeclListNode) -> EnumDeclNode;

rule enum_ctors {
    if enum_decl(enum_node, _, ctors);
    then ctors_enum(ctors) = enum_node;
}
rule enum_ctors_cons {
    if ctors_enum(ctors) = enum_node;
    if cons_ctor_decl_list_node(ctors, head_ctor, tail_ctors);
    then ctor_enum(head_ctor) = enum_node;
    then ctors_enum(tail_ctors) = enum_node;
}

// ## Desugaring MatchCase nodes

// ### The discriminee of a match case (list) node.
//
// I.e., the term that is being matched on in the match statement that a match
// case node belongs to.
func cases_discriminee(MatchCaseListNode) -> TermNode;
func case_discriminee(MatchCaseNode) -> TermNode;

rule match_stmt_cases_discriminee {
    if match_stmt_node(_, discriminee, cases);
    then cases_discriminee(cases) = discriminee;
}
rule cases_match_stmt_cons {
    if cases_discriminee(cases) = discriminee;
    if cons_match_case_list_node(cases, head_case, tail_cases);
    then case_discriminee(head_case) = discriminee;
    then cases_discriminee(tail_cases) = discriminee;
}

// ### Desugared AST nodes
func desugared_case_equality_atom(MatchCaseNode) -> IfAtomNode;
func desugared_case_equality_stmt(MatchCaseNode) -> StmtNode;
func desugared_case_block(MatchCaseNode) -> StmtListNode;
func desugared_case_block_list(MatchCaseListNode) -> StmtBlockListNode;

rule desugared_case_equality_stmt_loc {
    if match_case(case_node, pattern, _);
    if pattern_loc = term_node_loc(pattern);
    if stmt_node = desugared_case_equality_stmt(case_node);
    then stmt_node_loc(stmt_node) = pattern_loc;
}

rule desugared_case_defined {
    if match_case(case_node, _, _);

    then desugared_case_equality_atom(case_node)!;
    then desugared_case_equality_stmt(case_node)!;
    then desugared_case_block(case_node)!;
}
rule desugared_case_block_list_defined {
    if cases: MatchCaseListNode;
    then desugared_case_block_list(cases)!;
}

rule desugared_case_equality_atom_stmt {
    if discriminee = case_discriminee(case_node);
    if match_case(case_node, pattern, _);
    if atom = desugared_case_equality_atom(case_node);
    if stmt = desugared_case_equality_stmt(case_node);

    then equal_if_atom_node(atom, discriminee, pattern);
    then if_stmt_node(stmt, atom);
}
rule desugared_case_block_structure {
    if match_case(case_node, _, block);
    if desugared_stmt = desugared_case_equality_stmt(case_node);
    if desugared_block = desugared_case_block(case_node);

    then cons_stmt_list_node(desugared_block, desugared_stmt, block);
}
rule desugared_case_blocks {
    if cons_match_case_list_node(cases, head_case, tail_cases);

    if desugared_blocks = desugared_case_block_list(cases);
    if desugared_head_block = desugared_case_block(head_case);
    if desugared_tail_blocks = desugared_case_block_list(tail_cases);

    then cons_stmt_block_list_node(desugared_blocks, desugared_head_block, desugared_tail_blocks);
}

rule scopes_desugared_case {
    if block = desugared_case_block(case);

    if descendant_block = rule_descendant_stmt_list(block);
    if descendant_case = rule_descendant_match_case(case);

    if entry = entry_scope(descendant_case);
    if exit = exit_scope(descendant_case);

    then entry_scope(descendant_block) = entry;
    then exit_scope(descendant_block) = exit;
}

rule scopes_desugared_case_list {
    if blocks = desugared_case_block_list(cases);

    if descendant_blocks = rule_descendant_stmt_block_list(blocks);
    if descendant_cases = rule_descendant_match_case_list(cases);

    if entry = entry_scope(descendant_cases);
    if exit = exit_scope(descendant_cases);

    then entry_scope(descendant_blocks) = entry;
    then exit_scope(descendant_blocks) = exit;
}

// ## Semantic types, predicates and functions

type Type;

pred is_normal_type(ty: Type);
pred is_enum_type(ty: Type);
pred is_model_type(ty: Type);

enum TypeList {
    NilTypeList(),
    ConsTypeList(head: Type, tail: TypeList),
    SnocTypeList(init: TypeList, last: Type)
}

rule type_list_nil_not_cons {
    if NilTypeList() = ConsTypeList(_, _);
    then absurd();
}
rule type_list_cons_injective {
    if ConsTypeList(head_0, tail_0) = ConsTypeList(head_1, tail_1);
    then head_0 = head_1;
    then tail_0 = tail_1;
}

func semantic_type(ss: SymbolScope, Ident) -> Type;
rule semantic_decl_type {
    if decl_node_type(decl, type_decl_node);
    if type_decl(type_decl_node, ident);
    if ss = decl_symbol_scope(decl);
    then typ := semantic_type(ss, ident)!;
    then is_normal_type(typ);
}
rule semantic_decl_enum {
    if decl_node_enum(decl, enum_node);
    if enum_decl(enum_node, ident, _);
    if ss = decl_symbol_scope(decl);
    then typ := semantic_type(ss, ident)!;
    then is_enum_type(typ);
}
rule semantic_decl_model {
    if decl_node_model(decl, model_node);
    if model_decl(model_node, ident, _);
    if ss = decl_symbol_scope(decl);
    then typ := semantic_type(ss, ident)!;
    then is_model_type(typ);
}

func type_name(Type) -> Ident;
rule type_name_semantic_type {
    if semantic_type(_, name) = ty;
    then type_name(ty) = name;
}

func semantic_arg_types(ArgDeclListNode) -> TypeList;
rule semantic_arg_types_nil {
    if nil_arg_decl_list_node(n);
    then NilTypeList()!;
    then semantic_arg_types(n) = NilTypeList();
}
rule semantic_arg_types_cons {
    if cons_arg_decl_list_node(arg_decls, head, tail);
    if ss = arg_symbol_scope(head);
    if arg_decl_node_type(head, head_type_name);
    if head_type = semantic_type(ss, head_type_name);
    if tail_types = semantic_arg_types(tail);
    then ConsTypeList(head_type, tail_types)!;
    then semantic_arg_types(arg_decls) = ConsTypeList(head_type, tail_types);
}

type Pred;
func semantic_pred(scope: SymbolScope, Ident) -> Pred;
func pred_arity(Pred) -> TypeList;
rule semantic_decl_pred {
    if decl_node_pred(decl, pred_decl);
    if pred_decl(pred_decl, name, arg_decls);
    if ss = decl_symbol_scope(decl);
    then predicate := semantic_pred(ss, name)!;
    if arg_types = semantic_arg_types(arg_decls);
    then pred_arity(predicate) = arg_types;
}

type Func;
func semantic_func(scope: SymbolScope, Ident) -> Func;
func domain(Func) -> TypeList;
func codomain(Func) -> Type;

rule semantic_decl_func {
    if decl_node_func(decl, func_decl);
    if func_decl(func_decl, name, arg_decls, result_type_name);
    if ss = decl_symbol_scope(decl);
    then function := semantic_func(ss, name)!;
    branch {
        if arg_types = semantic_arg_types(arg_decls);
        then domain(function) = arg_types;
    } along {
        if result_type = semantic_type(ss, result_type_name);
        then codomain(function) = result_type;
    }
}
rule semantic_decl_ctor {
    if ctor_decl(ctor, ctor_name, arg_decls);
    if enum_node = ctor_enum(ctor);
    if ss = ctor_symbol_scope(ctor);
    then function := semantic_func(ss, ctor_name)!;
    branch {
        if arg_types = semantic_arg_types(arg_decls);
        then domain(function) = arg_types;
    } along {
        if enum_decl(enum_node, enum_name, _);
        if result_type = semantic_type(ss, enum_name);
        then codomain(function) = result_type;
    }
}

enum Rel {
    PredRel(Pred),
    FuncRel(Func)
}

func rel_name(Rel) -> Ident;
rule semantic_func_name {
    if r = FuncRel(semantic_func(_, name));
    then rel_name(r) = name;
}
rule semantic_pred_name {
    if r = PredRel(semantic_pred(_, name));
    then rel_name(r) = name;
}

rule rel_constructors_pred_total {
    if predicate: Pred;
    then PredRel(predicate)!;
}
rule rel_constructors_func_total {
    if function: Func;
    then FuncRel(function)!;
}

rule semantic_pred_scope_extension {
    if symbol_scope_extension(smaller, larger);
    if predicate = semantic_pred(smaller, ident);
    then semantic_pred(larger, ident) = predicate;
}
rule semantic_func_scope_extension {
    if symbol_scope_extension(smaller, larger);
    if function = semantic_func(smaller, ident);
    then semantic_func(larger, ident) = function;
}
rule semantic_type_scope_extension {
    if symbol_scope_extension(smaller, larger);
    if typ = semantic_type(smaller, ident);
    then semantic_type(larger, ident) = typ;
}

func arity(Rel) -> TypeList;
rule arity_laws {
    if rel: Rel;
    match rel {
        PredRel(predicate) => {
            if tys = pred_arity(predicate);
            then arity(rel) = tys;
        }
        FuncRel(function) => {
            if dom = domain(function);
            if cod = codomain(function);
            then tys := SnocTypeList(dom, cod)!;
            then arity(rel) = tys;
        }
    }
}

// ## Structures

type Structure;

type El;

enum ElList {
    NilElList(Structure),
    ConsElList(head: El, tail: ElList),
    SnocElList(init: ElList, last: El)
}

rule el_list_cons_injective {
    if ConsElList(head_0, tail_0) = ConsElList(head_1, tail_1);
    then head_0 = head_1;
    then tail_0 = tail_1;
}
rule el_list_snoc_injective {
    if SnocElList(init_0, last_0) = SnocElList(init_1, last_1);
    then init_0 = init_1;
    then last_0 = last_1;
}
rule el_list_cons_nil {
    if ConsElList(_, _) = NilElList(_);
    then absurd();
}
rule el_list_snoc_nil {
    if SnocElList(_, _) = NilElList(_);
    then absurd();
}

pred rel_app(Rel, ElList);

type ElName;
func var(Structure, ElName) -> El;

// ### The structure that elements belong to
func el_structure(El) -> Structure;
func els_structure(ElList) -> Structure;
rule nil_els_structure {
    if els = NilElList(structure);
    then els_structure(els) = structure;
}
rule cons_els_structure {
    if els = ConsElList(head, tail);
    if head_structure = el_structure(head);
    then head_structure = els_structure(els);
    then head_structure = els_structure(tail);
}
rule snoc_els_structure {
    if els = SnocElList(init, last);
    if last_structure = el_structure(last);
    then last_structure = els_structure(els);
    then last_structure = els_structure(init);
}

rule var_structure {
    if el = var(structure, _);
    then el_structure(el) = structure;
}

// ### Symbol access/instantiation

enum ElementType {
    AmbientType(Type),
    InstantiatedType(El, Type)
}

rule ambient_type_total {
    if ty: Type;
    then AmbientType(ty)!;
}

enum ElementTypeList {
    NilElementTypeList(),
    ConsElementTypeList(head: ElementType, tail: ElementTypeList),
    SnocElementTypeList(init: ElementTypeList, last: ElementType)
}

func ambient_el_type_list(TypeList) -> ElementTypeList;
rule ambient_el_type_list_nil {
    if tys = NilTypeList();
    then el_tys := NilElementTypeList()!;
    then ambient_el_type_list(tys) = el_tys;
}
rule ambient_el_type_list_cons {
    if tys = ConsTypeList(head_type, tail_types);
    if tail_el_types = ambient_el_type_list(tail_types);
    if head_el_type = AmbientType(head_type);
    then el_tys := ConsElementTypeList(head_el_type, tail_el_types)!;
    then ambient_el_type_list(tys) = el_tys;
}
rule ambient_el_type_list_snoc {
    if tys = SnocTypeList(init_types, last_type);
    if init_el_types = ambient_el_type_list(init_types);
    if last_el_type = AmbientType(last_type);
    then el_tys := SnocElementTypeList(init_el_types, last_el_type)!;
    then ambient_el_type_list(tys) = el_tys;
}

// ### The types of elements
pred el_type(El, ElementType);
pred el_types(ElList, ElementTypeList);

rule nil_el_types {
    if els = NilElList(_);
    then tys := NilElementTypeList()!;
    then el_types(els, tys);
}
rule cons_el_types {
    if els = ConsElList(head, tail);
    if el_type(head, head_type);
    if el_types(tail, tail_types);
    then tys := ConsElementTypeList(head_type, tail_types)!;
    then el_types(els, tys);
}
rule cons_el_types_reverse {
    if els = ConsElList(head, tail);
    if el_types(els, ConsElementTypeList(head_type, tail_types));
    then el_type(head, head_type);
    then el_types(tail, tail_types);
}

rule snoc_el_types {
    if els = SnocElList(init, last);
    if el_types(init, init_types);
    if el_type(last, last_type);
    then tys := SnocElementTypeList(init_types, last_type)!;
    then el_types(els, tys);
}
rule snoc_el_types_reverse {
    if els = SnocElList(init, last);
    if el_types(els, SnocElementTypeList(init_types, last_type));
    then el_types(init, init_types);
    then el_type(last, last_type);
}

rule rel_app_types {
    if rel_app(rel, els);
    if ambient_el_type_list(arity(rel)) = tys;
    then el_types(els, tys);
}

// This is only used from Rust. If it's removed we need to
// add an explicit functionality law for rel_app of
// FuncRel relations though.
func func_app(function: Func, args: ElList) -> El;
rule rel_app_func_app {
    if rel_app(FuncRel(function), SnocElList(args, result));
    then result = func_app(function, args);
}

// ### Constrained elements
//
// An element is constrained if it appears in a function
// application (including the result) or in the
// application of a predicate.
pred constrained_el(El);
pred constrained_els(ElList);
rule rel_app_constrained {
    if rel_app(_, args);
    then constrained_els(args);
}
rule constrained_head_tail {
    if constrained_els(ConsElList(head, tail));
    then constrained_el(head);
    then constrained_els(tail);
}
rule constrained_init_snoc {
    if constrained_els(SnocElList(init, last));
    then constrained_els(init);
    then constrained_el(last);
}

// ## Morphisms

type Morphism;
func dom(Morphism) -> Structure;
func cod(Morphism) -> Structure;

rule dom_total {
    if morph: Morphism;
    then dom(morph)!;
}
rule cod_total {
    if morph: Morphism;
    then cod(morph)!;
}

func map_el(Morphism, El) -> El;
func map_els(Morphism, ElList) -> ElList;

// Mapped elements live in the codomain structure.
rule map_el_structure {
    if mapped = map_el(mor, _);
    if cod = cod(mor);
    then el_structure(mapped) = cod;
}

// The operations map_el(mor, -) and map_els(mor, -) are total.
rule map_el_defined {
    if dom(mor) = struct;
    if el_structure(el) = struct;
    then map_el(mor, el)!;
}
// Morphisms commute with nil, cons and snoc.
rule map_els_defined {
    if els_structure(els) = dom(mor);
    match els {
        NilElList(_) => {
            if c = cod(mor);
            then cod_nil := NilElList(c)!;
            then map_els(mor, els) = cod_nil;
        }
        ConsElList(head, tail) => {
            if cod_head = map_el(mor, head);
            if cod_tail = map_els(mor, tail);
            then cod_cons := ConsElList(cod_head, cod_tail)!;
            then map_els(mor, els) = cod_cons;
        }
        SnocElList(init, last) => {
            if cod_init = map_els(mor, init);
            if cod_last = map_el(mor, last);
            then cod_snoc := SnocElList(cod_init, cod_last)!;
            then map_els(mor, els) = cod_snoc;
        }
    }
}

// Morphisms commute with relations and variables.
rule map_var {
    if el = var(_, name);
    if mapped_el = map_el(morph, el);
    if cod(morph) = cod_structure;
    then mapped_el = var(cod_structure, name);
}
rule map_rel_app {
    if rel_app(rel, args);
    if mapped_args = map_els(_, args);
    then rel_app(rel, mapped_args);
}

// Morphisms preserve and reflect types.
rule map_preserves_el_type {
    if el_type(el, el_typ);
    if mapped_el = map_el(morph, el);
    match el_typ {
        AmbientType(typ) => {
            then el_type(mapped_el, AmbientType(typ));
        }
        InstantiatedType(model_el, local_typ) => {
            if mapped_model_el = map_el(morph, model_el);
            then mapped_el_typ := InstantiatedType(mapped_model_el, local_typ)!;
            then el_type(mapped_el, mapped_el_typ);
        }
    }
}
rule map_reflects_el_type {
    if el_type(map_el(_, el), mapped_el_typ);
    match mapped_el_typ {
        AmbientType(typ) => {
            then el_type(el, AmbientType(typ));
        }
        InstantiatedType(_, _) => {
            // Can we say something in this case? Note that if
            //
            // mapped_el_typ = InstantiatedType(mapped_model_el, local_type)
            //
            // and map_el(morph, model_el) = mapped_model_el, then we don't want to necessarily
            // say that el_type(Instantiatedtype(model_el, local_type). Consider the case where we
            // have two distinct model_el that satisfy map_el(morph, model_el) = mapped_model_el,
            // i.e. the morphisms collapses the two elements into one.
            //
            // What we actually want to do here, probably, is to assert that an element
            // preimage_model_el exists in the domain that maps to model_el such that el has type
            // InstantiatedType(preimage_model_el, typ). This would be similar to Hindley-Milner,
            // but I'm not sure the existing machinery can deal with elements that are introduced
            // in this way.
        }
    }
}

// ### Kernel pairs of morphisms.

pred in_ker(Morphism, El, El);
rule in_ker_rule {
    if map_el(morph, el_0) = map_el(morph, el_1);
    then in_ker(morph, el_0, el_1);
}

// ### Images of morphisms.

pred el_in_img(Morphism, El);
rule el_in_img_rule {
    if map_el(morph, _) = el;
    then el_in_img(morph, el);
}

pred rel_tuple_in_img(Morphism, Rel, ElList);
rule rel_tuple_in_img_law {
    if rel_app(rel, dom_els);
    if cod_els = map_els(morphism, dom_els);
    then rel_tuple_in_img(morphism, rel, cod_els);
}

// ## Symbol checks
//
// This is for facilitating checks for duplicated symbols, wrong symbol types,
// and wrong argument numbers.

enum SymbolKind {
    TypeSymbol(),
    PredSymbol(),
    FuncSymbol(),
    RuleSymbol(),
    EnumSymbol(),
    CtorSymbol(),
    ModelSymbol()
}
rule {
    then TypeSymbol()!;
    then PredSymbol()!;
    then FuncSymbol()!;
    then RuleSymbol()!;
    then EnumSymbol()!;
    then CtorSymbol()!;
    then ModelSymbol()!;
}

// A SymbolScope represents a set of defined symbols (types, functions, preds, ... but not variables).
type SymbolScope;

pred symbol_scope_extension(smaller: SymbolScope, larger: SymbolScope);

func module_symbol_scope(module: ModuleNode) -> SymbolScope;
func decl_symbol_scope(node: DeclNode) -> SymbolScope;
func decls_symbol_scope(nodes: DeclListNode) -> SymbolScope;
func arg_symbol_scope(arg: ArgDeclNode) -> SymbolScope;
func args_symbol_scope(args: ArgDeclListNode) -> SymbolScope;
func ctor_symbol_scope(ctor: CtorDeclNode) -> SymbolScope;
func ctors_symbol_scope(ctor: CtorDeclListNode) -> SymbolScope;

rule module_symbol_scope_rule {
    if decls_module_node(module, decls);
    if ss = decls_symbol_scope(decls);
    then ss = module_symbol_scope(module);
}
rule decl_symbol_scope_total {
    if node: DeclNode;
    then decl_symbol_scope(node)!;
}
rule decls_symbol_scope_total {
    if nodes: DeclListNode;
    then decls_symbol_scope(nodes)!;
}
rule arg_symbol_scope_total {
    if arg: ArgDeclNode;
    then arg_symbol_scope(arg)!;
}
rule args_symbol_scope_total {
    if args: ArgDeclListNode;
    then args_symbol_scope(args)!;
}
rule ctor_symbol_scope_total {
    if ctor: CtorDeclNode;
    then ctor_symbol_scope(ctor)!;
}
rule ctors_symbol_scope_total {
    if ctors: CtorDeclListNode;
    then ctors_symbol_scope(ctors)!;
}

rule decl_nodes_symbol_cons {
    if cons_decl_list_node(nodes, head, tail);
    if ss = decls_symbol_scope(nodes);
    then ss = decl_symbol_scope(head);
    then ss = decls_symbol_scope(tail);
}

rule pred_args_symbol_scope {
    if decl_node_pred(decl, pred_decl);
    if pred_decl(pred_decl, _, args);
    if ss = decl_symbol_scope(decl);
    then args_symbol_scope(args) = ss;
}
rule func_args_symbol_scope {
    if decl_node_func(decl, func_decl);
    if func_decl(func_decl, _, args, _);
    if ss = decl_symbol_scope(decl);
    then args_symbol_scope(args) = ss;
}
rule ctor_args_symbol_scope {
    if ctor_decl(ctor, _, args);
    if ss = ctor_symbol_scope(ctor);
    then args_symbol_scope(args) = ss;
}

rule args_symbol_scope_cons {
    if cons_arg_decl_list_node(args, head, tail);
    if ss = args_symbol_scope(args);
    then arg_symbol_scope(head) = ss;
    then args_symbol_scope(tail) = ss;
}

rule enum_ctors_symbol_scope {
    if decl_node_enum(decl, enum_node);
    if enum_decl(enum_node, _, ctors);
    if ss = decl_symbol_scope(decl);
    then ctors_symbol_scope(ctors) = ss;
}
rule ctors_symbol_scope_cons {
    if cons_ctor_decl_list_node(ctors, head, tail);
    if ss = ctors_symbol_scope(ctors);
    then ctor_symbol_scope(head) = ss;
    then ctors_symbol_scope(tail) = ss;
}

// Lookups of the member symbol scope given a model type and the model type
// given its member symbol scope.
func model_member_symbol_scope(Type) -> SymbolScope;
func symbol_scope_model(SymbolScope) -> Type;

rule model_symbol_scope_law {
    if decl_node_model(decl, model_node);
    if model_decl(model_node, model_name, body);
    if ambient_scope = decl_symbol_scope(decl);
    if member_scope = decls_symbol_scope(body);
    then symbol_scope_extension(ambient_scope, member_scope);
    if typ = semantic_type(ambient_scope, model_name);
    then model_member_symbol_scope(typ) = member_scope;
    then symbol_scope_model(member_scope) = typ;
}


// The symbol scope that can be accessd via an element of model type.
func element_member_symbol_scope(el: El) -> SymbolScope;
rule element_member_symbol_scope_laws {
    if el_type(el, AmbientType(ty));
    if sym_scope = model_member_symbol_scope(ty);
    then element_member_symbol_scope(el) = sym_scope;
}

// This is the name of the Rust struct that holds the data for symbols defined in this scope.
func symbol_scope_name(ss: SymbolScope) -> Ident;
// - For modules, it's derived from the file name.
rule module_symbol_scope_name {
    if ss = module_symbol_scope(module);
    if name = module_name(module);
    then symbol_scope_name(ss) = name;
}
// - For model declarations, it's the model name
rule model_symbol_scope_name {
    if model_decl(_, name, body);
    if ss = decls_symbol_scope(body);
    then symbol_scope_name(ss) = name;
}

// The SymbolScope attached to a (variable) Scope.
// TODO: In a better world, we wouldn't need to distinguish `Scope`, which
// tracks which variables have been introduced within a rule, and
// `SymbolScope`, which tracks which symbols are available. Unfortunatey, an
// eqlog program contains lots of different Scope elements (I think each AST
// node in a rule that can introduce a new variable has its own scope, e.g.
// each statement). So if we would attach the accessible_symbol predicate to a
// Scope instead of a SymbolScope, we'd have copies of the whole set symbols
// (on the order of e.g. 1000) for each scope (on the order for 10000 or more).
// I tried it anyway, and self-compilation time for eqlog-eqlog increased from
// around 3 seconds to 12 seconds.
//
// Instead, the symbols available at a given AST node within a rule are
// available more indirectly, by accessing a SymbolScope via the Scope. Since a
// rule cannot introduce new symbols, all `Scope` elements in a rule can share
// the same SymbolScope, and actually all rules in the same ambient context
// (as of this writing just global_symbol_scope, eventually also `model` member
// scope) can share the same SymbolScope. This way, all data attached to the
// SymbolScope exists only once regardless of many Scope elements there are.

func scope_symbols(scope: Scope) -> SymbolScope;
// Propagate the same symbol scope through all scopes in a rule:
rule scope_extension_symbols {
    if scope_extension(s_0, s_1);
    if ss = scope_symbols(s_0);
    then scope_symbols(s_1) = ss;
}
rule rule_symbol_scope {
    if decl_node_rule(decl, rul);
    if ss = decl_symbol_scope(decl);
    if scope = entry_scope(rule_descendant_rule(rul));
    then scope_symbols(scope) = ss;
}

// A predicate tracking which symbols have are defined in a symbol scope.
pred defined_symbol(scope: SymbolScope, Ident, SymbolKind, Loc);

// A predicate tracking which symbols have are accessible in a symbols scope.
// At the moment, symbols are accessible if they're declared in the same
// symbols scope or a containing symbol scope.
pred accessible_symbol(scope: SymbolScope, Ident, SymbolKind, Loc);

rule defined_symbol_is_accessible {
    if defined_symbol(ss, name, kind, loc);
    then accessible_symbol(ss, name, kind, loc);
}
rule accessible_symbol_scope_extension {
    if symbol_scope_extension(smaller, larger);
    if accessible_symbol(smaller, name, kind, loc);
    then accessible_symbol(larger, name, kind, loc);
}

rule type_decl_defines_symbol {
    if decl_node_type(decl, type_decl);
    if type_decl(type_decl, name);
    if ss = decl_symbol_scope(decl);
    if kind = TypeSymbol();
    if loc = type_decl_node_loc(type_decl);
    then defined_symbol(ss, name, kind, loc);
}
rule enum_decl_defines_symbol {
    if decl_node_enum(decl, enum_decl);
    if enum_decl(enum_decl, name, _);
    if ss = decl_symbol_scope(decl);
    if kind = EnumSymbol();
    if loc = enum_decl_node_loc(enum_decl);
    then defined_symbol(ss, name, kind, loc);
}
rule model_decl_defines_symbol {
    if decl_node_model(decl, model_decl);
    if model_decl(model_decl, name, _);
    if ss = decl_symbol_scope(decl);
    if kind = ModelSymbol();
    if loc = model_decl_node_loc(model_decl);
    then defined_symbol(ss, name, kind, loc);
}
rule pred_decl_defines_symbol {
    if decl_node_pred(decl, pred_decl);
    if pred_decl(pred_decl, name, _);
    if ss = decl_symbol_scope(decl);
    if kind = PredSymbol();
    if loc = pred_decl_node_loc(pred_decl);
    then defined_symbol(ss, name, kind, loc);
}
rule func_decl_defines_symbol {
    if decl_node_func(decl, func_decl);
    if func_decl(func_decl, name, _, _);
    if ss = decl_symbol_scope(decl);
    if kind = FuncSymbol();
    if loc = func_decl_node_loc(func_decl);
    then defined_symbol(ss, name, kind, loc);
}
rule ctor_decl_defines_symbol {
    if ctor_decl(ctor, name, _);
    if ss = ctor_symbol_scope(ctor);
    if kind  = CtorSymbol();
    if loc = ctor_decl_node_loc(ctor);
    then defined_symbol(ss, name, kind, loc);
}
rule rule_decl_defines_symbol {
    if decl_node_rule(decl, rul);
    if rule_decl(rul, _);
    if ss = decl_symbol_scope(decl);
    if name = rule_name(rul);
    if kind = RuleSymbol();
    if loc = rule_decl_node_loc(rul);
    then defined_symbol(ss, name, kind, loc);
}

// ### Symbol lookup checks

// Only one kind of symbol is allowed.
pred should_be_symbol(name: Ident, kind: SymbolKind, scope_symbols: SymbolScope, loc: Loc);
// Two kinds of symbols are allowed, with `kind_1` being the typical one.
pred should_be_symbol_2(name: Ident, kind_1: SymbolKind, kind_2: SymbolKind, scope_symbols: SymbolScope, loc: Loc);
// Three kinds of symbols are allowed, with `kind_1` being the typical one.
pred should_be_symbol_3(name: Ident, kind_1: SymbolKind, kind_2: SymbolKind, kind_3: SymbolKind, scope_symbols: SymbolScope, loc: Loc);

rule arg_decl_should_be_type {
    if arg_decl_node_type(arg_decl, name);
    if ss = arg_symbol_scope(arg_decl);
    if type_kind = TypeSymbol();
    if enum_kind = EnumSymbol();
    if model_kind = ModelSymbol();
    if loc = arg_decl_node_loc(arg_decl);
    then should_be_symbol_3(name, type_kind, enum_kind, model_kind, ss, loc);
}
rule result_should_be_type {
    if decl_node_func(decl, func_decl);
    if func_decl(func_decl, _, _, result_type);
    if scope = decl_symbol_scope(decl);
    if type_kind = TypeSymbol();
    if enum_kind = EnumSymbol();
    if model_kind = EnumSymbol();
    if loc = func_decl_node_loc(func_decl);
    then should_be_symbol_3(result_type, type_kind, enum_kind, model_kind, scope, loc);
}
rule var_atom_should_be_type {
    if var_if_atom_node(atom, _, type_expr);
    // TODO: We should also handle member type exprs.
    if ambient_type_expr(type_expr, name);
    if scope = scope_symbols(entry_scope(rule_descendant_if_atom(atom)));
    if type_kind = TypeSymbol();
    if enum_kind = EnumSymbol();
    if model_kind = ModelSymbol();
    if loc = if_atom_node_loc(atom);
    then should_be_symbol_3(name, type_kind, enum_kind, model_kind, scope, loc);
}
rule pred_if_atom_should_be_pred {
    if pred_if_atom_node(atom, pred_name, _);
    if scope = scope_symbols(entry_scope(rule_descendant_if_atom(atom)));
    if kind = PredSymbol();
    if loc = if_atom_node_loc(atom);
    then should_be_symbol(pred_name, kind, scope, loc);
}
rule pred_then_atom_should_be_pred {
    if pred_then_atom_node(atom, pred_name, _);
    if scope = scope_symbols(entry_scope(rule_descendant_then_atom(atom)));
    if kind = PredSymbol();
    if loc = then_atom_node_loc(atom);
    then should_be_symbol(pred_name, kind, scope, loc);
}
rule app_atom_should_be_func {
    if app_term_node(term, name, _);
    if scope = scope_symbols(entry_scope(rule_descendant_term(term)));
    if func_kind = FuncSymbol();
    if ctor_kind = CtorSymbol();
    if loc = term_node_loc(term);
    then should_be_symbol_2(name, func_kind, ctor_kind, scope, loc);
}

// ### Natural numbers and argument numbers

type Nat;
func zero() -> Nat;
func succ(Nat) -> Nat;

func type_list_len(TypeList) -> Nat;
rule type_list_len_total {
    if tys: TypeList;
    then type_list_len(tys)!;
}
rule type_list_len_nil {
    if tys = NilTypeList();
    if len = type_list_len(tys);
    then len = zero();
}
rule type_list_len_cons {
    if tys = ConsTypeList(_, tail);
    if len = type_list_len(tys);
    if tail_len = type_list_len(tail);
    then len = succ(tail_len);
}
rule type_list_len_snoc {
    if tys = SnocTypeList(init, _);
    if len = type_list_len(tys);
    if init_len = type_list_len(init);
    then len = succ(init_len);
}

func term_list_len(TermListNode) -> Nat;
rule term_list_len_total {
    if terms: TermListNode;
    then term_list_len(terms)!;
}
rule term_list_len_nil {
    if nil_term_list_node(terms);
    if len = term_list_len(terms);
    then len = zero();
}
rule term_list_len_cons {
    if cons_term_list_node(terms, _, tail);
    if len = term_list_len(terms);
    if tail_len = term_list_len(tail);
    then len = succ(tail_len);
}

pred pred_arg_num_should_match(
    got: Nat,
    expected: Nat,
    usage: Loc
);
pred func_arg_num_should_match(
    got: Nat,
    expected: Nat,
    usage: Loc
);

rule pred_if_atom_arg_num_should_match {
    if pred_if_atom_node(atom, name, args);
    if got_len = term_list_len(args);
    if ss = scope_symbols(entry_scope(rule_descendant_if_atom(atom)));
    if expected_len = type_list_len(pred_arity(semantic_pred(ss, name)));
    if loc = if_atom_node_loc(atom);
    then pred_arg_num_should_match(got_len, expected_len, loc);
}
rule pred_then_atom_arg_num_should_match {
    if pred_then_atom_node(atom, name, args);
    if got_len = term_list_len(args);
    if ss = scope_symbols(entry_scope(rule_descendant_then_atom(atom)));
    if expected_len = type_list_len(pred_arity(semantic_pred(ss, name)));
    if loc = then_atom_node_loc(atom);
    then pred_arg_num_should_match(got_len, expected_len, loc);
}

rule app_term_arg_num_should_match {
    if app_term_node(tm, name, args);
    if got_len = term_list_len(args);
    if ss = scope_symbols(entry_scope(rule_descendant_term(tm)));
    if expected_len = type_list_len(domain(semantic_func(ss, name)));
    if loc = term_node_loc(tm);
    then func_arg_num_should_match(got_len, expected_len, loc);
}

// ## Control flow graph
pred cfg_edge(from: StmtNode, to: StmtNode);

// ### Control flow from and into StmtListNodes
// 
// If control flows into a list of statements, then it flows into the first statement in that list.
// If control flows out of a statement list, then it flows out of every suffix of the statement list, and from the last statement in the list.
// In case of an empty statement list, there's an ordinary cfg edge between every before-statement to every after-statement.
pred cfg_edge_stmts_stmt(from: StmtListNode, to: StmtNode);
pred cfg_edge_stmt_stmts(from: StmtNode, to: StmtListNode);

rule cfg_edge_stmts_stmt_cons {
    if cfg_edge_stmts_stmt(stmts, stmt);
    if cons_stmt_list_node(stmts, _, tail);
    then cfg_edge_stmts_stmt(tail, stmt);
}
rule cfg_edge_stmts_stmt_singleton {
    if cfg_edge_stmts_stmt(stmts, stmt);
    if cons_stmt_list_node(stmts, head, tail);
    if nil_stmt_list_node(tail);
    then cfg_edge(head, stmt);
}

rule cfg_edge_stmt_stmts_cons {
    if cfg_edge_stmt_stmts(stmt, stmts);
    if cons_stmt_list_node(stmts, head, _);
    then cfg_edge(stmt, head);
}
rule cfg_edge_stmt_stmts_nil {
    if cfg_edge_stmt_stmts(stmt, stmts);
    if nil_stmt_list_node(stmts);
    if cfg_edge_stmts_stmt(stmts, next_stmt);
    then cfg_edge(stmt, next_stmt);
}

// ### Control flow from and into branches
//
// This is for branch and match statements.

pred cfg_edge_fork(from: StmtNode, to: StmtBlockListNode);
pred cfg_edge_join(from: StmtBlockListNode, to: StmtNode);

rule cfg_edge_fork_cons {
    if cfg_edge_fork(stmt, blocks);
    if cons_stmt_block_list_node(blocks, head_block, tail_blocks);
    then cfg_edge_fork(stmt, tail_blocks);
    then cfg_edge_stmt_stmts(stmt, head_block);
}
rule cfg_edge_join_cons {
    if cfg_edge_join(blocks, stmt);
    if cons_stmt_block_list_node(blocks, head_block, tail_blocks);
    then cfg_edge_join(tail_blocks, stmt);
    then cfg_edge_stmts_stmt(head_block, stmt);
}

// ## Populating the cfg edge based on the AST

rule cfg_edge_if {
    if cons_stmt_list_node(_, first , tail);
    if if_stmt_node(first, _);
    if cons_stmt_list_node(tail, second , _);
    then cfg_edge(first, second);
}

rule cfg_edge_then {
    if cons_stmt_list_node(_, first , tail);
    if then_stmt_node(first, _);
    if cons_stmt_list_node(tail, second , _);
    then cfg_edge(first, second);
}

rule cfg_edge_branch_fork_blocks {
    if branch_stmt_node(branch_stmt, branch_blocks);
    then cfg_edge_fork(branch_stmt, branch_blocks);
}
rule cfg_edge_match_fork_blocks {
    if match_stmt_node(match_stmt, _, cases);
    if branch_blocks = desugared_case_block_list(cases);
    then cfg_edge_fork(match_stmt, branch_blocks);
}

rule cfg_edge_branch_join_blocks {
    if branch_stmt_node(branch_stmt, branch_blocks);
    if cons_stmt_list_node(_, branch_stmt , tail);
    if cons_stmt_list_node(tail, after_branch_stmt , _);
    then cfg_edge_join(branch_blocks, after_branch_stmt);
}
rule cfg_edge_match_join_blocks {
    if match_stmt_node(match_stmt, _, cases);
    if cons_stmt_list_node(_, match_stmt , tail);
    if cons_stmt_list_node(tail, after_match_stmt , _);
    if branch_blocks = desugared_case_block_list(cases);
    then cfg_edge_join(branch_blocks, after_match_stmt);
}

// ## The morphisms associated to statements.
//
// Each statement in a rule corresponds to a morphism of structures. The domain
// of this morphism corresponds to the data that has been queries or asserted
// earlier in the rule, and the codomain to the result of adjoining the data in
// that statement. Codomain and domain of subsequent statements match, so their
// morphisms are composable.

pred before_stmt_structure(StmtNode, Structure);
pred stmt_morphism(StmtNode, Morphism);

func before_rule_structure(RuleDeclNode) -> Structure;
rule before_rule_structure_total {
    if rn: RuleDeclNode;
    then before_rule_structure(rn)!;
}
rule before_first_rule_stmt {
    if rule_decl(rul, stmts);
    if cons_stmt_list_node(stmts, first, _);
    if structure = before_rule_structure(rul);
    then before_stmt_structure(first, structure);
}

rule cfg_edge_stmt_structure {
    if cfg_edge(from_stmt, to_stmt);
    if stmt_morphism(from_stmt, from_morphism);
    if from_cod = cod(from_morphism);
    then before_stmt_structure(to_stmt, from_cod);
}

func if_atom_morphism(IfAtomNode, before_structure: Structure) -> Morphism;
func then_atom_morphism(ThenAtomNode, before_structure: Structure) -> Morphism;
// This should only be defined for branch statements.
func branch_stmt_morphism(StmtNode, before_structure: Structure) -> Morphism;
// This should only be defined for match statements.
func match_stmt_morphism(StmtNode, before_structure: Structure) -> Morphism;

rule if_atom_morphism_dom {
    if morph_dom = dom(if_atom_morphism(_, before_structure));
    then morph_dom = before_structure;
}
rule then_atom_morphism_dom {
    if morph_dom = dom(then_atom_morphism(_, before_structure));
    then morph_dom = before_structure;
}
rule branch_stmt_morphism_dom {
    if morph_dom = dom(branch_stmt_morphism(_, before_structure));
    then morph_dom = before_structure;
}
rule match_stmt_morphism_dom {
    if morph_dom = dom(match_stmt_morphism(_, before_structure));
    then morph_dom = before_structure;
}

rule if_stmt_morphism_defined {
    if if_stmt_node(stmt, atom);
    if before_stmt_structure(stmt, before_structure);
    then morph := if_atom_morphism(atom, before_structure)!;
    then stmt_morphism(stmt, morph);
}
rule then_stmt_morphism_defined {
    if then_stmt_node(stmt, atom);
    if before_stmt_structure(stmt, before_structure);
    then morph := then_atom_morphism(atom, before_structure)!;
    then stmt_morphism(stmt, morph);
}
rule branch_stmt_morphism_defined {
    if branch_stmt_node(stmt, _);
    if before_stmt_structure(stmt, before_structure);
    then morph := branch_stmt_morphism(stmt, before_structure)!;
    then stmt_morphism(stmt, morph);
}
rule match_stmt_morphism_defined {
    if match_stmt_node(stmt, _, _);
    if before_stmt_structure(stmt, before_structure);
    then morph := match_stmt_morphism(stmt, before_structure)!;
    then stmt_morphism(stmt, morph);
}

pred if_morphism(Morphism);
pred surj_then_morphism(Morphism);
pred non_surj_then_morphism(Morphism);
pred noop_morphism(Morphism);

rule if_stmt_morphism_is_if {
    if if_stmt_node(stmt, _);
    if stmt_morphism(stmt, morph);
    then if_morphism(morph);
}
rule then_equal_stmt_morphism_is_surj {
    if then_stmt_node(stmt, atom);
    if equal_then_atom_node(atom, _, _);
    if stmt_morphism(stmt, morph);
    then surj_then_morphism(morph);
}
rule then_pred_stmt_morphism_is_surj {
    if then_stmt_node(stmt, atom);
    if pred_then_atom_node(atom, _, _);
    if stmt_morphism(stmt, morph);
    then surj_then_morphism(morph);
}
rule then_defined_stmt_morphism_is_non_surj {
    if then_stmt_node(stmt, atom);
    if defined_then_atom_node(atom, _, _);
    if stmt_morphism(stmt, morph);
    then non_surj_then_morphism(morph);
}
rule branch_stmt_morphism_is_noop {
    if branch_stmt_node(stmt, _);
    if stmt_morphism(stmt, morph);
    then noop_morphism(morph);
}
rule match_stmt_morphism_is_if {
    if match_stmt_node(stmt, _, _);
    if stmt_morphism(stmt, morph);
    then if_morphism(morph);
}

// ### Propagation of associated structures through the AST
//
// Even though a statement corresponds to a morphism, inside the statement we
// only need access to the codomain of that morphism. That's the
// stmt_structure, and similarly for subnodes of statements.
//
// #### Propagate stmt structure through if and then stmts.
pred stmt_structure(StmtNode, Structure);
pred if_atom_structure(IfAtomNode, Structure);
pred then_atom_structure(ThenAtomNode, Structure);
pred term_structure(TermNode, Structure);
pred terms_structure(TermListNode, Structure);
pred opt_term_structure(OptTermNode, Structure);
pred type_expr_structure(TypeExprNode, Structure);

rule stmt_structure_morphism {
    if stmt_morphism(stmt, morph);
    if s = cod(morph);
    then stmt_structure(stmt, s);
}

rule if_stmt_structure {
    if if_stmt_node(stmt, atom);
    if stmt_structure(stmt, structure);
    then if_atom_structure(atom, structure);
}
rule then_stmt_structure {
    if then_stmt_node(stmt, atom);
    if stmt_structure(stmt, structure);
    then then_atom_structure(atom, structure);
}
rule match_stmt_structure {
    if match_stmt_node(stmt, term, _);
    if stmt_structure(stmt, structure);
    then term_structure(term, structure);
}

// #### Propagate associated structures through if atoms.
rule equal_if_atom_structure {
    if equal_if_atom_node(atom, lhs, rhs);
    if if_atom_structure(atom, structure);
    then term_structure(lhs, structure);
    then term_structure(rhs, structure);
}
rule defined_if_atom_structure {
    if defined_if_atom_node(atom, term);
    if if_atom_structure(atom, structure);
    then term_structure(term, structure);
}
rule pred_if_atom_structure {
    if pred_if_atom_node(atom, _, arg_terms);
    if if_atom_structure(atom, structure);
    then terms_structure(arg_terms, structure);
}
rule var_if_atom_structure {
    if var_if_atom_node(atom, var_term, type_expr);
    if if_atom_structure(atom, structure);
    then term_structure(var_term, structure);
    then type_expr_structure(type_expr, structure);
}

// #### Propagate associated structures through then atoms.
rule equal_then_atom_structure {
    if equal_then_atom_node(atom, lhs, rhs);
    if then_atom_structure(atom, structure);
    then term_structure(lhs, structure);
    then term_structure(rhs, structure);
}
rule defined_then_atom_structure {
    if defined_then_atom_node(atom, var_term, term);
    if then_atom_structure(atom, structure);
    then opt_term_structure(var_term, structure);
    then term_structure(term, structure);
}
rule pred_then_atom_structure {
    if pred_then_atom_node(atom, _, arg_terms);
    if then_atom_structure(atom, structure);
    then terms_structure(arg_terms, structure);
}

// ### Propagate associated structure through type exprs.
rule member_type_expr_structure {
    if member_type_expr(type_expr, model_tm, _);
    if type_expr_structure(type_expr, strct);
    then term_structure(model_tm, strct);
}

// #### Propagate associated structures through terms.
rule cons_term_list_structure {
    if cons_term_list_node(terms, head, tail);
    if terms_structure(terms, structure);
    then term_structure(head, structure);
    then terms_structure(tail, structure);
}

rule some_opt_term_structure {
    if some_term_node(opt_term, term);
    if opt_term_structure(opt_term, structure);
    then term_structure(term, structure);
}

rule app_term_structure {
    if app_term_node(term, _, args);
    if term_structure(term, structure);
    then terms_structure(args, structure);
}

// ### Populate associated structures

// #### Variables, scopes and named elements

func semantic_name(VirtIdent, Scope) -> ElName;

rule semantic_name_defined {
    if var_in_scope(ident, scope);
    then semantic_name(ident, scope)!;
}
rule semantic_name_extension_scope {
    if scope_extension(smaller_scope, larger_scope);
    if name_smaller = semantic_name(ident, smaller_scope);
    if name_larger = semantic_name(ident, larger_scope);
    then name_smaller = name_larger;
}

func semantic_el(TermNode, Structure) -> El;
func semantic_els(TermListNode, Structure) -> ElList;
rule semantic_el_defined {
    if el: TermNode;
    if term_structure(el, structure);
    then semantic_el(el, structure)!;
}

rule semantic_els_nil {
    if nil_term_list_node(terms);
    if terms_structure(terms, structure);
    then nil_els := NilElList(structure)!;
    then semantic_els(terms, structure) = nil_els;
}
rule semantic_els_cons {
    if cons_term_list_node(terms, head, tail);
    if head_el = semantic_el(head, structure);
    if tail_els = semantic_els(tail, structure);
    then cons_els := ConsElList(head_el, tail_els)!;
    then semantic_els(terms, structure) = cons_els;
}

// #### The structures of semantic elements
rule semantic_el_struct {
    if el = semantic_el(_, structure);
    then el_structure(el) = structure;
}
rule semantic_els_struct {
    if els = semantic_els(_, structure);
    then els_structure(els) = structure;
}

// #### Semantics of terms
rule app_term_semantics {
    if app_term_node(result_term, func_name, arg_terms);
    if result_el = semantic_el(result_term, structure);
    if func_arg_els = semantic_els(arg_terms, structure);
    if ss = scope_symbols(entry_scope(rule_descendant_term(result_term)));
    if func_rel = FuncRel(semantic_func(ss, func_name));
    then rel_arg_els := SnocElList(func_arg_els, result_el)!;
    then rel_app(func_rel, rel_arg_els);
}

rule var_term_semantics {
    if var_term_node(term, ident);
    if scope = exit_scope(rule_descendant_term(term));
    if name = semantic_name(ident, scope);
    if el = semantic_el(term, structure);
    then el = var(structure, name);
}

func wildcard_name(TermNode) -> ElName;
rule wildcard_name_defined {
    if wildcard_term_node(term);
    then wildcard_name(term)!;
}
rule wildcard_term_semantics {
    if wildcard_term_node(term);
    if name = wildcard_name(term);
    if el = semantic_el(term, structure);
    then el = var(structure, name);
}

// #### Semantics of if atoms
rule equal_if_atom_semantics {
    if equal_if_atom_node(_, lhs_term, rhs_term);
    if lhs_el = semantic_el(lhs_term, structure);
    if rhs_el = semantic_el(rhs_term, structure);
    then lhs_el = rhs_el;
}
// No rule for `defined_if_atom` -- this is already taken care of because `semantic_el` is total.
rule pred_if_atom_semantics {
    if pred_if_atom_node(atom, predicate_name, arg_terms);
    if ss = scope_symbols(entry_scope(rule_descendant_if_atom(atom)));
    if rel = PredRel(semantic_pred(ss, predicate_name));
    if arg_els = semantic_els(arg_terms, _);
    then rel_app(rel, arg_els);
}
rule var_if_atom_semantics_ambient {
    if var_if_atom_node(atom, var_term, type_expr);
    // TODO: We should also handle member type exprs here.
    if ambient_type_expr(type_expr, type_name);
    if ss = scope_symbols(entry_scope(rule_descendant_if_atom(atom)));
    if el_typ = AmbientType(semantic_type(ss, type_name));
    if var_el = semantic_el(var_term, _);
    then el_type(var_el, el_typ);
}
rule var_if_atom_semantics_member {
    if var_if_atom_node(_, var_term, type_expr);
    if member_type_expr(type_expr, model_term, type_name);

    if var_el = semantic_el(var_term, strct);
    if model_el = semantic_el(model_term, strct);

    if member_ss = element_member_symbol_scope(model_el);
    if member_type = semantic_type(member_ss, type_name);
    then el_typ := InstantiatedType(model_el, member_type)!;
    then el_type(var_el, el_typ);
}

rule var_if_atom_should_be_member_type {
    //if var_if_atom_node(atom, var_term, type_expr);
    if var_if_atom_node(atom, _, type_expr);
    if member_type_expr(type_expr, model_term, type_name);
    // TODO: Would be better to use the location of the type expression, or even just type_name.
    // Those locations aren't saved at the moment though.
    if loc = if_atom_node_loc(atom);

    //if var_el = semantic_el(var_term, strct);
    if model_el = semantic_el(model_term, _);

    if member_scope = element_member_symbol_scope(model_el);
    if type_symbol = TypeSymbol();
    if model_symbol = ModelSymbol();
    if enum_symbol = EnumSymbol();

    then should_be_symbol_3(type_name, type_symbol, model_symbol, enum_symbol, member_scope, loc);
    //if member_type = semantic_type(member_scope, type_name);
    //then el_typ := InstantiatedType(model_el, member_type)!;
    //then el_type(var_el, el_typ);
}

// #### Semantics of then atoms
rule equal_then_atom_semantics {
    if equal_then_atom_node(_, lhs_term, rhs_term);
    if lhs_el = semantic_el(lhs_term, structure);
    if rhs_el = semantic_el(rhs_term, structure);
    then lhs_el = rhs_el;
}
rule defined_then_atom_semantics {
    if defined_then_atom_node(_, opt_var_term, term);
    if some_term_node(opt_var_term, var_term);
    if var_el = semantic_el(var_term, structure);
    if el = semantic_el(term, structure);
    then var_el = el;
}
rule pred_then_atom_semantics {
    if pred_then_atom_node(atom, predicate_name, arg_terms);
    if ss = scope_symbols(entry_scope(rule_descendant_then_atom(atom)));
    if rel = PredRel(semantic_pred(ss, predicate_name));
    if arg_els = semantic_els(arg_terms, _);
    then rel_app(rel, arg_els);
}

// ## Epic check

// ### Terms that should need epic checking
//
// These are terms that appear in then statements.

pred term_should_be_epic_ok(TermNode);
pred terms_should_be_epic_ok(TermListNode);

// #### Propagate should_be_epic_ok downwards.
rule terms_should_be_epic_ok_cons {
    if terms_should_be_epic_ok(terms);
    if cons_term_list_node(terms, head, tail);
    then term_should_be_epic_ok(head);
    then terms_should_be_epic_ok(tail);
}

rule terms_should_be_epic_ok_app {
    if term_should_be_epic_ok(tm);
    if app_term_node(tm, _, args);
    then terms_should_be_epic_ok(args);
}

rule then_atom_epic_ok_equal {
    if equal_then_atom_node(_, lhs, rhs);
    then term_should_be_epic_ok(lhs);
    then term_should_be_epic_ok(rhs);
}
rule then_atom_epic_ok_defined {
    if defined_then_atom_node(_, _, tm);
    then term_should_be_epic_ok(tm);
}
rule then_atom_epic_ok_pred {
    if pred_then_atom_node(_, _, args);
    then terms_should_be_epic_ok(args);
}

// ## Surjectivity check
//
// Since the morphisms we derive from statements are such that no two morphisms
// share a codomain, we don't need to reference a morphism in the surjectivity
// check.

pred el_should_be_surjective_ok(El);
pred el_is_surjective_ok(El);

rule surjective_codomain_should_be_ok {
    if surj_then_morphism(morph);
    if el_structure(el) = cod(morph);
    then el_should_be_surjective_ok(el);
}
rule non_surjective_codomain_should_be_ok {
    if non_surj_then_morphism(morph);
    if el_structure(el) = cod(morph);
    then el_should_be_surjective_ok(el);
}

rule surjective_img_el_is_ok {
    if el_should_be_surjective_ok(el);
    if el_in_img(_, el);
    then el_is_surjective_ok(el);
}
rule surjective_exempted_then_defined_term {
    if defined_then_atom_node(_, _, tm);
    if el = semantic_el(tm, _);
    then el_is_surjective_ok(el);
}


// ## Enum constructor surjectivity check
pred should_be_obtained_by_ctor(TermNode, EnumDeclNode);
rule defined_then_should_be_given_by_ctor {
    if defined_then_atom_node(atom, _, tm);
    if ss = scope_symbols(entry_scope(rule_descendant_then_atom(atom)));
    if el = semantic_el(tm, _);
    if el_type(el, AmbientType(semantic_type(ss, ty_name)));
    if enum_decl(enum_decl_node, ty_name, _);
    then should_be_obtained_by_ctor(tm, enum_decl_node);
}

pred is_given_by_ctor(TermNode, EnumDeclNode);

rule ctor_app_is_given_by_ctor {
    if app_term_node(tm, func_ident, _);
    if ctor_decl(ctor, func_ident, _);
    if ctor_enum(ctor) = enum_decl_node;
    then is_given_by_ctor(tm, enum_decl_node);
}

// ### Function definedness
//
// This predicate holds if an Eqlog function can be made defined via the Rust API.
pred function_can_be_made_defined(Func);

rule function_can_be_made_defined_if_codomain_normal_type {
    if decl_node_type(decl, type_node);
    if type_decl(type_node, ident);
    if ss = decl_symbol_scope(decl);
    if ty = semantic_type(ss, ident);
    if codomain(function) = ty;
    then function_can_be_made_defined(function);
}
rule function_can_be_defined_if_constructor {
    if ctor_decl(ctor, ident, _);
    if ss = ctor_symbol_scope(ctor);
    if function = semantic_func(ss, ident);
    then function_can_be_made_defined(function);
}

// ## Match statement exhaustiveness check
//
// ### Checking that the pattern of every match case is a valid enum constructor.

pred case_pattern_is_variable(Loc);
pred case_pattern_is_wildcard(Loc);
rule case_pattern_is_variable_defined {
    if match_case(_, pattern, _);
    if var_term_node(pattern, _);
    if pattern_loc = term_node_loc(pattern);
    then case_pattern_is_variable(pattern_loc);
}
rule case_pattern_is_wildcard_defined {
    if match_case(_, pattern, _);
    if wildcard_term_node(pattern);
    if pattern_loc = term_node_loc(pattern);
    then case_pattern_is_wildcard(pattern_loc);
}

// The constructor of the pattern of a match case, if any, i.e. if the pattern
// term is a valid enum constructor.
func match_case_pattern_ctor(MatchCaseNode) -> CtorDeclNode;
rule case_pattern_app_should_be_constructor {
    if match_case(match_node, pattern, _);
    if scope = scope_symbols(entry_scope(rule_descendant_match_case(match_node)));
    if app_term_node(pattern, func_name, _);
    if pattern_loc = term_node_loc(pattern);
    if ctor_sym = CtorSymbol();
    then should_be_symbol(func_name, ctor_sym, scope, pattern_loc);
}
rule match_case_pattern_ctor_defined {
    if match_case(case_node, pattern, _);
    if app_term_node(pattern, func_name, _);
    if ctor_decl(ctor, func_name, _);
    then match_case_pattern_ctor(case_node) = ctor;
}

// ### Checking of constructor arguments in patterns
pred is_pattern_ctor_arg(TermNode);
pred are_pattern_ctor_args(TermListNode);
rule is_pattern_ctor_arg_cons {
    if are_pattern_ctor_args(tms);
    if cons_term_list_node(tms, head, tail);
    then is_pattern_ctor_arg(head);
    then are_pattern_ctor_args(tail);
}

rule are_pattern_ctor_args_defined {
    if match_case(_, pattern, _);
    if app_term_node(pattern, _, args);
    then are_pattern_ctor_args(args);
}

pred pattern_ctor_arg_is_app(Loc);
rule pattern_ctor_arg_is_app_defined {
    if is_pattern_ctor_arg(arg);
    if app_term_node(arg, _, _);
    if loc = term_node_loc(arg);
    then pattern_ctor_arg_is_app(loc);
}

pred pattern_ctor_arg_var_is_not_fresh(Loc);
rule pattern_ctor_arg_var_is_not_fresh_defined {
    if is_pattern_ctor_arg(arg);
    if var_term_node(arg, ident);
    if scope = entry_scope(rule_descendant_term(arg));
    if var_in_scope(ident, scope);
    if loc = term_node_loc(arg);
    then pattern_ctor_arg_var_is_not_fresh(loc);
}

// ### Which constructors occur in a case list, and if they determine the enum type uniquely

pred cases_contain_ctor(MatchCaseListNode, CtorDeclNode);
rule contains_ctor_case_head {
    if cons_match_case_list_node(cases, head_case, _);
    if ctor = match_case_pattern_ctor(head_case);
    then cases_contain_ctor(cases, ctor);
}
rule contains_ctor_case_tail {
    if cons_match_case_list_node(cases, _, tail_cases);
    if cases_contain_ctor(tail_cases, ctor);
    then cases_contain_ctor(cases, ctor);
}

pred match_stmt_contains_ctor_of_enum(StmtNode, CtorDeclNode, EnumDeclNode);
rule match_stmt_contains_ctor_of_enum_defined {
    if match_stmt_node(stmt, _, cases);
    if cases_contain_ctor(cases, ctor);
    if ctor_enum(ctor) = enum_decl_node;
    then match_stmt_contains_ctor_of_enum(stmt, ctor, enum_decl_node);
}

func cases_determined_enum(MatchCaseListNode) -> EnumDeclNode;
rule ctor_cases_determine_enum_singleton {
    if cons_match_case_list_node(cases, head_case, tail_cases);
    if nil_match_case_list_node(tail_cases);
    if enum_type = ctor_enum(match_case_pattern_ctor(head_case));
    then cases_determined_enum(cases) = enum_type;
}
rule ctor_cases_determine_enum_cons {
    if cons_match_case_list_node(cases, head_case, tail_cases);
    if enum_type = cases_determined_enum(tail_cases);
    if enum_type = ctor_enum(match_case_pattern_ctor(head_case));
    then cases_determined_enum(cases) = enum_type;
}

rule match_term_type_if_cases_determine_enum {
    if match_stmt_node(_, match_term, cases);
    if enum_decl_node = cases_determined_enum(cases);
    if ss = scope_symbols(entry_scope(rule_descendant_term(match_term)));
    if enum_decl(enum_decl_node, ident, _);
    if enum_type = AmbientType(semantic_type(ss, ident));
    if match_el = semantic_el(match_term, _);
    then el_type(match_el, enum_type);
}

// ## Exhaustiveness of case lists in match statement

pred match_stmt_should_contain_ctor(StmtNode, CtorDeclNode);
rule match_stmt_should_contain_ctor_defined {
    if match_stmt_node(stmt, match_term, _);
    if el_type(semantic_el(match_term, _), AmbientType(enum_type));
    if ss = scope_symbols(entry_scope(rule_descendant_term(match_term)));
    if semantic_type(ss, enum_ident) = enum_type;
    if enum_decl(enum_decl_node, enum_ident, _);
    if ctor_enum(ctor) = enum_decl_node;
    then match_stmt_should_contain_ctor(stmt, ctor);
}

pred match_stmt_contains_ctor(StmtNode, CtorDeclNode);
rule match_stmt_contains_ctor_defined {
    if match_stmt_node(stmt, _, cases);
    if cases_contain_ctor(cases, ctor);
    then match_stmt_contains_ctor(stmt, ctor);
}
